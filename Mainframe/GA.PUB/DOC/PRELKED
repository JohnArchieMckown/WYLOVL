OPTIONS: UNN IND 6 CHAR TN10 FORM=BOND
DOC#PRELKED PUBLIC                         Latest update:  06/01/86
Information Technology Services            Creation date:  06/01/75
Stanford University                        Length:        260 lines


PRELKED is an object module scanner and linkage editor preprocessor
program.  Its major purpose is to aid in the construction of a
subroutine library.  FORTRAN, for example, does not produce the
necessary control information for the linkage editor to store each
subprogram individually.  PRELKED scans object modules produced by a
language processor and produces a copy of each module followed by
the control statements needed by the linkage editor.  After being
processed by PRELKED, each object module can be processed
independently by the linkage editor and stored as a separate member
of a load module output data set.

The main input to PRELKED is one or more object modules (card images
on disk or tape) produced by a language processor (e.g., FORTRAN).
The output of PRELKED is those same object modules with appropriate
linkage editor control statements appended to each.  PRELKED
produces three types of linkage editor control statements:  NAME,
ALIAS and optionally SETSSI.  When the linkage editor encounters a
NAME statement, it finishes processing the input received to that
point and stores a load module version of the input with the name
found on the NAME statement into the output data set.  This name may
then be used by any program (including the linkage editor) to access
the load module.

ALIAS statements establish one or more alternate names  by  which
the  load module  may  be accessed.  For a FORTRAN example, suppose
a subroutine named BASE has two other entry points (established by
ENTRY statements), BASE1 and BASE2.  It would be desirable that a
reference to any of these  three  names would  cause  the linkage
editor to access this subroutine.  PRELKED creates those additional
ALIAS statements, so when BASE  is  stored,  it  will  have
associated with it the names BASE, BASE1 and BASE2.

SETSSI statements record the date on which the load module was
created.

PRELKED can only handle one control section per object module.  If
more than one control section is encountered, only the first name is
retained for use in the NAME statement generated by PRELKED.  This
can occur only when programming in Assembler.  If planning to use
PRELKED, the user should avoid interspersing code from different
CSECTs.  If no named control section is found, PRELKED will generate
a NAME statement with no name.  This will be flagged as an error by
the linkage editor.  This second condition could only occur if an
object module in assembly-language contained an unnamed CSECT or
START statement, or if any non-assembler-directive statement
occurred outside the range of a CSECT, DSECT, or START.

PRELKED can handle a maximum of sixteen (l6) entry points for any
one program.  If more than sixteen are specified, only the first
sixteen are included in ALIAS statements generated by PRELKED.  (The
linkage editor will not handle more than sixteen aliases.)

Both the input and output data sets are assumed to contain card
images.  The record format is assumed to be fixed and blocked.  The
logical record length is assumed to be 80 bytes.  The block sizes
will be set to appropriate sizes for current public storage devices
unless overriding information is specified on the DD statements or
found in the data set labels.  These overriding block sizes must be
multiples of 80.  Keep in mind that the Linkage Editor cannot handle
data sets with blocksizes over 3200.

FIELD OF APPLICATION:  Utility

SHARE CODE(S):  120.60, 120.40

MAIN PROGRAM SOURCE LANGUAGE:  Assembler

CONTROL OPTIONS

R Option

The replace option takes care  of  the  situation in which  the
linkage  editor's  output  data  set already contains a module with
the same name as one of the new modules.  The following table
explains the effect  of the replace option.

          NAME statement encountered by the linkage editor
                      ____________________________________________
                     |              Replace Option                |
                     |      Specified      |     Not Specified    |
 ____________________|_____________________|______________________|
| Another module     | Old module deleted; |  New module ignored; |
| exists with the    | new module takes    |  old module left     |
| same name          | its place           |  unchanged           |
|____________________|_____________________|______________________|
| No other module    |               New module is                |
| exists with the    |               added to output              |
| same name          |               data set                     |
|____________________|____________________________________________|

S Option

The S option generates a SETSSI control statement in the linkage
editor load module.  The format of the statement is:

               SETSSI  000yyddd

where yyddd is the year and day on which the PRELKED job  that
created  the load  module  was  run.   This  option  is  helpful  in
maintaining program libraries.  Since SSI information is displayed
by all programs that list PDS directories, it is a handy method of
checking the date the program was  last replaced  in  the  library.
Note that the S option must be explicitly coded each time the module
is replaced so the SETSSI statement reflects  the  last date
replaced.

JOB REQUIREMENTS

Five cataloged procedures are available for PRELKED.  (To look at a
copy of any procedure type the WYLBUR command:  USE
SYS4.PROCLIB#procname.) PRELINK is the basic procedure for PRELKED as
documented.  LBLD allows you to prelink-edit and build a subroutine
load module library.  FORTVLBD, FORTLBLD and ASMLBLD allow you to
create a subroutine load module library from FORTRAN or Assembler
source modules.  Note that the NCAL (no automatic library
call) option of the linkage editor is used and that there are no
SYSLIB DD statements supplied.  This will often result in a warning
message from the linkage editor about "unresolved external
references."  Following are the basic job setup requirements for
using each procedure.

All procedures shown below assume that your output data set is NEW
and will be assigned a disposition of CATLG.  For data sets which
already exist (e.g., for a loadmodule library to which you are
adding members) two symbolics, STATUS and DISP, are available to
override the defaults.  For example, for an existing data set you
should add STATUS=OLD to the list of EXEC statement parameters.
Technically, the disposition of a data set which is already
cataloged should also be changed to DISP=KEEP, however, failure to
do so will only result in a warning message.  Note:  Square brackets
[] enclose items that are optional and may be left out at the user's
option.  Lowercase words indicate information to be supplied by the
user.

PRELINK Procedure

   //  JOB Statement
   //  EXEC  PRELINK[,PARM='options'],IDSN='WYL.gg.uuu.dsname1',
   //       ODSN=WYL.gg.uuu.dsname2

If included, the PARM options may be R or S or both (separated by
commas) for the control options described previously.  Specify the
data set (WYL.gg.uuu.dsname1) for your input object modules (IDSN).
Specify the data set (WYL.gg.uuu.dsname2) for your output (ODSN ).
To supply your object code in stream, rather than from an external
data set, leave the IDSN and IVOL parameters off the EXEC statement
and follow the statement with

   //OBJIN  DD  *

   <--- your object deck input


LBLD Procedure

This procedure will prelink-edit and create a subroutine load module
library from object module input.

   //  JOB Statement
   //  EXEC LBLD[,PARM.PRELINK='options'],OBJDSN='WYL.gg.uuu.dsname',
   //       DSN='WYL.gg.uuu.libname'

If included, the PARM options may be R or S or both.  Specify the
data set name (WYL.gg.uuu.dsname) under which your input object code
is stored.  Supply the name for the new subroutine load module
library to be created (WYL.gg.uuu.libname).

To supply your object code in stream, rather than from an external
data set, omit OBJDSN and OBJVOL parameters from the EXEC statement
and add the following

   //PRELINK.OBJIN  DD  *

   <--- your object deck input


FORTVLBD, FORTLBLD, and ASMLBLD Procedures

To create a subroutine library from the original source code,
procedures are available for both FORTRAN and Assembler.  Except for
parameters associated with a particular compiler, the format of the
job setups are identical.  All procedures are slight modifications
of the corresponding compile and link-edit procedures in which a
PRELINK step has been inserted between the compile and link steps.
ASMLBLD invokes Assembler H.  FORTVLBD uses the VS FORTRAN compiler
while FORTLBLD access the older IBM Fortran compilers (HX by
default).  Note that a library built with FORTVLBD may not be used
with a main program compiled with an older FORTRAN compiler.

The basic format of the EXEC statement is

   //  EXEC proc[,PARM.PRELINK='options'],DSN='WYL.gg.uuu.libname'

The proc name must be given (FORTVLBD, FORTLBLD or ASMLBLD); option
R or S or both may be listed; the name of the subroutine library to
be created (WYL.gg.uuu.libname) must be specified.

Shown below is the format for a job setup to invoke the VS FORTRAN
procedure to compile, prelink-edit and link-edit the source code.

   //  JOB Statement
   //  EXEC  FORTVLBD[,PARM.FORT='compiler options'],
   //     DSN='WYL.gg.uuu.libname'[,PARM.PRELINK='options'],
   //FORT.SYSIN  DD  *

   <--- FORTRAN source program

The following is an example of a job to build a subroutine library:

   //BUILDLIB  JOB  (A1.X29,999,l0),FRED
   //   EXEC  FORTLBLD,PARM.FORT='XREF',
   //   PARM.PRELINK='R,S',DSN=WYL.A1.X29.SUBLIB'
   //FORT.SYSIN  DD  *
          SUBROUTINE SUBl(A,B,C)
             .
             .
             .
          END
          SUBROUTINE SUB2(X,Y,Z)
             .
             .
             .
          END
          FUNCTION SIN(X)
             .
             .
             .
          ENTRY COS(X)
             .
             .
             .
          END

PRELKED allows the user to compile and link-edit a set of
subprograms and then store each routine independently in a program
library.

SUBMITTAL INFORMATION:

    PROGRAMMER:  Bob Werner
    AFFILIATION:  University of Iowa Computer Center
    DATE:  September l973
    MODIFIED BY:  Mark Lawrence
    AFFILIATION:  Information Technology Services
    DATE OF LAST REVISION:  June l975

DISCLAIMER

This program has been tested and has been found to operate as
described in this document.  However, no warranty is expressed or
implied by this publication regarding aptness, accuracy or
efficiency of this program for the individual application.  The user
is responsible for the choice of the program and charges or problems
incurred.  I.T.S. will investigate errors that are reported in
sufficient detail but cannot guarantee their correction.
