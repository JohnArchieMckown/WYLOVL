.cm increase time to 30 seconds, region to 512K, lines to 10000
.cm run two pass - use chars u340
.im syspub layout=guide ll=80
.hy set endpt 3
.im boldital chars=u340
.tr | 16
.bs \
.sr sec C\C
.bs
.wd
.fn set 3
.fn set 1 ////
.fn set 2 /____________________///
.fn set 3 ////
.hy set sup 2
.hy add WYLBUR
.hy add ORVYL
.hy add LOADFILE
.hy add MILTEN
.titlepage
.bt //- % -//
.ra #246
.ra September 1983
.ce on;.sp 6
ORVYL:

The Stanford Timesharing System

Reference Manual
.sk
.ce off
.pa
.sp 35 a
.boxon

.tr % 8F
.ce % Copyright 1975, 1983 by The Board of Trustees of the
.tr % %
.tr % 40
.ce Leland Stanford Junior University
.ce All rights reserved
.ce Printed in the United States of America

.ce Information Technology Services
.ce Stanford University
.ce Stanford, California 94305


.boxoff
.pa
.prelim 'About This Manual'
This manual is a functional description of
ORVYL, the timesharing monitor developed by Stanford University, as seen by
the terminal user and programmer.
.point set b b b
.point begin
Chapter 1 gives a general overview of ORVYL.
.point
Chapter 2 is a description of the ORVYL file system and the
command language file controls available to you.
.point
Chapter 3 describes LINK processing and control of your program
execution under ORVYL.
.point
Chapter 4 details the command language debugging and program
event recording aids available to the ORVYL programmer.
.point
Chapter 5 explains the ORVYL supervisor services and
the ORVYL macro language.
Macro instructions available to the programmer at the assembly
language level are organized by management areas.
.point
Chapter 6 gives information about URAM, the Unified Record Access Method.
.point
Chapter 7 describes VAM/370, the ORVYL File Batch Access Method.
.point
Chapter 8 briefly discusses the public programs available in ORVYL.
.point end
.us Document Symbol Conventions
.ix 'symbol conventions in document'

In the general form of an ORVYL command or macro instruction,
lowercase letters identify the actual information to be
entered.
For example, the command form:

   CREATE filename1 [FROM filename2 [APPEND]] [REPLACE]

indicates that you must specify a valid file name(s) as part
of the CREATE command.
.point set b b b
.point begin
Square brackets, [ ], denote optional elements in
an ORVYL command or macro instruction; they are not typed as
part of the statement.
.point
Braces, { }, in the command form indicate that you must
specify at least one of the alternatives enclosed in the braces;
braces are not typed as part of the statement.
.point
A vertical bar, |, separates alternatives or options.
.point end
Thus, in this example, you may use the CREATE command to copy the contents of
the active file or filename2 to filename1 (REPLACE) or add the
contents of filename2 to the end of filename1 with APPEND.
(More information on the CREATE command is given in section &create..)
.chapter 'Introduction'
ORVYL is the product of a number of years of development of
timesharing resources on IBM hardware at Stanford.  From its
introduction in the late sixties as a timesharing monitor on an
IBM 360/67, ORVYL has become a powerful timesharing
system, taking full advantage of expanded System/370 hardware
capabilities.

ORVYL currently operates under OS/MVS on
IBM 3081 hardware.  In
conjunction with the
.footnote 'WYLBUR'
Extensive documentation on WYLBUR is available in Document Sales,
Forsythe Hall.  Online help is available for any WYLBUR command
mentioned in this document by typing HELP <command>.
.footend
text-editing and remote job entry systems and
MILTEN terminal communication systems, ORVYL provides the
capability of executing user programs in an interactive
environment.

ORVYL brings a number of useful facilities to interactive programming:
.point set b b b
.point begin
A command language providing file manipulation
capabilities, program execution controls, and a
debugging capability.
.point
A means of access to reentrant compilers and data
base management systems called subprocessors,
allowing simultaneous processing by many users.
.point
A unique and OS/MVS independent file system which
employs special file security and file sharing
controls.
.point
A program interface with WYLBUR allowing
convenient use of available interactive system
resources.
.point end
At the assembly language level, ORVYL also provides a number of
program management services for your programs and subprocessors:
.point set b b b
.point
Input and output processing macros permitting
communication between your program, the
terminal, ORVYL files, and the WYLBUR active file.
.point
General interrupt facilities allowing your
program to control input/output processing and
utilize the hardware timer interrupt facilities.
.point
Miscellaneous supervisor services, such as
reporting the date and time of day and memory
management.
.point end
ORVYL permits many users to share both the central processing
unit (CPU) and memory.  ORVYL users share the CPU;
processing of a single user program occurs in a number of
opportunities or "turns".  Paging, controlled by the ORVYL
dispatcher, permits several users to share central computer
memory.  Pages of user program memory are transferred from disk
to memory only as they are required by the program being
executed.

ORVYL maintains a file system independent from that administered
by WYLBUR under OS/MVS.
The ORVYL file system provides file protection and
sharing capabilities uniquely suited to the timesharing
environment.
Specific levels of access to particular files or all files
created by you may be extended to other specified users or to
a general class called PUBLIC.  Files may be designated for
concurrent use by many potential users or temporarily reserved
by a single user for development or updating.
A largely transparent interface between ORVYL files and the
WYLBUR active file provides an efficient text-editing capability
and a direct method for the loading of program object modules
maintained in the OS/MVS file system.

On the 3081, user files and the indexes required to access user
files are maintained on disk.  All disk allocation information,
as well as file access information, is also retained on disk.
The ORVYL file system maintains the following information, organized
by accounting group and by file, on user storage:
.ix 'user storage information'
.point set b -
.point begin
By group:
.point 2
group and user name;
.point 2
number of ORVYL blocks currently in use in all files;
.point 2
PUBLIC class access privileges;
.point 2
privileges for individual non-owning users.
.point end
.point set b -
.point begin
By file:
.point 2
file name;
.point 2
number of ORVYL blocks currently in use in the file;
.point 2
PUBLIC class access privileges;
.point 2
file privileges for individual non-owning users.
.point end
.section 'ORVYL Command Language Processor (CLP)'
.ix 'Command Language Processor' . 'see also CLP'
Much of ORVYL's flexibility comes at the Command Language
Processor (CLP) level.
.ix 'CLP'
In the timeshared environment, the ORVYL command language allows
you to exercise a level of control over program execution and a
"virtual computer" (that is, virtual memory) usually available
only to an operator sitting at a computer console.  By entering
ORVYL commands at a terminal, you may direct the loading and
execution of a program, as well as examine and modify an address
space, with a small set of general purpose commands.

The ORVYL command language appears as a subset of
a larger group of WYLBUR commands.
In fact, since both operate using the WYLBUR active file, a
parallel command language structure has been developed between
WYLBUR and ORVYL.
For example, to store and retrieve the contents of a WYLBUR
active file on a data set, you employ the SAVE and USE commands.
Similarly, to pass data to and from an ORVYL file, you issue the
PUT and GET commands.
.section 'ORVYL Public Programs'
.ix 'public programs'
.ix 'program' 'public'
ORVYL supports the interactive applications of the Stanford Public
Information REtrieval System
.footnote '(SPIRES)'
Documentation for SPIRES is available in Document Sales, Forsythe Hall.
.footend
and a number of interactive processors
called public
.footnote 'programs.'
Documentation for public programs is usually available in Document
Sales, Forsythe Hall, or the reference racks in the public terminal
room in Forsythe Hall.
.footend
ORVYL public programs currently
implemented include SNOBOL (SPITBOL), PL360, a JCL Scanner, and
a BNF Analyzer.  APL, PL/C, BASIC, FORTRAN, WATFIV, Pascal, SCRIPT, and SORT are
available under ORVYL.  For
a list of programs currently supported, type the SHOW PROGRAMS PUBLIC command.

.cm ORVYL was first designed by Roger Fajman and, under the direction
.cm of Rod Fredrickson, implemented at the Campus Facility of the
.cm Stanford Computation Center in 1968.  John Borgelt developed the
.cm original ORVYL file system.  In 1971, a means for batch access to
.cm the ORVYL file system (VAM) was designed by Richard Levitt and
.cm later enhanced by Carol Lennox.
.cm Throughout the period 1968-71, ORVYL also benefitted from
.cm important contributions made by Richard Carr, Don Gold, and
.cm James Moore.
.cm
.cm To achieve operating efficiencies, a redesigned ORVYL-II
.cm was introduced in 1973.  Substantial cost reductions were
.cm achieved through basic changes to ORVYL'S paging and dispatching
.cm mechanisms implemented by Richard Carr.  Parallel language and
.cm data base systems development also took place under the
.cm direction of Bob Berns (Languages Group), John Schroeder
.cm (SPIRES), and Donn Martin (BALLOTS).
.cm
.cm ORVYL is a new design intended to make maximum use of IBM
.cm hardware and OS/VS advances.
.cm It is a major part of the interactive system software developed
.cm by the Stanford Center for Information Processing, Charles R.
.cm Dickens, Director.
.cm ORVYL was designed by the SCIP Interactive Systems Group and is
.cm the combined effort of Richard Carr, Carol Lennox, Richard
.cm Levitt, John Montague, Michael Powell, and William Skane, all
.cm under the direction of James Moore and Edgar Williams.
.pa
.chapter 'ORVYL File System'
.section 'ORVYL File Structure'
.ix 'file' 'structure'
An ORVYL file is a collection of data blocks; each block
is 2048 bytes in length.
You may write data blocks less than 2048 bytes in length;
however, since each block is stored in a 2048-byte space,
storage charges are equivalent for complete and incomplete
blocks.
.ix 'storage charges'
An ORVYL block may be created or released independent of any
other block.  No charges are assessed for blocks until they are
created or written.
.ix 'charges'
.section 'File Naming Conventions'
.ix 'file' 'naming conventions'
.sr chart &pubSWprt
ORVYL maintains file names of the general form:

   ORV.gg.uuu.filename
.ix 'filename'

.fo off
gg   identifies the accounting group in which the file was created

uuu  identifies the user who created the file

.fo
.hi 5
filename is a file identifier containing as many as 33
alphanumeric characters.  Legal alphanumeric characters for
inclusion in a file name include the letters A-Z, numbers 0-9,
asterisk *, underscore _, and period .; periods separate elements
in the complete file name.  In
naming ORVYL files, periods may separate the
file name into levels.
.hi

When creating or referencing an ORVYL file, you need
specify only the filename; group and user
identification are supplied automatically by ORVYL.  When access
has been permitted by the file owner, other users may also
reference one or more of the owner's files.  The following chart
lists the legal forms of address for ORVYL files, followed by a
description of the type of user each form is intended to serve.
All forms listed are legal for input to the Command Language
Processor (CLP); only a subset, however, may be used to name files in
.ix 'CLP'
ORVYL macros.

.pa
.fo off
Valid ORVYL Filename Forms | For  | For    |        Description
                           | CLP? | Macro? |
__________________________________________________________________________
ORV.gg.uuu.filename        | Yes  |  Yes   | Fully qualified filename
__________________________________________________________________________
filename                   | Yes  |  Yes   | Used by the file owner
__________________________________________________________________________
@gg.&uuu.filename          | Yes  |  Yes   | For members of another group
&uuu.@gg.filename          | Yes  |  Yes   | with different user initials
__________________________________________________________________________
&uuu.filename              | Yes  |  Yes   | For members of the file
filename USER uuu          | Yes  |  No    | owner's group
__________________________________________________________________________
@gg.filename               | Yes  |  Yes   | For a member of a different
filename GROUP gg          | Yes  |  No    | group with the same user
                           |      |        | initials as the file owner
__________________________________________________________________________
filename USER uuu GROUP gg | Yes  |  No    | USER identifies the file owner.
filename GROUP gg USER uuu | Yes  |  No    | GROUP identifies the owner's
                           |      |        | group.
__________________________________________________________________________
filename ACCOUNT uuu$gg    | Yes  |  No    | ACCOUNT identifies the file
filename ACCOUNT gg.uuu    | Yes  |  No    | owner's initials and group.
__________________________________________________________________________
filename PUBLIC            | Yes  |  No    | PUBLIC file (PUB$gg)
__________________________________________________________________________
.fo on

When ORVYL file macros require specification of a user name
(group identifier plus user initials), the forms gg.uuu or
uuu.gg are both accepted.
For use with CLP, PUBLIC is accepted
as a valid group and user identifier for the account in which
the ORVYL public files reside (that is, PUB$gg).

Programs may create and write temporary ORVYL files during
execution; (see the description of the ATTACH 2 macro in chapter 5).
Such temporary files are erased as soon as the program detaches
the file.

Throughout this manual, the term filename
.ix 'filename'
implies all of the valid ORVYL filename forms shown above.
The term "account-info" implies any of the following:
.ix 'account-info definition'

   USER uuu [GROUP gg]
   GROUP gg [USER uuu]
   ACCOUNT uuu$gg
   ACCOUNT gg.uuu
   PUBLIC
.section 'ORVYL File Creation'
.ix 'file' 'creation'
.sr file &pubSWprt
An ORVYL file is created in one of the three following ways:
.point set b b b
.point begin
with the PUT command, copying the contents of the
WYLBUR active file to an ORVYL file
.point
by a user program running under ORVYL (see section &load.)
.point
by execution of the LINK command (see section &link.), creating a file which
contains an executable program.
.point end
Using the CREATE command (see section &create.), you may establish an
ORVYL file with no contents.
An optional version of the CREATE command also
permits you to copy or append the contents of one file to
another.  File contents and directory information may be
destroyed by the ERASE command.  Employing the
RENAME command (see section &rename.), you may change the names of established
ORVYL files.
.subsection 'WYLBUR Active File'
.ix 'WYLBUR' 'active file'
ORVYL and WYLBUR both make use of the
WYLBUR active file.
The WYLBUR active file is an important interface between the
.ix 'active file' 'description'
ORVYL and OS/MVS file systems.
It is a temporary or working collection of lines of text.
Using the WYLBUR text-editing facility, lines may be inserted,
replaced, or deleted on a line-by-line basis.
Within lines, individual characters or character strings may be
inserted, modified, or deleted.

The WYLBUR active file provides a convenient means for
introducing programs and associated data into ORVYL.  Program
output may be directed to the active file for listing at the
terminal or on a printer.  Output may also be written
online to WYLBUR data sets or ORVYL files for later use.

The ORVYL facilities controlling the storage of the contents of
the WYLBUR active file in an ORVYL file and the transfer of the
contents of an ORVYL file to your WYLBUR active file are
the PUT and GET commands, respectively (see sections &put and &get.).
.subsection 'CREATE Command'
.sr create &pubSWprt
.ix 'Command' 'CREATE'
   CREATE filename1 [FROM filename2 [APPEND]] [REPLACE]

Allocates a file directory entry in the ORVYL file system for a
file to be identified by the specified name (here, filename1).
.ix 'filename'

The FROM option creates a new file in the ORVYL file system
called filename1 and, in addition, copies the contents of an
existing file, filename2, to the newly allocated file.
Access controls are not copied from filename2 to filename1.

REPLACE deletes any contents of filename1 and copies the
contents of the active file or filename2 to an existing
filename1.
APPEND copies blocks from filename2 to the end of filename1.
Block numbers are assigned beginning with one greater than the
last existing block number in filename1.
.subsection 'ERASE Command'
   ERASE filename [CONTENTS]
.ix 'Command' 'ERASE'

Removes the specified file from the ORVYL file system, destroying
any file contents.  CONTENTS
deletes all user data from filename1, but retains ORVYL file
directory information.
.subsection 'RENAME Command'
.ix 'Command' 'RENAME'
.sr rename &pubSWprt
   RENAME filename1  TO  filename2

Changes the name of an existing ORVYL file (filename1) to
filename2.
The RENAME command does not affect the file contents or those
statistics and access privileges maintained for the file
contents by ORVYL.
.subsection 'DEFLATE Command'
.ix 'Command' 'DEFLATE'
   DEFLATE filename

Deletes all empty blocks from the specified file.
Does not modify file directory information or other file
contents.
.subsection 'PUT Command'
.ix 'Command' 'PUT'
.sr put &pubSWprt
   PUT filename [format] [REPLACE|APPEND] [(blocking factor)]
                                          [HEX|NUMBERED|INTEGER]

Copies the contents of the WYLBUR active file to the specified
.ix 'active file' 'PUT command'
ORVYL file.

.us Options

.hi 5
format -- The PUT format options specify the form in which
data is to be stored in the ORVYL file.
If no format is specified, ORVYL assumes that the file is
to be written in EDIT format:
.hi

        EDIT      The specified ORVYL file is to be written using the WYLBUR
                  compressed text format.  This format includes the WYLBUR
                  line number, a field containing the line length, and the
                  compacted text.  This format is equivalent to the PREST
                  format discussed in chapter 5.

        VARIABLE  The specified ORVYL file is to be written using the VARIABLE
                  format.  This format contains the WYLBUR line number, a
                  field containing the line length, and the line text.  The
                  line text lincludes imbedded blanks; trailing blanks are
                  truncated.

        CARD      The specified ORVYL file is to be written using CARD format.
                  CARD format instructs WYLBUR to pass fixed-length lines 80
                  characters long.  Lines exceeding this length are truncated
                  to the first 80 characters.  No length field or WYLBUR line
                  number is included.  CARD format is equivalent to the
                  specification LRECL=80.  See LRECL note below.

        PRINT     The specified ORVYL file is to be written using PRINT
                  format.  PRINT format instructs WYLBUR to pass fixed-length
                  lines 133 characters long.  Lines exceeding this length are
                  truncated to the first 133 characters.  No length field or
                  WYLBUR line number is included.  PRINT format is equivalent
                  to the format specification LRECL=133.  See LRECL note below.

        LRECL=n   The specified ORVYL file is to be written using LRECL
                  format.  LRECL format instructs WYLBUR to pass fixed-length
                  lines n characters long.  Lines exceeding this length are
                  truncated to n characters.  If the specified line is not
                  an integer factor of the size of an ORVYL block (2048 bytes),
                  as many lines of length n as can be accommodated are
                  included in a single data block.

.hi 5
REPLACE -- Deletes the contents of the specified ORVYL file
prior to writing the current WYLBUR active file in that
file.  Previously assigned access privileges are retained.

APPEND -- If the specified ORVYL file already exists,
appends the contents of the current WYLBUR active file to
that ORVYL file.

(blocking factor) -- Specifies the number of lines in the
WYLBUR active file to be contained in a single block in
the ORVYL file, where a single ORVYL block may contain as
many as 2048 bytes.

HEX -- Condenses a WYLBUR active file written in
hexadecimal representation into EBCDIC and writes the
translated contents in the specified ORVYL file.
Causes each pair of hexadecimal characters in the active
file to be converted to the corresponding EBCDIC value
before the active file is copied to the specified ORVYL
file.
This option is only valid for use (a) with the CARD format
when the NUMBERED option is not employed or (b) with the LRECL
format specification.  The LRECL value n must be an even integer.
Attempts to translate invalid hexadecimal characters to EBCDIC
cause the PUT command to be aborted.

NUMBERED -- When CARD format is also specified, the decimal
WYLBUR line number is stored in character positions 73
through 80 in each line of the ORVYL file.
Each line must have a unique line number, but line numbers
need not be in ascending order.
If the line number exceeds 9999.999, the left-most
digits are discarded.

INTEGER -- When CARD format is also specified, the WYLBUR
line number is stored in character positions 73 through 80
in each line of the the ORVYL file.
Line numbers include leading and trailing zeros; however,
the decimal point is omitted.
.hi

To use the NUMBERED sequence and INTEGER
sequence numbers in subsequent GET commands, the file must be
retrieved GET NUMBERED or GET INTEGER.
If neither option is specified, the contents of character
positions 73-80 are treated as any other data.
.subsection 'GET Command'
.ix 'Command' 'GET'
.sr get &pubSWprt
   GET filename [format] [CLEAR|MERGE] [SKIP=n] [HEX|NUMBERED|INTEGER] [LINES=n]

Copies the contents of the specified ORVYL file to your
WYLBUR active file.
.ix 'active file' 'GET command'

.us Options

.hi 5
format -- The GET format options specify the form in which
data is presently stored on the ORVYL file.
If no format is specified, ORVYL assumes that the file was
written using the compressed text format EDIT.
When the specified format contains no line numbers, WYLBUR
supplies them.
.hi

        EDIT      The specified ORVYL file was written employing the WYLBUR
                  compressed text format.  This format includes the WYLBUR
                  line number, a field containing the line length, and the
                  length, and the compacted text.  This format is equivalent
                  to the PREST format discussed in chapter 5.

        VARIABLE  The specified ORVYL file was written employing the VARIABLE
                  format.  This format contains the WYLBUR line number, a
                  field containing the line length, and the line text.  The
                  line text includes embedded blanks.

        CARD      The specified ORVYL file is composed of fixed-length lines
                  80 characters long.  CARD format is equivalent to the format
                  specification LRECL=80.  No length field or WYLBUR line
                  number is included in CARD format.

        PRINT     The specified ORVYL file is composed of fixed-length lines
                  133 characters long.  PRINT format is equivalent to the
                  format specification LRECL=133.  No length field or WYLBUR
                  line number is included in PRINT format.

       LRECL=n    The specified ORVYL file is composed of fixed-length lines
                  n characters long.  No length field or WYLBUR line number
                  is included in LRECL format.

.hi 5
CLEAR -- Deletes the current contents of the WYLBUR active
file prior to passing the contents of the specified ORVYL
file to the WYLBUR active file.

MERGE -- Appends or interleaves the contents of the
specified ORVYL file in the current WYLBUR active file.
When used with the EDIT, VARIABLE, and CARD NUMBERED format
options, the included WYLBUR line numbers are employed
when inserting lines in the active file.  When used with
any other format option, file contents are appended to the
active file.
MERGE may not be used to replace lines in the current
active file.

SKIP=n -- Skips the first n lines of the specified ORVYL
file and copies all remaining lines to the WYLBUR active
file.

HEX -- Expands the contents of the ORVYL file into
hexadecimal representation for use in the WYLBUR active
file.
Each byte in the ORVYL file is expanded into two printable
hexadecimal characters.
This option is only valid for use (1) with the CARD
format when the NUMBERED option is not employed or (2)
with the LRECL format specification, where LRECL is an
even integer.

NUMBERED -- When the CARD format option is also specified,
employs the decimal line numbers contained in character
positions 73 through 80 in each line in the ORVYL file as
WYLBUR line numbers (see PUT NUMBERED).

INTEGER -- When the CARD format option is also specified,
employs the integer line numbers contained in character
positions 73 through 80 in each line in the ORVYL file as
WYLBUR line numbers (see PUT INTEGER).

LINES=n -- Copies only the first n lines of the specified
ORVYL file, or the next n lines following a SKIP=n
option, to the WYLBUR active file.
.hi
.section 'File Access Controls'
.ix 'file' 'access controls'
The ORVYL file system maintains a flexible security scheme for
all user files.
This system is based on the principle that access to each file
must be explicitly stated and then controlled by the file owner.
Access to a particular file or all files created by one user may
be extended to any one or all other users.

When an ORVYL file is first created, no access is permitted to
any user except the file owner.
By specifying a level of access to a particular file or global
access to all files with the SET PERMIT command, the file owner
may explicitly assign file control to other users.
.subsection 'SET PERMIT Command, By File'
.ix 'Command' 'SET PERMIT'
   SET PERMIT [filename] [FOR {gg.uuu|GROUP gg|PUBLIC}]
              [READ|WRITE|NONE] [APPEND] [EXTEND]

The SET PERMIT command allows you to specify a number of different
ways that other users may access your files.  You may set access
privileges for an individual file or for all files owned by you.
(However, you may not assign access privileges to individual library
members; access granted applies to  your entire library.)  You may
restrict access to another specified user or group or may use the
PUBLIC option to open your file(s) to all users.

Access permits must be explicitly set.  There are no default
privileges assigned by ORVYL to an individual file or files;
however, an ORVYL program, such as SPIRES, may establish defaults
when it creates a file on your behalf.

To give another user access privileges to a single file:

   SET PERMIT filename FOR gg.uuu [access-level-option]

To give another user access privileges to all your files:

   SET PERMIT FOR gg.uuu [access-level-option]

To grant access privileges to another group to a single file:

   SET PERMIT filename FOR GROUP gg [access-level-option]

To give another group access privileges to all your files:

   SET PERMIT FOR GROUP gg [access-level-option]

To give all users access to your file:

    SET PERMIT FOR PUBLIC [access-level-option]

.us Options

.hi 5
filename -- The name of the file to which the SET PERMIT command
is applied.

READ -- Permits reading of the file only.  Does not allow
any changes to be made to the file.

WRITE -- Permits full access, including reading the file,
making changes to the file, appending records to the
file, and erasing the file.
.hi
.subsection 'SET SHARE Command'
.ix 'Command' 'SET SHARE'
   SET SHARE filename

Prevents exclusive use of the specified file by any user.  The
file is to be used in common and may only be attached by user
programs or the Command Language Processor (CLP) with MODE=SHARE.  Only
.ix 'CLP'
the file owner may issue the SET SHARE command.
.subsection 'SET NOSHARE Command'
.ix 'Command' 'SET NOSHARE'
   SET NOSHARE filename

Permits you to attach the specified file to the exclusion of
all others.  Only the file owner may issue the SET NOSHARE
command.
.subsection 'SET FILEMASK Command'
.ix 'Command' 'SET FILEMASK'
   SET FILEMASK filename {WRITE|READ|NONE|APPEND}

The SET FILEMASK command is a way to restrict access to an
individual ORVYL file.  It overrides any other permits that may have
been granted.  FILEMASK may be set to WRITE (the default), READ,
APPEND (which may also be specified with READ), or NONE.  Only the
file owner may issue the SET FILEMASK command; it may not be
extended to others.

.us Options

.ix filename 'on SET FILEMASK Command'
.hi 5
filename -- The name of the ORVYL file to which the SET
FILEMASK command is applied.

WRITE -- The default.  Permits full access, including reading
the file, making changes to the file, appending
records to the file, and erasing the file.

READ -- Restricts access to the ability to read the file.
Does not allow any changes to be made to the file contents.

NONE -- No one, including the file owner, may access this
file.  The file owner may remove this restriction
with a subsequent SET PERMIT command.

APPEND -- Restricts access to the ability to add records to
the end of a file; does not allow the file to be
read.  May also be specified with READ if READ
privileges are to be granted.
.hi
.subsection 'SET CLP Command'
.ix 'Command' 'SET CLP'
   SET CLP filename

Permits the execution of all ORVYL Command Language Processor
(CLP) commands otherwise available to the user for operation on the
.ix 'CLP'
specified file.  When a file is first created, SET CLP is in
effect.  Only the file owner may issue the SET CLP command.
.subsection 'SET NOCLP Command'
.ix 'Command' 'SET NOCLP'
   SET NOCLP filename

Blocks the execution of the ORVYL file commands ERASE, PUT, RENAME,
SET PERMIT, SHOW FILES, ERASE, and DEFLATE.  SET NOCLP does not affect
processing of the specified file by a user program.  SET NOCLP may
only be issued by the file owner.
.subsection 'SET TIMER Command'
.ix 'Command' 'SET TIMER'
   SET TIMER m:n

where m is seconds and n is tenths of seconds.
.section 'File Information Commands'
.ix 'Command' 'file information'
.ix 'file' 'information commands'
The ORVYL file information commands allow the file owner, or any
user with file access privileges, to display information on
individual files.
Available information includes the size of a specified file in
ORVYL blocks (SHOW BLOCKS), the access privileges established
for a specific file with the SET PERMIT command (SHOW PERMITS),
the net level of access to a specific file for the user issuing the command
(SHOW ACCESS), the file access privileges associated with all
files created by a single user, and the SHARE status set for a
particular file with the SET SHARE/NOSHARE commands.
.subsection 'SHOW BLOCKS Command'
.ix 'Command' 'SHOW BLOCKS'
   SHOW BLOCKS filename
   SHOW BLOCKS [FILE] filename|uuu.gg|ACCOUNT {uuu.gg|gg.uuu}|FOR account

Prints the number of ORVYL blocks included in the specified file,
followed by the numbers of the first and last blocks in that
file.

An ORVYL file is a collection of 2048 (2K) byte blocks.  SHOW BLOCKS
gives the total number of ORVYL blocks you are using.  It can also
be used to show the blocks used for a single file or the total
blocks used by another account.  An index block is allocated for
each file; this block is not reported by SHOW FILE BLOCKS or by SHOW
BLOCKS [filename] but is included in the total for your account.

You are charged only for the ORVYL blocks you actually use, not for
blocks allocated.

When specified with a filename, the SHOW BLOCKS command displays
the number of ORVYL blocks included in the specified file, followed
by the numbers of the first and last blocks in that file.

If the SHOW BLOCKS command is specified with an account (gg.uuu),
the information displayed includes the number of blocks currently in
use, followed by the current limit on the number of ORVYL blocks
which can be allocated to the user.  If no user is specified, the
account of the user issuing the command is assumed.
.subsection 'SHOW ACCESS Command'
.ix 'Command' 'SHOW ACCESS'
   SHOW ACCESS filename

Displays the access privileges available to the user issuing the command for
the specified file.
The privilege displayed is a combination of (1) the file and
account-level permits for the user issuing the command, the group of that user, and PUBLIC and
(2) the global access limit assigned by SET FILEMASK.
.subsection 'SHOW SHARE Command'
.ix 'Command' 'SHOW SHARE'
   SHOW SHARE filename

Displays the SHARE status set by the file owner for the specified
file.
.subsection 'SHOW CLP Command'
.ix 'Command' 'SHOW CLP'
   SHOW CLP filename

Displays the CLP (Command Language Processor) condition set
for the specified file by the file
owner.
.subsection 'SHOW FILEMASK Command'
.ix 'Command' 'SHOW FILEMASK'
   SHOW FILEMASK filename

Displays the access level assigned to the specified file with the
SET FILEMASK command.
.section 'Directory Information Commands'
.ix 'Command' 'directory information'
.ix 'directory information commands'
Available information on your files includes statistics on
the number of allocated blocks and the number of blocks
currently in use (SHOW BLOCKS) and an alphabetical listing of
certain or all ORVYL files, selected according to optional
criteria (SHOW FILES).
.subsection 'SHOW BLOCKS Command'
.ix 'Command' 'SHOW BLOCKS'
   SHOW BLOCKS [uuu.gg]

Displays the current limit on the number of ORVYL blocks which
can be allocated to the user, followed by the number of blocks
currently in use.
If no user is specified, the user issuing the command is assumed.
.subsection 'SHOW PERMITS Command'
.ix 'Command' 'SHOW PERMITS'
   SHOW PERMITS [xxx.yy] [FOR{uuu.gg|PUBLIC}]

Prints a list of users who currently enjoy access to the
specified user's files.  If no user is specified (xxx.yy), then
ORVYL reports all access privileges assigned by the user issuing
the command.  Any user assigned access privileges may display all
privileged users as well as the level of access assigned to
each.
.subsection 'SHOW ACCESS Command'
.ix 'Command' 'SHOW ACCESS'
   SHOW ACCESS uuu.gg

Displays the access privilege available to the user issuing the command for
all files owned by the specified user (uuu.gg).
This privilege is a combination of the privileges assigned both
the user issuing the command and PUBLIC.
.subsection 'SHOW FILES Command'
.ix 'Command' 'SHOW FILES'
   SHOW FILES [BLOCKS] [DATED] [ERASE] [FORMAT]
              [{LIKE|UNLIKE|FROM}\name] [USER\uuu [GROUP\gg]] [ALL]

Any of the following options may be appended to the SHOW FILES
command to provide additional information or modify the file
name display.

.us Options

.hi 5
BLOCKS -- Displays the number of file blocks allocated to the
specified file, together with first (F) and last (L) block
numbers.
If a file has been created with no contents, the BLOCKS
option reports NO CONTENTS.

DATED -- Includes the creation date and date of last use
for each file.

ERASE -- Prompts you with the name of each file
satisfying the SHOW FILES criteria.
A YES reply to the file name prompt causes ORVYL to delete
the file.

FORMAT -- Lists the format (for example, EDIT, VARIABLE) in which
data was written in the specified ORVYL file.  See the
descriptions of ORVYL file formats in section &file..

LIKE name -- Displays those file names that begin with the
specified name.

UNLIKE name -- Displays those file names that do not begin
with the specified name.

FROM name -- Prints the names of all files in alphabetical
order, beginning with the specified name.

USER uuu [GROUP gg] -- Lists the names of files for the specified
user.  Only those files to which the user issuing the command has some level of
access are displayed.

ALL -- Displays BLOCKS, DATED, and FORMAT information for
the specified file.
.hi
.subsection 'SHOW FILES ATTACHED Command'
.ix 'Command' 'SHOW FILES ATTACHED'
   SHOW FILES [ATTACHED]

ATTACHED -- Displays the names of all those ORVYL files currently
attached by the logged-on user.
.pa
.chapter 'Executing ORVYL Programs'
Under ORVYL, user programs may be executed by employing one of
the ORVYL interactive language processors (for example, PL/C, PL360,
APL, BASIC, SPITBOL) or by loading standard OS object
modules produced by OS/VS language
.footnote 'processors.'
For instructions
on the execution of programs written under the interactive
language processors, consult the detailed
documentation for each, available in Document Sales, Forsythe Hall.
.footend

ORVYL accepts object modules produced online or from one of the
following language processors: FORTRAN IV (G and H), PL360, OS
Assembler, PL/1 and COBOL.  Object modules are processed by the
ORVYL loader to produce a load module.  Load module output may
then be executed directly or stored in an ORVYL load module
library for subsequent execution.
.section 'Creating Load Modules'
.ix 'creating' 'load modules'
.ix 'load modules'
.sr link &pubSWprt
The LINK command invokes the ORVYL loader.
Object modules may be input from a file in the ORVYL file system,
from your WYLBUR active file, or from both.
The LINK command is written in the general form:
.ix 'Command' 'link'

   LINK {ACTIVE|FROM filename} [CLEAR] [LIST] [ENTER [PAUSE] [parm]]

where ACTIVE specifies that the contents of your WYLBUR
active file are to be used as the primary input for LINK.
The alternate form, FROM filename, directs LINK to the specified
ORVYL file for input.
ORVYL files for use as LINK input must be written in EDIT or CARD
format.  (See section &file for a description of ORVYL file
formats.)
CLEAR clears the previous contents of user memory, if any.
LIST logs all LINK control statements and ENDs of object decks
as they are processed.

ENTER instructs ORVYL to begin program execution immediately
following the completion of LINK processing providing a NAME
statement wasn't used to store the program in a LOADFILE.
The PAUSE option for ENTER returns control to the Command
Language Processor (CLP) and sets the program entry point to the first
instruction.
Execution may then be initiated with the GO command (see the section &go.).
With the ENTER option, parameters may also be passed to your
program in the form:

          'text' or PARM='text'

Text may be any set of characters,
including matched sets of parentheses, doubled quotes, or
doubled apostrophes.
.section 'LINK Input and Control Statements'
.ix 'statement' 'LINK input and control'
.ix 'LINK input and control statements'
LINK input may consist of complete object modules, load modules,
and the LINK control statements detailed below.  You should
note that WYLBUR, MILTEN, or ORVYL commands may not be included
in LINK input.

The following LINK control statements provide much of the
flexibility available with the OS Linkage Editor.
.ix 'OS linkage editor'
.ix 'linkage editor'
Certain OS Linkage Editor functions (for example, OVERLAY) are not
supported under ORVYL LINK.  Other functions familiar to OS
Linkage Editor users have been modified, while still others have
been added specifically to meet the special requirements of the
ORVYL programmer.

The OS Linkage Editor allows you to specify certain
error diagnostics, processing, and space allocation options in
the OS JCL.
Similarly, ORVYL provides a control statement PARM that specifies
certain global options prior to the processing of all other LINK
input.
.subsection 'PARM statement'
.ix 'statement' 'PARM'
.sr pvt &pubSWprt
   PARM [option1] [option2]  ...

must precede all other control statements in the LINK input.  The
following PARM options are currently available:

.hi 5
LET -- Permits LINK processing to continue to the creation
of an executable program despite the occurrence of certain
non-critical errors such as duplicate control sections, an
error on a control statement, or overflow in the ALIAS,
REPLACE, or CHANGE symbol tables.

NCAL -- Precludes LINK from calling library members in
order to resolve external references.
NCAL allows you to conserve space in the
output LOADFILE, since subprograms maintained in libraries need
not be included.  When a program is
invoked with the CALL command (see section &call.), all
unresolved references are resolved from those libraries
specified in the SYSLIB control statement(s).

SIZE=n -- Specifies the amount of storage required for the
program MAP to be constructed.  SIZE must be a decimal
value less than or equal to 65536 and may be expressed as
nK bytes, where the value of n is less than or equal to
64; the default SIZE is 12K bytes.

LIST -- All control statements are echoed at the terminal
as they are processed.

MAP -- Prints a module map at the terminal.  This map is
ordered by CSECT location, while the map available with
the SHOW MAP command is ordered alphabetically by symbol
name.

OSNT -- Specifies that the program is to be entered with OS
Entry Conventions.  This does not imply, however, that OS
supervisor calls in the program will execute.

FORT -- The program calls the FORTRAN library (implies
OSNT).

URAM -- The program employs the Unified Record Access
Method (URAM); see chapter 6 for more information on URAM.

PROT -- The program may not modify itself (that is, the
program is refreshable).  When loaded, the program is
protected from inadvertent modification.

SHRD -- The program is reentrant and may be shared by
several users.  Each user of the program is provided a
separate user work area.

PRIV -- The program is declared private.  The output
LOADFILE is protected against all access from user
programs.
Any attempt to SHOW or PATCH the program when loaded is
blocked.

.hi
LINK control statements may not be placed within an object
module.
In several cases, the placement of control statements is
restricted.
The last paragraph of each section below indicates any
restrictions.
Control statements may be as many as 133 characters in length,
but may not be continued from one line to the next.
Blanks are used to separate operands in LINK control statements.

If a file contains an INCLUDE or other control statement that
specifies a second filename, then the default USER and GROUP for
the second file is taken from the first.
.subsection 'ALIAS Statement'
.ix 'statement' 'ALIAS'
ALIAS specifies additional names for the output library member.
As many as 16 aliases may be specified for one library member.

   ALIAS symbol [symbol ...]

where symbol is defined as a control section, entry name, or
alternate name for the program.  When the program is executed by
calling an ALIAS which is a control section or entry name,
execution begins at the external name referenced.

An ALIAS statement must precede the NAME statement used to
specify the member name.
.subsection 'CHANGE Statement'
CHANGE replaces an external symbol by the new symbol enclosed in
parentheses following the external symbol.

   CHANGE external-symbol (new-symbol)  ...

where external-symbol may be a control section name, an entry
name, or an external reference.  New-symbol is the name to which
the external symbol is to be changed.

A CHANGE statement must immediately precede either (1) the object
module containing the external symbol to be changed or (2) the
INCLUDE statement specifying that object module.
.subsection 'COMMENT Statement'
.ix 'statement' 'COMMENT'
COMMENT documents LINK processing.  ORVYL logs all COMMENT
messages at the user terminal as they are encountered in LINK
input.

   COMMENT any-text
.subsection 'ENTRY Statement'
.ix 'statement' 'ENTRY'
ENTRY specifies the symbolic name of the first instruction to be
executed when the program is ENTERed or called by its module
NAME.

   ENTRY external-name

where external-name is the name of an instruction, not a data
name.

An ENTRY statement must precede the NAME statement for the
module, if one exists.
.subsection 'EXPAND Statement'
.ix 'statement' 'EXPAND'
EXPAND lengthens a control section or named common section by a
specified number of bytes.

   EXPAND name (xxxx)

where name is the symbolic name of a common section or control
section, the length of which is to be increased, and (xxxx) is
the decimal number of bytes to be added to the length of the
common or control section.

An EXPAND statement must immediately follow the object module
containing the control or common section to which it refers.
If the module contains more than one section, then the named
section must be the last one defined.
.subsection 'INCLUDE Statement'
.ix 'statement' 'INCLUDE'
INCLUDE specifies ORVYL files or LOADFILES that are to be sources
of additional input for LINK.
INCLUDE statements are processed in the order in which they
appear in the input.
Only one file or LOADFILE may be processed per INCLUDE statement.

   INCLUDE filename [(membername...)]

where filename is the name of a file or LOADFILE to be used as an
additional source of input.
For a LOADFILE, at least one membername must be specified.
Other files must be written in EDIT or CARD format.
.subsection 'NAME Statement'
.ix 'statement' 'NAME'
NAME specifies the name of the program to be stored in a
LOADFILE.
Serves as a delimiter, allowing multiple program processing in a
single pass.

   NAME membername [(R)]

where membername is the name to be assigned to the program
created from the preceding input.  (R) indicates that this
program replaces an identically named module in the output
LOADFILE.  After a NAME statement has been processed, memory is
automatically cleared for the next program.  Once stored in a
LOADFILE, the CALL command may be used to execute the stored
program.
.ix 'Command' 'CALL'

The NAME statement is placed after the last object module or
control statement that is to be used for the program.
.subsection 'PAGE Statement'
.ix 'statement' 'PAGE'
PAGE aligns a control section or named common area on a 4K page
boundary.

   PAGE [{common-area-name|csectname} ...]

where common-area-name is the name of the common area to be
aligned on a page boundary.
Csectname is the name of the control section to be aligned on a
page boundary.
If no name is specified, then the next common or control section
encountered in the input is aligned on a page boundary.

The PAGE statement must immediately precede either (1) the object
module defining the common area or control section or (2)
the INCLUDE statement specifying that object module.
.subsection 'REPLACE Statement'
.ix 'statement' 'REPLACE'
REPLACE specifies one or more of the following:
.point set b b b
.point begin
replacement of one control section with another
.point
deletion of a control section
.point
deletion of an entry name.
.point end
   REPLACE {csectname1 [(csectname2)]|entry-name} ...

where csectname is the name of a control section.  If csectname1
is used, the control section is deleted; if csectname2 is also
specified, the first control section is replaced with the
second.  Entry-name is the entry name to be deleted.

The REPLACE statement must immediately precede either (1) the
module containing the control section or entry name to be
replaced or deleted or (2) the INCLUDE statement specifying
the module.
.subsection 'LOADFILE Statement'
.ix 'statement' 'LOADFILE'
LOADFILE specifies the LOADFILE in which the program is to be
placed by a NAME statement following LINK processing.
If this statement is not included in the LINK input, PROGLIB is
the default LOADFILE.

   LOADFILE filename

where filename is the name of the LOADFILE member.

If a number of programs are linked at the same time, the
last named LOADFILE is assumed for each program.

The LOADFILE statement may be placed anywhere before the NAME
statement.
.subsection 'SYSLIB Statement'
.ix 'statement' 'SYSLIB'
SYSLIB specifies an automatic call library for LINK processing.
As many as eight libraries may be specified in separate SYSLIB
statements.

   SYSLIB filename

where filename is the name of a LOADFILE.

The SYSLIB statement must precede the NAME statement for each
program that is to make use of the automatic call libraries.
.subsection 'ZAPNAME Statement'
.ix 'statement' 'ZAPNAME'
ZAPNAME identifies a CSECT in a load module that is to be
modified by subsequent ZAPVER and ZAPREP control statements.

   ZAPNAME [csectname]

where csectname is the name of a previously defined control
section.
.subsection 'ZAPVER Statement'
.ix 'statement' 'ZAPVER'
ZAPVER compares the contents of the control section defined by
the ZAPNAME statement at a specified location with text supplied
by you.

   ZAPVER [hex-offset] [text]

where hex-offset is the hexadecimal displacement of the data to
be inspected and text is supplied by you for comparison
with the data.  The value of hex-offset must be between 0 and the
length of the CSECT.  Text may be a sequence of hexadecimal
digits or a character string enclosed by quotation marks.  Text
data may not be separated by commas.

A ZAPVER statement must be preceded by a ZAPNAME statement.
.subsection 'ZAPREP Statement'
.ix 'statement' 'ZAPREP'
ZAPREP modifies data at a specified location in the control
section previously defined by the ZAPNAME statement.
Data supplied by you replaces the currently defined contents.

   ZAPREP [hex-offset] [text]

where hex-offset is the hexadecimal displacement of the data to
be modified and text is supplied by the user for replacement.
The value of hex-offset must be between 0 and the length of the
CSECT.  Text may be a sequence of hexadecimal digits or a
character string enclosed by quotation marks.  Text data may not
be separated by commas.

A ZAPREP statement must be preceded by a ZAPNAME statement.
.section 'LOADFILES'
.ix 'LOADFILES'
.sr load &pubSWprt
LINK output is stored in a load module library called a LOADFILE.
.ix 'LINK output'
A LOADFILE may contain any number of programs.  Normally, only the
Command Language Processor (CLP) is used to read and write
LOADFILES.

Whenever a NAME statement is encountered in LINK input, a
corresponding load module is stored in your LOADFILE.  If
the LINK input also contains a LOADFILE control statement,
then the LOADFILE name is derived from that
statement.  If no output name was specified during LINK, ORVYL
assigns output to PROGLIB, the default LOADFILE assigned each
user.  PROGLIB is created automatically when you first
creates a load module.

A LOADFILE maintains a directory that contains member and alias
names.  This directory is automatically extended as the need
arises, subject only to your total ORVYL file space
allocation.  LOADFILE member and alias names, along with PARM
controls specified during LINK, may be displayed with the SHOW
PROGRAMS command.

   SHOW PROGRAMS [LIBRARY loadfile] [account-info]

where SHOW PROGRAMS displays member names, alias names, and
.ix 'Command' 'SHOW PROGRAMS'
corresponding PARM controls for the user issuing the command's PROGLIB.
The option LIBRARY directs ORVYL to the specified loadfile for
the display.
The account-info options (see section &chart.) identify a PROGLIB or LOADFILE
created by another user.
For example, SHOW PROGRAMS PUBLIC displays all the available
ORVYL public programs in the public PROGLIB (ACCOUNT PUB$gg).

Programs contained in a LOADFILE or an entire LOADFILE may be
deleted using the ERASE command:
.ix 'Command' 'ERASE'

   ERASE loadfile [#program|(program)]

When a member is deleted, all aliases for the member are also
erased.
Space formerly occupied by the member is returned to the file
system.

If a "private" program is stored in a LOADFILE, any attempt to
.ix 'private program'
read or write the LOADFILE is precluded.  (See the PRIV LINK
control statement in section &pvt..)  Your program may not ATTACH
.ix 'Command' 'ATTACH'
a LOADFILE that contains a private program.
.section 'Loading ORVYL Programs'
.ix 'loading ORVYL programs'
.ix 'program' 'loading ORVYL'
The CALL command allows direct execution for programs stored in a
.ix 'Command' 'CALL'
LOADFILE during LINK processing.  For ease in debugging, an
.ix 'LINK'
intermediate command, LOAD, permits you to load the program
.ix 'Command' 'LOAD'
only; the ENTER command may then be employed to initiate
.ix 'Command' 'ENTER'
execution.  The EXIT command clears the loaded program from user
.ix 'Command' 'EXIT'
memory.
.subsection 'CALL Command'
.ix 'Command' 'CALL'
.sr call &pubSWprt
   CALL name [LIBRARY loadfile] [PUBLIC|ACCOUNT gg.uuu|USER uuu|GROUP gg]]
             [CLEAR] [PAUSE] [parm]

CALL initiates execution of the specified program.  If the name is
an external entry point as well as an alias, execution begins at
the entry point.

.us Options

.hi 5
LIBRARY -- Specifies a LOADFILE other than your
default library PROGLIB.
When used with the account-info options (see section &chart.), the PUBLIC
PROGLIB, another PUBLIC LOADFILE or another user's
LOADFILE may be specified.
If no LIBRARY is specified, ORVYL first searches your
library for the program.
If the program is not found, ORVYL then searches the public
PROGLIB.

CLEAR -- Clears any previous program from user memory.

PAUSE -- If specified, program is loaded but execution is not begun.
Execution may then be initiated with the GO command.
.pa
parm -- Parameters to be passed to the user program in the form:

          'text' or PARM='text'

Text may be any set of characters,
including matched sets of parentheses, doubled quotes, or
doubled apostrophes.
.hi
.subsection 'LOAD Command'
.ix 'Command' 'LOAD'
   LOAD name [LIBRARY loadfile] [account-info] [CLEAR]

LOAD loads the specified load module, but does not initiate
execution.  The LOAD command may be used in combination with LINK
.ix 'LINK'
to merge a series of load modules and object decks into one
program.
For information on executing loaded programs, see the ENTER
command.

.us Options

.hi 5
LIBRARY -- Specifies a LOADFILE other than your
default library PROGLIB.
When used with the account-info options (see section &chart.), the PUBLIC
PROGLIB, another PUBLIC LOADFILE or another user's
LOADFILE may be specified.
If no LIBRARY is specified, ORVYL first searches the
user issuing the command's library for the program.
If the program is not found, ORVYL then searches the public
PROGLIB.

CLEAR -- Clears any previous program from user memory.
.hi
.subsection 'ENTER Command'
.ix 'Command' 'ENTER'
   ENTER [PAUSE] [parm]

ENTER initiates execution of a program previously loaded with the
LINK or LOAD command.  At ENTER, external symbols are resolved
from libraries.

.us Options

.hi 5
PAUSE -- Returns control to the Command Language Processor (CLP)
and sets the program entry point to the first instruction.
Execution may then be initiated with the GO command.

parm -- Parameters to be passed to the user program in the form:

          'text' or PARM='text'

Text may be any set of characters,
including matched sets of parentheses, doubled quotes, or
doubled apostrophes.
.hi
.subsection 'SET ENTRY Command'
.ix 'Command' 'SET ENTRY'
   SET ENTRY external-symbol

SET ENTRY sets the entry point of the program to the specified
symbol.  The SHOW ENTRY command displays the current program
entry point.  SET ENTRY must be specified before the program is
first entered.
.subsection 'SHOW CORE Command'
.ix 'Command' 'SHOW CORE'
   SHOW CORE

SHOW CORE displays a summary of your memory utilization.
.subsection 'SHOW MAP Command'
.ix 'Command' 'SHOW MAP'
   {SHOW|DUMP} MAP [CSECT] [EXTRN] [ENTRY] [COMMON] [DUMMY] [FROM symbol]

You must have a program in core to use the SHOW MAP command.
Displays all external symbols in alphabetical order, where
options display the following information:

   CSECT  - control section name
   EXTRN  - unresolved external references
   ENTRY  - resolved entry points
   COMMON - common section names
   DUMMY  - external dummy section names
   FROM symbol  - begin the MAP display at the specified symbol
.subsection 'EXIT Command'
.ix 'Command' 'EXIT'
   EXIT

EXIT clears your program and detaches all input/output
devices.
.subsection 'GO Command'
.ix 'Command' 'GO'
.sr go &pubSWprt
   GO [TO location] [EVENTS n] [NOLIST] [CONTINUE] [TRAP location]

.us Options

.hi 5
TO location -- Alters the location of the next instruction
to be executed.

EVENTS n -- Continues execution until n events occur.
Events include program events, monitor events, and program
traps.  The NOLIST option on EVENTS suppresses reporting of
all events except the last.  When an EVENT has been set,
CONTINUE specifies that execution is to resume following a
PER session break (see section &per.).

TRAP location -- Establishes a temporary trap at the
specified location.
This trap is cleared at the next session break.
.hi
.subsection 'ATTN Command'
.ix 'Command' 'ATTN'
.ix 'ATTN' 'command'
.sr attn &pubSWprt
   ATTN [EVENTS n] [NOLIST] [TRAP location]

.us Options

.hi 5
EVENTS n -- Continues execution until n events occur.
Events include program events, monitor events, and program
traps.  The NOLIST option on EVENTS suppresses reporting of
all events except the last.

TRAP location -- Establishes a temporary trap at the
specified location.
This trap is cleared at the next session break.
.hi
.section 'Program Execution Control'
.ix 'program' 'execution control'
Once execution has begun, you can exert control over the
program in several ways.  Command-driven programs allow
you to EXIT the problem program unconditionally.  In
addition, the program may also contain a facility that passes
control to the Command Language Processor (CLP) using the PAUSE macro.
If, for example, the program is designed so that unrecognized
commands are passed directly to the CLP,
the PAUSE command can be employed to halt program execution and
.ix 'Command' 'PAUSE'
give control to CLP.

Using the ATTN or BREAK terminal key is a more direct means of
.ix 'ATTN' 'key'
.ix 'BREAK key'
.ix 'session break' 'ATTN'
.ix 'session break' 'BREAK'
control for problem programs.  When a terminal is in output or
idle mode, an ATTN is a request for a processing break.  Control
is passed to your program's ATTN exit routine, if one
exists.  Otherwise, a session break is scheduled and control is
passed to the CLP.  When your program's ATTN exit routine is
entered, the program should cease processing and request further
instructions in the form of reading a command from the terminal.
If the program does not issue a terminal read, a second ATTN
passes control directly to the CLP.  You should pause prior to the
second ATTN to allow the program sufficient time to respond.

If the terminal is in input mode, an ATTN does not cause a
session break.  Your program may choose to ignore an ATTN on
input and reprompt for input.  For this case, a meta-ATTN, a
single question mark followed by an ATTN has been defined.  On
input, a single question mark followed by an ATTN always forces
a session break.

To resume execution following a session break, you may issue
.ix 'session break' 'resume execution'
the GO or ATTN command.  GO resumes execution at the point at
.ix 'Command' 'GO'
which the program interrupt occurred.  ATTN resumes execution at
.ix 'Command' 'ATTN'
.ix 'ATTN' 'program interrupt'
your attention exit routine, if one exists, and simulates
an immediate ATTN upon program resumption.
.pa
.chapter 'Debugging Programs Under ORVYL'
.section 'Session Breaks'
.ix 'session break'
A session break occurs when your program is interrupted during
execution.  In a session break, control is returned to the ORVYL
Command Language Processor (CLP).
A session break may be initiated by you at a terminal, by
your program, or by an error in your program.
During a session break, any ORVYL command may be used to display
or modify program status.
Your program may prevent modification of the WYLBUR active
file during a session break.
The following table describes the session break types.

    Session Break                      Cause

    ATTENTION           (1) Typing an ATTN while your terminal is
                            printing or is idling.
.ix 'session break' 'ATTN'

                        (2) Typing only a question mark (?) followed by
                            ATTN while the terminal is awaiting input.

    PAUSE                   Execution of a PAUSE macro by your program.
.ix 'session break' 'PAUSE'

    PANIC                   Detection of a PANIC condition by the system
                            or your program.
.ix 'session break' 'PANIC'

    TRAP                    Execution of a user-specified program trap.
.ix 'session break' 'TRAP'

    PROGRAM                 Detection of a user-specified program event.
.ix 'session break' 'PROGRAM'

    MONITOR                 Execution of a selected MONITOR CALL instruction.
.ix 'session break' 'MONITOR'
.section 'Reentering User Programs'
.ix 'user programs' 'reentering'
You may resume program execution from a session break by
issuing the GO or ATTN command.
.ix 'Command' 'GO'
.ix 'Command' 'ATTN'
.ix 'ATTN' 'session break'
The GO command returns control to your program, resuming
execution at the point at which the interrupt occurred.
The ATTN command returns control to your program but
simulates an interrupt before the next instruction.  See section &go and section &attn
for information on the GO and ATTN commands.
.section 'Obtaining User Program Information'
.ix 'user programs' 'obtaining information'
ORVYL provides a number of program diagnostic commands for use
during a session break.
Employing these commands, you may display:
.point set b b b
.point begin
contents of a core location;
.point
summary of your memory utilization;
.point
contents of the program registers;
.point
contents of floating-point registers;
.point
current program status word (PSW);
.point
contents of registers saved at the last interrupt;
.point
program status word (PSW) saved at the last interrupt;
.point
established program traps;
.point
value of an expression.
.point end
In each of the following commands, the SHOW form causes the
specified information to be displayed at the terminal, while the
DUMP form causes the specified information to be appended to
your WYLBUR active file.
.subsection 'SHOW CORE Command (SC)'
.ix 'Command' 'SHOW CORE'
.ix 'Command' 'DUMP CORE'
   {SHOW|DUMP} CORE start-address-expression
                    {length|TO end-address-expression}
                    [MATCH {hexadecimal-expression|'string'}
                           {length|TO end-address-expression}]

Displays the contents of the specified core location.
If no location is specified, prints a summary of your
program area utilization.
(See section &exp for a definition of expression.)
The MATCH option instructs ORVYL to search for a hexadecimal
expression or string over the range from the starting address to
an ending address.
.subsection 'SHOW ADDRESS Command (SA)'
.ix 'Command' 'SHOW ADDRESS'
.ix 'Command' 'DUMP ADDRESS'
   {SHOW|DUMP} ADDRESS expression

Displays the value of the specified expression in decimal and
hexadecimal representation.
(See section &exp for a definition of expression.)
.subsection 'SHOW GPR Command (SG)'
.ix 'Command' 'SHOW GPR'
.ix 'Command' 'DUMP GPR'
   {SHOW|DUMP} GPR [first-register [last-register]]

Displays the contents of the specified general register or range
of general registers.
If no registers are specified, ORVYL reports the contents of all
registers (0-15).
.subsection 'SHOW FPR Command (SF)'
.ix 'Command' 'SHOW FPR'
.ix 'Command' 'DUMP FPR'
   {SHOW|DUMP} FPR [first-register [last-register]]

Displays the contents of the specified floating-point register or
range of floating-point registers.
If no registers are specified, ORVYL reports the contents of all
floating-point registers.
.subsection 'SHOW PSW Command (SP)'
.ix 'Command' 'SHOW PSW'
.ix 'Command' 'DUMP SAVEGPR'
   {SHOW|DUMP} PSW

Displays the user program status word.
.subsection 'SHOW SAVEGPR Command (SSG)'
.ix 'Command' 'SHOW SAVEGPR'
   {SHOW|DUMP} SAVEGPR [first-register [last-register]]

Displays the contents of the range of general registers saved at
the last interrupt.
If no registers are specified, ORVYL reports the contents of all
interrupt general registers (0-15).
.subsection 'SHOW SAVEPSW Command (SSP)'
.ix 'Command' 'SHOW SAVEPSW'
.ix 'Command' 'DUMP SAVEPSW'
   {SHOW|DUMP} SAVEPSW

Displays the program status word saved at the last interrupt or
most recently modified by a PATCH SAVEPSW command.
.subsection 'SHOW ALL Command'
.ix 'Command' 'SHOW ALL'
.ix 'Command' 'DUMP ALL'
   {SHOW|DUMP} ALL [NOCORE] [NOMAP]

Displays the user program status word (PSW), the contents of all
general and floating-point registers, SAVEGPRS, SAVEPSW,
information on memory utilization, and the program map.  The
option NOCORE suppresses memory utilization information; NOMAP
suppresses the program map.
.section 'Modifying User Programs'
.sr exp &pubSWprt
.ix 'user programs' 'modifying'
.ix 'user programs' 'debugging'
The ORVYL debugging commands below permit you to modify
program status during a session break.
.ix 'session break' 'modify program status'
A general expression, as employed below, may be replaced by any
one of the following quantities:
.point set b b b
.point begin
An external name in the program MAP.  The value
substituted for the external name is the address
associated with that name.
.point
A decimal integer.  Decimal integers may be whole
numbers only; that is, they begin with a non-zero
digit and contain no decimal points.
.point
A hexadecimal integer.  A valid hexadecimal integer
consists of the numbers 0-9 and the letters A-F, and
begins with a zero digit (0).
.point end
The arithmetic operators +, -, *, and / may be employed in
general expressions.
As in FORTRAN, the arithmetic operators * and / take precedence.
Parentheses may also be used to control the order of evaluation
in a general expression.

ORVYL supports seven expression notations with special meanings:

   NOTATION                     MEANING

   *               Substitute the current user program PSW instruction
                   address for *.

   @n              Substitute the lower 24-bits of the current contents
                   of the general program register n for @n in the
                   expression, where n is a decimal integer from 0 to 15.

   nK              Substitute the value of n multiplied by 1024.

   nM              Substitute the value of n multiplied by the
                   hexadecimal value X'100000'.

   >n              Substitute the word at location n in your virtual
                   memory, where n is a pointer to the desired value.

   $hhh            Substitute the value of the start of the program
                   address space plus the quantity hhh for $hhh in the
                   expression, where hhh is a hexadecimal integer.  In
                   this case, hhh need not begin with a zero (0).

   #hhh            Substitute the value of the start of your work
                   space plus the quantity hhh for #hhh in the
                   expression, where hhh is a hexadecimal integer.  In
                   this case, hhh need not begin with zero (0).

A register-expression must be evaluated as a valid program register.
A location-expression is any expression that evaluates to a
valid program address.
A hexadecimal-expression must consist of only hexadecimal digits,
and need not begin with a zero (0).
.subsection 'PATCH CORE Command (PC)'
.ix 'Command' 'PATCH CORE'
   PATCH CORE location-expression
            {hexadecimal-expression|'character-string'}
            [VERIFY {hexadecimal-expression|'character-string'}|NOVERIFY]

Changes the value at the specified core location.
The VERIFY option causes ORVYL to abort the patch if the string
does not match the current contents of the location.  If neither
VERIFY nor NOVERIFY is specified, ORVYL indicates the previous
value of the patched location.  The NOVERIFY option causes this
message to be suppressed.
.subsection 'PATCH GPR Command (PG)'
.ix 'Command' 'PATCH GPR'
   PATCH GPR register-expression expression

Changes the value of the specified general register.
.subsection 'PATCH FPR Command (PF)'
.ix 'Command' 'PATCH FPR'
   PATCH FPR register-expression hexadecimal-expression

Changes the value of the specified floating-point register.
The value patches from left to right within the register.
.subsection 'PATCH IA Command (PIA)'
.ix 'Command' 'PATCH IA'
   PATCH IA expression

Changes the user instruction address.
.subsection 'PATCH PSW Command (PP)'
.ix 'Command' 'PATCH PSW'
   PATCH PSW byte-displacement hexadecimal-expression

Modifies the specified bytes of the user program status word.
.subsection 'PATCH SAVEGPR Command (PSG)'
.ix 'Command' 'PATCH SAVEGPR'
   PATCH SAVEGPR register-expression expression

Alters user interrupt register to the value of the specified
expression.
.subsection 'PATCH SAVEIA Command (PSIA)'
.ix 'Command' 'PATCH SAVEIA'

   PATCH SAVEIA expression

Alters user interrupt instruction address to the value of the
specified expression.
.subsection 'PATCH SAVEPSW Command (PSP)'
.ix 'Command' 'PATCH SAVEPSW'
   PATCH SAVEPSW byte-displacement hexadecimal-expression

Alters the specified bytes of the user interrupt program status
word to the value of the specified hexadecimal expression.
.section 'Setting Program Traps'
.ix 'setting' 'program traps'
.ix 'program' 'traps'
.ix 'program' 'traps' 'setting'
.ix 'session break' 'by setting program trap'
You may cause a session break at a predetermined point in
program execution by setting a program trap.
A session break occurs after execution of the instruction located
at the trap address.

When you set a program trap, ORVYL assigns the trap an
index number.
This index is displayed at the terminal and must be used to later
reference the trap.

ORVYL does not permit program traps to be set on an SVC
instruction, on any location other than on a halfword boundary,
or on a location already specified as a trap.
.subsection 'SET TRAP Command (ST)'
.ix 'Command' 'SET TRAP'
   SET TRAP location-expression

Establishes a program trap at the specified location.
ORVYL indicates the trap index number assigned.
.subsection 'SHOW TRAPS Command (STS)'
.ix 'Command' 'SHOW TRAPS'
.ix 'Command' 'DUMP TRAPS'
   {SHOW|DUMP} TRAPS

Displays the index number and location(s) of all program traps
currently enabled as well as the first halfword of the
instruction trapped at each location.
.subsection 'CLEAR TRAP Command (CT)'
.ix 'Command' 'CLEAR TRAP'
   CLEAR TRAP index-number

Clears the program trap defined at the specified index position.
.subsection 'CLEAR TRAPS Command (CTS)'
.ix 'Command' 'CLEAR TRAPS'
   CLEAR TRAPS

Clears all defined program traps.
.section 'ORVYL Program Event Recording and Monitoring'
.ix 'program' 'event recording' 'monitoring'
.sr per &pubSWprt
ORVYL supports program event recording (PER) and monitoring,
two tools helpful in program debugging.  Program event recording
detects:
.point set b b b
.point begin
successful execution of a branch instruction
.point
changes in the contents of specified general registers
.point
an instruction fetch from specified main-storage location(s)
.point
changes in the contents of specified main-storage location(s).
.point end
Program monitoring permits detection of selected
MONITOR CALL instructions as they are encountered in your program.

Program event recording may be invoked by specifying a PER
control block in the program or by issuing the SET EVENT command
.ix 'Command' 'SET EVENT'
at the terminal.
Monitoring is initiated by setting a program monitor mask or with
the SET MONITOR command.
.ix 'Command' 'SET MONITOR'
.subsection 'Program Event Recording (Program Control)'
.ix 'program' 'event recording' 'program control'
Your program controls those conditions that are considered
events for recording purposes; it can specify one or more events
to be detected.
When a specified event does occur, control passes to your
PANIC exit routine.  Information identifying the event type is
passed to the exit routine in register 15.

Control information for program-event recording is contained in a
12-byte control block provided by your program.

   CONTROL  BYTES           CONTROL INFORMATION
   WORD

   0         0-3       Event masks (bits 0-3)
                       General register masks (bits 16-31)

   1         4-7       Starting address (bits 8-31)

   2         8-11      Ending address (bits 8-31)


PER Event Masks -- Bits 0-3:

   Bit:

    0      Successful Branching Event
    1      Instruction Fetching Event
    2      Storage Alteration Event
    3      General Register Alteration Event

When a bit is one (1), the corresponding event is monitored; when
a bit is zero (0), the event is not monitored.

PER General Register Masks -- Bits 16-31:
Specify which general registers are monitored for content
alteration.  These 16 bits correspond one-to-one to the 16
general registers in ascending order.  When a bit is one (1), the
register is monitored for alteration; when zero, the register is
not monitored.

PER Starting Address -- Bits 8-31:
Contains the beginning address for the main storage area to be
monitored.

PER Ending Address -- Bits 8-31:
Contains the ending address for the main storage area to be
monitored.

Program event recording may be enabled by specifying (1) a PANIC
exit routine and (2) a PER control block with a non-zero event
mask.  The PANIC exit routine and PER control block are specified
by the SET 7 and SET 17 supervisor operations, respectively.

When PER is enabled and a specified program event takes place, an
interrupt occurs and the PANIC exit routine is entered.  The PER
code and PER address are written in register 15.  Bits 0-3
contain the PER code (event type); bits 8-31 contain the PER
address of the instruction which caused the event.

PROGRAMMING NOTE:  Program event recording is controlled by the
PANIC bit in the PSW mask byte.  When the PANIC bit is zero, a
program event does not cause an interrupt.  You should note
that the PANIC bit is set to zero whenever a user exit is
entered.
.subsection 'Program Event Recording (SET EVENT Command)'
.ix 'program' 'event recording' 'SET EVENT'
.ix 'Command' 'SET EVENT'
.ix 'session break' 'SET EVENT'
   SET EVENT [[FETCH] [STORE] [RANGE=(first-address[ last-address])]]
             [BRANCH] [REGISTER={(list)|ALL}]

The SET EVENT command causes a session break whenever specified
program events occur in your program.  All program events to
be recorded must be specified with a single SET EVENT command.

.hi 5
FETCH causes a session break upon each successful
instruction fetch from the specified range of main storage
locations.

STORE causes a session break upon each successful
alteration within the specified range of main storage
locations.

RANGE specifies a range of storage location for use with
the FETCH and/or STORE option(s).  If both FETCH and STORE
are specified, then RANGE applies to both.  If no explicit
range is specified, the program's main storage area is
monitored.

BRANCH causes a session break upon each successful
execution of a branch instruction.

REGISTER causes a session break upon alteration of the
contents of the specified general registers.  Registers may
be specified individually in a list; registers (0-15) are
specified with ALL.
.hi

.* FUNCTION
The SET EVENT command causes a session break whenever specified
program events occur in your program.  All program events to be
recorded must be specified with a single SET EVENT command.

.subsection 'Program Monitoring (Program Control)'
.ix 'program' 'monitoring' 'program control'
When your program has set a PANIC exit routine (SET 7) and a
non-zero monitor mask (SET 18), MONITOR CALL instructions pass
control to the PANIC exit routine and place monitor information
in register 0.

The monitor mask is contained in a 4-byte control block provided
by your program.  Bits 16-31 of the monitor control block
correspond one-to-one to monitor classes 0-15.  Any number of
monitor mask bits may be on at any one time.

The contents of bits 8-15 of the MONITOR CALL instruction
constitute the monitor class number.  The address specified by
the B1 and D1 fields of the instruction forms the monitor code.

When a MONITOR CALL instruction is processed and the
.ix 'MONITOR CALL'
corresponding monitor mask is one, a monitor interrupt occurs.
At the interrupt, the monitor code number (bits 0-7) and the
monitor code (bits 8-31) are returned in register 0.
.subsection 'Program Monitoring (SET MONITOR Command)'
.ix 'program' 'monitoring' 'SET MONITOR'
.ix 'Command' 'SET MONITOR'
.ix 'session break' 'SET MONITOR'
   SET MONITOR {list|ALL}

The SET MONITOR command may be used to selectively cause a
session break upon execution of a MONITOR CALL instruction.

.hi 5
.us Options

list -- Enables monitoring for each class (0-15) specified in the list.

ALL -- Enables monitoring for all MONITOR CALL instructions.
.hi

SET MONITOR cancels any previous SET MONITOR command.  The SET
MONITOR command is aborted if your program already employs
the MONITOR exit feature.  The CLEAR MONITOR command disables
.ix 'Command' 'CLEAR MONITOR'
program monitoring.  Any MONITOR CALL instruction executes as a
.ix 'MONITOR CALL'
NOP following a CLEAR MONITOR command.  The SHOW MONITOR command
.ix 'Command' 'SHOW MONITOR'
displays any SET MONITOR command setting currently in effect.

PROGRAMMING NOTE:  Program monitoring is controlled by the PANIC
bit in the PSW mask byte.  When the PANIC bit is zero, a MONITOR
CALL instruction executes as a NOP and does not cause an
interrupt.  You should note that the PANIC bit is set to
zero whenever a user exit is entered.

Technical information on program event recording and monitoring
are available in
.italic System/370 Principles of Operation,
IBM Publication GA22-7000.
.pa
.chapter 'ORVYL Supervisor Services'
ORVYL offers you a broad range of supervisor
services at the assembly language level.
ORVYL macro instructions allow you to exercise control
over system activities and facilities in each of the following
areas:
.point set b b b
.point begin
terminal input and output
.point
WYLBUR input and output
.point
ORVYL file input and output
.point
ORVYL file access privileges
.point
user program management.
.point end
When assembled, each macro instruction expands into one or more
executable machine instructions.
The generated instructions load the program-specified parameters
into the appropriate registers and issue a supervisor call
instruction (SVC).
.ix 'SVC'
.ix 'supervisor call instruction'
Returns from the SVC instruction are then loaded in the
appropriate registers by the supervisor; all registers not
altered by the SVC remain unchanged.
In general, error conditions are indicated by the value returned
in register 15.

The cataloged macro library SYS3.ORVYL.UMACLIB includes the
prototypes for all macros described in chapter 5.
To assemble ORVYL programs, you may either employ the
standard cataloged procedure ASMORVYL or write the appropriate
.ix 'ASMORVYL'
JCL for calling the assembler with the above macro library.

The cataloged procedure ASMORVYL is a copy of the standard ASMC
procedure in which those DD cards that reference standard VS
macro libraries are replaced by one DD card that references the
ORVYL macro library.
When assembling ORVYL programs for use under the ORVYL File Batch
Access Method (VAM/370), the BATCH macro must always be invoked
.ix 'BATCH macro'
before calling any other ORVYL macros.
The BATCH macro initializes the assembly for expansion of all
succeeding ORVYL macros to be processed under VAM.
See chapter 7 for a description of the File Batch Access Method
(VAM/370).

ORVYL employs registers 0, 1, 14, and 15 to pass macro
parameters.  Unlike OS/MVS, a supervisor save area in register 13
need not be provided under ORVYL.
.section 'Input and Output Protocols'
.ix 'input and output' 'protocols'
Input and output to an ORVYL device occurs under the following
general I/O protocol, where a device is defined as a file,
terminal, or other device enabled for use under
WYLBUR/MILTEN/ORVYL.
To use an ORVYL device, that device must first be
attached by the program (see ATTACH macro, section &attach.).
.ix 'input and output' 'ATTACH'
Each request for input or output (for example, READ, WRITE) is normally
followed by the WAIT instruction.
.ix 'WAIT'
A WAIT must always be issued prior to another request which
employs the same device.
.ix 'input and output' 'WAIT'
WAIT coordinates competing demands for input and output service
and provides the user program with concurrent computing and
input/output capabilities.
When processing is complete, you detach the device,
relinquishing control to other users.

Almost every user program request for input/output occurs in the
following sequence.
The user program:
.point set b b b
.point begin
issues the SVC to perform the input/output operation;
.point
checks the return code to detect whether or not the
operation has begun;
.point
if operation has not begun, performs error processing;
.point
if operation has begun, issues a WAIT SVC for the
input/output operation;
.point
checks the return code from WAIT to detect whether or not
the operation has successfully completed;
.point
if operation is not successful, performs exception
processing;
.point
if operation is successful, continues with next program
task.
.point end
In general, a return of zero from the input/output SVC and the
WAIT SVC indicates that the operation has begun or that the
operation is successful, respectively.
.section 'Terminal Input and Output'
.ix 'input and output' 'terminal'
ORVYL provides two terminal communication protocols, one
providing line-by-line input and output, the other servicing
display terminals.
Display input and output services allow you to
converse with display terminal devices connected to ORVYL
through MILTEN with a PDP-11 front-end system.
Two terminal modes are available when using display terminals,
2741 MODE and DISPLAY MODE.
.ix '2741 MODE'
.ix 'DISPLAY MODE'
2741 MODE recognizes the device for line-by-line input and
output.
DISPLAY MODE I/O allows full screen input and output, providing
the ability to format the screen using multiple prompts.
Existing ORVYL programs can operate with display devices in 2741
MODE with no program changes.

The ORVYL macro CONTROL 21 allows the ORVYL program to sense the
terminal type and characteristics.
Conditions set by macros CONTROL 2 (SET TABS), CONTROL 8
(embedded control character in column 1), and CONTROL 26
(NEWLINE) are ignored when MODE=DISPLAY.

DISPLAY MODE I/O allows three additional READ options, all of
.ix 'DISPLAY MODE' 'READ'
which are totally dependent upon those features available on the
particular display device being used.
The SUPPRESS option removes trailing blanks from READ data fields
.ix 'DISPLAY MODE' 'SUPPRESS'
and adds a field terminator character.
The SCREEN option returns the entire contents of the display face
.ix 'DISPLAY MODE' 'SCREEN'
as READ data when you type SEND ENTER or RETURN.
The IMMEDIATE option returns data in the mode specified without
.ix 'DISPLAY MODE' 'IMMEDIATE'
any intervention by you.
.subsection 'Control Codes for Display Input and Output'
.ix 'input and output' 'control codes for display'
When your program prepares a buffer containing data for
transmission to the display terminal, the EBCDIC character codes
presented in the table below should be placed in the buffer to
control positioning on the screen.
These symbolic definitions are provided in the ORVYL macro
DSPCODES.
.ix 'DSPCODES'
Legal abbreviations for the following EQU values is shown in
parenthesis preceding the description.

              Control Character Definitions for MODE=DISPLAY
.ix 'control character definitions for MODE=DISPLAY'

                       OUTPUT CODES

   CURSRET  EQU   X'0D'   (CR)     Back up cursor to start of line

   ERASLINE EQU   X'3C'   (EL)     Erase line, cursor to end

   LINEFEED EQU   X'25'   (LF)     Move cursor down one line

   CURSDOWN EQU   X'25'   (CD)     Same as LINEFEED

   NEWLINE  EQU   X'15'   (NL)     ERASLINE - CURSRET - LINEFEED

   CURSUP   EQU   X'1B'   (CU)     Move cursor up one line

   CURSFOR  EQU   X'2B'   (CF)     Non-destruct cursor space

   CURSBACK EQU   X'16'   (CB)     Non-destruct cursor backspace

   BACKSPAC EQU   X'16'   (BS)     Same as CURSBACK

   CURSHOME EQU   X'12'   (HC)     "Home" cursor (line 0, co. 0)

   TAB      EQU   X'05'   (HT)     Jump to next input field

   BACKTAB  EQU   X'3B'   (RT)     Backup to previous input field

   ERASCREN EQU   X'1C'   (ES)     Clear screen and CURSHOME

   ERASDATA EQU   X'1D'   (EU)     Clear unprotected fields only

   STARTUNP EQU   X'1F'   (SU)     Write following data unprotected

   STARTPRO EQU   X'19'   (SP)     Write following data protected

   BELL     EQU   X'2F'   (BEL)    Ring console alarm

   IDLE     EQU   X'17'   (IL)     Null timing character

   CURSADDR EQU   X'11'   (AC)     Jump cursor (followed by 2 data bytes -
                                   line no., col. no.)

                        INPUT CODES

   FIELDSEP EQU   X'22'   (FS)     End-of-field for SUPPRESS option
.section 'WYLBUR Input and Output'
.ix 'input and output' 'WYLBUR'
The ORVYL macros that allow your program to communicate with
WYLBUR can be grouped into three categories:
.point set b b b
.point begin
those macros allowing your program to read or write the WYLBUR active
file employing terminal I/O services
.point
those macros allowing your program to pass commands to WYLBUR, ORVYL, and
MILTEN
.point
those macros allowing your program to
employ WYLBUR text-editing facilities.
.point end
.subsection 'WYLBUR Active File as an Extension of the Terminal'
.ix 'active file' 'as extension of terminal'
Your program can read or write the contents of the WYLBUR
active file by designating a MODE=TEXT option for the terminal
READ and WRITE macros.
These forms are called READ TEXT and WRITE TEXT macros.
.ix 'READ TEXT macro'
.ix 'WRITE TEXT macro'
To read the active file, the program specifies an input area
to receive active file data, the format in which WYLBUR
is to pass the data, and a line number or associative range
specifying the data to be passed.
The available formats are analogous to those format options which
you may specify in a WYLBUR USE or LIST command.

To write data to the active file, the program issues a WRITE
macro with the TEXT option.
This macro specifies an output area containing the data, a
format indicator that instructs WYLBUR on how to interpret the
data, and an operation specification indicating whether the
data is to be used to delete, replace, or insert lines in the
active file.

In addition, ORVYL CONTROL macros are available to:
.ix 'CONTROL macros'
.point set b b b
.point begin
report the number of lines in the active file;
.point
obtain the line number of the first line in the active file;
.point
detect the line number of the last line in the active file;
.point
delete the contents of the active file;
.point
instruct WYLBUR to type a given line of the active file to the
terminal;
.point
sense your option settings in WYLBUR;
.point
set and report the WYLBUR mode word.
.point end
The WYLBUR mode word is a collection of flags that affect
.ix 'WYLBUR' 'mode word'
processing of macro calls and controls issued by your program.
The PREST/UNPREST flag indicates whether data is to be passed in
.ix 'PREST flag'
.ix 'UNPREST flag'
a compressed or uncompressed form.
For READ TEXT and WRITE TEXT macros, the PREST/UNPREST flag is
the only mode word flag that affects input and output.
.subsection 'Command Passing and Prompting at the Terminal'
.ix 'terminal' 'command passing and prompting'
Your program can utilize MILTEN, WYLBUR, and ORVYL command
processing as an extension of program command processing by
using one of the following macros:
.point set b b b
.point begin
COMMAND
.point
WRITE EDIT (Terminal WRITE macro with MODE=EDIT option)
.point
MILCOM
.point
READ EDIT (Terminal READ macro with MODE=EDIT option)
.point end
These four macros, in conjunction with the terminal READ TEXT and
WRITE TEXT options, eliminate the need for developing editing
capabilities or duplicating code in each user program.
These macros add the entire command language capability of all
interactive systems to your program.
If you do not want to utilize extended program command
processing, you must process all terminal input/output within the
program.

In considering whether or not to use any of the above macro calls,
you should consider the control
to be exerted over command prompting at the terminal and over
interactive systems command processing.
In general, to control all command prompting and processing by an
interactive system (for example, all WYLBUR or all ORVYL commands),
you employ the COMMAND, WRITE EDIT or MILCOM macro calls
to selectively pass those commands not recognized by your
program to the desired interactive system.
To specifically assign WYLBUR the task of command prompting and
processing, you employ the READ EDIT macro call.
Under READ EDIT, WYLBUR processes those commands that it
recognizes and passes unrecognized commands to your program.

Using the COMMAND macro, a program specifies the area containing
a command string and indicates that the command string is to be
passed until recognized either by all systems (WYLBUR, MILTEN,
and ORVYL) or by some combination of systems.

Alternatively, the program may issue a WRITE EDIT macro,
specifying the area containing a command string.
The command string is then passed only to WYLBUR and MILTEN for
processing.
To limit command processing to MILTEN only, the program issues
the MILCOM macro.

Both of the above macros can be employed by a program for (1) the
processing of program generated commands or (2) the processing
of unrecognizable commands received in response to a normal
terminal READ command issued by the program.
Both macros give the program the ability to utilize the full
power of MILTEN, WYLBUR, and ORVYL command processing to augment
program functions.

Issuing the READ EDIT macro causes control of the terminal to be
relinquished to WYLBUR for both command prompting and command
processing.
Control returns to your program whenever you enter a
command at the terminal that is not recognized by WYLBUR.
The program may then process the command if it is able to, issue
the COMMAND macro which instructs ORVYL and MILTEN to attempt
processing, write an error message to the terminal, or any
combination of the above.

When using the READ EDIT and WRITE EDIT macros, WYLBUR mode word
flags define what types of changes to the active file are to be
.ix 'WYLBUR' 'mode word' 'flags'
allowed.

The following flags may be set:
.point set b b b
.point begin
BLOCK -- Prohibits execution of a command which would cause
a change in the active file.
.point
NONUM -- Precludes execution of the WYLBUR NUMBER command.
.point
NOALGN -- Blocks execution of the WYLBUR commands ALIGN,
JUSTIFY, and CENTER.
.point
SBBLOCK -- Enforces the BLOCK, NONUM, and NOALGN flags
during program session breaks.
.point end
WYLBUR issues an error message at the terminal whenever it
receives a command blocked by a mode word flag.
Under WRITE EDIT, control is immediately returned to your
program following an error message.
For READ EDIT, WYLBUR prompts again and retains control.

In addition, an INFORM flag may be set to indicate that your
program must be informed of all changes as they take place.
When this flag is set, WYLBUR returns changes to your program
on a line-by-line basis unless the command causing the changes
is a USE, FETCH or COPY command.
In those cases, WYLBUR returns as many lines as will fit into
that input area specified by your program in the READ EDIT
macro call.
Since most WYLBUR commands can change more than one line in the
active file, the program must continue to issue successive READ
EDIT macros in order to process all changes.

If you do not want program command prompting to be resumed
automatically by WYLBUR once all changes associated with a
single command have been reported, you can include a CHANGES option
with the EDIT option on each READ EDIT call.
The CHANGES option causes WYLBUR to report changes as described
above; however, once all changes for a particular command have
been reported, WYLBUR returns control of the terminal to your
program instead of retaining control of the terminal and
issuing a new command prompt.

When using READ EDIT with the WYLBUR mode word set to cause
reporting of changes, two additional macros are available to
control the processing sequence between your program and
WYLBUR.
These are (1) an abort macro to stop any pending, unreported
changes in a READ EDIT sequence and (2) a grant permission
macro to quarantee that your program only processes
reported information.
.section 'ORVYL Memory Management'
.ix 'memory' 'management'
Under ORVYL, your virtual memory is managed in an address
.ix 'virtual memory'
space divided into pages.
An ORVYL page consists of 4096 bytes of memory.
.ix 'page'
Each page begins at an address that is a multiple of 4096.
(In hexadecimal representation, decimal 4096 is 01000; thus, any
address ending in three zeros is a multiple of 4096.)

The ORVYL supervisor sets an upper limit on the total number of
pages which can be made available to each user program at any
one time.
Within this general constraint, ORVYL permits your program to
reserve that number of pages actually required to complete the
program task, as well as to release pages whenever they are no
longer needed for the program.
.subsection 'Reserving and Releasing ORVYL Pages'
.ix 'ORVYL pages' 'reserving and releasing'
.ix 'page' 'reserving and releasing'
You begin each session with a null and undefined ORVYL
memory.
A null memory condition means that no ORVYL pages have yet been
reserved for your program.
A null memory condition also occurs whenever an EXIT SVC is
processed or the EXIT command is typed at the terminal.

To use ORVYL memory, a sufficient number of
pages must first be explicitly or implicitly reserved.
Any attempt by an ORVYL program to make use of memory addresses
on pages which have not been reserved results in a program
error.

When you instruct ORVYL to load a program for execution
(see the discussion on program loading in chapter 3), the ORVYL
loader automatically reserves a sufficient number of pages to
accomodate the program.  This address space then remains reserved
until the program terminates execution.

During execution, your program may request additional memory
for the program work area.
Using the SET 14 supervisor operation, the program specifies the
amount of memory required.
When this request can be satisfied, ORVYL reserves the necessary
number of pages and returns the initial address to the executing
program.

The executing program may make any number of memory requests,
subject only to ORVYL's overall limit on the number of pages
available to each program.
An optional form of the SET 14 macro allows the program to
request that the largest possible program work space be
reserved.

Programs may release all or part of previously reserved memory
with the SET 15 macro.  Any attempt by an ORVYL program to
release pages not reserved results in a program
error.  The ability to release does not extend to memory reserved
by the ORVYL loader.

Since the SET 15 macro releases memory in page units, the release
request should always specify a page boundary as the starting
address and a memory length that is a multiple of the page size
(4096).
Release requests overlapping a fractional part of a page cause
the entire page to be released.
.subsection 'Defining ORVYL Page Contents'
.ix 'ORVYL pages' 'defining contents'
.ix 'page' 'defining contents'
Once an ORVYL page has been reserved, the contents of that page
must next be defined.
ORVYL considers a page to be defined as soon as your program
stores information in it.
Whenever the contents of a particular page are no longer
required, your program should act to free the contents of
that page.
Designed for this purpose, the SET 1 supervisor operation frees
the contents of a page without releasing it from the program's
addressable memory.

The SET 2 macro advises the paging supervisor of those pages
which have become inactive but ought to remain defined.
This macro helps the paging supervisor find those pages that may
be best removed to auxiliary memory for a period while other
pages are brought into real memory.

The SET 0 macro permits your program to define more than one
page in a single operation.  Used mainly by the ORVYL loader,
this feature ensures that uninitialized large arrays and common
areas are always defined at the point of program entry.
.section 'Exit Routines'
.ix 'Exit routines'
The following table summarizes the types of exit routines which
ORVYL allows you to establish, with a description of
the event causing exit routine entry.

   EXIT ROUTINE          REASON FOR ENTRY

   TIMER                 Time interval expired.
.ix 'TIMER'

   SVC                   An SVC instruction numbered 0-195 was issued.
.ix 'SVC'

   PANIC                 The system or your program detected a PANIC
.ix 'PANIC'
                         condition, a program event, or a monitor call
                         instruction.

   ATTN                  You typed an ATTN at the terminal during
.ix 'Command' 'ATTN'
.ix 'ATTN' 'exit routine'
                         output (CPU control), or typed a question
                         mark (?) followed by an ATTN during input
                         (terminal control).

   WAIT                  An operation on the device was completed.
.ix 'WAIT'
                         Issuing a WAIT macro will now cause no
                         delay in execution.
.subsection 'Register Contents upon EXIT Routine Entry'
.ix 'Exit routines'
.ix 'Exit routines' 'register contents'
   (0)                   Monitor information if a MONITOR CALL interrupt
                         occurs.  See section &per for information on
                         MONITOR CALL interrupts.

   (1)                   SVC     -    SVC number
                         PANIC   -    PANIC code
                         ATTN    -    Device identifier
                         WAIT    -    Device identifier

   (14)                  Information supplied when your exit routine
                         was established.  See the description of SET (5-9).

   (15)                  Program event information if a PROGRAM EVENT
                         interrupt occurs.  See section &per for
                         information on PROGRAM EVENT interrupts.
.subsection 'Interruption Codes'
.ix 'Exit routines' 'interruption codes'
   SVC                   SVC number

   PANIC                 <=0 Complement of user PANIC code
                          >0 Program Interrupt Code

   Bit 24 -     1        PROGRAM EVENT interrupt

   Bit 25 -     1        MONITOR CALL interrupt

   Bits 26-31 - 1        Operation exception
                2        Privileged operation exception
                3        Execution exception
                4        Protection violation
                5        Addressing exception
                6        Specification exception
                7        Data exception
                8        Fixed overflow
                9        Fixed divide exception
               10        Decimal overflow
               11        Decimal divide exception
               12        Exponent overflow
               13        Exponent underflow
               14        Significance Exception
               15        Floating Divide Exception
               16        Two I/O operations issued for same device
                         or file with no intervening WAIT

A MONITOR CALL interrupt or program exception may occur
.ix 'MONITOR CALL'
simultaneously with a PROGRAM EVENT interrupt.  If a PROGRAM
.ix 'PROGRAM EVENT'
EVENT occurs, PER information is returned in register 15; if a
MONITOR CALL occurs, monitor information is returned in register
0.

When a program interruption occurs, the program status word (PSW)
and registers are saved in the supervisor save area.
The exit routine may sense the save area using an ORVYL macro.
The mask byte is set to zero upon exit routine entry.
.subsection 'SAVE AREA FORMAT'
.ix 'Exit routines'
.ix 'Exit routines' 'save area format'
               BYTE(S)                   CONTENTS

         {  0-1                       Interruption code
         {
         {  2       Bits 0-1          Instruction length code
         {               2-3          Condition code
   ORVYL {               4-7          Program mask
         {
   PSW   {  3       mask byte         Bit 0 1=Timer exit enabled
         {                                1 1=ATTN exit enabled
         {                                2 1=WAIT exits enabled
         {                                3 1=PANIC exit enabled
         {
         {  4-7                       Instruction address

            8-71                      General registers 0-15

When the exit routine has performed all the tasks assigned to it,
the exit routine transfers control using an ORVYL macro.  ORVYL
uses the original save area to resume program execution
unless the program specifies use of a modified copy of the
original save area.
.section 'Macro Coding and Symbol Conventions'
.ix 'macros' 'coding and symbol conventions'
Each of the macro instructions below is described in the
following format:
.point set b b b
.point begin
Macro instruction general form
.ix 'macros' 'instruction general form'
.point
Purpose
.point
Operands
.point
Returns
.point end
In the general form, the macro name appears in uppercase letters
and may be coded directly.
Operands are presented in lowercase letters and are described
individually in the operands section.
Operands enclosed in square brackets are optional elements in the
macro instruction.
The brackets are not coded in the macro instruction.
Macro parameters are positional.  When an option is omitted for a
particular instruction, a comma must be coded in its place.  The
applicable register for each operand is listed in parentheses
directly below the operand.
In general, the registers used by ORVYL macros (that is, registers
0, 1, 15, 14) are loaded in the order in which parameters are
specified.
Return values for affected registers from both the macro
expansion and WAIT are listed in the returns sections.

An operand presented in the form xxx-la indicates that the
address may be coded in either explicit or implied form.
The macro will expand to execute a load address (LA) instruction
and load the parameter register indicated in parentheses with
the address.
If an address already exists in a register, the operand may be
written as an absolute expression enclosed in parentheses.
The macro will expand to execute a load register (LR) instruction
to load the parameter register from the register specified by
the expression.
If the address is already in the parameter register, the
expression should consist of the register number expressed as a
decimal integer.

An operand written in the form xxx-l or xxx-lh operates the same
as la , but a load (L) or load half-word (LH) instruction is
generated in place of the LA instruction.

You may specify the instruction used to load a parameter
register by prefixing the operand by LA:,L:,LH:,or IC: or by
enclosing a register operand in parentheses.  The table below
shows the code generated by the macro expansion for each form of
specification.

   PARAMETER             GENERATED CODE

   (expression)          LR p,expression
   LA:expression         LA p,expression
   L:expression          L  p,expression
   LH:expression         LH p,expression
   IC:expression         SR p,p
                         IC p,expression

Whenever MODE is specified as part of a macro call, one or more
.ix 'macros' 'MODE'
operands may be complemented by the macro expansion.
To avoid error, specified operands must be non-negative.  Unless the
operand registers are specifically modified by the supervisor
routines, ORVYL returns complemented registers to their
uncomplemented state before passing control to your program.
.subsection 'Macro Expansions'
.ix 'macros' 'expansions'
   ATTACH (0),(1),(15),(14)
   LCR  0,0         MODE=WAIT
   LCR  1,1         MODE=SHARE,CONTROL
   LCR  15,15       MODE=OLD
   SVC  249         ATTACH       VAM CODE=00

   COMMAND (0),(1),(15)
   LCR  1,1         MODE=WYLBUR
   LCR  15,15       MODE=NOCLP
   SVC  254         COMMAND      VAM CODE=04

   CONTROL (0),(1),(15),(14)
   LCR  0,0         MODE=WAIT
   LCR  1,1         MODE=FORMAT
   SVC  245         CONTROL      VAM CODE=08

   DETACH (0)
   SVC  248         DETACH       VAM CODE=12

   EXIT
   SVC  253         EXIT         VAM CODE=16

   MILCOM (0),(1),(15),(14)
   SVC  238         MILCOM       VAM CODE=60

   PANIC (0)
   SVC  252         PANIC        VAM CODE=20

   PAUSE
   SVC  255         PAUSE        VAM CODE=24

   READ (0),(1),(15),(14)
   LCR  0,0         MODE=WAIT
   LCR  1,1         MODE=TEXT,CHANGES,TRUNCATE
   LCR  15,15       MODE=EDIT,CHANGES,SKIP
   LCR  14,14       MODE=DISPLAY
   SVC  247         READ         VAM CODE=28

   RELEASE (0)
   SVC  243         RELEASE      VAM CODE=32

   RESERVE (0)
   LCR  0,0         MODE=WAIT
   SVC  244         RESERVE      VAM CODE=36

   SENSE (0),(1),(15),(14)
   SVC  250         SENSE        VAM CODE=40

   SET (0),(1),(15),(14)
   SVC  251         SET          VAM CODE=44

   STATUS (0),(1),(15),(14)
   SVC  241         STATUS       VAM CODE=48

   WAIT (0)
   SVC  242         WAIT         VAM CODE=52

   WRITE (0),(1),(15),(14)
   LCR  0,0         MODE=WAIT
   LCR  1,1         MODE=TEXT,DISPLAY
   LCR  15,15       MODE=EDIT,DISPLAY
   SVC  246         WRITE        VAM CODE=56
.section 'General Device Control'
.ix 'general device control'
.us Purpose:

Makes a device available for use by a program.
See ATTACH under each device type for further information.
.ix 'general device control' 'ATTACH'
.ix 'ATTACH'
.subsection 'DETACH:  Detaching Devices and Files'
.ix 'DETACH'
.ix 'general device control' 'DETACH'
   DETACH  id-l
            (0)

.us Purpose:

Specifies that an attached device is no longer required by the
program and that this device will not be used again until
another ATTACH macro is issued.
.ix 'ATTACH'

.us Operands:

   id-l             device identifier

.us Returns:

   (15) = 0         Operation started.

.us Returns from WAIT:

No registers changed.
.subsection 'WAIT:  General Synchronization'
.ix 'general device control' 'WAIT'
.ix 'WAIT'
   WAIT  id-l
          (0)

.us Purpose:

Suspends program execution until the current operation on the
specified device is completed.
Every operation must be followed by WAIT before another request
to that device can be initiated.

.us Operands:

   id-l             device identifier

.us Returns:

See the values returned for specific operations.
.section 'Terminal Input/Output and Control'
.ix 'terminal' 'input/output and control'
.subsection 'ATTACH (1):  Attaching User Terminal'
.sr attach &pubSWprt
.ix 'ATTACH'
   ATTACH 1[,MODE=WAIT]
          (0)

.us Purpose:

Attaches the terminal that began the session.

.us Returns:

   (15) = 0         Operation started.
    (0) =           32-bit terminal identifier


.us Returns from WAIT:

   (15) = 0         ATTACH completed.

WAIT is optional when attaching the terminal.
.subsection 'READ:  Terminal Input'
.ix 'READ'
   READ  id-l,location-la,length-la[,prompt-la]
           (0)    (1)       (15)       (14)

.us Purpose:

Reads a line of input from the terminal.
A prompt may be specified, as well as a message to precede the
prompt.
A maximum response time from the terminal may also be specified
(TIME-OUT feature).  Specifying a TIME-OUT on READ does not
.ix 'TIME-OUT'
.ix 'READ' 'TIME-OUT'
affect operation of any other timer set by the program (that is,
those enabled by the SET 3 and SET 4 macros).

.us Operands:

   id-l            terminal identifier

   location-la     location of input area

   length-la

                       1st 16-bits - number of seconds to wait before
                                     TIME-OUT (600 maximum) or zero
                       2nd 16-bits - length of input area (data may be
                                     lost if less than 133 bytes)-zero illegal

   prompt-la       location of the area containing a prompt and/or message text

If a prompt and/or message text is specified, the area must
contain an output line and a prompt in the following format:

   Field size:     Contents:

    2 bytes        w(Length of message text to be written) - may be zero
    2 bytes        p(Length of prompt) - may be zero
    w bytes        Line to be written  }
    p bytes        Prompt              }  Total of not more than 163
                                          characters

If message text is specified, ORVYL appends a carriage
return to the line.

.us Returns from READ:

   (15) = 0        Operation begun.

.us Returns from WAIT:

   (15) = 0        Successful completion.
          4        Input line terminated with ATTN.  (Input buffer
                   contains all characters typed before ATTN.)
          8        Read terminated by TIME-OUT.
         -4        Permanent I/O error.
         -8        Illegal tab used.

    (1) =          Number of bytes read.
.subsection 'WRITE:  Terminal Output'
.ix 'WRITE'
   WRITE  id-l,location-la,length-la
            (0)    (1)       (15)

.us Purpose:

Writes a line of output to the terminal.

.us Operands:

   id-l            terminal identifier

   location-la     location of the area containing the line

   length-la       length of the area in the legal range zero (0)
                   through 163

.us Returns:

   (15) = 0        Operation begun.

.us Returns from WAIT:

   (15) = 0        Successful completion.
         -4        Permanent I/O error.
          4        ATTN typed during terminal output.

Unless CONTROL 25 has been set, ORVYL appends a carriage
return to lines transmitted to the terminal.
.subsection 'READ,MODE=DISPLAY:  Display Terminal Input'
.ix 'READ,MODE=DISPLAY'
   READ  id-l,location-la,length-la,outbuf-la,MODE=DISPLAY
           (0)    (1)       (15)      (14)

.us Purpose:

Reads either a set of responses to prompts or the contents of the
scope face at the completion of the READ.  With the exception of the
immediate option, a maximum response time may be specified (TIME-OUT feature).
.ix 'TIME-OUT'
A set of fields is contained in "outbuf", each of which describes
a write count, a prompt count, a read count, write text, and prompt
text.  These fields are used to create a display on the scope face and
to define unprotected and protected spaces on the scope face.
Protected spaces are defined by write and prompt data, while those
unprotected spaces into which you may type type responses are defined
by the read counts.

.us Operands:

   id-l           terminal identifier

   location-la    location of input area.

   length-la

                       1st 16 bits - Number of seconds before TIME-OUT
                                     (600 maximum) or zero
                       2nd 16 bits - Length of input area - zero illegal
                                     (data may be lost if less than 133
                                     bytes), maximum is 4096

    outbuf-la      Two bytes of option codes specifying how and when data
                   is to be returned.  If no option code is specified,
                   responses are padded with trailing blanks to the
                   specified length of the read field.  The meaning of
                   on-bits is:

                      Bit:        Meaning:

                      16 IMMED    Read immediate (no intervention by
                                  user required).

                      15 SCREEN   Read entire screen (write, prompt, and
                                  read data when you enter SEND or
                                  equivalent).

                      14 SUPPRESS Read responses only and suppress
                                  trailing blanks (end of field marked
                                  by field separator character).

                      13-1        Reserved.

                    After the option code, two bytes of length of the output
                    buffer which follows must be specified.  If no output
                    data exists, the length field should be zero.  The
                    output data, if there is any, must follow the count.
                    The output buffer consists entirely of data fields,
                    which are defined as:

                    Subfield size:      Contents:

                      2 bytes           w (Length of write data) -
                                          may be zero
                      2 bytes           p (Length of prompt data) -
                                          may be zero
                      2 bytes           r (Length of unprotected
                                           read area)
                      w bytes           Write data
                      p bytes           Prompt data

                    An unprotected area on the scope is defined each time
                    a non-zero "r" subfield is encountered.  Screen
                    formatting controls are contained in the write and
                    read prompt data.

.us Returns from READ:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
         -4       Permanent I/O error.
         -8       Illegal tab used.
        -12       Illegal terminal for MODE=DISPLAY.
          4       Input screen terminated with ATTN.
          8       Read terminated by TIME-OUT.

    (1) =         Number of bytes read.

   Input Area =   For no options:
                       The area contains each response padded with trailing
                       blanks up to the length of the specified read field.

                  For SUPPRESS option:
                       The area contains each response delimited by the field
                       separator character.

                  For SCREEN and IMMEDIATE options:
                       The area contains the full contents of the scope face.

For READ MODE=DISPLAY, a sufficiently large return area must be
.ix 'READ,MODE=DISPLAY'
specified in order to return the requested data.
If no options are specified, the sum of the "r" lengths is
sufficient.
For the suppress trailing blank option, the number of "r" length
fields must be added to the sum of the "r" lengths to ensure a
sufficient return area.
In any case, if the return area is too small, data will be
discarded.
.subsection 'WRITE,MODE=DISPLAY:  Display Terminal Output'
.ix 'WRITE,MODE=DISPLAY'
   WRITE  id-l,location-la,length-la,MODE=DISPLAY
            (0)    (1)       (15)

.us Purpose:

Writes data to the scope face.
No options apply in this mode.

.us Operands:

   id-l            terminal identifier

   location-la     location of the area containing write data

   length-la       length of the area (zero illegal)

Display control characters may be interspersed with write data.
The member 'CODES' in SYS3.ORVYL.UMACLIB may be used to obtain
definitions for a number of commonly used control characters.

.us Returns:

   (15) = 0        Operation begun.

.us Returns from WAIT:

   (15) = 0        Successful completion.
         -4        Permanent I/O error.
         -12       Illegal terminal for MODE=DISPLAY.
          4        ATTN typed during output.

No carriage return is appended to the output buffer when
transmitted to the display terminal.
The program includes screen formatting instructions in the output
buffer.

Core storage in ORVYL is divided into pages of 4096 bytes each.
.ix 'core storage'
A buffer area must begin on a double-word boundary and may not
.ix 'buffer' 'area'
cross more than one page boundary.
If a page boundary is crossed, the buffer must extend at least 8
.ix 'page' 'boundary'
bytes on the second page.
A buffer of 4096 bytes or less may begin on any
double-word.
A buffer of 6144 bytes may begin as much as 2048 bytes from the
beginning of a page, while an 8192-byte buffer must begin on a
page boundary.
For maximum efficiency, buffers of 4096 bytes or less should
reside on a single page.
.subsection 'CONTROL (0-1):  Page Eject and Spacing'
.ix 'page' 'eject and spacing'
   CONTROL  id-l,code-la,n-la
              (0)  (1)    (15)

.us Purpose:

Controls page eject and spacing on the terminal with no other
data transmission.
Ignored when MODE=DISPLAY.

.us Operands:

   id-l           terminal identifier

   code-la        operation code

                   Code:     Meaning:
                     0       Space n blank lines, where 0 < n < 66 (any value
                             greater that 66 is treated as a page eject).
                     1       Page eject (skip 4 lines).

   n-la           Number of lines to space for CONTROL 0

.us Returns:

   (15) = 0          Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
         -4       Permanent I/O Error.
          4       ATTN typed during output.
.subsection 'CONTROL (2-3):  Setting Tabs'
.ix 'setting' 'tabs'
   CONTROL  id-l,code-la,location-la
              (0)  (1)       (15)

.us Purpose:

Sets tabs on the terminal.

.us Operands:

   id-l           terminal identifier

   code-la        operation code

                   Code:     Operation:
                     2       Set tabs.
                     3       Sense tabs.

   location-la    Location of the 16-byte area which contains or will
                  receive the tabs.  Each byte specifies a tab position
                  and is a positive integer less than or equal to 133.
                  The first zero byte encountered terminates tab setting.
                  Each succeeding tab position must be greater than the
                  the preceding tab position.

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
.subsection 'CONTROL (4-6):  Terminal Input Translation'
.ix 'terminal' 'input translation'
   CONTROL  id-l,code-la
              (0)  (1)

.us Purpose:

Controls translation of all terminal input.
Affects both direct input to an ORVYL program and input to
WYLBUR.

.us Operands:

   id-l           terminal identifier

   code-la        operation code

                   Code:     Operation:
                     4       Translates all lowercase alphabetic characters
                             to uppercase (SET UPPER).
                     5       Cancels translation of lowercase alphabetic
                             characters (SET UPLOW).
                     6       Senses translation status.

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion (codes 4 and 5).
          0       Upper translation in effect (code 6).
          4       Uplow translation in effect (code 6).
.subsection 'CONTROL (7-9):  Carriage Control'
.ix 'carriage control'
   CONTROL  id-l,code-la
              (0)  (1)

.us Purpose:

Controls page eject and spacing on the terminal based on the
first character of each output line transmitted to the terminal
after the CONTROL macro is issued.
CONTROL (7-9) ignored when MODE=DISPLAY.

.us Operands:

   id-l              terminal identifier

   code-la           operation code

                      Code:     Meaning:
                        7       No control characters to be contained in
                                output lines.
                        8       First character in each line is a control
                                character.  Control characters are
                                interpreted and not printed.  Legal con-
                                trol characters include:
                                    blank     Skip no lines before
                                              printing.
                                      0       Skip one line before
                                              printing.
                                      -       Skip two lines before
                                              printing.
                                      1       Page eject before printing.
                                              (Skip 4 lines.)
                                 Any other character found in column 1 is
                                 interpreted as a blank.
                         9       Sense whether control character interpretation
                                 is being performed.

.us Returns:

   (15) = 0           Operation begun.

.us Returns from WAIT:

   (15) = 0           Successful completion (codes 7 and 8).
          0           No control character interpretation is being
                      performed (Code 9).
          4           Control character interpretation is being performed
                      on the first character of each output line.
.subsection 'CONTROL (21):  Reading Terminal Characteristics'
.ix 'reading' 'terminal characteristics'
   CONTROL  id-l,21,location-la
              (0) (1)  (15)

.us Purpose:

Provides current information about the user terminal and the
current session.

.us Operands:

   id-l           terminal identifier

   location-la    Location of the 60-byte area which is to receive the
                  terminal information.  The format of this area may
                  be obtained by invoking the TTYP macro in the
                  your ORVYL macro library.  The data returned includes:

                        Hardware information:  MILTEN line number,
                         port address, line speed, carriage width,
                         screen depth, etc.

                        User established information:  account,
                         name, tabs, privileges, and settings (for example,
                         CASE/BACK/TERSE/COMM/FASTLIST/TIMEOUT).

.us Returns:

   (15) = 0       Operation begun.


.us Returns from WAIT:

   (15) = 0       Successful completion.

The TTYP macro may be used without parameters to establish
.ix 'TTYP macro'
labels for referencing returned data.
If no parameters are specified, all labels are prefixed with the
mnemonic TTYP.
If another prefix is desired, you can code 'PFX=string',
where 'string' is a 1 to 4 character label in the operand field.
This string is used as the label prefix.
.subsection 'CONTROL (22-24):  ATTN Session Break'
.ix 'ATTN' 'session break'
.ix 'session break' 'ATTN'
   CONTROL  id-l,code-la
              (0)  (1)

.us Purpose:

Forces the occurrence of a session break if you type ATTN
to terminate output or to interrupt computing.
Facilitates the debugging of programs that have ATTENTION exits.

.us Operands:

   id-l           terminal identifier

   code-la        operation code

                  Code:     Operation:
                   22       Inhibits a session break following ATTN
                            (default condition).
                   23       Forces a session break following ATTN.
                   24       Senses the session break condition.

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion (codes 22 and 23).
          0       Session break forced  (code 24).
          4       Session break inhibited (code 24).
.subsection 'CONTROL (25-27):  NEWLINE Carriage Return'
.ix 'NEWLINE carriage return'
   CONTROL  id-l,code-la
              (0)  (1)

.us Purpose:

Controls the automatic carriage return (NEWLINE) supplied at the
conclusion of a normal terminal WRITE.  CONTROL 25 suppresses the
automatic carriage return; CONTROL 26 reenables automatic
carriage returns.  In addition, the NEWLINE status set by CONTROL
25 or reset with CONTROL 26 may be sensed with CONTROL 27.

.us Operands:

   id-l           terminal identifier

   code-la        operation code

                  Code:     Operation:

                   25       Suppresses an automatic NEWLINE at the
                            end of WRITE operation.
                   26       Reenables the automatic NEWLINE.
                   27       Senses the NEWLINE condition.

.us Returns:

   (15) = 0       Operation begun.
.pa
.us Returns from WAIT:

   (15) = 0       Operation successful (codes 25 and 26).
          0       NEWLINE supplied at end of terminal WRITE
                  operation (code 27).
          4       NEWLINE not supplied (code 27).

When the automatic NEWLINE function is suppressed, successive
WRITE operations cause all output to be printed on a single
line.  A NEWLINE character (X'15') must be included in the data
stream in order to initiate a new physical line.

A WRITE with NEWLINE suppressed followed by a READ operation
unlocks the terminal following the last character of the WRITE
text.
.subsection 'CONTROL (28):  Modifying Terminal Session Information'
.ix 'modifying' 'terminal session information'
   CONTROL  id-l,28,location-la
              (0) (1)  (15)

.us Purpose:

Changes or reestablishes session and terminal characteristics.

.us Operands:

   id-l           terminal identifier

   location-la    Location of the 60-byte area which contains data to be
                  used as new session characteristics.  The format of
                  this area is identical to that for CONTROL 21; it
                  may be obtained by invoking the TTYP macro in your
.ix 'TTYP macro'
                  ORVYL macro library.  Not all fields can be modified;
                  those which can are marked with an asterisk to the
                  left in the macro expansion.  Values for fields which
                  cannot be modified are ignored.

.us Returns:

   (15) = 0       Operation begun.

.us Returns from Wait:

   (15) = 0       Successful completion
          4       One or more fields were invalid.

The TTYP macro may be invoked with a 'SET=YES' operand to
generate unique labels for those fields which can be modified.
A 'PFX =string' operand can also be used to set a one to four
character prefix for all labels.
If no PFX operand is given, all labels are generated with TTYP as
the prefix.
.section 'WYLBUR Input/Output and Control'
.ix 'WYLBUR' 'input/output and control'
.subsection 'WYLBUR PREST Format'
.ix 'WYLBUR' 'PREST format'
The term 'WYLBUR PREST format' refers to that type of WYLBUR
internal text storage which compresses text strings by removing
multiple blanks.
The use of this format generally reduces the space required to
store character data.
You have the option of receiving or sending
active file data in this format when requests are made to
WYLBUR.

Associated with each prest line is a length count.
Since prest lines have all blanks removed, a line composed of
only blank characters is defined by a length count of zero (0).

Lines that contain at least one non-blank character also contain
"blank/non-blank" count bytes.
A "blank/non-blank" count byte is divided into two half-bytes;
the first half-byte is the "blank" count and the second
half-byte is the "non-blank" count.
Each non-blank character string in the line is preceded by a
"blank/non-blank" count, indicating how many blanks preceded the
non-blank (first half-byte), and the length of the non-blank
string (second half-byte).
The non-blank character string follows this "blank/non-blank"
count byte.
This pattern is repeated until the length count associated with a
given prest line is exhausted.

The length count at the beginning of each prest line is the sum
of the number of "blank/non-blank" count bytes plus the number
of non-blank characters contained in the line.
If a blank string in the unprest line exceeds 15 characters in
length, successive "blank/non-blank" count bytes occur.
If a non-blank string exceeds 15 characters in length, count
bytes are inserted between each sub-string of 15 non-blank
characters.
.subsection 'CONTROL (12):  Setting the WYLBUR Mode Word'
.ix 'setting' 'the WYLBUR mode word'
.ix 'WYLBUR' 'mode word' 'setting'
   CONTROL  id-l,12,word-la
              (0) (1) (15)

.us Purpose:

Sets the WYLBUR mode word, directing WYLBUR in its processing of
READ TEXT, WRITE TEXT, READ EDIT and WRITE EDIT calls.
This setting remains in effect for all subsequent WYLBUR requests
or until another CONTROL 12 is issued.

.us Operands:

   id-l         terminal identifier

   word-la      WYLBUR mode word.
                ON bits:     Meaning:

                   31        PREST   Returns line from the active file in WYLBUR
                                     PREST format.  Affects READ EDIT, WRITE
                                     EDIT, READ TEXT, and WRITE TEXT requests.
                   30        INFORM  Informs program of changes to the active
                                     file on READ EDIT and WRITE EDIT requests.
                   29        BLOCK   Blocks execution of all commands which
                                     cause changes to the active file on READ
                                     EDIT and WRITE EDIT requests.
                   28        NONUM   Blocks execution of the NUMBER command on
                                     READ EDIT and WRITE EDIT requests.
                   27        NOALGN  Blocks execution of the ALIGN, JUSTIFY, and
                                     CENTER commands on READ EDIT and WRITE
                                     EDIT requests.
                   26        SBBLOCK Ensures that BLOCK, NONUM, and NOALGN
                                     are in effect during all session breaks.
                   25        SYNTAX  Indicates that commands with syntax errors
                                     should still be passed to program.
                  8-24       Reserved for future use.
                  0-7        A character to prefix WYLBUR command prompts in
                             READ EDIT mode.  A zero (0) indicates that no
                             prompt prefix is to be used.

                             When an ORVYL program is first entered, the command
                             language processor sets the prompt prefix to '-'.
                             CONTROL 12 allows you to change or eliminate the
                             prefix.

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
.subsection 'CONTROL (13):  Reading the WYLBUR Mode Word'
.ix 'reading' 'the mode word'
.ix 'WYLBUR' 'mode word' 'reading'
   CONTROL  id-l,13
              (0) (1)

.us Purpose:

Returns the current setting of the WYLBUR mode word.

.us Operands:

   id-l           terminal identifier

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.

    (1) =         Current WYLBUR mode word setting.
.subsection 'CONTROL (14):  Detecting the WYLBUR Active File Size'
.ix 'detecting' 'active file size'
.ix 'active file' 'detecting file size'
.ix 'WYLBUR' 'active file' 'detecting size'
   CONTROL  id-l,14
              (0) (1)

.us Purpose:

Reports the current size of the WYLBUR active file.

.us Operands:

   id-l           terminal identifier

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.

    (1) =         Number of lines in WYLBUR active file.
.subsection 'CONTROL (15):  Obtaining the First WYLBUR Line Number'
.ix 'obtaining' 'first line number'
.ix 'WYLBUR' 'first line number'
   CONTROL  id-l,15
              (0) (1)

.us Purpose:

Reports the line number of the first line in the active file.

.us Operands:

   id-l           terminal identifier.

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
          4       Active file is empty.

    (1) =         Line number of the first active file line (times 1000).
.subsection 'CONTROL (16):  Obtaining the Last WYLBUR Line Number'
.ix 'obtaining' 'last WYLBUR line number'
.ix 'WYLBUR' 'last line number'
   CONTROL  id-l,16
              (0) (1)

.us Purpose:

Reports the line number of the last line in the active file.

.us Operands:

   id-l           terminal identifier

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
          4       Active file is empty.

    (1)           Line number of the last active file line (times 1000).
.subsection 'CONTROL (17):  Deleting the WYLBUR Active File Contents'
.ix 'deleting' 'active file contents'
.ix 'active file' 'deleting contents'
.ix 'WYLBUR' 'active file' 'contents'
   CONTROL  id-l,17
              (0) (1)

.us Purpose:

Deletes the current WYLBUR active file contents.

.us Operands:

   id-l           terminal identifier

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.
.subsection 'CONTROL (18):  Aborting a Command in Progress in WYLBUR'
.ix 'WYLBUR' 'aborting command in progress'
   CONTROL  id-l,18
              (0) (1)

.us Purpose:

Aborts any READ EDIT or WRITE EDIT command processing which is in
progress in WYLBUR.
A CONTROL 18 issued under other processing control is ignored.

.us Operands:

   id-l           terminal identifier

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Successful completion.

A CONTROL 18 abort request is issued by the supervisor whenever a
session break occurs for any reason.
Since the program cannot control when these events occur, a
CONTROL 20 permission request should be issued each time a
changed line in a READ EDIT input area is about to be processed.

When a CONTROL 18 is issued, all command processing and changes
reporting is aborted.
If your program is processing a multiple line buffer
containing changes (READ EDIT, return code 8) when the abort
occurs, all lines in that buffer for which no permission has
been obtained (CONTROL 20) will be deleted from the active file.
.subsection 'CONTROL (19):  Output from the WYLBUR Active File to the Terminal'
.ix 'output from active file to terminal'
.ix 'active file' 'output to terminal'
.ix 'WYLBUR' 'active file' 'output to terminal'
   CONTROL  id-l,19,word-la
              (0) (1) (15)

.us Purpose:

Causes WYLBUR to type one line of the active file at the
terminal.

.us Operands:

   id-l           terminal identifier

   word-la        WYLBUR line number (times 1000) to be written.

.us Returns:

   (15) = 0       Operation begun.

.us Returns:

   (15) = 0       Successful completion.
          4       Line does not exist.
.subsection 'CONTROL (20):  Obtaining Permission to Process Changed Lines'
.ix 'obtaining' 'permission to process changed lines'
   CONTROL  id-l,20
              (0) (1)

.us Purpose:

For a program using READ EDIT with the INFORM flag on, ensures
that a changed line returned in a READ EDIT buffer with return
code 8 still exists in the active file.
If an abort should occur during processing of a READ EDIT
multiple line buffer (return code 8) by your program, WYLBUR
deletes those lines contained in the buffer from the active
file.
Control 20 ensures that a line is retained in the active file and
notifies your program that an abort has occurred.

.us Operands:

   id-l           terminal identifier

.us Returns:

   (15) = 0       Operation begun.

.us Returns from WAIT:

   (15) = 0       Processing permission granted and recorded.
          4       Processing permission denied because one or more abort
                  conditions have occurred since the last READ EDIT
                  buffer was returned.
.subsection 'READ,MODE=TEXT:  Reading the WYLBUR Active File'
.ix 'READ,MODE=TEXT'
.ix 'reading' 'the active file'
.ix 'active file' 'reading'
.ix 'WYLBUR' 'active file' 'reading'
   READ  id-l,location-la,length-la,control-la,MODE=TEXT
           (0)    (1)       (15)       (14)

.us Purpose:

Reads lines from the WYLBUR active file and places them in your
program area in one of several available formats.

.us Operands:

   id-l           terminal identifier

   location-la    location of the area which is to receive the line(s)

   length-la      1st 16 bits - zero (0) for codes 0/6, 100/106,
                                300/306,400/406
                                LRECL for codes 200/206, where
                                1<=LRECL<=235
                  2nd 16 bits - length of input area -
                                zero illegal
                                Codes 0/6 - if the PREST flag is off in
                                  the WYLBUR mode word, data may be lost
                                  if this length is less than 240 bytes.
                                  If the PREST flag is on in the WYLBUR
                                  mode word, data may be lost if this
                                  length is less than 256 bytes.
                                Codes 200/206 - Data may be lost if this
                                  length is not a multiple of LRECL.
                                Codes 300/306 - Data may be lost if this
                                  length is not a multiple of 80.
                                Codes 400/406 - Data may be lost if this
                                  length is not a multiple of 80.

   control-la     pointer to that area containing information on the line(s)
                  to be read and the format in which the requested data
                  is to be returned by WYLBUR.

   Specifying area   (bytes 1-2) -

                     CODE   MEANING

                       0    Read first line only.
                       1    Read line immediately preceding first line.
                       2    Read line immediately following first line.
                       3    Read line(s) from first line to last line, if given.
                       4    Read line(s) from first line to last line which
                            contain the given string.  Stop at last line if
                            given.  A zero length string reads only blank lines.
                       5    Read line(s) from first line containing the given
                            string at the starting column.  Stop at the ending
                            line, if given.
                       6    Read line(s) from line containing the given string
                            in columns from first column through last column.
                            Stop at last line, if given.

                 100/106    Similar to codes 0-6, but only the line number(s)
                            will be returned.  (NOTEXT)

                 200/206    Similar to codes 0-6, except that only the text of
                            the line(s) will be returned, truncated or padded to
                            LRECL characters per line.  A positive LRECL must be
                            supplied in the first 16 bits of the length-1a
                            operand.

                 300/306    Similar to codes 200/206, except that an LRECL=80 is
                            implied and positions 73/80 are replaced by the
                            WYLBUR line number in decimal format.

                 400/406    Similar to code 300/306, except that an LRECL=80
                            is implied and positions 73/80 are replaced by the
                            WYLBUR line number in integer format.

     (all codes)      bytes 3-4   - Maximum number of lines to be read.
                                    Ignored for codes 0,1,2.  A zero means
                                    ead lines until the area is filled.
     (all codes)      bytes 5-8   - First WYLBUR line number (times 1000).
                                    A (-1) means, "read those lines beginning
                                    with the line following the last one read
                                    with READ TEXT."
     (codes 3,4,5,6)  bytes 9-12  - Last WYLBUR line number (times 1000).
                                    A zero means "read lines until last."
                                    99999.999 is the highest possible line
                                    number.
     (codes 4,5,6)    bytes 13-14 - First column, where 1<=FCOL<=235.  Ignored
                                    for code 4.
     (codes 4,5,6)    bytes 15-16 - Last column, where 1<=FCOL<=
                                    LCOL<=235.  Ignored for codes 4,5.
     (codes 4,5,6)    bytes 17-18 - String length.  Must be non-zero except
                                    for code 4.
     (codes 4,5,6)    bytes 19 on - String text, where 1<=FCOL+string
                                    length-1<=235.


.us Returns:

   (15) = 0        Operation begun.


.us Returns from WAIT:

   (15) = 0        Successful completion.
          4        Specified line(s) not contained in the data set.
          8        User area is too small.

    (1) =          Total number of bytes transferred.

   (14) =          Number of lines read.

   AREA =    CODES 0/6
                   For each line read, one set of the following:
                   bytes 1/4 - line number (times 1000)
                   byte 5    - number of text bytes in the line
                   bytes 6/L - line text
             CODES 100/106
                   For each line read, one set of the following:
                   4 bytes   - line number (times 1000)
             CODES 200/206 and 300/306
                   For each line read, one set of the following:
                   LRECL bytes - line text adjusted to LRECL

For option codes 0/6, text is returned in PREST or UNPREST
format according the the setting of the PREST flag in the WYLBUR
mode word in effect at the time of the READ TEXT call.
For option codes 200/206 and 300/306, the PREST flag in the
WYLBUR mode word is ignored and text is always returned unprest.

For option codes 3/6, 103/106, 203/206, 303/306 and 403/406, as
many lines are read as can be accommodated in the area as
long as the total number of lines requested or the ending line
number is not exceeded.
For these codes, reading begins with the first line number equal
to or greater than the starting line number.
To read the entire active file, specify zero (0) as the starting
line number.
After each returned buffer has been processed, add one (1) to the
last line number read and issue another READ TEXT until all
lines have been read or use the -1 value in bytes 5/8.
.subsection 'WRITE,MODE=TEXT:  Writing to the WYLBUR Active File'
.ix 'WRITE,MODE=TEXT'
.ix 'writing' 'to the active file'
.ix 'active file' 'writing to'
.ix 'WYLBUR' 'active file' 'writing to'
   WRITE  id-l,location-la,length-la,lines-la,MODE=TEXT
            (0)    (1)       (15)      (14)

.us Purpose:

Writes or deletes specific lines in the WYLBUR active file.

.us Operands:

   id-l              terminal identifier

   location-la       location of the area which contains the lines
                     in the specified format.

   length-la         1st 16 bits - disposition code

                            Disposition codes:

                            0    Replace or insert line(s)
                            1    Replace line(s).
                            2    Insert line(s).
                            3    Delete line(s).
                            4    LRECL option (append only).
                            5    NUMBERED option (insert or append).
                            6    INTEGER option (insert or append).

                     2nd 16 bits - length of the area

   lines-la          for CODES 0,1,2,3,5,6:  1st 16 bits - zero
                                             2nd 16 bits - number of lines
                                             to be written or deleted.

                     for CODE 4:
                         1st 16 bits - LRECL, 1 <= LRECL <= 235
                         2nd 16 bits - number of lines to be written

   AREA =
     (CODES 0,1,2)   For each line, one set of the following:
                       bytes 1/4 - line number (times 1000)
                       byte 5    - number of text bytes in the line
                       bytes 6/L - line text
     (CODE 3)        For each line, one set of the following:
                       bytes 1/4 - line number (times 1000)
     (CODE 4)        For each line, one set of the following:
                       bytes 1/LRECL -  line text
     (CODE 5)        For each line, one set of the following:
                       bytes  1/72 - 72 bytes of line text
                       bytes 73/80 - 8-byte WYLBUR line number
                                     in decimal format.
     (CODE 6)        For each line, one set of the following:
                       bytes  1/72 - 72 bytes of line text
                       bytes 73/80 - 8-byte WYLBUR line number
                                     in INTEGER format.

.us Returns:

   (15) = 0          Operation begun.

.us Returns from WAIT:

   (15) = 0          Successful completion.
          4          Completed, line longer than WYLBUR length option.
          8          Line truncated to 235 chars in WYLBUR.
         12          No room in WYLBUR active file.
         16          Line does not exist (REPLACE or DELETE).
         20          Line already exists (INSERT).
         24          Contents of area were invalid.
         28          Line number too large for WYLBUR.

   (15) = 12,16,20,24,28:

    (1) =            Residual byte count.

If register 15 returns a value of 12, 16, 20, 24 or 28, no
indication that lines were either truncated or longer than the
WYLBUR length option is provided.
Such a condition, however, does not cause the write to be
canceled.

With codes 0, 1, and 2, text is interpreted in PREST or
UNPREST format in accordance with the current setting of the
PREST flag in the WYLBUR mode word.
For codes 4, 5, and 6, the setting of the PREST flag in the
WYLBUR mode word is ignored and text is assumed to be UNPREST.

With disposition code 4, lines can only be appended to the active
file.
Each LRECL bytes is used to create a new line.
If the number of bytes is not an exact multiple of LRECL,
register 15 returns the value 24 and a non-zero residual
byte count is returned in register 1.
If the active file is empty, the line is assigned the WYLBUR
line number 1.000.
If lines exist, new lines are assigned a line number which is
the sum of the highest existing line number and the current
WYLBUR delta value.

For disposition code 5, each 80-byte length is used to form a new
line.
The contents of positions 73/80, which must be valid WYLBUR line
numbers, are used to number the line and insert it into the
active file.
If the number of bytes is not an exact multiple of 80, register
15 returns the value 24 and a non-zero residual byte count
is returned in register 1.
.subsection 'READ,MODE=EDIT:  Allowing WYLBUR to Issue Command Prompts'
.ix 'READ,MODE=EDIT'
.ix 'issuing command prompts - WYLBUR'
.ix 'WYLBUR' 'issuing command prompts'
   READ  id-l,location-la,length-la[,write-la],MODE=EDIT
           (0)    (1)       (15)       (14)

.us Purpose:

Permits the program to relinquish control of the terminal to
WYLBUR for command prompting and processing until an
unrecognized command is entered from the terminal or,
optionally, until a command is entered which causes changes to
the active file.

.us Operands:

  id-l              terminal identifier

  location-la       Location of the area which is to receive text returned
                    from WYLBUR.  The text is either an unrecognized
                    command in UNPREST format or, optionally, a changed
                    line(s) in the active file.

  length-la         Length of the area.  UNPREST data may be lost if less
                    than 240 bytes.  PREST data may be lost if less than
                    256 bytes.  Zero illegal.

  write-la          Location of an area containing a write line.

                          If a write operation is specified, the write
                          area must contain an output line with count as
                          specified:

                          Field size:  Contents:
                           2 bytes     w (Length of line to be written
                                         to terminal, where 0<w<163 )
                           w bytes     Line to be written to terminal

.us Returns:

   (15) = 0         Operation begun.

.us Returns from WAIT:

   (15) = 0         Command was not recognized by WYLBUR.
    (1) =           Total number of bytes transferred.  If zero, user
                    at terminal typed a question mark (?) and then ATTN
                    as a command to cause a session break to be scheduled.
   AREA =           The illegal command.

The following returns occur only if the INFORM flag is on in
.ix 'INFORM flag'
the WYLBUR mode word and the command being processed is causing
changes to the active file.

   (15) = 4         A line, typed at terminal, was inserted into active
                    file.  (COLLECT,INSERT)
    (1) =           Total number of bytes transferred.
   (14) =           1 (number of lines inserted)
   AREA =           bytes 1/4  - line number inserted
                    byte 5     - number of text bytes in line
                    bytes 6/L  - text or line inserted

   (15) = 8         Line(s), not typed at terminal, were inserted into
                    active file. (USE, FETCH, COPY, ALIGN, JUSTIFY).
    (1) =           Total number of bytes transferred.
   (14) =           Number of lines transferred.
   AREA =           One set of the following for each line inserted:
                    bytes 1/4  - line number inserted
                    byte 5     - number of text bytes in the line
                    bytes 6/L  - line text inserted

   (15) = 12        A line, typed at terminal, was replaced in active
                    file.  (REPLACE)
    (1) =           Total number of bytes transferred.
   (14) =           1 (number of lines replaced)
   AREA =           bytes 1/4  - line number replaced
                    byte 5     - number of text bytes in line
                    bytes 6/L  - line text replaced

   (15) = 16        A line, not typed at terminal was replaced in active
                    file.  (CHANGE, MODIFY, EDIT, CENTER)
    (1) =           Total number of bytes transferred.
   (14) =           1 (number of lines replaced)
   AREA =           bytes 1/4  - line number replaced
                    byte 5     - number of text bytes in line
                    bytes 6/L  - line text replaced

   (15) = 20        One line was deleted, another inserted in active file
                    (MOVE).
    (1) =           Total number of bytes transferred.
   (14) =           1 (number of lines inserted)
   AREA =           bytes 1/4  - line number deleted
                    bytes 5/8  - line number inserted
                    byte 9     - number of text bytes in line inserted
                    bytes 10/L - line text inserted line

   (15) = 24        Line(s) were deleted from active file
                    (DELETE,ALIGN,JUSTIFY).
    (1) =           First line number deleted.
   (14) =           Last line number deleted.

   (15) = 28        A CLEAR TEXT occurred in WYLBUR.

Illegal commands are returned one at a time in UNPREST format.
All other returns listed occur only if the INFORM flag of the
WYLBUR mode word is on.

When the INFORM flag is on, the following guide lines are
applicable to the changes being reported:
.point set b b b
.point begin
The text for changed lines is returned in either PREST
or UNPREST format in accordance with the PREST flag
setting in the WYLBUR mode word.
.point
If the NONUM flag is not set in the WYLBUR mode word,
the NUMBER command is allowed, but the changes in
line numbers are not reported.
.point
At the terminal, you may not issue a DELETE which
specifies disjoint ranges.  You must enter one command
for each range to be deleted.
.point
The program may stop both the command in progress and
all reporting of changes in mid-stream either
explicitly or inadvertently by issuing a request to
WYLBUR other than READ EDIT.
A session break has the same effect upon a command in
progress.
.point
For return codes 4, 12, 16, and 20, if the command
causing the changes affects more than one line, each
line is reported one line at a time as soon as
the line is changed, regardless of the specified size
of the receive area.
Before changing the next line, WYLBUR waits for
another READ EDIT request.
.point
On return code 8, WYLBUR passes on each successive
READ EDIT request as many changed lines as fit in
the program input area until all changes have been
exhausted.
.point end
Before attempting to process a line in the input buffer, your
program should first issue a CONTROL 20 permission request.
When permission is granted, the program is assured that the
change reporting sequence has not been aborted due to a program
panic or session break.
.point set b b b
.point begin
When the command causing changes is the ALIGN or
JUSTIFY command, each line to be split is first
reported as a line which has been deleted, (return
code 24), and on the next READ EDIT request, the new
aligned or justified lines are reported as "not
typed-inserted" lines (return code 8).
.point end
In this form of READ EDIT, your program receives no
indication that all changes associated with a command have been
reported.
The next READ EDIT may cause WYLBUR to prompt you for a new
command.
For notification that all changes for a given
command have been completed, use READ EDIT CHANGES.
.subsection 'READ,MODE=(EDIT,CHANGES):  Editing the WYLBUR Active File'
.ix 'READ,MODE=(EDIT,CHANGES)'
.ix 'editing the active file'
.ix 'active file' 'editing'
.ix 'WYLBUR' 'active file' 'editing'
   READ  id-l,location-la,length-la[,write-la],MODE=(EDIT,CHANGES)
           (0)    (1)        (15)      (14)

.us Purpose:

Allows your program to receive control of the terminal once
all changes to the active file caused by one command have been
reported by WYLBUR.

Specifications are identical to those described for READ EDIT,
except that a new return code is received by your program.
This return code indicates that all changes to the active file
caused by a previous command have been completed.

.us Operands and Returns:

All identical to those of READ MODE=EDIT.

.us Additional return from WAIT:

   (15) = 32     Changes completed.

This READ EDIT option may also be employed when a return code of
8 is issued on the WAIT following a WRITE EDIT request.
A return code of 8 indicates that the INFORM flag in the WYLBUR
mode word is on; the command passed with the WRITE EDIT
causes changes to the active file.
This option allows the program to obtain changes via the READ
EDIT mechanism without giving up control of the terminal once
all changes caused by the command passed in the WRITE EDIT are
reported.
.subsection 'WRITE,MODE=EDIT:  Passing WYLBUR and MILTEN Commands'
.ix 'WRITE,MODE=EDIT'
.ix 'passing' 'WYLBUR and MILTEN commands'
.ix 'WYLBUR' 'passing commands'
.ix 'Command' 'passing' 'WYLBUR and MILTEN commands'
   WRITE  id-l,location-la,length-la,code-la,MODE=EDIT
            (0)    (1)       (15)      (14)

.us Purpose:

Passes a command to WYLBUR and MILTEN for execution.

.us Operands:

   id-l              terminal identifier

   location-la       location of the area containing the WYLBUR command

   length-la         length of the area, 1 < length < 163

   code-la           0        the line has been typed at the terminal
                     nonzero  the line has not been typed

The last 31 bits of the code-la register are reserved.

.us Returns:

   (15) = 0          Operation begun.

.us Returns from WAIT:

   (15) = 0          Successful completion with no changes to the active file.
          4          Successful completion with changes to the active file.
                     This code is returned only if the INFORM and BLOCK flags
                     in the WYLBUR mode word are off.
          8          Active file changes pending, issue READ MODE=(EDIT,CHANGES)
                     next.  This code is returned only if the INFORM flag
                     is on and the BLOCK flag is off in the WYLBUR mode word.
         -4          Active file changes prohibited.  This code is returned
                     only if (1) a BLOCK, NONUM, or NOALGN flag is on in the
                     WYLBUR mode word and (2) command execution would violate
                     that flag.
         -8          An error was detected and an error message was typed on
                     the terminal.  If code-la was set, then the command was
                     also typed with the message.

    (1) = 0          No write/idle attention outside ORVYL.
          4          Write/idle attention outside ORVYL and session break was
                     scheduled.

WARNING:  If a return code 8 from WAIT is followed by any command
to WYLBUR other than a READ EDIT or READ EDIT with CHANGES, then
the changes to the active file are aborted.
.subsection 'MILCOM:  Passing Commands to MILTEN Only'
.ix 'MILCOM'
.ix 'passing' 'commands to MILTEN only'
.ix 'Command' 'passing' 'to MILTEN only'
   MILCOM id-l,location-la,length-la,code-la
            (0)    (1)       (15)      (14)

.us Purpose:

Passes a string to MILTEN to be used as the text for a WTO to the
operator's console or as a command to be executed directly by
MILTEN.

.us Operands:

   id-l              terminal identifier

   location-la       location of the area which contains the string

   length-la         length of the area, 1 <length < 163

   code-la

                     Code:       Meaning:

                       0         Command input from terminal

                       1         Command input was not from
                                 the terminal

                       2         String to be used in WTO to the
                                 operator

.us Returns:

   (15) = 0          Operation begun

.us Returns from WAIT:

   (15) = 0          Successful completion
          4          String was used as a command but an error was detected
                     and INVALID message typed.  If code-1a was 1, the
                     incorrect command was also typed.
          8          Command passed was the name of a subsystem.  Control
                     was not passed to the subsystem.  Use WRITE, MODE=EDIT
                     or COMMAND, MODE=WYLBUR to pass control to the subsystem.

    (1) = 0          No write/idle ATTN outside ORVYL.
          4          Write/idle ATTN outside ORVYL.
.section 'ORVYL File Input/Output and Control'
.ix 'file' 'input/output and control'
.subsection 'ATTACH (2):  Attaching ORVYL Files'
.ix 'ATTACH'
.ix 'attaching ORVYL files'
   ATTACH   2,location-la,length-la[,MODE=([SHARE][,OLD][,WAIT])]
            (0)   (1)       (15)

.us Purpose:

Requests the use of a file.

.us Operands:

   location-la       Location of the area containing the file name.
                     Zero if a temporary file.

   length-la         Length of the area.  Zero if a temporary file.

   MODE=SHARE        Other tasks may attach the file at the same time.

   MODE=OLD          The file already exists.  If this option is not specified,
                     a new file will be created.

   MODE=WAIT         If the file cannot be immediately attached, the
                     program will wait for it to become available.

.us Returns:

   (15) = 0          Operation begun.
          4          Attach was already begun.
          8          Device was already attached not MODE=SHARE.
         12          Device was already attached MODE=SHARE.
         -4          Too many devices attached.
         -8          Device name illegal.
        -12          ORVYL file system unavailable.

    (0) =            32-bit file identifier

The valid file identifier is returned in register zero (0) when
the return in register 15 is 0, 4, 8 or 12.

.us Returns from WAIT:

   (15) = 0          Attach completed.
         -4          File not immediately available.
          4          Access not permitted.
          8          File storage limit exceeded (not MODE=OLD).
         12          No space remains in file directory.
         16          File does not exist (MODE=OLD)
         20          File already exists (not MODE=OLD).
         24          System tables overflowed.
         28          File space exhausted (not MODE=OLD).
         32          File may only be attached MODE=SHARE.
.subsection 'READ:  Reading File Blocks'
.ix 'reading' 'file blocks'
.ix 'file block' 'reading'
   READ  id-l,location-la,length-la,block-la[,MODE=([WAIT][,SKIP])]
           (0)    (1)       (15)      (14)

.us Purpose:

Reads a data block from a file.

.us Operands:

   id-l              file identifier

   location-la       Location of the area which is to receive the block

   length-la         Length of the area.  Maximum area size is 8192 bytes.
                     Blocks will be read until this area is filled.

   block-la          The number of the first block to be read.  Block
                     numbers start at zero.

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

   MODE=SKIP         If the requested block does not exist, then the
                     next existing block should be read instead.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O Error.
          4          File not immediately available.
          8          READ access to this file prohibited.
         12          Block does not exist.

    (1) =            Number of bytes read.

   (14) =            Number of last block processed, plus one.

The number of bytes read is no greater than the length
of the area.
If a block written using less than 2048 bytes is read, another
block is not read, regardless of the total size of the
area.
Contents of the area specified, but not filled, remain undefined.
See &core for core storage restrictions.
.subsection 'WRITE:  Writing File Blocks'
.sr core &pubSWprt
.ix 'writing' 'file blocks'
.ix 'file block' 'writing'
   WRITE  id-l,location-la,length-la,block-la[,MODE=WAIT]
            (0)    (1)       (15)      (14)

.us Purpose:

Writes a data block to a file.

.us Operands:

   id-l              file identifier

   location-la       location of the area containing the block

   length-la         Length of the area.  The maximum area size is 8192 bytes.
                     Blocks are written until the area is emptied.

   block-la          block number or beginning block number

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          WRITE access to this file prohibited.
         12          Rewriting an existing block not permitted.
         16          File storage limit exceeded.
         20          File space exhausted.

    (1) =            Number of bytes transmitted.

   (14) =            Number of last block processed, plus one.

Core storage in ORVYL is divided into pages of 4096 bytes
each.
A buffer area must begin on a double-word boundary and may not
cross more than one page boundary.
If a page boundary is crossed, the buffer must extend at least 8
bytes onto the second page.
A buffer of 4096 bytes or less may begin on any
double-word.
A buffer of 6144 bytes may begin as much as 2048 bytes from the
beginning of a page, while an 8192 byte buffer must begin on a
page boundary.
For maximum efficiency, buffers of 4096 bytes or less should
reside on a single page.
.subsection 'CONTROL (0):  Creating File Blocks'
.ix 'creating' 'file blocks'
.ix 'file block' 'creating'
   CONTROL  id-l,0,block-la[,MODE=WAIT]
             (0) (1) (15)

.us Purpose:

Creates a file data block of undefined content.

.us Operands:

   id-l              file identifier

   block-la          block number

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.
         12          Block already exists.
         16          File storage limit exceeded.
         20          File space exhausted.
.subsection 'CONTROL (1):  Deleting a File Block'
.ix 'deleting' 'a file block'
.ix 'file block' 'deleting'
   CONTROL  id-l,1,block-la[,MODE=WAIT]
             (0) (1) (15)

.us Purpose:

Deletes a file data block.

.us Operands:

   id-l              file identifier

   block-la          block number

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O Error.
          4          File not immediately available.
          8          Access not permitted.
         12          Block does not exist.
.subsection 'CONTROL (2):  Deleting a Range of File Blocks'
.ix 'deleting' 'a range of file blocks'
   CONTROL  id-l,2,first-la,last-la[,MODE=WAIT]
             (0) (1) (15)    (14)

.us Purpose:

Deletes a range of file data blocks.

.us Operands:

   id-l              file identifier

   first-la          first block number

   last-la           last block number

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.
         12          Not all blocks in the range exist.

    (1)              Number of blocks deleted.
.subsection 'CONTROL (3):  Testing for the Existence of a File Block'
.ix 'testing for existence of a file block'
.ix 'file block' 'testing for existence'
   CONTROL  id-l,3,block-la[,MODE=WAIT]
             (0) (1) (15)

.us Purpose:

Tests for the presence of a file block.

.us Operands:

   id-l              file identifier

   block-la          block number

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Specified block present.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.
         12          Block not present.
.subsection 'CONTROL (4):  Obtaining the File First Block Number'
.ix 'obtaining' 'file first block number'
.ix 'file block' 'obtaining' 'first block number'
   CONTROL  id-l,4[,MODE=WAIT]
             (0) (1)

.us Purpose:

Reports the first block number in the file.

.us Operands:

   id-l              file identifier

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.
         12          No blocks in file.

    (1) =            Number of first block in the file.
.subsection 'CONTROL (5):  Obtaining the File Last Block Number'
.ix 'obtaining' 'file last block number'
.ix 'file block' 'obtaining' 'last block number'
   CONTROL  id-l,5[,MODE=WAIT]
             (0) (1)

.us Purpose

Reports the last block number in the file.

.us Operands:

   id-l              file identifier

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.
         12          No blocks in file.

    (1) =            Number of last block in the file.
.subsection 'CONTROL (6):  Obtaining the Total Number of File Blocks'
.ix 'obtaining' 'total number of file blocks'
.ix 'file block' 'obtaining' 'total number of blocks'
   CONTROL  id-l,6[,MODE=WAIT]
             (0) (1)

.us Purpose:

Reports the total number of blocks in the file.

.us Operands:

   id-l              file identifier

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.

    (1) =            Number of user-written blocks in the file.

   (14) =            Number of billable blocks in the file, including
                     both user blocks and system index blocks.
.subsection 'CONTROL (7):  Writing an Updated File Index'
.ix 'writing' 'an updated file index'
.ix 'file' 'writing an updated index'
   CONTROL  id-l,7[,MODE=WAIT]
             (0) (1)

.us Purpose:

Updates the index for the file.
Ensures that all file updates are retained in case of system
error.

.us Operands:

   id-l              file identifier

   MODE=WAIT         If the request cannot be immediately processed, the
                     program waits for the file to become available.

.us Returns:

   (15) = 0          Operation begun.
        -12          ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0          Successful completion.
         -4          Permanent I/O error.
          4          File not immediately available.
          8          Access not permitted.
.subsection 'CONTROL (8):  Erasing and Renaming Files'
.ix 'erasing files'
.ix 'file' 'erasing'
.ix 'file' 'renaming'
.ix 'renaming files'
   CONTROL  id-l,8,location-la[,length-la][,MODE=WAIT]
             (0) (1)   (15)       (14)

.us Purpose:

Erases or renames files.
This macro may be used to erase a file only if the file is not
attached with MODE=SHARE.
A DETACH following the scratch option results in an error.

.us Operands:

   id-l             file identifier

   location-la      location of the area containing the new file name.
                    If no name is specified (that is, if R15=0), the file
                    is erased.

   length-la        length of the file name.

   MODE=WAIT        If the request cannot be immediately processed, the
                    program waits for the file to become available.

.us Returns:

   (15) = 0         Operation begun.
         -4         File attached MODE=SHARE.
         -8         New name illegal.
        -12         ORVYL file system not available.
          4         Attempt to change file owner during rename.

.us Returns from WAIT:

   (15) = 0         Successful completion.
         -4         Permanent I/O error.
          4         File not immediately available.
          8         Access not permitted.
         12         New file name already exists.
         16         No space available in file directory.
.subsection 'CONTROL (9):  Assigning Account Level File Privileges'
.ix 'assigning' 'account level file privileges'
.ix 'file' 'privileges' 'assigning account'
   CONTROL  id-l,9,access-la[,user-la]
             (0) (1) (15)      (14)

.us Purpose:

Assigns and withdraws access privileges for a file.
Changes in file access privileges for any user do not affect that
user if the file is attached when the change is made.  If user is
not specified, then the FILEMASK is altered.  Only the file owner
may alter the FILEMASK.

.us Operands:

   id-l             file identifier

   access-la        code specifying the permitted access

                    bits 29-31  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only
                    bit 28        0  may not extend access to others
                                  1  may extend access to others

   user-la          location of the 6-byte area containing the name of
                    the user to whom access is to be permitted (that is,
                    gg.uuu).  If no user is specified, the FILEMASK is
                    altered.

.us Returns:

   (15) = 0         Operation begun.
         -4         File attached MODE=SHARE.
         -8         Illegal user.
        -12         ORVYL file system not available.
          4         Non-owner attempt to alter owner's privileges.

.us Returns from WAIT:

   (15) = 0         Successful completion.
         -4         Permanent I/O error.
          4         File not immediately available.
          8         Attempt to extend more privileges than user has.
         12         Attempt to extend privileges to a user who has not
                    been validated for ORVYL file use.
         16         No space remains in file directory.
.subsection 'CONTROL (10):  Assigning PUBLIC File Privileges'
.ix 'assigning' 'PUBLIC file privileges'
.ix 'file' 'privileges' 'assigning PUBLIC'
   CONTROL  id-l,10,access-la
              (0) (1) (15)


.us Purpose:

Assigns and withdraws the access privileges for a file to all
valid terminal users.
Changes in PUBLIC access privileges may only be made by the file
owner.
If the file was attached MODE=SHARE, a change to public
privileges does not affect those users attached to the file when
the change was made.

.us Operands:

   id-l             file identifier

   access-la        code specifying the permitted access

                    bits 29-31  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only
                    bits 0-28        not used

.us Returns:

   (15) = 0         Operation begun.
          4         Attempt to alter public privileges by non-owning
                    user.
        -12         ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0         Successful completion.
.subsection 'CONTROL (11):  Reading File Access Privileges'
.ix 'reading' 'file access privileges'
.ix 'file' 'privileges' 'reading'
   CONTROL  id-l,11[,location-la,length-la]
              (0) (1)    (15)      (14)

.us Purpose:

Reports the FILEMASK and PUBLIC access privileges for a file.
If the issuer is the file owner or a user with EXTEND privileges,
also reports all other users with access to the file as well as
the access privileges each user enjoys.
Otherwise, only the owner, PUBLIC, and any privileges belonging to the
user issuing the command are reported.

.us Operands:

   id-l           file identifier

   location-la    Location of the area which is to receive the names
                  of the users with privileges and the access
                  privileges.  If no location is given, only the
                  PUBLIC and owner's privileges are reported.

   length-la      length of the area (at least 7 bytes)

.us Returns:

   (15) = 0       Operation begun.
        -12       ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0       Successful completion.
         -4       Permanent I/O error.

    (1)           Public and FILEMASK:
                    Public privileges:
                    bits 21-23  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only
                    FILEMASK:
                    bits 29-31  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only

    (14)          Number of privileged users.

    AREA =        7 bytes for each privileged user:

                  bytes 1-6 - user name (that is, gg.uuu)
                          7 - user privileges:
                              bits 5-7  000  no access
                                        001  read only
                                        111  read and write
                                        011  read and append
                                        010  append only
                              bit 4       0  may not permit access to others
                                          1  may permit access to others

Privileged users are reported until the specified area is
filled.
.subsection 'CONTROL (12):  Setting SHARE ONLY Mode for ATTACH Macro'
.ix 'setting' 'SHARE ONLY for ATTACH'
.ix 'ATTACH'
   CONTROL  id-l,12,state-la
              (0) (1) (15)

.us Purpose:

Specifies that a file may or may not be attached only with
MODE=SHARE.
Changes in the SHARE ONLY ATTACH condition may only be made by
the file owner.
The SHARE ONLY condition may be specified even when the file is
currently attached (not MODE=SHARE); in this case, SHARE ONLY
takes effect after the file is next detached.

.us Operands:

   id-l           file identifier

   state-la       zero, file may be attached normally
                  non-zero, file may be attached only MODE=SHARE

.us Returns:

   (15) = 0       Operation begun.
          4       Attempt to alter SHARE ONLY ATTACH condition by
                  non-owning user.
        -12       ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0       Successful completion.

SHARE ONLY prevents exclusive file use but does not
prevent file updating by a program using the RESERVE and RELEASE
macros.
.subsection 'CONTROL (13):  Sensing SHARE ONLY Mode for ATTACH Macro'
.ix 'sensing' 'SHARE ONLY for ATTACH'
   CONTROL  id-l,13
              (0) (1)

.us Purpose:

Senses the ATTACH condition for a file.

.us Operands:

   id-l             file identifier

.us Returns:

   (15) = 0         Operation begun.
        -12         ORVYL file system not available.

.us Returns from WAIT:

   (15) = 0         File may be attached normally.
          4         File may be attached only MODE=SHARE.
.subsection 'CONTROL (14):  Setting the File Format Field '
.ix 'setting' 'file format field'
   CONTROL id-l,14,info-la[,MODE=(FORMAT,WAIT)]
            (0)  (1) (15)

.us Purpose:

Writes the file format field (4 bytes) in the file directory
entry for the specified file.  This field may be employed by any
user program, but is used primarily by the Command Language
Processor (CLP) to retain the format (for example, EDIT, CARD, LRECL)
in which the file is stored.  WRITE access privilege is required
in order to modify the file format field.

.us Operands:

   id-l             file identifier

   info-la          information to be written
                    in the file directory entry

   MODE=FORMAT      Sets the FORMAT entry for the file.

.us Returns:

   (15) = 0         Operation begun
        -12         File system not available


.us Returns from WAIT:

   (15) = 0         Information written in the file
                    directory entry.
        -12         File system not available.
          4         File not immediately available.
          8         Access not permitted.

.us Format in (15) (4 bytes):

  byte 1      TYPE = X'80'  Library
                     X'40'  Loadfile
                     X'04'  Fixed LRECL=nn
                     X'05'  Numbered (LRECL=nn)
                     X'06'  Integer  (LRECL=nn)
                     X'01'  Edit
                     X'02'  Variable
   byte 2            Reserved for URAM use
   bytes 3-4         LRECL
.subsection 'CONTROL (15):  Sensing the File Format Field'
.ix 'sensing' 'file format field'
.ix 'file' 'sensing format field'
   CONTROL id-l,15
             (0) (1)

.us Purpose:

Retrieves the file format field (4 bytes).

.us Operands:

   id-l             file identifier

.us Returns:

   (15) = 0         Operation begun
        -12         File system not available

.us Returns from WAIT:

   (15) = 0         FORMAT option set
         12         FORMAT option not set
        -12         File system not available

    (1) =           4 bytes of file format information
                    See 5.10.18 format description.
.subsection 'CONTROL (16):  Setting a File's CLP/NOCLP Condition'
.ix "file" "setting a file's CLP/NOCLP condition"
.ix 'CLP'
.ix 'NOCLP'
   CONTROL id-l,16,state-la
             (0) (1) (15)

.us Purpose:

Sets the CLP/NOCLP condition for a file.
If NOCLP is set, the terminal user cannot ERASE, PUT, RENAME, SET
PERMIT, SHOW FILES ERASE, or DEFLATE the specified file.
Only the file owner may set or reset this condition.

.us Operands:

   id-l             file identifier

   state-la         0 - all CLP commands may be performed for the
                        file (CLP).
                    1 - CLP may not modify the file (NOCLP).

.us Returns:

   (15) = 0         Operation begun
          4         Attempt to alter CLP/NOCLP condition by a
                    non-owning user
        -12         File system not available

.us Returns from WAIT:

   (15) = 0         Operation successful
.subsection 'CONTROL (17):  Sensing a File's CLP/NOCLP Condition'
.ix "file" "sensing a file's CLP/NOCLP condition"
   CONTROL id-l,17
             (0) (1)

.us Purpose:

Senses the CLP/NOCLP condition set for a file.

.us Operands:

   id-l              file identifier

.us Returns:

   (15) = 0          Operation begun
        -12          ORVYL file system not available

.us Returns from WAIT:

   (15) = 0          Any CLP command may be executed (CLP).
          4          CLP may not modify the file (NOCLP).
.subsection 'STATUS (0):  Assigning Global File Access'
.ix 'assigning' 'global file access'
.ix 'file' 'assigning global access'
.ix 'global file access'
   STATUS  0,access-la,usera-la[,userb-la]
           (0)  (1)      (15)      (14)

.us Purpose:

Assigns and withdraws global file access privileges for all files
owned by a user.
Changes made in access privileges do not affect access to any
files in use at the time the change is made.

.us Operands:

   access-la      code specifying the permitted access

                    bits 29-31  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only
                    bit 28        0  may not extend access to others
                                  1  may extend access to others

   usera-la       location of the 6-byte area which contains the name of
                  the user to whom access is to be permitted.

   userb-la       location of the 6-byte area containing the name of the
                  file owner.  If none is given, the current user is implied.

.us Returns:

   (15) = 0       Operation begun.
         -4       Too many devices attached.
         -8       Account name illegal.
        -12       ORVYL file system unavailable.
          4       Attempt to extend privileges to owner.

    (0) =         32-bit device identifier (used only for WAIT).

.us Returns from WAIT:

   (15) = 0       Successful completion.
          4       Attempt to extend more privileges than the user has.
          8       Attempt to extend privileges to a user who has not
                  been validated for ORVYL file use.
         12       Attempt to extend privileges by a user who has not
                  been validated for ORVYL file use.
         16       No space available in file directory.
.subsection 'STATUS (1):  Assigning Global PUBLIC Access'
.ix 'assigning' 'global PUBLIC access'
.ix 'global public access'
   STATUS  1,access-la
           (0)  (1)

.us Purpose:

Assigns and withdraws global file access for all the files owned
by a user to all validated terminal users.
Changes in PUBLIC access may only be made by the file owner.

.us Operands:

   access-la      code specifying permitted access

                    bits 29-31  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only

.us Returns:

   (15) = 0       Operation begun.
         -4       Too many devices attached.
        -12       ORVYL file system unavailable.

    (0) =         32-bit device identifier (used only for WAIT).

.us Returns from WAIT:

   (15) = 0       Successful completion.
.subsection 'STATUS (2):  Reading File Names, Creation Date, and Last Use'
.ix 'reading' 'file names'
.ix 'reading' 'creation date'
.ix 'reading' 'last use'
   STATUS  2,location-la,length-la[,name-la]
           (0)   (1)       (15)      (14)

.us Purpose:

Reports the names, creation dates and last reference dates of a
user's files.
Files are reported in alphabetical order.
Only permitted users may list file names of other users.

.us Operands:

   location-la      location of the area which is to receive the file
                    names and dates

   length-la        length of the area (at least 56 bytes)

   name-la          40-byte area containing:
                    bytes  1-6 - name of the file owner
                             7 - period (.)
                          8-40 - filename (padded with blanks)
                                 If bytes 7-40 or 8-40 are blank, reporting
                                 begins with the first file.  If a
                                 matching file name is not encountered,
                                 reporting begins with the next file name
                                 encountered in collating sequence order.
                                 If user is not given, the user issuing
                                 the command is assumed.

.us Returns:

   (15) = 0       Operation begun.
         -4       Too many devices attached.
         -8       Name illegal.
        -12       ORVYL file system unavailable.

    (0) =         32-bit device identifier (used only for WAIT).

.us Returns from WAIT:

   (15) = 0       Successful completion.
          4       Account has not been validated for ORVYL file use.
          8       No files exist to be reported.
         12       Reading file names prohibited.
         16       No files exist in higher collating sequence.

    (1)           Number of file names reported.

   AREA =         56 bytes for each file name reported:

                  bytes 1-44:  ORV.gg.uuu.filename
                       45-50:  creation date (YYMMDD)
                       51-56:  last reference date (YYMMDD)

File names are reported until the area is filled.
.subsection 'STATUS (3):  Detecting Account Level Access Privileges'
.ix 'detecting' 'account level access privileges'
   STATUS  3,location-la,length-la[,user-la]
           (0)   (1)       (15)      (14)

.us Purpose:

Reports privileged users as well as the access privileges each
user is assigned.  Users are reported in alphabetical sequence.
Only the file owner and users with EXTEND privileges may report
other users.  Users without EXTEND privileges may detect only
their own access privileges.

.us Operands:

   location-la      location of the area which is to receive the
                    user names and access privileges

   length-la        length of the area (at least 7 bytes)

   user-la          6-byte area containing the name of the user
                    If a user is not given, the current user is assumed.

.us Returns:

   (15) = 0       Operation begun.
         -4       Too many devices attached.
         -8       Name illegal.
        -12       ORVYL file system unavailable.

    (0) =         32-bit device identifier (used only for WAIT).

.us Returns from WAIT:

   (15) = 0       Successful completion.
          4       Account does not exist.
          8       Reporting privileged users prohibited.
    (1)           Public privileges:
                    bits 21-23  000  no access
                                001  read only
                                111  read and write
                                011  read and append
                                010  append only
    (14)          Number of users sensed.

   AREA =         7 bytes for each user sensed:
                  bytes 1-6:  user
                          7:  user's privileges:
                              bits 5-7  000  no access
                                        001  read only
                                        111  read and write
                                        011  read and append
                                        010  append only
                              bit 4       0  may not extend access
                                             to others
                                          1  may extend access to
                                             others
                              bits 0-3       not used

Users are reported until the area is filled.
.subsection 'STATUS (4):  Obtaining Current Space and Usage Statistics'
.ix 'obtaining' 'current space and usage statistics'
   STATUS  4[,user-la]
           (0)  (1)

.us Purpose:

Reports the space allocated to and the current space usage of a
user.
Only permitted users may report space status.

.us Operands:

   user-la        6-byte area containing the user name.  If no user
                  is given, the current user is assumed.

.us Returns:

   (15) = 0       Operation started.
         -4       Too many devices attached.
         -8       Account name illegal.
        -12       ORVYL file system unavailable.

    (0) =         32-bit device identifier (used only for WAIT).

.us Returns from WAIT:

   (15) = 0       Successful completion.
          4       Account has not been validated for ORVYL file use.
          8       Sensing this user's space prohibited.

    (1)           Space allotment (number of blocks).

   (14)           Space used (number of blocks).
.subsection 'STATUS (5):  Allocating ORVYL File Space'
.ix 'allocating file space'
.ix 'file' 'allocating space'
   STATUS  5,blocks-la
           (0) (1)

.us Purpose:

Add a user entry to the ORVYL file directory and set the block
allocation limit.
The maximum block limit you can set is 250 blocks.
A negative request or one for more than the limit is reset to
250.
Zero allocation is legal and means that you may access ORVYL
files permitted to you by other accounts, including PUBLIC
files, but are not allowed to create your own files.

.us Operands:

   blocks-la       maximum number of blocks to be allowed this account

.us Returns:

   (15) =  0       Operation started
           -4      Too many devices attached
          -12      ORVYL file system unavailable
    (1)  =         Number of blocks being allocated (may be changed
                   to maximum)
    (0)  =         32-bit device identifier (used only for WAIT).

.us Returns from WAIT:

   (15) =  0       Successful completion
           4       Group entry already exists
           8       No space in file directory
.subsection 'RESERVE:  Obtaining Exclusive File Control'
.ix 'obtaining' 'exclusive file control'
.ix 'file' 'obtaining exclusive control'
   RESERVE  id-l[,MODE=WAIT]
              (0)


.us Purpose:

Obtain exclusive control of a file which is attached with
MODE=SHARE.

.us Operands:

   id-l           file identifier

   MODE=WAIT      If exclusive control cannot be immediately obtained,
                  the program waits until control can be obtained.

.us Returns:

   (15) = 0       Operation started.

.us Returns from WAIT:

   (15) = 0       Exclusive control obtained.
          4       Exclusive control not immediately available.
          8       WRITE access to this file prohibited.
.subsection 'RELEASE:  Relinquish Exclusive File Control'
.ix 'relinquish exclusive file control'
.ix 'file' 'relinquish exclusive control'
   RELEASE  id-l
              (0)

.us Purpose:

Relinquishes exclusive control previously obtained by RESERVE.

.us Operands:

   id-l            file identifier

.us Returns:

   (15) = 0

.us Returns from WAIT:

   (15) = 0
.section 'SUZAN Path Input/Output'
.ix 'SUZAN path input/output'
.subsection 'ATTACH (4):  Creating and Opening a SUZAN Path'
.ix 'ATTACH'
.ix 'SUZAN path input/output' 'creating and opening'
   ATTACH  4,location-la,length-la[,return-la][,MODE=([WAIT][,CONTROL])]
           (0)   (1)       (15)       (14)

.us Purpose:

Requests the creation and opening of a SUZAN path.
For further information on SUZAN/3081, see the User's Guide to
SVCCOM.  (SVCCOM is the development system for SUZAN/3081.)

.us Operands:

   location-la       Location of the area containing the path tags and
                     password.  Area is 20 bytes long and contains the
                     8-byte identifier for your side of the path,
                     the 8-byte identifier for the other side of the path,
                     and the 4-byte password for the path.
                     The two identifiers may not be the same nor
                     may they begin with hexidecimal 255 (X'FF').

   length-la         1st 16-bits - number of seconds to wait before
                                   TIME-OUT (600 maximum) or zero.
                                   If TIME-OUT is specified, MODE=WAIT
                                   must also be specified.
                     2nd 16-bits - length of buffer to be allocated
                                   by the system for the path.  This
                                   length must be at least as large
                                   as the longest transaction to be
                                   received by the user (maximum 8192).

   return-la         Location of a 9-byte area where information is
                     placed if there is a path name conflict (as defined
                     in the SUZAN documentation).
                     Byte 1 contains the duplicate-path-names flags from
                     the PATHMFL field of the PATH block
                     Bytes 2-9 contain the jobname of the conflicting
                     path.

   MODE=WAIT         The program waits until a path device is available
                     and the other side of the path has been opened.
                     If the timeout value is zero, the program waits
                     indefinitely for the path to be completed.  If
                     the time interval is not zero and the time interval
                     expires before the path can be opened, the return
                     code in register 15 indicates the status of the path.

   MODE=CONTROL      You request control of the path.

.us Returns:

   (15) = 0          Operation begun.
         -4          Too many devices attached.
        -12          ORVYL-SUZAN path interface not available.
    (0) =            32-bit path identifier

The path identifier is valid only when register 15 is 0.

.us Returns from WAIT:

   (15) = 0         Attach completed.  (Path identifier valid)
         -8         No path device available.  (Path identifier no longer
                                               valid; path not attached.)
         16         Other side of path not open. (Path identifier valid)

The attention exit for a PATH device is entered
whenever any activity (for example, partner close, new transaction,
discretionary post) is noted.
.subsection 'READ:  Receiving a Message Using a SUZAN Path'
..ix 'SUZAN path input/output' 'receiving a message'
   READ  id-l,location-la,length-la[,MODE=([WAIT][,TRUNCATE])]
           (0)    (1)       (15)

.us Purpose:

Reads a message from a SUZAN path.

.us Operands:

   id-l             path identifier

   location-la      Location of the area to receive the message

   length-la        1st 16-bits - number of seconds to wait before
                                  TIME-OUT (600 maximum) or zero
                    2nd 16-bits - length of the area.  Maximum size
                                  is 8192 bytes.  0 is invalid.

   MODE=WAIT        The program waits until the other side of the path
                    has been opened and a message is received.  If the
                    timeout value is zero, the program waits indefinitely
                    for a message to be received.  Otherwise, if the time
                    interval expires before a message is received, the
                    return code in register 15 indicates the status of
                    the path.

   MODE=TRUNCATE    If the message to be received is larger than the
                    specified area, the remainder is ignored.  If
                    MODE=TRUNCATE is not specified, as much of the
                    message as fits is placed into the area, and the
                    remainder is kept for subsequent READ operations.

.us Returns:

   (15) = 0         Operation begun.
        -12         ORVYL-SUZAN path interface not available.

.us Returns from WAIT:

   (15) = 0         Successful completion.
         -4         Other side of path has been closed. (Not MODE=CONTROL)
          4         No messages received.
         12         End-of-file message received. (MODE=CONTROL only)
         16         Other side of path not yet open.
    (1) =           Number of bytes read. (register 15 = 0 only)
   (14) =           Number of bytes not read. (register 15 = 0 only)
                    Valid even for MODE=TRUNCATE

Core storage in ORVYL is divided into pages of 4096 bytes
each.
A buffer area may not cross more than one page boundary.
A buffer of 4096 bytes or less may begin on any byte; a
buffer of 6144 bytes may begin as much as 2048 bytes from the
beginning of a page; and an 8192-byte buffer must begin on a
page boundary.
For maximum efficiency buffers of 4096 bytes or less should
reside on a single page.
.subsection 'WRITE:  Sending a Message Using a SUZAN Path'
.ix 'SUZAN path input/output' 'sending a message'
   WRITE   id-l,location-la,length-la[,MODE=WAIT]
             (0)    (1)       (15)

.us Purpose:

Writes a message across a SUZAN path.

.us Operands:

   id-l             path identifier

   location-la      location of the area containing the message

   length-la        1st 16-bits - number of seconds to wait before
                                  TIME-OUT (600 maximum) or zero
                    2nd 16-bits - length of the area.  Maximum size
                                  is 8192 bytes.  0 is invalid.

   MODE=WAIT        The program waits until the other side of the path
                    the other side's buffer.  If the timeout value specified
                    is zero, the program waits indefinitely for the
                    message to be sent.  Otherwise, if the interval
                    expires before the message can be sent, the return
                    code in register 15 indicates the status of the path.

.us Returns:

   (15) = 0         Operation begun.
        -12         ORVYL-SUZAN path interface not available.

.us Returns from WAIT:

   (15) = 0         Successful completion.
         -4         Other side of path has been closed.
          8         Other side's buffer is full, message not sent.
         16         Other side has not yet opened.

Core storage in ORVYL is divided into pages of 4096 bytes
each.
A buffer area may not cross more than one page boundary.
A buffer of 4096 bytes or less may begin on any byte; a
buffer of 6144 bytes may begin as much as 2048 bytes from the
beginning of a page; and an 8192-byte buffer must begin on a
page boundary.
For maximum efficiency buffers of 4096 bytes or less should
reside on a single page.
.section 'User Program Control'
.ix 'user programs' 'control'
.subsection 'COMMAND:  Executing a Subsystem Command'
.ix 'executing a subsystem command'
.ix 'Command' 'executing a subsystem command'
.ix 'user programs' 'executing subsystem command'
.ix 'subsystem command - executing'
   COMMAND  code-la,location-la,length-la[,MODE=(WYLBUR,NOCLP)]
              (0)       (1)       (15)

.us Purpose:

Passes a command to the ORVYL CLP for
.ix 'CLP'
execution.
The MODE=WYLBUR option also allows passing of the command to
WYLBUR or other subsystems for execution.
The MODE=NOCLP option blocks command processing by the ORVYL
.ix 'NOCLP'
Command Language Processor (CLP).

.us Operands:

   code-la          0         the command has been typed at the
                              terminal.
                    non-zero  the command has not been typed at the
                              terminal.

   location-la      location of the area containing the command

   length-la        length of the area (maximum is 133)

.us Returns:

   (15) = 0         The command was executed.
          4         An error was detected and a message has been typed.
                    If code-la was set as not typed, the command
                    was echoed as a part of the error diagnostic.
          8         Command passed was the name of a subsystem.  Control
                    was not passed to the subsystem.  Use WRITE,MODE=EDIT
                    or COMMAND,MODE=WYLBUR to pass control to the
                    subsystem.

Since there are no means of reporting changes in the WYLBUR
active file to your program when using the COMMAND macro,
WRITE,MODE=EDIT should be used whenever the program requires
notification of changes to the active file.
.subsection 'EXIT:  Returning Control to the Command Language Processor'
.ix 'returning control to CLP'
.ix 'CLP'
.ix 'EXIT'
.ix 'user programs' 'returning control to CLP'
   EXIT

.us Purpose:

Returns control from your program to the ORVYL Command Language
Processor (CLP) and clears the contents of user memory.

.us Returns:

Does not return to your program.
.subsection 'PAUSE:  User-Initiated Session Break'
.ix 'user-initiated session break'
.ix 'session break' 'user-initiated'
.ix 'PAUSE'
.ix 'session break' 'PAUSE'
   PAUSE

.us Purpose:

Initiates a session break.
If, during the session break, you enter a GO command,
.ix 'Command' 'GO'
.ix 'PAUSE' 'GO'
control returns to the instruction immediately following
the PAUSE.
Entering the ATTN command causes entry to your attention
.ix 'Command' 'ATTN'
.ix 'PAUSE' 'ATTN'
.ix 'ATTN' 'session break'
.ix 'session break' 'ATTN'
exit routine.
The condition code and registers are preserved when the PAUSE
macro is issued.
All, however, may be changed by you during the session
break.  In addition, you may specify the address where execution
is to resume.
.subsection 'PANIC:  Program or System Initiated Session Break'
.ix 'PANIC'
.ix 'program' 'initiated session break'
.ix 'system initiated session break'
.ix 'session break' 'system initiated'
.ix 'session break' 'program initiated'
.ix 'session break' 'PANIC'
   PANIC  code-la
            (0)

.us Purpose:

Used when an error condition is detected by your program.
PANIC causes a session break, unless a PANIC exit routine has
been specified by you.

.us Operands:

   code-la          15-bit code defined by your program describing the error

.us Returns:

No registers are changed, unless you did so during the
session break.
You may modify the address where execution resumes.

A PANIC exit routine, if present, may cause resumption of main
program execution at some point other than immediately after the
PANIC macro call and may change register values.
.subsection 'SET (0-2):  Address Space Management'
.ix 'address space management'
   SET  code-la,location-la,length-la
          (0)       (1)       (15)

.us Purpose:

Advises the supervisor of the areas of the program address space
which
       - will be needed soon.
       - are no longer needed.
       - not needed immediately, but still of use.

.us Operands:

   location-la      location of an area of core storage

   length-la        length of the core storage area.  For code 0
                    the maximum is 16K (16384), there is no limit
                    for codes 1 or 2.

   code-la          code = 0  The program intends to reference the
                              specified area soon.
                           1  The contents of the specified area are
                              no longer required by the program.
                           2  The program does not intend to reference
                              the specified area immediately.
                    Note:     The supervisor manages storage in pages
                              of 4096 bytes each.  If a page contains
                              any part of the area specified in the SET
                              macro, the request applies to the entire page.

.us Returns:

   (15) = 0       Successful completion.
          4       Unsuccessful due to insufficient pages.  (code
                  0 only)
.subsection 'SET (3-4):  Setting the Time Interval'
.ix 'setting' 'time interval'
.ix 'time' 'interval' 'setting'
   SET  code-la[,interval-la]
          (0)        (1)

.us Purpose:

Sets your real or compute time interval timer.
The timer is continuously decremented in either real or compute
time.
Your timer exit routine is entered when the timer reads
zero.
The timer continues to decrement until reset.

.us Operands:

   code-la          code = 3  real time interval
                           4  compute time interval

   interval-la      The time interval specified in units of 26 microseconds,
                    where a unit is equivalent to 1/38400 seconds.  An
                    internal specification of zero (0) cancels any
                    previously specified interval.

.us Returns:

  (15) =            Any time remaining in the previous interval.
.ix 'establish' 'program exit routines'
.subsection 'SET (5-9):  Establishing Program Exit Routines'
.ix 'program' 'exit routine' 'establishing'
   SET  code-la[,routine-la][,id-la][,user-info-la]
          (0)       (1)        (15)    (14)

.us Purpose:

Establishes the entry point of the specified exit routine.

.us Operands:

   code-la          code = 5  set timer exit routine
                           6  set SVC exit routine
                           7  set PANIC exit routine
                           8  set ATTN exit routine for an I/O device
                           9  set WAIT exit routine for an I/O device

   routine-la       entry point of the routine or zero to disable exit
                    routine.

   id-la            the device identifier for codes 8 and 9.
                    Note:  expressed as "la", not "l".

   user-info-la     any value specified by the program.  Upon exit
                    routine entry, this value is placed in register 14.
                    This parameter may be used to point to a work area
                    required by the exit routine.

.us Returns:

  (15) =            Previous exit routine.

   (14) =           Previous user information.
.subsection 'SET (10):  Resuming Program Execution From an EXIT Routine'
.ix 'resuming program execution from an exit routine'
.ix 'program' 'exit routine' 'resuming program execution'
   SET  10[,area-la]
         (0)  (1)

.us Purpose:

Issued by an exit routine, relinquishes control so that program
execution may resume.  Returns control to the point of
interruption.  The condition code, mask byte, and registers are
preserved unless you modify the supervisor save area.

.us Operands:

   area-la          Address of a modified save area image obtained using
                    a SENSE 15 macro within the exit routine.  If none
                    is given, the supervisor area saved on entry to the
                    exit routine is used to resume execution of the
                    main code.

.us Returns:

Execution resumes at location indicated by the PSW address
contained in the specified area.
.subsection 'SET (11):  Setting the Mask Byte'
.ix 'setting' 'the mask byte'
   SET  11[,mask-la]
         (0)  (1)

.us Purpose:

Sets the mask byte to enable or inhibit entry into exit routines.
.ix 'program' 'exit routine' 'mask byte'

.us Operands:

   mask-la          mask byte, logical combination of:
                       X'80' = enable Timer exit
                       X'40' = enable ATTN exit
                       X'20' = enable WAIT exit
                       X'10' = enable PANIC exit

.us Returns:

  (15) =            Previous mask byte.
.subsection 'SET (12):  Setting Order-of-Service Priority'
.ix 'setting' 'order-of-service priority'
  SET  12,priority-la
         (0)  (1)

.us Purpose:

Specifies order-of-service priority.

.us Operands:

   priority-la      priority from 0 to 15, higher numbers are served
                    first.  Initial priority is 15.

.us Returns:

  (15) =            previous priority
.subsection 'SET (13):  Modifying the Contents of the Communications Area'
.ix 'modifying' 'contents of communications area'
   SET  13,disp-la,length-la,location-la
         (0) (1)     (15)        (14)

.us Purpose:

Modifies the user or subprocessor communications area.
This 16-byte area is separate from any user program space and may
be used by the program in any manner.
Each user program is assigned an individual communications area;
each subprocessor maintains a single communications area for all
users of that subprocessor.

.us Operands:

   disp-la          Displacement of the first byte in the area to be
                    written.  (Displacement from 0 through 15)

   length-la        number of bytes to be written.

   location-la      location of the data.

.us Returns:

No registers changed.
.subsection 'SET (14):  Reserving Additional Virtual Memory'
.ix 'reserving' 'additional virtual memory'
.ix 'virtual memory' 'reserving'
.ix 'memory' 'virtual' 'reserving additional'
   SET  14,minlen-la,maxlen-la
         (0)  (1)      (15)

.us Purpose:

Reserves memory for program work space.

.us Operands:

   minlen-la         minimum additional amount of memory (that is, that
                     amount absolutely required for the work space).

   maxlen-la         amount of additional memory desired.

                     If maxlen=0, the maximum amount of memory
                     available to the program is reserved.

.us Returns:

   (15) = 0          Successful completion.

          4          Insufficient memory to satisfy request.

    (1) =            Initial address of additional reserved memory.

    (0) =            Amount of memory reserved.
.subsection 'SET (15):  Releasing Virtual Memory'
.ix 'releasing virtual memory'
.ix 'virtual memory' 'releasing'
.ix 'memory' 'virtual' 'releasing'
   SET  15,location-la,length-la
         (0)   (1)       (15)

.us Purpose:

Releases memory from the program work space.

.us Operands:

   location-la       location of memory to be released

   length-la         amount of memory to be released

                     SET 15 manages storage in pages of 4096 bytes each.
                     If a page contains any part of the area described
                     in the SET macro, then the request releases the
                     entire page from the program work space.

.us Returns:

   (15) = 0          Successful completion.
.subsection 'SET (16):  Reserving Virtual Memory by Specific Address'
.ix 'reserving' 'virtual memory by specific address'
.ix 'virtual memory' 'reserving by specific address'
.ix 'memory' 'virtual' 'reserving by specific address'
   SET  16,location-la,length-la
         (0)   (1)       (15)

.us Purpose:

Reserves memory for the program work space at a specific address
within the limits of the work space (see the description of the
SENSE 2 macro).  An attempt to reserve pages not contained in the
proper range or to reserve pages already reserved is a program
error.

.us Operands:

   location-la       location of memory to be reserved

   length-la         amount of memory to be reserved

.us Returns:

   (15) = 0          Successful completion.

          4          Insufficient memory to satisfy request.

    (1) =            Location of memory reserved.

    (0) =            Amount of memory reserved.
.subsection 'SET (17):  Enabling Program Event Recording'
.ix 'enabling' 'program event recording'
.ix 'program' 'event recording' 'enabling'
   SET  17,area-la
         (0) (1)

.us Purpose:

Enables program event recording and allows specification of those
events that cause an interruption.
To disable program event recording, specify a
PER control block with a zero (0) event mask or a zero value in
register 1.

.us Operands:

   area-la         location of the 12-byte area that contains a new
                   PER control block (see section &per for a definition
                   of the PER control block.)

.us Returns:

   (15) = 0        Successful completion.

          4        Request rejected; you issued a SET EVENT command
.ix 'Command' 'SET EVENT'
                   at the terminal.
.subsection 'SET (18):  Enabling Program Monitoring'
.ix 'enabling' 'program monitoring'
.ix 'program' 'monitoring' 'enabling'
   SET  18,area-la
         (0) (1)

.us Purpose:

Enables monitoring and allows specification of the monitor mask.
Monitoring may be disabled by specifying a zero (0) monitor mask
or a zero value in register 1.

.us Operands:

   area-la         location of a 4-byte area that contains the
                   monitor control block (see section &per for a
                   definition of the monitor control block.)

.us Returns:

   (15) = 0        Successful completion.

          4        Request rejected; you issued a SET MONITOR command
                   at the terminal.
.subsection 'SET (19):  Protecting Memory Areas'
.ix 'protecting memory areas'
.ix 'memory' 'protecting areas'
   SET  19,location-la,length-la
         (0)   (1)       (15)

.us Purpose:

Precludes modification of the contents of a specified area in
memory by the program or by input/output operations.
The memory area to be specified must be reserved and defined.

.us Operands:

   location-la     location of area to be protected

   length-la       amount of memory to be protected

.us Returns:

   (15) = 0        Successful completion
          4        Page not defined

The supervisor manages storage in pages of 4096 bytes each.
.ix 'supervisor storage'
If a page contains any part of the area specified in the SET
macro, the request applies to the entire page.
If any part of the area is not defined the protection operation
is aborted without processing any succeeding pages.
.subsection 'SET (20):  Cancelling Memory Area Protection'
.ix 'memory' 'cancelling area protection'
   SET  20,location-la,length-la
         (0)   (1)       (15)

.us Purpose:

Cancels memory protection enabled by SET 19.

.us Operands:

   location-la     location of protected memory

   length-la       amount of protected memory

.us Returns:

   (15) = 0        Successful completion
          4        Page not defined

The supervisor manages storage in pages of 4096 bytes each.
If a page contains any part of the area specified in the SET
macro, the request applies to the entire page.
If any part of the area is not defined, the protection operation
is aborted without processing any succeeding pages.
.subsection 'SET (21):  Synchronizing Cooperating ORVYL Programs (ENQUEUE)'
.ix 'synchronizing cooperating programs (ENQUEUE)'
.ix 'ENQUEUE'
   SET  21,location-la,length-la[,MODE=TEST]
         (0)   (1)       (15)

.us Purpose:

Provides a mechanism for obtaining exclusive control of a logical
resource.
No two programs may simultaneously use the same logical resource
name.
At your option, the program may be suspended until the
required logical resource is available.

.us Operands:

   location-la      Location of an area containing a logical
                    resource name.

   length-la        Length of the name.  Maximum is 128 bytes.

.us Returns:

  (15) =  0         Logical resource has been obtained for exclusive
                    use.
           4        Logical resource not immediately available.  (Only
                    occurs if MODE=TEST is specified.)

    (1) =           Reserved for future use.

No specific format for resource names is defined or
enforced.
Cooperating users must define their own conventions.
Only one logical resource at a time may be enqueued by each
terminal.
.subsection 'SET (22):  Synchronizing Cooperating ORVYL Programs (DEQUEUE)'
.ix 'synchronizing cooperating programs (DEQUEUE)'
.ix 'DEQUEUE'
   SET   22,id-la
          (0) (1)

.us Purpose:

Releases exclusive control over a previously enqueued resource.

.us Operands:

   id-la            Reserved for future use.
.subsection 'SET (23):  Setting the Memory Initialization Value'
.ix 'setting' 'memory initialization value'
.ix 'memory' 'setting initialization value'
   SET  23,value-la
         (0) (1)

.us Purpose:

Sets the 1-byte value used to clear all newly defined virtual
memory pages.

.us Operands:

   value-la         value between 0 and 255
.subsection 'WAIT (0):  Suspending Program Execution While Awaiting Interrupts'
.ix 'suspending program execution while awaiting interrupts'
.ix 'program' 'suspending execution while awaiting interrupts'
   WAIT  0
         (0)

.us Purpose:

Allows a program to suspend execution while awaiting the
expiration of a time interval, ATTN, or I/O completion.

.us Returns:

Control is never passed to the instruction following WAIT 0.
Your program should define the timer, ATTN, and/or WAIT exit
routine(s) which are to receive control.
The exit routine is responsible for altering the saved program
address if execution is to resume at some other point.
.section 'User Program Information'
.ix 'user programs' 'obtaining information'
.subsection 'SENSE (0):  Reserved Address Space Status'
.ix 'reserved address space status'
   SENSE  0,location-la
          (0)   (1)

.us Purpose:

Reports on the status of the specified location in the program
reserved address space.

.us Operands:

   location-la    location to be tested

.us Returns:

   (15) = 0       The specified address is within the program reserved
                  address space and has been defined.

          4       The specified address is within the program reserved
                  address space but has not been defined.

          8       The specified address is not within the program reserved
                  address space.

    (0) =         Miscellaneous status information.  (R15 = 0 only)

                  Bit:

                  0-29        Reserved.
                  30          Protected page.
                  31          Presently in core.

The supervisor manages storage in pages of 4096 bytes each.
Thus the status reported refers to the entire page in which the
specified location resides.
.subsection 'SENSE (1):  Work Area Management Statistics'
.ix 'work area management statistics'
   SENSE    1
            (0)

.us Purpose:

Obtains program work area management statistics.

.us Returns:

   (15) =         Amount of memory available but not yet reserved for
                  program work area.

    (1) =         Total amount of memory available for program work area.
.subsection 'SENSE (2):  Virtual Memory Address Space Limits'
.ix 'virtual memory' 'address space limits'
.ix 'memory' 'virtual' 'address space limits'
   SENSE    2
            (0)

.us Purpose:

Describes the memory address range from which program work area
is reserved.

.us Returns:

   (15) =         Length of the address space.

    (1) =         Start of the address space.
.subsection 'SENSE (3):  Current Time and Date'
.ix 'time' 'current'
.ix 'date - current'
   SENSE  3
          (0)

.us Purpose:

Reports today's date and the current clock time.

.us Returns:

   (15) =         Year, month, and day in the format:  YYYYMMDD.

    (1) =         Time of day in 26 micro-second units.  This unit is
                  equivalent to 1/38400 seconds.
.subsection 'SENSE (4):  Elapsed Time'
.ix 'elapsed time'
.ix 'time' 'elapsed'
   SENSE  4
          (0)

.us Purpose:

Reports real and compute time since the beginning of the current
terminal session.

.us Returns:

   (15) =         Elapsed ORVYL compute time since the beginning of
                  the terminal session in 26 micro-second units.
                  This unit is equivalent to 1/38400 seconds.


    (1) =         Elapsed real time since the beginning of the
                  terminal session in 26 micro-second units.  This
                  unit is equivalent to 1/38400 seconds.
.subsection 'SENSE (5):  Time Interval Currently in Effect'
.ix 'time' 'interval' 'currently in effect'
   SENSE  5
          (0)

.us Purpose:

Reports the amount of time remaining in the current time interval
as established by you.

.us Returns:

   (15) =         Time remaining in the current time interval.  Time is
                  reported in 26 micro-second units, where a single
                  unit is equal to 1/38400 seconds.
.subsection 'SENSE (6):  Mask Byte'
.ix 'mask byte'
   SENSE  6
          (0)

.us Purpose:

Detects the mask byte.

.us Returns:

   (15) =         Mask byte, logical combination of:
                     X'80' = Timer exit enabled
                     X'40' = ATTN exit enabled
                     X'20' = WAIT exit enabled
                     x'10' = PANIC exit enabled
.subsection 'SENSE (7):  Program Service Priority'
.ix 'program' 'service priority'
   SENSE  7
          (0)

.us Purpose:

Detects the service priority established for the program.

.us Returns:

   (15) =         Priority (0-15).
.subsection 'SENSE (8):  User Name, Account, and Terminal'
.ix 'user name, account, terminal'
   SENSE  8,location-la
          (0)   (1)

.us Purpose:

Reports the current user, group, and terminal identifier.

.us Operands:

   location-la      27-byte area to receive data.

.us Returns:

No registers changed.

AREA:

  bytes  0-2 - current user (uuu)
           3 - $
         4-7 - group and subgroup (ggrr)
        8-10 - terminal identifier (ann)
       11-26 - user session identification, if provided
.subsection 'SENSE (9-14):  Reporting Program Exit Routines, Completion Test'
.ix 'reporting' 'program exit routines'
.ix 'reporting' 'exit routines, completion test'
.ix 'program' 'exit routine' 'reporting'
.ix 'program' 'exit routine' 'completion test'
   SENSE  code-la[,id-la]
            (0)     (1)

.us Purpose:

Reports the entry point of the specified exit routine location or
completion status of a specific I/O device.

.us Operands:

   code-la       code =  9  Timer exit
                        10  SVC exit
                        11  PANIC exit
                        12  ATTN exit for a specific device
                        13  WAIT exit for a specific device
                        14  Test for I/O completion on a specific device

   id-la         For codes 12, 13 and 14, the device identifier.

.us Returns:

   code = 9-13   (15) =    Location of exit routine or zero if none
                           established.

                 (14) =    User information specified when the exit
                           routine was established.

   code = 14     (15) = 0  Operation completed on device.
                        4  Operation in progress on device.
.subsection 'SENSE (15):  PSW and GPR Save Area'
.ix 'PSW and GPR save area'
.ix 'GPR and PSW save area'
   SENSE  15,area-la
           (0) (1)

.us Purpose:

Obtains the save area after a program interrupt.
The exit routine can modify the copy of the save area received
and use the modified copy to alter register contents or
instruction execution sequence of main program when control is
relinquished by a SET 10 macro.  (See 5.13.8 and 5.5.)

.us Operands:

   area-la       Location of the 72-byte area which will contain the
                 program status word and general program registers.

.us Returns:

No registers changed.
.subsection 'SENSE (16):  Program Exception Address'
.ix 'program' 'exception address'
   SENSE  16
           (0)

.us Purpose:

Employed after an address PANIC, SENSE returns the address at
.ix 'PANIC'
which the PANIC exception occurred.

.us Returns:

   (15) =        The PANIC exception address.
.subsection 'SENSE (17):  Reading the Communications Area'
.ix 'reading' 'the communications area'
   SENSE  17,disp-la,length-la,location-la
           (0) (1)     (15)        (14)

.us Purpose:

Reads the 16-byte program (user or subprocessor) communications
area.

.us Operands:

   disp-la       Displacement of the first byte to be read (0-15).

   length-la     Number of bytes to be read.

   location-la   Location of the area which will receive the data.

.us Returns:

No registers change.
.subsection 'SENSE (18):  Identifying the Command Used to Call the Program'
.ix 'identifying command used to call program'
.ix 'Command' 'identifying command used to call program'
   SENSE  18,location-la,length-la
           (0)   (1)       (15)

.us Purpose:

Returns the command string which initiated execution.

.us Operands:

   location-la      Location of the area which will contain the text.

   length-la        Length of the area.  (If the specified area contains
                    less than 133 bytes, some data may be lost.)

.us Returns:

    (15) = 0        The command was typed.
           4        The command was not typed.

     (1) =          Length of the command.
.subsection 'SENSE (19):  Passing Command Parameter Strings'
.ix 'passing' 'command parameter strings'
.ix 'Command' 'passing' 'command parameter strings'
   SENSE  19,location-la,length-la
           (0)   (1)       (15)

.us Purpose:

Returns any parameter string specified with the command that
initiated execution.

.us Operands:

   location-la      location of the area which is to contain the text.

   length-la        length of the area.  (If the specified area is
                    less than 133 bytes, some data may be lost.)

.us Returns:

   (15) = 0         Text was typed.
          4         Text was not typed.

    (1) =           Length of the text string.
.subsection 'SENSE (21):  Obtaining the Program Event Recording Control Block'
.ix 'obtaining' 'program event recording control block'
.ix 'program' 'event recording' 'obtaining control block'
   SENSE  21,location-la
           (0)   (1)

.us Purpose:

Obtains the 12-byte PER control block.  If the PER event mask is
zero (0), then PER is not enabled.

.us Operands:

   location-la      location of the 12-byte area which is to contain
                    the PER control block

.us Returns:

   (15) = 0         PER not enabled or enabled by your program.
          4         PER enabled with the SET EVENT command.
.subsection 'SENSE (22):  Obtaining the Monitor Mask'
.ix 'obtaining' 'monitor mask'
   SENSE  22,location-la
           (0)   (1)

.us Purpose:

Obtains the monitor mask.

.us Operands:

   location-la     location of the 4-byte area which is to contain
                   the monitor mask

.us Returns:

   (15) = 0        Monitoring not enabled or enabled by your program.
          4        Monitoring enabled by the SET MONITOR command.
.ix 'Command' 'SET MONITOR'
.subsection 'SENSE (23):  Reporting File System Information'
.ix 'reporting' 'file system information'
   SENSE  23
           (0)

.us Purpose:

Reports file system availability and space information.

.us Returns:

   (15) =  0       File system currently available.
           4       File system unavailable.

   (14) =          Maximum allocation allowed any account.

    (0) =          File blocks available.

    (1) =          Total blocks in the file system.
.subsection 'SENSE (24):  Sensing the Memory Initialization Value'
.ix 'memory' 'sensing initialization value'
.ix 'sensing' 'memory initialization value'
   SENSE   24
            (0)

.us Purpose:

Senses the memory initialization value (See SET 23).

.us Returns:

   (15) =          1-byte value used to clear all new virtual memory
                   pages as they are defined.
.subsection 'SENSE (25):  ORVYL CPU Time'
.ix 'ORVYL CPU time'
.ix 'CPU time'
.ix 'time' 'ORVYL CPU'
   SENSE   25
            (0)

.us Purpose:

Reports ORVYL CPU time (see SENSE 4) and the ORVYL I/O count.

.us Returns:

    (0) =          I/O count

    (1) =          CPU time consumed under ORVYL in timer units.

   (14) =          Elapsed time of session in timer units

   (15) =          Virtual memory charge (page-seconds)

A timer unit is equal to 1/38400 seconds (26 microseconds).
.subsection 'SENSE (26):  Obtaining the Current Time Block'
.ix 'obtaining' 'current time block'
.ix 'time' 'obtaining current block'
   SENSE   26
            (0)

.us Purpose:

Reports the time block currently in effect.

.us Returns:

   (15) =  0       Successful completion

   (1)  =          Time block

                   0 = Day
                   1 = Evening
                   2 = Night
                   3 = Weekend
.subsection 'SENSE (27):  Obtaining the JES Display Buffers'
.ix 'obtaining' 'JES display buffers'
   SENSE  27,location-la,length-la,code-la
           (0)   (1)       (15)     (14)

.us Purpose:

Returns various JES display buffers.

.us Operands:

   location-la     Location of the area which will receive the JES
                   display buffer.

   length-la       Length of the area.  (If the area is not long enough,
                   JES data is lost.)

   code-la         code indicating JES buffer desired.
                      0   ??? status display
                      1   ??? status display

.us Returns:

   (15) = 0        Successful completion.
          4        Invalid option code.
          8        JES information truncated.

    (1) =          Length of data transferred.
.pa
.chapter 'URAM'
.section 'URAM Description'
.ix 'URAM' 'description'
URAM (Unified Record Access Method) performs several functions and
provides many services:
.point set b b b
.point begin
program to I/O interface
.point
device independence
.point
record level I/O
.point
multiple record formats and conversion
.point
buffered I/O
.point
standardized I/O
.point end
.section 'The ASSIGN Command'
.sr assign &pubSWprt
.ix 'ASSIGN'
.ix 'Command' 'ASSIGN'
The ASSIGN command is available to those languages employing URAM and
.ix 'URAM' 'ASSIGN'
is written in the general form:

   ASSIGN ddname TO device-type {INPUT|OUTPUT|UPDATE} [options]

where ddname is a 1-8 character string (initial alpha) and device type
may be COMMAND, TERMINAL, NULL, FILE, or a range in your WYLBUR active
file.  COMMAND sends a command to ORVYL for execution, TERMINAL
assigns input or output to the terminal, NULL causes all input or
output to be ignored, and FILE followed by a valid ORVYL filename
identifies an ORVYL file for input or output.  Specifying a valid
WYLBUR line range causes input or output to be directed to your
WYLBUR active file.
.subsection 'ASSIGN Options'
.ix 'ASSIGN' 'options'
   OLD, NEW, MOD, or SHR (or SHARE)
   RECFM=F, E, VT, or VBS
   LRECL = logical record length
   BLKSIZE = blocking factor
   DELTA = WYLBUR delta
   KEYED ( for ORVYL files only)

RECFM=F denotes fixed records

RECFM=E identifies WYLBUR EDIT format

RECFM=VBS is variable blocked spanned records

RECFM=VT marks variable text records

VBS provides fastest record access;
however, if VS is used for an ORVYL file, a GET issued for that file
includes extraneous characters.  For ORVYL GET access, RECFM=E
or RECFM=F are recommended.  DELTA may be used when assigning a WYLBUR
line range only.

If you do not assign a file named in your program, the program
interrupts execution at the point where the file is referenced and
requests that the file be assigned.  The effect of an ASSIGN command
extends only until program execution has terminated.  For this
reason, ASSIGN by PARM card is usually recommended.
.section 'URAM II MACROS'
.ix 'URAM' 'macros'
.subsection 'Initialize URAM'
.ix 'URAM' 'initialize'
   UINIT       resvm-l
                  (0)

.us Purpose:

Initialize URAM, set up memory management, attach master
terminal, and other URAM housekeeping chores.
This macro must be executed prior to the execution of all other
URAM macros.

.us Operands:

  resvm-l          Amount of core URAM reserves for itself.  The
                   remainder of core is used by your program.  URAM
                   dynamically allocates ORVYL memory pages.  If the
                   amount of memory is not sufficient, URAM attempts
                   to allocate more memory for itself.

.us Returns:

   (15) =          amount of memory left for you to reserve

    (0)  =         length of memory until URAM memory

    (1)  =         start of memory
.subsection 'Open a URAM File or Device'
.ix 'URAM' 'macros'
.ix 'open a URAM file or device'
.ix 'URAM' 'open a file or device'
   OPEN       FCB-l,opnd-la
               (1)   (15)

.us Purpose:

Open the file or device.  The parameters are merged into the FCB.
If necessary, an FCB is generated.  The device is attached and URAM
The device is attached and URAM initialization for the device
initialization for the device takes place.  If appropriate, buffer
allocation is done.  ASSIGN command parameters override the parameters
.ix 'Command' 'ASSIGN'
specified in the open parameter area.

.us Operands:

  FCB-l            FCB address.  This parameter is specified for those
                   devices for which an FCB has been generated by an
                   an ASSIGN command.

  opnd-la          open parameter area.  This area contains the device
                   parameters to be used in the open.  This area may
                   be generated using the OPNPARMS macros.  The open
                   parameter dsect may be generated with the OPND macro.

.us Returns:

   (15) =          error code

    (1) =          FCB address
.subsection 'Copy the OPND Dsect'
.ix 'URAM' 'macros'
.ix 'copy' 'the OPND dsect'
   OPND

.us Purpose:

Copy the Open Parameter Dsect into your program.

.us Operands: None.
.subsection 'Create an Open Paramater Area with Specified Parameters'
.ix 'creating' 'open parameter area with specified parameters'
.ix 'URAM' 'create open parameter area'
   OPNPARMS        NAME=,DEVICE=,IOTYPE=,
                   FILE=,FORMAT=,LENGTH=,VFORMAT=,VLENGTH=,
                   KEYED=,COMPRESSED=,LIBRARY=,MEMBER=,
                   DISP=,BLKSIZ=,VOLUME=,NOBUF=,
                   SRANGE=,ERANGE=,DELTA=,RANGE=,FCOL=,LCOL=,
                   PROMPT=,TIMEOUT=,PATH=,BUFFER=

.us Purpose:

Create an open parameter area with the parameters specified.
Only the NAME= and DEVICE= parameters must be specified.

.us Operands:

   NAME=            File name to be associated with this FCB.
                    (Data set name)

   DEVICE=          Device type
                        ORV - ORVYL file
                        ACT - WYLBUR Active file
                        COMD - Command file
                        TERM - Terminal
                        NULL - Null file
                        BUFFER - Buffer I/O
                        SUZAN - SUZAN path

   IOTYPE=          Direction of I/O.
                        IN - input
                        OUT - output
                        INOUT - update
                        UPDATE - update

   FILE=            Name of ORVYL file to be opened.

   FORMAT=          Actual record format:
                        F   - fixed length
                        VBS - variable length
                        E   - edit (WYLBUR pressed format)
                        VT  - variable text (WYLBUR format with
                              trailing blanks removed)
                        U - undefined

   LENGTH=          Actual record length

   VFORMAT=         Virtual record format:
                        F   - fixed length
                        VBS - variable length
                        E   - edit (WYLBUR pressed format)
                        VT  - variable text (WYLBUR format with
                              trailing blanks removed)
                        U - undefined

   VLENGTH=         Virtual record length

   DISP=            Disposition of the file
                        NEW - create a new output file
                        OLD - read from an existing file
                        ERASE - erase existing file; write to new
                                 file.
                        SHR - share
                        APPEND - append records to an existing
                                 file

   KEYED=YES        Specified in addition to FORMAT=VBS for INDEXED files.

   COMPRESSED=YES   File records in compressed form (valid for format=vbs
                    only)

   MINBUF=YES       Do not buffer I/O, this is a memory conservation
                    option.  It minimizes the amount of memory required
                    by URAM to do I/O.

   LIBRARY=YES      ORVYL PDS library file

   MEMBER=          ORVYL PDS member name

   SRANGE=          Start of range

   ERANGE=          End of range

   DELTA=           Sequential increment factor

   RANGE=           This specification used if the range is associative

   FCOL=            first column of start of associative range

   LCOL=            last column of start of associative range

   TIMEOUT=         Time out for GETS (in seconds).  Must be less than 500.

   VOLUME=          <volume name>; volume on which data set
                     resides.

   BLKSIZ=          block size; valid for O.S. files only.

   PROMPT=          Address of prompt location formated:
                      2 bytes blank, 2 bytes length (n), n bytes prompt

   PATH=            20 character SUZAN path identifier

   USERBUF=         Address of user specified buffer (BUFFER).

                    OPERANDS ARE EITHER NUMBERS OR STRINGS NOT ENCLOSED
                    IN QUOTES.
.subsection 'Close a URAM File or Device'
.ix 'URAM' 'macros'
.ix 'close a URAM file or device'
.ix 'URAM' 'close' 'a file or device'
   CLOSE      FCB-l
               (1)

.us Purpose:

Closes specified file or device.  If an output file, buffers are
written.  The buffers and FCB are freed.  The device is detached.

.us Operands:

   FCB-l             FCB address.

.us Returns:

   (15) =           error code
.subsection 'Read a Record from a URAM File or Device'
.ix 'reading' 'record from URAM file or device'
.ix 'URAM' 'reading from file or device'
   GET     buff-la,FCB-l,prompt-la,length-la[,MODE=PROMPT]
             (0)    (1)    (15)      (14)

.us Purpose:

Retrieves a record from the input file or device.
The record number (key) may be specified for direct access
devices.  A prompt may be specified for terminal devices.

.us Operands:

   buff-la          Buffer where record is to be placed, if zero.  A
                    buffer is supplied and the address is returned in
                    R1.  Another GET may overwrite this buffer.

   FCB-l            FCB address.

   recno-la         Record number of the desired record.  If zero, file
                    is treated as sequential.

   prompt-la        Prompt address.  The prompt location is formatted
                    as follows:

                          2 bytes timeout information
                          2 bytes prompt length (n)
                          n bytes prompt text.

   length-la        Length of record to get.  This parameter is used
                    only with undefined gets.

   MODE=PROMPT      Specifies that R15 points to a prompt area.

.us Returns:

   (15) =           error code

    (1) =           record address

    (0) =           record length
.subsection 'Write a Record to a URAM File or Device'
.ix 'URAM' 'macros'
.ix 'writing' 'record to URAM file or device'
.ix 'URAM' 'write record to file or device'
   PUT      buff-la,FCB-l,recno-la,length-la
              (0)    (1)    (15)     (14)


.us Purpose:

A record is written to the output file or device.
The record number (key) may be specified for direct access
devices.

.us Operands:

   FCB-l            FCB Address

   buff-la          location of record to be output

   recno-la         record number of record to be written

   length-la        Length of record to put.  This parameter is used
                    only with undefined gets.

.us Returns:

   (15) =           error code
.subsection 'Delete a Record from a URAM File'
.ix 'URAM' 'macros'
.ix 'deleting' 'record from URAM file'
.ix 'URAM' 'delete' 'record from file'
   DELETE      FCB-l,recno-la
                (1)    (15)

.us Purpose:

Delete a record from a URAM file.  The record with the specified
record number is deleted and its space freed.
If the record does not exist, no operation is performed.  This
operation is valid for update or output files only.

.us Operands:

   FCB-l            FCB-address

   recno-la         Record number of the record to be deleted
                    optional.

.us Returns:

   (15) =           error code
.subsection 'Obtain a Buffer for a Subsequent PUT'
.ix 'obtaining' 'buffer for subsequent PUT'
.ix 'URAM' 'obtain' 'buffer for subsequent PUT'
   GETPUTB   FCB-l
              (1)

.us Purpose:

A request for a buffer which will subsequently contain a
record to be written out.
The address is returned in register 1 and the length in register
0.
GETPUTB may be interpreted as a priming call to the write
routine, while PUT does the actual write.
This buffer is reused so GETPUTB calls must be separated by PUT
calls.
However, a GETPUTB call is not required for each PUT; for example,
writing out a preformatted logical record requires only a
PUT pointing to that record

.us Operands:

   FCB-l            FCB Address

.us Returns:

   (15) =           error code

    (1) =           address of buffer

    (0) =           length of buffer
.subsection 'Process ASSIGN Command Text'
.ix 'URAM' 'macros'
.ix 'process ASSIGN command text'
.ix 'URAM' 'process ASSIGN command text'
.ix 'ASSIGN' 'process command text'
   ASSIGN      strlen-la,,astring-la
                  (0)        (15)

.us Purpose:

To generate an FCB from the text of an ASSIGN command.
.ix 'Command' 'ASSIGN'
The ASSIGN command is documented in section &assign..
The parameters specified in the command text override those
specified by the OPEN.

.us Operands:

   strlen-la        Length of command text

   astring-la       Address of ASSIGN command text

.us Returns:

   (15) =           error code

    (1) =           FCB address
.subsection 'Copy the FCB dsect'
.ix 'copy' 'the FCB dsect'
.ix 'URAM' 'copy the FCB dsect'
   FCBD

.us Purpose:

Copy the File Control Block dsect into your program.
This dsect must be assembled into programs using the GET and PUT
macros.

.us Operands: None.
.subsection 'Obtain the Address of a Specified FCB'
.ix 'obtaining' 'list of FCBs'
.ix 'URAM' 'obtain' 'address of specified FCB'
   FUNC        FINDFCB,FCB-l,FCB=CHAR
                  (0)   (1)

.us Purpose:

Returns the address of the specified FCB.

.us Operands:

   FCB-l            Pointer to 8 character string containing FCB name.

   FCB=CHAR         FCB is specified as a character string.  Left
                    justified and padded with blanks.

.us Returns:

   (15) =           error code

    (1) =           FCB address
.subsection 'Obtain List of FCBs'
.ix 'URAM' 'obtain' 'list of FCBs'
   FUNC     FCBLIST
               (0)

.us Purpose:

Obtain a list of existing file control blocks (FCBs).
The list entries are 12 bytes long: 8 bytes FCB name, left
justified, padded with blanks.
4 bytes FCB address.
There may be empty (zeroed) entries in the FCB list.

.us Returns:

   (15) =           error code

    (0) =           number of entries in list (any entry may be zero)

    (1) =           FCB list address
.subsection 'Turn On or Suppress URAM Error Messages'
.ix 'turn on or suppress URAM error messages'
.ix 'URAM' 'turn on error messages'
.ix 'URAM' 'suppress error messages'
.ix 'suppress or turn on URAM error messages'
.ix 'error messages - URAM'
.ix 'URAM' 'error messages'
   FUNC        code
                 (0)

.us Purpose:

Turn on and off URAM printing of error messages.

.us Operands:

   code             operation code

                        Code                  Operation

                        ERROR         cause URAM to print error messages
                                      in addition to error codes returned.

                        NOERROR       suppress URAM error messages.

.us Returns:

  None
.subsection 'Obtain a Specific URAM Error Message'
.ix 'obtaining' 'specific URAM error message'
.ix 'URAM' 'obtain' 'specific error message'
   FUNC     ERRORTEXT,FCB-l,errorcode-la,[MODE=URAM]
                (0)    (1)      (15)

.us Purpose:

Return an appropriate error message text for the URAM error code
specified in R15.

.us Operands:

   FCB-l            address of FCB in which error occurred (if applicable)

   errorcode-la     URAM error code

   MODE=URAM        specifies that URAM print error message

.us Returns:

   (15) =           error code

    (0) =           message length

    (1) =           message text address
.subsection 'Clean Up Buffers'
.ix 'URAM' 'clean up buffers'
.ix 'buffer' 'clean up'
   FUNC     CLEAN,[FCB-l]
              (0)   (1)

.us Purpose:

FUNC CLEAN de-buffers files:  Output buffers are written out and
input buffers are cleared.  If you plan to modify your files
directly with ORVYL macros, you may use this macro to insure
proper buffering.  All files or a specific file may be specified.

.us Operands:

   FCB-l            denotes debuffering of the specific FCB

.us Returns:

   (15) =           error code
.subsection 'Close All Files and Free Unneeded URAM System Buffers'
.ix 'URAM' 'close' 'all files'
.ix 'URAM' 'free unneeded system buffers'
   FUNC     FREEPOOL
              (0)

.us Purpose:

Close all files and return unneeded URAM system buffers.

.us Returns:

   (15) =           error code
.subsection 'Obtain Memory'
.ix 'URAM' 'obtain' 'memory'
   FUNC     GETM,,length-la
              (0)     (15)

.us Purpose:

To obtain free storage for your program.
Core is allocated in multiples of 4K.
You are responsible for further refinements in user memory
management.

.us Operands:

   length-la        amount of storage requested in bytes.

.us Returns:

   (15) =           error codes

    (1) =           address of start of storage obtained.
.subsection 'Free Memory'
.ix 'URAM' 'free memory'
.ix 'free memory'
.ix 'memory' 'free - URAM'
   FUNC        FREEM,length-la,address-la
                 (0)   (15)       (14)

.us Purpose:

Return previously obtained free storage to URAM.

.us Operands:

   length-la         Length of storage to be returned.

   address-la        Address of the start of storage to be returned.

.us Returns:

   (15) =            error codes
.subsection 'Find a Member of a ORVYL PDS'
.ix 'find member of ORVYL PDS'
.ix 'URAM' 'find member of ORVYL PDS'
   FUNC        FIND,FCB-l,memb-la
                (0)  (1)   (15)

.us Purpose:

Find a member in a ORVYL PDS file by member name.
Succeeding GETs to the specified FCB get records from that
member.
Used with the include libraries of PLC, WATORV, etc.
Valid for input files only.

.us Operands:

   FCB-l            FCB address

   memb-la          Address of the 8 character member name, left
                    justified and padded with blanks if necessary.

.us Returns:

  (15) =           error code
.subsection 'Delete a Member of an ORVYL PDS'
.ix 'deleting' 'member of ORVYL PDS'
.ix 'URAM' 'delete' 'member of ORVYL PDS'
   FUNC       DELMEMB,FCB-1,memb-1a
                (0)   (1)   (15)

.us Purpose:

Delete a member in a ORVYL PDS file.

.us Operands:

   FCB-l            FCB address

   memb-la          Address of the 8 character member name, left
                    justified and padded with blanks if necessary.

.us Returns:

  (15) =            error code
.subsection 'Rewind a URAM File'
.ix 'rewind URAM file'
.ix 'URAM' 'rewind file'
   FUNC        REWIND,FCB-l
                 (0)   (1)

.us Purpose:

Rewind a file.

.us Operands:

   FCB-l            FCB address

.us Returns:

   (15) =           error code
.subsection 'Obtain Current Record Number of URAM File'
.ix 'URAM' 'obtain' 'current file record number'
.ix 'obtaining' 'current record number of URAM file'
   FUNC        NOTE,FCB-l
                (0)  (1)

.us Purpose:

Returns in R1, the line or record number of the current record
(input) or the next record (output).  Line numbers are WYLBUR
line numbers x 1000.

.us Operands:

   FCB-l            FCB address


.us Returns:

   (15) =           error code

    (1) =           line or record number
.subsection 'Point to a Specific Active File Line'
.ix 'point to specific active file line'
.ix 'active file' 'pointing to specific line'
.ix 'URAM' 'point to specific line in active file'
   FUNC     POINT,FCB-l,dataline-la
              (0)  (1)     (15)

.us Purpose:

FUNC POINT causes susequent file GETs to begin with the line
specified.  The file must be an active file opened for input.

.us Operands:

   FCB-l            FCB address

   dataline-la      WYLBUR line number.  (x 1000)

.us Returns:

   (15) =           error code
.subsection 'Establish ATTN, SVC Exit Routines'
.ix 'establish' 'ATTN, SVC exit routines'
.ix 'URAM' 'establish' 'ATTN exit routine'
.ix 'URAM' 'establish' 'SVC exit routine'
   FUNC        code,,routine-la,userinfo-l
                 (0)    (15)       (14)

.us Purpose:

Establishes the entry point of the specified exit routine.
These exit macros must be used in place of the ORVYL exit macros.

.us Operands:

   code             operation code

                       Code              Operation

                     ATTNEXIT      set ATTN exit routine

                     SVCEXIT       set SVC exit routine

   routine-la       entry point of the routine or zero to disable the
                    exit routine

   userinfo-l       any value specified by the program.  Upon exit routine
                    entry, this value is placed in register 14.  This
                    parameter may be used to point to a work area
                    required by the exit routine.


.us Returns:

   (15) =           error code

    (1) =           previous exit routine

    (14) =          previous user information
.subsection 'Establish a Command Exit'
.ix 'establish' 'a command exit'
.ix 'Command' 'establish a command exit'
.ix 'URAM' 'establish' 'command exit'
   FUNC     CMDEXIT,,routine-la,userinfo-la
               (0)      (15)       (14)

.us Purpose:

Establishes an entry point in your program.
Command file commands are passed to this entry point.
The command address are passed in register R1; the command
length in register R0.
The exit routine address is pointed to by r14.
If no entry is set, commands are passed to ORVYL and WYLBUR.

.us Operands:

   routine-la       command routine entry point.

   userinfo-la      any value specified by your program.  Upon exit
                    routine entry, this value is placed in register 15.
                    This parameter may be used to point to a work area
                    required by the exit routine.

.us Returns:

   (15) =           error code

    (1) =           previous exit routine

    (14) =          previous user information
.subsection 'Return from a Command Routine'
.ix 'return from a command routine'
.ix 'Command' 'return from a command routine'
.ix 'URAM' 'return from command routine'
   FUNC       CMDRET
                 (0)

.us Purpose:

To return to URAM after user command file processing.

.us Returns:

   None
.pa
.chapter 'File Batch Access Method'
VAM/370 provides a means for access to the ORVYL file system for
.ix 'VAM/370'
batch user programs.  VAM/370 operates independently of ORVYL and is
only available when ORVYL is not operating.

All ORVYL file system macros described in chapter 5 operate in the
VAM/370 environment; that is, all macro coding, parameters, and
return values are identical under VAM/370 and ORVYL.

In addition, many other macros used in ORVYL programs are also
accepted by VAM/370.  Many of these macros (for example, PAUSE or
COMMAND), while strictly compatible with VAM/370, are simply
ignored in the course of batch access method processing.
.section 'Writing VAM/370 Programs'
.ix 'VAM/370' 'writing programs'
Due to naming conflicts in ORVYL and OS/MVS macros, you must
separate ORVYL file manipulation operations from OS/MVS data set
manipulation portions of VAM/370 programs.

To direct the program interface to VAM/370 instead of ORVYL, the
batch macro must be placed as the first macro call in the VAM/370
program.

   Macro:            Batch

   Purpose:          Places all following ORVYL macros under control
                     of VAM/370; that is, sets the assembler global
                     flag &BATCH for expansion of all succeeding macros.

   Operands:         None

   Returns:          No executable code
.section 'Assembling VAM/370 Programs'
.ix 'VAM/370' 'assembling programs'
VAM/370 programs are assembled in the same manner as ORVYL programs.
.ix 'VAM/370'
VAM/370 macros are contained in the cataloged main library
SYS3.ORVYL.UMACLIB.  To assemble VAM/370 programs, either use the
.ix 'VAM/370' 'SYS3.ORVYL.UMACLIB'
cataloged procedure ASMORVYL or write appropriate JCL for
calling the assembler with the above macro library.
.ix 'ASMORVYL'
.section 'Link-editing VAM/370 Programs'
.ix 'VAM/370' 'link-editing programs'
VAM/370 load modules always contain the module VAM.  In the following
example, the member VAM is included from the partitioned data set
VAMLIB.

   //LINK   JOB      uuu.gg,CLASS=E
   //      EXEC      LKED
   //LKED.VAMLIB     DD  DSNAME=SYS3.IS.LINKLIB,DISP=SHR
   //SYSIN  DD *
      INCLUDE        VAMLIB(VAM)
        .
        .       <--  Other link-edit control cards
        .
      ENTRY          myprog
      NAME           myprog
   /*
.section 'Executing VAM/370 Programs'
.ix 'VAM/370' 'executing programs'
.ix 'VAM/370'
The cataloged procedure VAMGO supplies the JCL required for VAM/370
execution.  The symbolic parameter PROG invokes your program.
Example:

   //GO     JOB      uuu.gg,CLASS=B
   //      EXEC      VAMGO,PROG=myprog
             .
             .  <--  user JCL statements
             .

VAM execution-time routines claim approprimately 80K bytes
of core.  This requirement should be taken into account in the REGION
estimate.
.pa
.chapter 'ORVYL Public Programs'
The following ORVYL public programs are available or planned for
implementation.  Programs marked with an asterisk (*) employ
URAM (see chapter 6).  The CALL command (see section &call.) is used to
.ix 'URAM' 'public programs'
.ix 'Command' 'CALL'
access public programs.
.ix 'public programs'
.ix 'program' 'public'

.us     Public Program|                      |CALL programname

     BNF Analyzer                        ANALYZER
     JCL Scanner                         JCLSCAN, JCL
     PL360                               PL360
    *SPITBOL                             SPITBOL, SNOBOL
    *PL/C                                PLC
    *ORVYL/FORTRAN                       --
     LISP                                LISP
    *WATFIV                              WATFIV
     VS APL                              APL
     BASIC                               BASIC
.pa
.index 1 'INDEX' 2
.contents
