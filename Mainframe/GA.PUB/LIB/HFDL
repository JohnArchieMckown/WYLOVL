;  EXEC FILE TO RUN A HOST FORMS DEFINITION LANGUAGE (HFDL) JOB
;
;*****
;
;  PROGRAM         WYL.GA.PUB.LIB#HFDL
;  AUTHOR          Clifford Johnson, T.S.S., I.T.S.
;  DATE WRITTEN    FEBRUARY, 1984
;  UPDATE LOG :
;  Revised 09/28/87 by Mark Lawrence (GA.MCL):  general cleanup.
;  Revised 10/09/87 MCL:  use test HFDL, put UNN in jcl
;  Revised 07/06/88 MCL:  production HFDL; run RLG jobs on SYSB
;
;
;*****
;  FIRST THE EXEC VARIABLES ETC. ARE INTIALIZED.
;  (LINES 101-300)
;*****
    CLEAR VARIABLES
    DECLARE STRING OLDESC DV
    DECLARE NUM OLDELTA OLDACT
    OLDESC = ESCAPE
    OLDELTA = DELTA
    SET ESCAPE &
    SET DELTA = 1
    OLDACT = ACTNO
    OPEN HFDL TITLE 'JCL generated by UTIL HFDL'
;
;  HERE THE RESERVED STRINGS ARE SET.
;
    S7 = '  1001'
    S9 = 'Dsname of HFDL input file             \'
    S8 = '?                                     \'
    S7 = S7||'  '||(1001 + SIZE(S9))
    S9 = S9||'FORMS\'
    S8 = S8||':BOND\'
    S7 = S7||'  '||(1001 + SIZE(S9))
    S9 = S9||'DUPLEX\'
    S8 = S8||':NO   \'
    S7 = S7||'\'
; SET FORMS/DUPLEX = WHATEVER IS CURRENTLY ON THE 9700
DUMP $DPRT7
READ STR S1 UPP USING=LAST
DEL LAST
S0 = SUB(S1,IND(S1,' F=')+3,4)
IF (S0 EQ 'BLUE') S8 = SUB(S8,1,40)||S0||SUB(S8,45)
IF (S0 EQ '3HOL') S8 = SUB(S8,1,40)||S0||SUB(S8,45)
S0 = SUB(S1,IND(S1,'PLEX=')+5,2)
IF (S0 EQ 'YE') S8 = SUB(S8,1,46)||'YES'||SUB(S8,50)
;*****
;  THE EXEC TERMINAL INPUTS ARE OBTAINED.
;  (LINES 301/399)
;*****
COMM Host Forms Definition Language EXEC file - Version 07/06/88
    N0 = 6
    N8 = 1
    IF (PARM NE '') EXEC 326
COMM For help, type ? in response to any prompt.
    READ STR S0 UPP PRO='Do you want instructions (RETURN=NO)? ' ATTN=4906
    IF (S0 NE '' AND S0 NE 'NO' AND S0 NE 'N' AND S0 NE ' N') THEN LIST 7005/7026 EXEC UNN ATTN=312
    EXEC SAVE
IF (PARM EQ '') EXEC 325
IF (N0 NE 6) EXEC 325
IF (N5 EQ 1) EXEC 325
IF (N5 GT 1) S0 = UPPER(SUB(PARM,1,N5-1))
ELSE S0 = PARM
W0 = 318
EXEC 6501
S8 = ':'||S0||SUB(S8,SIZE(S0)+2)
COMM Your HFDL input file is:  &S0
N0 = 12
    EXEC 6006
N5 = IND(PARM,'/')
IF (N5 EQ 0) EXEC 312
IF (N5 EQ SIZE(PARM)) EXEC 312
S0 = UPPER(SUB(PARM,N5+1))
    W0 = 332
    EXEC 6501
COMM Your EXEC responses will be read from the file:  &S0
COMM
    COPY FROM &S0 TO END
    N9 = 1
    W1 = 1
    EXEC 312
;*****
;  THE NEXT SECTION IS THE PROGRAM CORE.
;  (LINES 1001/3999)
;*****
COMM Your job setup is being formatted.
W8 = END
PUTEND //   JOB
S0 = 'FORMS'
EXEC 5006 SAVE
PUTEND /*JOBPARM  FORMS=&S0,FCB=FULL
PUTEND //HFDL  EXEC  HFDL
PUTEND //CSSIN  DD  *
CHA 73 TO 'UNN' IN LAST NOLIST
S0 = 'Dsname of HFDL'
EXEC 5006 SAVE
W7 = END
DUMP CAT LIKE &S0
READ STR S1 USING=LAST
IF (SUB(S1,1,3) EQ 'No ') THEN COMM HFDL input file &S0 not catalogued.  Job aborted.
THEN EXEC 4906
DEL &W7/LAST
COPY FROM &S0 TO END
W7 = END
DUMP SIZE OVER 72 LINES &W8+4/LAST
READ STR S1 USING=LAST
IF (SUB(S1,1,3) NE 'No ') THEN COMM HFDL input file has lines over 72 columns.  Job aborted.
THEN EXEC 4906
POINT C'END;' IN &W8/LAST NOLIST
IF (CUR EQ -1) THEN COMM HFDL input file has no "END;" statement.  Job aborted.
THEN EXEC 4906
DEL &W7/LAST
;*****
;  THE NEXT SECTION IS THE EDIT/SAVE/RUN ROUTINE FOR JCL
;  GENERATING EXECS. (LINES 4801/4899)
;*****
  COMM The job is ready to run.
  S1 = 'Enter RUN, SAVE, PAUSE, LIST, or QUIT (RETURN=RUN): '
  READ STRING S0 UPPER PRO='&S1' ATTN=4906
  IF (SUB(S0,1,1) NE '?') THEN EXEC 4815
  LIST 4810/4813 EXEC UNN COLUMNS=3 ATTN=4807
;
; Enter:
;   ***   RUN to submit your HFDL batch job;
;   ***   SAVE to save the job setup;
;   ***   PAUSE to edit the job setup;
;   ***   LIST to list the job setup;
;   ***   QUIT to abort the EXEC.
;
    EXEC 4807
  IF (ABB('QUIT',S0,1)) EXEC 4901
  IF (ABB('LIST',S0,1)) THEN LIST &W8/LAST ATTN=4807
     THEN EXEC 4807
IF (ABB('PAUSE',S0,1)) THEN COMM The job setup is in lines &W8/&(LAST) of your active file.
THEN COMM Type 'EXEC' to continue this EXEC.
THEN EXEC PAUSE
  IF (S0 NE '' AND S0 NE 'RUN') EXEC 4820.1
  IF (MACHINE NE 'RLG') RUN &W8/LAST UNN HOLD NOTIFY SYSAFF=SYSA
     ELSE RUN &W8/LAST UNN HOLD NOTIFY
  EXEC 4906
  IF (~ABB(S0,'SAV')) EXEC 4837
  S1 = 'Enter a Dsname to Save the Job Setup (RETURN=do not save): '
  READ STRING S0 UPPER PRO='&S1' ATTN=4906
  IF (SUB(S0,1,1) NE '?') THEN EXEC 4832
  LIST 4825/4830 EXEC UNN COLUMNS=3 ATTN=4820
;
; If you respond to this prompt with a dsname, then your job setup will be
; saved under that name.  This will enable you to re-run your HFDL program
; without re-running this EXEC, with modifications in the HFDL file and/or
; in the job setup.  Saving the job setup is a recommended practice.
;
    EXEC 4822
  IF (S0 EQ '') EXEC 4806
  W0 = 4835
  EXEC 6501
  SAVE &S0 LINES=&W8/LAST
  EXEC 4806
  IF (S0 NE 'EXECSAVE') EXEC 4809
    IF (N7 EQ 1) THEN COMM EXEC Inputs contain a BREAK - no save possible.
                 THEN EXEC 4809
  S1 = 'Enter a Dsname to Save the EXEC Input (BREAK=backup) (RETURN=do not save): '
  READ STRING S0 UPPER PRO='&S1' ATTN=4806.5
  IF (SUB(S0,1,1) NE '?') THEN EXEC 4853
  LIST 4844/4851 EXEC UNN COLUMNS=3 ATTN=4806.5
;
; If you specify a dsname in response to this prompt, all your inputs to
; this EXEC file will be saved under that name.  Subsequently, if you run
; this EXEC specifying this dsname as the PARM, then the EXEC will take all
; its input options (up to the next prompt) from that dataset.  This facility
; helps greatly when you have to do many re-runs of a program using the same
; HFDL input file, HFDL options, and RUN options.
;
  EXEC 4838
  IF (S0 EQ '') EXEC 4806.5
  W0 = 4856
  EXEC 6501
  SAVE &S0 LINES=0/&W8-1
EXEC 4806.5
;*****
;  THE NEXT SECTION IS THE END OF PROGRAM ROUTINE.
;  (LINES 4901/4999)
;*****
    PIC &(OLDACT)
    SET DELTA &(OLDELTA)
    SET ESCAPE &(OLDESC)
COMM Exiting Host Forms Definition Language EXEC file.
    CLEAR EXEC
;*****
;  THE NEXT SECTION IS THE INPUT FETCH ROUTINE.
;  (LINES 5001/5009)
;*****
    S0 = SUB(S8,IND(S9,S0))
    S0 = SUB(S0,2,IND(S0,'\')-2)
    IF (IND(S0,' ') GT 0) S0 = SUB(S0,1,IND(S0,' ')-1)
    EXEC RETURN
;*****
;  THE NEXT SECTION IS THE PROMPT PROCESSOR.
;  (LINES 6001/6999)
;*****
    IF (N0 GT IND(S7,'\')) EXEC 406
    S0 = SUB(S7,N0-3,1)
    N4 = N1
    N1 = N0
    IF (S0 GT '1')  EXEC 6101
    IF (SIZE(S7) GT N0+4 AND SUB(S7,N0+3,1) NE '=')
       THEN N2 = SUB(S7,N0+4,3) - SUB(S7,N0-2,3)
       ELSE N2 = SIZE(S9) + 1 - SUB(S7,N0-2,3)
    S1 = SUB(S9,SUB(S7,N0-2,3),N2-1)
    S2 = SUB(S8,SUB(S7,N0-2,3),N2-1)||' '
    S0 = ''
    IF (N8 EQ 0) S0 = S0||' (BREAK=backup)'
    IF (SUB(S2,1,1) EQ ':')
    THEN S0 = ' (RETURN='||SUB(S2,2,IND(S2,' ')-2)||') '||S0
    IF (SUB(S1,SIZE(S1)-1) NE '') THEN S1 = 'Enter '||S1||S0
       ELSE S1 = 'Enter '||SUB(S1,1,IND(S1,"  "))||S0
IF (SUB(S1,SIZE(S1)) EQ ' ') S1 = SUB(S1,1,SIZE(S1)-1)
    IF (N9 EQ 0) THEN READ STRING S0 UPPER PRO='&S1: ' ATTN=6061
  ELSE READ STRING S0 UPPER USING=&W1
  ELSE COMM &S1: &S0
  ELSE W1 = &W1 + 1
  IF (S0 NE '?' AND N9 EQ 0) PUTEND &S0
  IF (S0 NE '?') EXEC 6024
  IF (N0 EQ 6) LIST 7026/7028 EXEC UNN ATTN=6023
  IF (N0 EQ 12) LIST 7028/7033 EXEC UNN ATTN=6023
IF (N0 EQ 18) LIST 7033/7041 EXEC UNN ATTN=6023
  EXEC 6023
    IF (S0 EQ '' AND SUB(S2,1,1) EQ '?')
       THEN COMM You must respond to this prompt.
      THEN EXEC 6023
    IF (S0 EQ '' AND SUB(S2,1,1) EQ '!')
       THEN S0 = '                                          '
       THEN S0 = SUB(S0,1,N2-2)
       THEN EXEC 6055
    IF (S0 EQ '') EXEC 6056
IF (IND(S0,' ') GT 0) THEN COMM Your response must not contain any blanks.
THEN EXEC 6023
    W0 = 6051
    IF (IND(S1,'Dsname') GT 0) EXEC 6501
;  HERE THE USER RESPONSE IS INSERTED IN STRING S8
;  FIRST A LENGTH CHECK
    IF (SIZE(S0) GE N2) THEN COMM &S0:  INVALID (TOO LONG)
       THEN EXEC 6015
    S0 = S0||'                             '
    S0 = SUB(S0,1,IND(SUB(S8,SUB(S7,N0-2,3)+1),'\')-1)
    S8 = SUB(S8,1,SUB(S7,N0-2,3)-1)||':'||S0||SUB(S8,SUB(S7,N0-2,3)+SIZE(S0)+1)
IF (N0 EQ 24 AND SUB(S8,125,4) NE 'BOND' AND SUB(S8,125,4) NE 'BLUE' AND SUB(S8,125,4) NE '3HOL') N0 = N0 + 12
    N0 = N0 + 6
;  REBOUND FOR NEXT PROMPT
    N8 = 0
    EXEC RETURN
;   *****
    IF (N8 EQ 1) EXEC 4906
    IF (N0 EQ 6) EXEC 4906
    N8 = 1
    N7 = 1
    N0 = N4
    EXEC RETURN
;  HERE GROUPED OPTIONS ARE PROCESSED - FIRST FIND END OF GROUP
    N2 = S0
    N0 = N0 + 6
    IF (N0 GT IND(S7,'\')) EXEC 6107
    S0 = SUB(S7,N0-3,1)
    IF (S0 EQ N2) EXEC 6102
;  NEXT FIND THE GROUP PROMPT
    S0 = SUB(S7,IND(S7,'&N2=')+2)
S1 = ' '
    IF (N8 EQ 0) S1 = S1||'(BREAK=backup)'
    S1 = 'Enter '||SUB(S0,1,IND(S0,'\')-1)||S1
EXEC 6127
COMM
COMM Current option values you may change:
    N2 = N1
    S0 = ''
    N3 = SUB(S7,N2-2,3)
    S2 = SUB(S9,N3)
    S2 = SUB(S2,1,IND(S2,'\')-1)
    IF (IND(S2,' ') GT 0) S2 = SUB(S2,1,IND(S2,' ')-1)||'='
     ELSE S2 = S2||'='
    S2 = S2||SUB(S8,N3+1)
    S2 = SUB(S2,1,IND(S2,'\')-1)
    IF (IND(S2,' ') GT 0) S2 = SUB(S2,1,IND(S2,' ')-1)
    S0 = S0||S2
    N2 = N2 + 6
IF (SUB(S0,SIZE(S0)) EQ '=') S0 = S0||'default'
COMM &S0
    IF (N2 LT N0) EXEC 6110
    IF (N9 EQ 0) THEN READ STRING S0 UPPER  PRO='&S1: ' ATTN=6061
  ELSE READ STRING S0 UPPER USING=&W1
  ELSE COMM &S1: &S0
  ELSE W1 = &W1 + 1
  IF (S0 NE '?' AND N9 EQ 0) PUTEND &S0
  IF (S0 NE '?') EXEC 6128
  EXEC 6127
IF (ABB('LIST',S0)) EXEC 6108.1
IF (IND(S0,' ') GT 0) THEN COMM Your list of options must not contain any blanks.
THEN EXEC 6127
    IF (S0 NE '') EXEC 6201
    EXEC 6058
;  THIS SECTION PROCESSES "keyword=value,..." OPTION STRINGS
  IF (SUB(S0,SIZE(S0)) NE ',')  S0 = S0||','
    N2 = IND(S0,'=')
    IF (N2 EQ 0) THEN COMM &S0:  INVALID (NO "=" SIGN)
       THEN EXEC 6108.1
    N2 = IND(S9,SUB(S0,1,N2-1))
    IF (N2 EQ 0) THEN COMM &S0:  INVALID
       THEN EXEC 6108.1
    S0 = SUB(S0,IND(S0,'=')+1)
S2 = SUB(S0,1,IND(S0,',')-1)||'                              '
    N3 = IND(SUB(S9,N2),'\')
    S2 = SUB(S2,1,N3-2)
    S8 = SUB(S8,1,N2-1)||':'||S2||SUB(S8,N2+N3-1)
    S0 = SUB(S0,IND(S0,',')+1)
    IF (SIZE(S0) GT 0) EXEC 6202
    EXEC 6108.1

;  HERE INPUT DSNAMES ARE PROCESSED (ACTIVE FILE NOT RECOGNIZED)

    S0=UPPER(S0)
    TRY DV=DSNVER(S0)  ; CHECK DSN
    IF (TRYERR) WRI S0||':  Invalid syntax in dsname' ; stupid wylbur
         THEN EXEC 4906 ;                      dsnver barfs if bad...

    IF (DV NE 'OK') WRI S0||':  '||DV
         THEN EXEC 4906 ; BAD DSN
    S0=DSNFORMAT(S0)

  EXEC &W0

;*****
;  THE NEXT SECTION IS THE LONGER TERMINAL MESSAGES.
;  (LINES 7001/7999)
;*****

This EXEC file builds the job setup for running a Host Forms
Definition Language job.  Such a job generates two output files:
    * the HFDL log, which includes compilation and error messages (SYSOUT=A)
    * the FORM generated (SYSOUT=G)

By default, these files will be placed in OUTPUT HOLD; you must
expressly RELEASE them to be printed on the 9700.  To review the HFDL
log to identify any errors, specify SYSOUT=A on the FETCH command.
Likewise, you can purge only the HFDL log by specifying SYSOUT=A on the
PURGE command.

Often you will want to PURGE both output files after finding an error
in the HFDL log; this is why OUTPUT HOLD is the default.

The generated FORM cannot be reviewed online, since it contains
special characters which only the 9700 understands.  To print the
FORM but not the HFDL log, specify SYSOUT=G on the RELEASE command.

Unless otherwise indicated, entering BREAK in response to a prompt
will end the EXEC - and two consecutive BREAKs will always end it.

Enter the WYLBUR dataset name of your HFDL input file.

You may choose BOND, 3HOL, or BLUE forms for printing on the 9700.
The default is set to whatever forms happen to be currently mounted
on the 9700 printer.  (The WYLBUR command "$DPRT7" displays the
current status of the 9700 printer.)

Specify YES if you want your HFDL log printed on both sides of the
page, and NO if you do not want this.  The DUPLEX option defaults to
whatever the current 9700 is printing.  (The WYLBUR command "$DPRT5"
displays the current status of the 9700 printer.)

Please note that the DUPLEX option only effects the HFDL log, that
is, SYSOUT=A.

