;  RESTORE--Restore (to disk) a file written to tape by BACKUP.
CLR VAR
;  last revision date:
DECLARE STRING REVDATE
REVDATE='03/06/91'
;  recent revision history:
;  03/06/91:  checking for invalid dsn on rename, bad index file
;  02/26/91:  3480 support
;  07/26/89:  Correct bug in prompt/all logic
;
;  10/25/88:  Substitute correctly for bad disk volume on
;             any machine.  Report substitutions.
;             Allow specification of DSN, NEWVOL, MACHINE in PARM.
;
;  05/16/88:  New variables, general cleanup.  OPEN new
;             active file instead of clearing.  Recover from bad index
;             dsn, duplicate data set names.
;
;  6/17/85:   Bug fix. Cross-account RENAME wasn't stripping trailing
;             blanks from dsname.
;
; variable usage

;  S0         Various prompts
;  BADVOL     Flag: bad disk volume
;  IXDSN      DSN of INDEX file
;  RSDSN      DSN of file to be restored
;  RNDSN      New (rename) dsn
;  TAPEVOL    Volume serial number of tape
;  TUNIT      Unit name for tape
;  DISKVOL    Target disk volume
;  NEWVOL     Requested target disk volume
;  SUBVOL     A suitable substitute for an invalid volume
;  CONTCHAR   Continuation character (col. 72) in IEHMOVE command
;  DISKVOL    Volume on which restored file is to be written
;  RESTORX    Reply to RESTORE prompt...YES, NO, or volume
;  XMACHINE   Target machine on which job is to run
;  XMFLAG     Flag: running on a different machine
;  USERACCT   Account as gg.uuu
;  USERESC    User's ESCAPE character
;  OLDACT     Previous active file number, 0 if none
;
;  N0         work variable
;  SPACE      Space allocation in tracks
;  DVCOL      Column number in command line where disk volume appears
;  LINCMD     Number of lines per IEHMOVE command:  2 or 3
;  MODEFLAG   Flag:  0=prompt, 1=all
;
;  IXP2       Pointer into INDEX file
;  IXP1       Pointer to first line of command
;  SUBCOUNT   Number of volume substitutions made
;  TRACKL     Track length in Kbytes
;
;  AJLINE     line-number for collecting allocate JCL
;  XEND       END line...for dumps
DECLARE STRING  IXDSN RSDSN TAPEVOL CONTCHAR DISKVOL RESTORX USERACCT
DECLARE STRING  USERESC RNDSN SUBVOL NEWVOL XMACHINE TUNIT
DECLARE NUM  SPACE DVCOL LINCMD MODEFLAG FILESEQ IXP2 IXP1 TRACKL
DECLARE NUM  XEND OLDACT SUBCOUNT AJLINE
DECLARE BOOLEAN XMFLAG BADVOL
COMM
USERESC = ESC
SET ESC &
SUBCOUNT = 0
USERACCT = GROUP||'.'||USER
OLDACT = ACTNO
IF (LINES EQ 0) OLDACT = 0
NEWVOL=''
SUBVOL=''
TUNIT='TAPE'
XMFLAG=FALSE
XMACHINE=''
COMM RESTORE -- Restore files written to tape by BACKUP.  Revised &(REVDATE)
; parm check
PARM=UPP(STRIP(PARM))
IF (PARM EQ '') EXE 80 ; no parm

; got a parm
IF (INDEX(PARM,'=') EQ 0) EXE 70 ; no keywords, assume it's dsn
N0=INDEX(PARM,'VOL=')
IF (N0 EQ 0) EXE 65
; Got VOL=
NEWVOL=SUBSTR(PARM,N0+4,6) ; get volser
PARM=SUBSTR(PARM,1,N0-1)||SUBSTR(PARM,N0+10) ; strip out VOL=volser
PARM=STRIP(PARM)
PARM=STRIP(PARM,'B',',')
SUBVOL=NEWVOL

N0=INDEX(PARM,'DSN=')   ; DSN for index file
IF (N0 EQ 0) EXE 68
IXDSN=SUBSTR(PARM,N0+4) ; get index dsname
PARM=SUBSTR(PARM,1,N0-1)||SCAN_SKIP(IXDSN) ; strip out dsn stuff
IXDSN=SCAN_TOKEN(IXDSN) ; remove any trailing parms
PARM=STRIP(PARM)
PARM=STRIP(PARM,'B',',')

N0=INDEX(PARM,'MACHINE=')   ; MACHINE on which to run
IF (N0 EQ 0) EXE 69
XMACHINE=SUBSTR(PARM,N0+8) ; get machine
PARM=SUBSTR(PARM,1,N0-1)||SCAN_SKIP(XMACHINE) ; strip out machine
XMACHINE=SCAN_TOKEN(XMACHINE) ; remove any trailing parms
IF (MACHINE NE XMACHINE AND XMACHINE NE '') XMFLAG=TRUE
PARM=STRIP(PARM)
PARM=STRIP(PARM,'B',',')

; What's left
IF (PARM EQ '') EXE 75 ; done
WRI PARM||':  Ignored.'
EXE 75

; parm was just dsn
IXDSN=PARM
EXE 75

; see if we got an index dsn yet
IF (IXDSN NE '') EXE 104

REA STR S0 UPP PRO 'Do you want instructions? ' ATTN=950
IF (IND('YES.OK.?.HELP',S0) NE 0) LIST 1001/1099 EXE UNN ATTN=NEXT

; INDEX FILE
READ STRING IXDSN UPP PRO 'Name of your INDEX file? ' ATTN=950
IF (IXDSN EQ '?') LIST 1301/1399 EXE UNN ATTN=PREV
THEN EXEC 100
IF (IXDSN EQ '') EXE 200 ; RESTORE INDEX
TRY USE &(IXDSN) KEEP
IF (TRYERR) EXE 100
IF (TRYATTN) EXE 950
SET ACTIVE NAME=RESTORE TITLE='JCL generated by UTIL RESTORE'
SET PREFIX
READ STRING TAPEVOL USING FIRST COLUMNS 18/23  ; tape vol-ser
READ STRING TUNIT USING FIRST COLUMNS 12/15    ; tape unit name
IF (NEWVOL EQ '') SUBVOL=SUBSTR(DSNINFO(IXDSN),1,6) ; substutute vol: index vol
   THEN EXEC 105 ; didn't specify NEWVOL

; CHECK VOL.
IF (XMFLAG) EXEC 105 ; don't check if cross-machine restore
XEND = END
$DUMP UCB &(NEWVOL)
IF (IND(LINE(LAST),'NOT FOUND') EQ 0) DEL &(XEND)/L ; FOUND A VOL.
   THEN EXEC 105
; VOL NOT FOUND...
DEL &(XEND)/LAST
WRI 'Volume '||NEWVOL||' not found.'
IF (YESNO('Use it anyway? ') EQ 'YES') EXE 105
REA STR NEWVOL UPP PRO 'New volume = '
NEWVOL=STRIP(NEWVOL)
IF (NEWVOL EQ '') EXE 105
EXE 104.6 ; recheck

IF (SUBSTR(SUBVOL,1,3) NE 'SCR') EXE 106 ; OK, not on temp.
; index on temp, find another substitute
SUBVOL = 'PUB123'
IF (MACHINE EQ 'SYSC') SUBVOL='PUBC03'
IF (MACHINE EQ 'RLG') SUBVOL='RLG023'
NUMBER BY 1.0 START 1.0
AJLINE=0.101 ; where to collect allocate dds if cross-machine
;
LINCMD = 2   ; LINES PER DATA SET...FOR OLD BACKUP
REA STR CONTCHAR USING 1 COL 72/72       ; * IF NEW BACKUP
IF (CONTCHAR EQ '*') LINCMD = 3        ; NEW
LINCMD = LINCMD
;
IF (CONTCHAR EQ ' ') WRI 'ERROR:  This data set is not an INDEX file created by BACKUP.'
THEN EXEC 950
IXP2 = LINCMD
EXE 500
; RESTORE INDEX FROM TAPE

COMM
COMM RESTORE will now restore your INDEX file from your BACKUP tape.
COMM
REA STR TAPEVOL UPP PRO 'Volume serial number of your BACKUP tape: ' ATTN=100
IF (TAPEVOL EQ '?') LIST 1401/1499 EXE UNN ATTN=PREV
THEN EXE 205
IF (SIZE(TAPEVOL) NE 6) WRI TAPEVOL||':  INVALID.  Tape number must be 6 characters'
THEN EXE 205
IF (VER(SUB(TAPEVOL,3,4),'0123456789') NE 0) WRI TAPEVOL||':  INVALID.  Last 4 characters must be numeric'
THEN EXE 205
IF (SUB(TAPEVOL,2,1) EQ '0') TUNIT='3480'

; SEQNO
FILESEQ = 1
REA STR S0 UPP PRO 'File sequence number of the INDEX file (RETURN=1): ' ATTN=200
IF (S0 EQ '?') LIST 1501/1599 EXE UNN ATTN=PREV
THEN EXE 220
IF (S0 EQ '') EXE 230 ; DEFAULT
IF (VER(S0,'0123456789') NE 0) WRI S0||'INVALID.  Specify a number.
THEN EXE 220
FILESEQ = S0

; DSN FOR INDEX
REA STR IXDSN UPP PRO 'Data set name to assign to the INDEX file: '
IF (IXDSN EQ '?') LIST 1601/1699 EXE UNN ATTN=PREV
THEN EXE 230
IF (SUB(IXDSN,1,4) NE 'WYL.') IXDSN = 'WYL.&(USERACCT).&(IXDSN)' ; QUALIFY NAME
; GOT VOLSER, SEQNO

PUTEND //  JOB ,'INDEX RESTORE',TIME=(,5)
IF (TUNIT EQ '3480') PUTEND /*SETUP T3480=1 INPUT=&(TAPEVOL)
   ELSE PUTEND /*SETUP T=1 INPUT=&(TAPEVOL)
PUTEND /*JOBPARM HOLD=OUTPUT,PURGE=NO
PUTEND // EXEC IOPROGM
PUTEND //IN DD UNIT=(&(TUNIT),,DEFER),DISP=OLD,VOL=SER=&(TAPEVOL),LABEL=&(FILESEQ)
PUTEND //OUT DD DSN=&(IXDSN),DISP=(,CATLG),
PUTEND //  UNIT=DISK,SPACE=(6000,(10,10),RLSE)

RUN NOTIFY
COMM
COMM When this job has executed, invoke RESTORE again, and specify
COMM &(IXDSN) as the name of your INDEX file.
EXE 950

; MODE SET
REA STR S0 UPP PRO 'Do ALL data sets, or PROMPT for each? ' ATTN=950
IF (S0 EQ '') EXE *-1
IF (IND('HELP?',S0) NE 0) LIST 1201/1299 EXE UNN ATTN=500
THEN EXE 500
IF (SUB(S0,1,3) EQ 'ALL') MODEFLAG = 1
THEN EXE 600
IF (SUB(S0,1,3) EQ 'PRO') MODEFLAG = 0
THEN EXE 600
WRI S0||':  INVALID.  Reply PROMPT or ALL.'
EXE 500

; TOP OF LOOP...ONE PASS PER DATA SET
READ STRING S0 USING &(IXP2) COLUMNS 20
IF (SUBSTR(S0,1,3) EQ 'ME=') S0 = SUBSTR(S0,4)
RSDSN = STRIP(S0)
IF (DSNVER(RSDSN) EQ 'BAD DSN') WRI 'Error: Data set name "&(RSDSN)" from INDEX file is invalid.'
   THEN WRI 'Record in error is:'
   THEN LIS &(IXP2)
   THEN WRI 'This data set is not a valid INDEX file from BACKUP.'
   THEN EXE 950
RNDSN = RSDSN
DVCOL = 38               ; OLD BACKUP
IF (LINCMD EQ 3) DVCOL = 24  ; NEW BACKUP
READ STRING DISKVOL USING &(IXP2)-1 COLUMNS &(DVCOL)/&(DVCOL+5)  ; GET VOLSER
IF (SUBSTR(DISKVOL,1,1) EQ '=') DVCOL = DVCOL+1 ; OFF 1
THEN EXE 604
IXP1 = IXP2-LINCMD+1
IF (NEWVOL EQ '') EXE 607
; force new volume
DISKVOL=NEWVOL
CH &(DVCOL)/&(DVCOL+5) TO '&(DISKVOL)' IN &(IXP2)-1 NOL ; fix cmd.
IF (MODEFLAG NE 1) EXE 610
EXE 631

; CHECK VOL.
XEND = END
BADVOL = FALSE
$DUMP UCB &(DISKVOL)
IF (IND(LINE(LAST),'NOT FOUND') NE 0) BADVOL = TRUE ; didn't find it
DEL &(XEND)/LAST

IF (MODEFLAG EQ 0) EXE 608.5 ; Prompt mode

; ALL mode

IF ( ~BADVOL) EXE 631 ;  if volume OK
; bad volume, ALL mode
   SUBCOUNT=SUBCOUNT+1
   IF (SUBCOUNT LE 5) WRI 'Volume '||DISKVOL||' not found for dataset '||RSDSN
      THEN            WRI 'volume '||SUBVOL||' substituted.'
   DISKVOL = SUBVOL
   CH &(DVCOL)/&(DVCOL+5) TO '&(DISKVOL)' IN &(IXP2)-1 NOL ; fix cmd.
   EXE 631  ; don't prompt

; PROMPT mode
IF (~BADVOL) EXE 610
; bad volume, prompt mode
DISKVOL = SUBVOL
CH &(DVCOL)/&(DVCOL+5) TO '&(DISKVOL)' IN &(IXP2)-1 NOL ; change cmd.
; Volume OK, prompt mode
READ STRING RESTORX UPP PRO 'Restore &(RSDSN) (to &(DISKVOL))? '  ATTN=750
IF (RESTORX EQ '?') WRI 'Reply YES, NO, or with the name of a disk volume.'
THEN EXE 610
IF (INDEX('YES OK RESTORE ',RESTORX) NE 0) EXEC 631  ; DO IT
IF (RESTORX EQ '') DEL &(IXP1)/&(IXP2)
THEN EXEC 700
IF (RESTORX EQ 'NO') DEL &(IXP1)/&(IXP2)
THEN EXEC 700
IF (RESTORX EQ 'N') DEL &(IXP1)/&(IXP2)
THEN EXEC 700
IF (SIZE(RESTORX) NE 6) WRI RESTORX||':  INVALID.  Reply YES, NO, or a volume name.'
THEN EXEC 610
; MAY BE A VOLUME NAME.
IF (XMFLAG) EXE 627 ; cross-machine, can't check it
XEND = END
$DUMP UCB &(RESTORX)
IF (IND(LINE(LAST),'NOT FOUND') EQ 0) DEL &(XEND)/LAST ; Found vol
   THEN EXE 627
; NOT FOUND
DEL &(XEND)/LAST
IF (SUB(RESTORX,1,3) EQ 'PUB' AND VER(SUB(RESTORX,4,3),'0123456789') EQ 0)
   THEN WRI RESTORX||' is no longer on the system.'
   THEN DISKVOL=SUBVOL  ; SUBSTITUTE A GOOD VOL.
   THEN CH &(DVCOL)/&(DVCOL+5) TO '&(DISKVOL)' IN &(IXP2)-1 NOL ; CHANGE THE COMMAND TOO
   THEN EXEC 610
; Not found, and name isn't PUBxxx
WRI RESTORX||':  INVALID.  Reply YES, NO, or the name of a disk volume.'
   THEN EXE 610
; FOUND THE VOLUME.
DISKVOL = RESTORX

;  Change volume in command file
CH &(DVCOL)/&(DVCOL+5) TO '&(DISKVOL)' IN &(IXP2)-1 NOL  ; CHANGE THE COMMAND TOO
IF (SUB(DISKVOL,1,3) EQ 'SCR') CH 'DISK' 19/30/32 TO 'SYSDA' IN &(IXP2)-1 NOL
ELSE CH 'SYSDA' 19/30/32 TO 'DISK' IN &(IXP2)-1 NOL

; CATALOG
PUTLINE &(IXP1+1.1)                CATLG,                                                  *
; Check for acct change
IF (LINCMD NE 3.0) EXE 700   ; OLD BACKUP, FORGET IT
; SEE IF RENAME
IF (SUBSTR(RSDSN,5,6) EQ USERACCT) EXE 640  ; ACCOUNTS MATCH
IF (SUBSTR(RSDSN,1,3) EQ 'SYS') EXE 640 ; SYSn., forget accounts
RNDSN = DSNFORMAT(SUBSTR(RSDSN,12)) ; no match, requalify w/ours
; Check for duplicate name
IF (XMFLAG) EXE 645 ; cross machine..
IF (DSNVER(RNDSN) EQ 'NOT THERE') EXE 645 ; OK
IF (DSNVER(RNDSN) EQ 'BAD DSN') WRI RNDSN||':  Invalid dsname.'
   THEN EXE 643
WRI RNDSN||' is already cataloged.'
REA STR S0 UPP PRO 'Specify a new (unique) name for &(RSDSN): ' ATTN=750
S0=STRIP(S0)
IF (S0 EQ '?') LIS 1101/1199 EXE UNN ATTN=NEXT
   THEN EXEC 643
IF (DSNVER(S0) EQ 'BAD DSN') WRI S0||':  Invalid dsname.'
   THEN EXEC 643
TRY RNDSN=DSNFORMAT(S0)
IF (TRYERR) EXE 643
EXE 640

IF (RNDSN EQ RSDSN) EXE 650 ; no rename
PUTLINE &(IXP1+1.5)                RENAME=&(RNDSN),
CH 72 TO '*' IN &(IXP1+1.5) NOL
WRI 'Data set will be renamed &(RNDSN)'

;  SEE IF PREALLOCATE
IF (LINCMD NE 3) EXE 700   ; OLD BACKUP, FORGET IT
IF (SUB(LINE(IXP1+1),34,2) NE 'PS') EXE 700 ; NOT SEQUENTIAL
IF (SUB(LINE(IXP1),56,6) EQ 'KBYTES') EXE 660 ; NEW NEW BACKUP
REA VAL SPACE USI &(IXP1) COL 47/51    ; NUMBER OF TRACKS
IF (SPACE LT 17) EXE 700            ; SMALL...
TRY ALLOC &(RNDSN) ON &(DISKVOL) NOCAT SEQ TRACKS &(SPACE)
IF (TRYERR) EXE 680 ; failed, try new volume
EXE 700

; NEW FORMAT...CHECK VOLUME AND SPACE
REA VAL SPACE USI &(IXP1) COL 47/54       ; KBYTES
IF (XMFLAG) TRACKL=47 ; cross-machine, can't check disk
   THEN EXEC 666.5
S0 = DISKVOL                      ; VOLUME SERIAL
EXE 2000 SAVE                      ; CHECK DEVTYPE
IF (TRACKL EQ 0.0) WRI 'Volume &(DISKVOL) not found; specify a new volume.'
THEN EXE 680
IF (SPACE LT 500) EXE 700             ; SMALL
SPACE = INT((SPACE/TRACKL)+.99)     ; KBYTES to TRACKS, round up
IF (XMFLAG) EXE 690 ; Cross-machine, can't do wylbur alloc
TRY ALLOC &(RNDSN) ON &(DISKVOL) NOCAT SEQ TRACKS &(SPACE)
IF (TRYERR) EXE 680 ; get new vol
EXE 700

; ALLOC failed, presumably because space not available
; (we've already verified that vol exists, and it's unlikely we'd
; have a dsname syntax error; we've also check for duplicate name)
REA STR RESTORX UPP PRO 'Specify a new disk volume :'
EXE 621 ; go check it

; Batch allocate of large sequential file (cross-machine)
PUTLINE      &(AJLINE) //A  DD  DSN=&(RNDSN),UNIT=SYSALLDA,
PUTLINE &(AJLINE+.001) //  DISP=(,KEEP),VOL=SER=&(DISKVOL),SPACE=(TRK,(&(SPACE),10))
AJLINE=AJLINE+.002

; END OF LOOP
IXP2 = IXP2 + LINCMD
IF (IXP2 LE LAST) EXEC 600
IF (SUBCOUNT GT 5) WRI 'Note:  New disk volume substituted &(FORMAT(SUBCOUNT,-1,0)) times'

EXEC 800

; ATTN EXIT FROM PROMPT MODE
DEL &(IXP1)/LAST
EXE 800
;  COMMON
IF (LINES EQ 0) WRI 'No data sets selected to restore.'
   THEN EXEC 950
PUTLINE .01 //RESTORE JOB ,'DATA SET RESTORE'
IF (TUNIT EQ '3480') PUTLINE .02 /*SETUP T3480=1 INPUT=&(TAPEVOL)
   ELSE PUTLINE .02 /*SETUP T=1 INPUT=&(TAPEVOL)
IF (XMFLAG) PUTLINE .03 /*JOBPARM SYSAFF=&(XMACHINE)
PUTLINE 0.8 // EXEC RESTORE,TAPE=&(TAPEVOL),TUNIT=&(TUNIT)
PUTLINE 0.9 //SYSIN DD *
IF (AJLINE GT 0.101) PUTLINE 0.100 //ALLOC EXEC NULL
NUMBER

; Cleanup and normal exit
COMM
COMM The job is now in your active file and ready to run.
COMM List and check for errors, then type RUN.
IF (OLDACT NE 0) COMM Type PICK &(OLDACT) to restore your previous active file.
COMM (RESTORE done)

SET ESC &(USERESC)
CLR EXE

; ABORT
IF (OLDACT NE 0) PICK &(OLDACT)
SET ESC &(USERESC)
COMM Leaving RESTORE.
CLR EXE
; EXPLAIN--GENERAL
This EXEC file is used to restore to disk files that were copied
to tape by BACKUP.  BACKUP writes an "index" file on disk that
contains the commands needed to restore the files from tape.

This EXEC reads the index file, constructs JCL, modifies commands,
and preallocates data sets when necessary.  When RESTORE is done,
you must RUN the job that it has constructed.

; Help rename
There is already a cataloged data set with the same name as the one
you wish to restore.  Specify a new name to use for the restored data
set.

; EXPLAIN MODE

If you reply PROMPT, RESTORE will prompt you with each data set name
from the index file and ask you if you wish to restore it to disk.

If you reply ALL, RESTORE will scan the index file and preallocate
data sets as necessary (same as PROMPT mode), but will not ask you
about each one.  Use this mode if you want to restore all the data
sets.

; HELP INDEX NAME
When you run BACKUP, it creates a data set called the INDEX FILE;
this file contains the utility control statements needed to restore
the files to disk, as well as some other information (format, size,
etc.) about the files.  BACKUP writes this file on the tape before
copying your disk files to the tape; it will also (optionally) write
this file on disk.

If you have a copy if this INDEX file on disk now, reply with the
name of the INDEX file.  If you don't have a copy on disk and want to
restore it from the tape, press RETURN in response to this prompt,
and this EXEC will submit a job to restore it (this will cost you an
extra tape mount).  If you want to give up, press BREAK in response
to this prompt.

---------HELP TAPE VOLSER----------------
Every tape at the Stanford Data Center has a six-character "volume
serial number" (sometimes called a "tape number") that identifies the
tape to the system and to the operators.  If you own the tape, you
were assigned this number when you submitted it at the Information
Desk.  If you are renting the tape, the system assigned it during a
job (i.e., your BACKUP job), and the job output indicated the number.

If you are not sure what your tape number is, you should terminate
RESTORE by pressing the BREAK key in response to prompts, and then
issue the command UTIL SHOWTAPE to get a list of your tapes.

---------HELP FILESEQ---------------------
The File Sequence Number is the relative position of a file on the
tape; the first file is 1, the second is 2, etc.  If you had the
system assign you a tape when you ran BACKUP, the INDEX file will be
number 1 on the tape.  If you used your own tape, or a tape that was
assigned to you in an earlier job, you had the choice of writing
files at the beginning of the tape (destroying any previously created
files), or adding files to the end.  In the latter case you specified
a starting file sequence number to BACKUP, and should specify the
same number here.  When you add files to a BACKUP tape, it will end
up with several INDEX files:  One as the first file (from the first
BACKUP job), and one more each time BACKUP is used to add files to
the tape.

If you're not sure where the INDEX file you want is on the tape,
examine the output from the BACKUP job that wrote it.  If you can't
find that output, then terminate RESTORE and issue the command
UTIL TAPESNIF to run a job that will scan the tape and show you what
is there.

------------HELP INDEX DSN------------------------------
Specify the name you want assigned to your INDEX file when it
is written on disk.  This name must be unique, that is, you must
not now have a data set with this name.


;  SUBROUTINE TO FIND OUT DISK TYPE

;  ON INPUT:  S0=VOLSER
;  ON OUTPUT: S0=DEVICE TYPE (6 CHAR.)    TRACKL=TRACK LENGTH
;  RETURNS VIA "EXEC RETURN"
;  USES XEND AS "END" LINE

XEND = END
$DUMP UCB &S0
IF (IND(UPP(LINE(XEND)),'NOT FOUND') NE 0) EXE 2020
CH 45/99 TO '' IN &(XEND)/L NOL
CH 1/9 TO '' IN &(XEND)/L NOL
ALI &(XEND)/L LEN 9 EVE
NUM &(XEND)/L BY 1
REA STR S0 USI &(XEND+4)  ; UCBTYPE FIELD FROM UCB
DEL &(XEND)/LAST
N0 = IND('123456789ABCDEF',SUB(S0,8,1))*6-5  ; INDEX INTO TABLE
S0 = SUB(' 2311  2301  2303  2302  2321 2305-12305-2 2314  3330  3340  3350  3375 3330-1 3380 ',N0,6)
TRACKL = SUB('   3.6  20.4   4.9   4.9   2.0  14.1  14.7   7.3  13.0   8.4  19.0   0.0  13.0  47.0',N0,6)
EXEC RETURN

; HERE IF NOT FOUND
S0 = '******'
TRACKL = 0.0
DEL &(XEND)/LAST
EXE RETURN
