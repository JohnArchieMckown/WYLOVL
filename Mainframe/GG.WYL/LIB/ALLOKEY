//ALLOKEY JOB  ,CLASS=B
//       EXEC  PL1XCLG,PARM.PLI='AG,A,C,F(I),M,STG',
//             PARM.GO='RESTORE'
//* NOTE - PL1 OPTIMIZING COMPILER
//PLI.RECORD DD DSN=SYS3.EXPORT.MISC,DISP=SHR
//SYSIN DD *
     /*  KWRDUMP--UTILITY ROUTINE TO DUMP/RESTORE/COPY/LIST
         THE WYLBUR/MILTEN KEYWORD FILE  */
     %DECLARE
              RECORDSIZE FIXED; /* SIZE OF OUTPUT RECORD    */
   /* THE RECORDSIZE PREPROCESSOR VARIABLE IS USED TO ASSIGN
      THE OUTPUT RECORD SIZE WHEN THE KEYWORD FILE IS DUMPED
     THIS SIZE IS THE NEXT HIGHER MULTIPLE OF 80.           */


 KEYDUMP: PROC (PARM) OPTIONS (MAIN);
  DECLARE
     1 KEYRECORD UNALIGNED BASED(KEYPTR),
       %INCLUDE RECORD(KEYREC) ;
       %RECORDSIZE = (79+KWR_REC_SIZE)/80*80 ;

  DECLARE

     NULL BUILTIN,             /* REFERENCE NULL FUNCTION */
     KWWRITE ENTRY(POINTER,FILE) RETURNS(BIN FIXED(15)),
     KWREPL  ENTRY(POINTER,FILE) RETURNS(BIN FIXED(15)),
     KWREAD  ENTRY(POINTER,FILE) RETURNS(BIN FIXED(15)),
     PARM CHAR(100) VAR,PARMX CHAR(10) VAR,
     (SYSUT1S INPUT,SYSUT2S OUTPUT) FILE STREAM,
     (SYSUT1D INPUT SEQUENTIAL,SYSUT2D DIRECT OUTPUT) FILE KEYED
        ENVIRONMENT (REGIONAL(2) F RECSIZE(KWR_REC_LEN)),
     (RECORDIN,RECORDOUT,ANYOUT,LISTKEY,EOFSYSUT1) BIT(1),
     PARMVAL(4) CHAR(10) STATIC
        INIT ('DUMP','RESTORE','COPY','LIST'),
     (SORTCMD,RECORDCMD) CHAR(80),
     SORTSTORAGE         BIN FIXED(31),
     (SORTRC,WRITERC)    BIN FIXED(31),
     RECORDBUF CHAR(RECORDSIZE),
       ( KWRFIELD CHAR(KWR_REC_SIZE) POS(1) ) DEFINED RECORDBUF,
     KEYBUF CHAR(KWR_REC_SIZE),
       (PHYSKEY CHAR(KWR_KEY_LEN) POS(KWR_KEY_POS),
        KWR CHAR(KWR_REC_LEN) POS(KWR_REC_POS),
        HASHED CHAR(8) POS(1)  ) DEFINED KEYBUF,
     1 KEYCHAIN BASED (KEYPTR),
        2 KEYREC CHAR(KWR_REC_SIZE),
     1 KEYFMT UNALIGNED BASED (KEYPTR),
        2 USEID CHAR(3),
        2 ACCNT CHAR(2),
        2 PASSWORD CHAR(3),
        2 KWRRJE FIXED BIN(15),
        2 KWRSPUSD FIXED BIN(15),
        2 KWRSPMAX FIXED BIN(15),
        2 KWRIFL BIT(8),
        2 KWRAFL BIT(8),
        2 KBIN CHAR(3),
        2 KWRWRCT BIT(8),
        2 REWRITE_COUNT BIT(8),
        2 BUDGET  BIT(24),
        2 CHARGES BIT(24),
        2 CARD_MAX FIXED BIN(15),
        2 LINE_MAX FIXED BIN(15),
        2 CPU_MAX  FIXED BIN(15),
        2 KWRBFL   BIT(8),
        2 DESTINATION CHAR(8),
        2 FORMS    CHAR(4),
        2 HASPRES  CHAR(11),
        2 JOBNAME  CHAR(8),
        2 JOBNO    FIXED BIN(15),
        2 HRSALL   FIXED BIN(15),
        2 HRSACC   FIXED BIN(15),
        2 MAXSESN  CHAR(1),
        2 MAXSESL  CHAR(1),
        2 TERM_CLASS BIT(8),
        2 KWRTFL   BIT(8),
        2 ORVLIB   CHAR(5),
        2 ORVPROG  CHAR(8),
        2 ORVRES   CHAR(8),
        2 SECURITY CHAR(75),
        2 RESERVED CHAR(32),
     (KEYPTR,KEYBASE,XPTR,YPTR) POINTER,
     (FSTRING CHAR(10),GSTRING CHAR(7)
        INIT ('GROUP','UNDER','SYS','ACCT','OPR','ADMIN','INVALID')
        ) (7) VARYING,
     (TEST,FLS(7) INIT ('00000100'B,'00001000'B,'00100000'B,
        '01000000'B,'00010000'B,'00000010'B,'10000000'B) ) BIT(8),
     FLAGC CHAR(2),PASSWORDX CHAR(3),
     COUNT FIXED BIN(15),
     (TOTSPUSD,TOTSPMAX) FIXED BIN(31),
     (ENCODE,DECODE) BIT(64),
     KWRBUF CHAR(KWR_REC_LEN);

  GETRCD: PROCEDURE RETURNS(CHAR(RECORDSIZE));
   /* THIS PROCEDURE READS IN THE NEXT RECORD AND DECODES IT
      FOR THE SORT PROGRAM.  IT SELECTS THE RECORD FROM EITHER
      THE DIRECT ACCESS FILE SYSUT1D OR THE SEQUENTIAL FILE
      SYSUT1S                                                 */
   DECLARE SORTRECORD CHAR(RECORDSIZE) ;

   IF RECORDIN THEN DO;
     ON ENDFILE(SYSUT1S) BEGIN;
       EOFSYSUT1 = '1'B;
     END;
   END;
   ELSE DO;
     ON ENDFILE(SYSUT1D) BEGIN;
       EOFSYSUT1 = '1'B;
     END ;
   END ;

   IF RECORDIN
     THEN DO;
       GET FILE(SYSUT1S) EDIT (RECORDBUF) (A(RECORDSIZE));
       KEYBUF = KWRFIELD ;   /* MOVE TO RECORD */
     END;
     ELSE DO;
       READ FILE(SYSUT1D) INTO (KWR) KEYTO (PHYSKEY);
     END ;

   IF EOFSYSUT1
     THEN CALL PLIRETC(8);
     ELSE DO ;
       UNSPEC(HASHED) = BOOL(UNSPEC(HASHED),DECODE,'0110'B);
       CALL PLIRETC(12);
     END;

   SORTRECORD = KEYBUF ;
   RETURN (SORTRECORD) ;
 END GETRCD ;

 PUTRCD: PROCEDURE(SORTEDBUF);
   /* THIS PROCEDURE OUTPUTS THE SORTED RECORDS AS WELL AS A
      LIST OF WHAT IS IN THE KEYWORD FILE               */
   DECLARE SORTEDBUF CHAR(RECORDSIZE);

   KEYPTR = ADDR(SORTEDBUF);

   DO I=1 TO 7;
     IF I<7 THEN TEST=KWRIFL&FLS(I);
     ELSE TEST=BOOL(KWRAFL&FLS(7),FLS(7),'0110'B);
     IF TEST
       THEN FSTRING(I)=' ('||GSTRING(I)||')';
       ELSE FSTRING(I)='';
   END;

   FLAGC='  ';
   IF KWRSPUSD>=KWRSPMAX THEN
     IF KWRSPUSD>KWRSPMAX THEN FLAGC='**'; ELSE FLAGC='* ';
   IF LISTKEY THEN PASSWORDX=PASSWORD;   ELSE PASSWORDX=' ';

   PUT FILE (SYSPRINT) SKIP EDIT
     (ACCNT||'.'||USEID) (A(8))
     (PASSWORDX,KBIN) (A(KWR_KEY_LEN),A(3))
     (FLAGC) (X(1),A(2))
     (KWRSPUSD,KWRSPMAX,KWRRJE) (3 F(6))
     (FSTRING) (X(2),7 A);

   TOTSPUSD=TOTSPUSD+KWRSPUSD;   TOTSPMAX=TOTSPMAX+KWRSPMAX;

   IF ANYOUT THEN DO;
     KEYBUF=KEYREC;
     IF RECORDOUT
       THEN DO;
         UNSPEC(HASHED)=BOOL(UNSPEC(HASHED),ENCODE,'0110'B);
         KWRFIELD = KEYBUF;
         PUT FILE (SYSUT2S) EDIT (RECORDBUF) (A(RECORDSIZE));
         CALL PLIRETC(4);
       END;
       ELSE DO;
         WRITERC = KWWRITE(KEYPTR,SYSUT2D); /* WRITE IT OUT */
         IF WRITERC > 0 THEN DO;
           PUT FILE(SYSPRINT) SKIP EDIT('***** WRITE ERROR *****',
             ACCNT||'.'||USEID,WRITERC) (A,A,X(2),F(5));
           CALL PLIRETC(16);
         END;
         CALL PLIRETC(4);
       END;
   END;
   ELSE CALL PLIRETC(4);
   COUNT=COUNT+1;
  END PUTRCD;

  /* DEFINE THE SORT COLUMNS
         **********************************************
         *          RECORD SIZE DEPENDECY             *
         **********************************************   */

  SORTCMD = ' SORT FIELDS=(4,2,CH,A,1,3,CH,A),FILSZ=E10000 ';
  RECORDCMD = ' RECORD TYPE=F,LENGTH=(240) ' ;
  SORTSTORAGE = 178*1024;  /* SET IT TO 178K */

  ON ERROR CALL PLIDUMP;
  OPEN FILE (SYSPRINT) LINESIZE (132) PAGESIZE (55);

  PARMX=PARM;
  IF PARMX='' THEN DO;
     PARMX='LIST';
     GOTO PARMFOUND;
     END;
  DO I=1 TO 4;
     IF PARMX=PARMVAL(I) THEN GO TO PARMFOUND;
     END;
  PUT FILE (SYSPRINT) SKIP LIST
     (PARMX||': INVALID PARM--LIST ASSUMED.');
  PARMX='LIST';

 PARMFOUND:
  RECORDIN=PARMX='RESTORE';
  ANYOUT=PARMX~='LIST';
  RECORDOUT=PARMX='DUMP';
  LISTKEY='0'B;
  EOFSYSUT1='0'B;
  ENCODE,DECODE=UNSPEC('TTMCCTAG');
  COUNT,TOTSPUSD,TOTSPMAX=0;

  IF RECORDIN
    THEN DO;
      OPEN FILE(SYSUT1S) TITLE ('SYSUT1');
      ON ENDFILE(SYSUT1S) EOFSYSUT1='1'B;
    END;
    ELSE DO;
      OPEN FILE (SYSUT1D) TITLE ('SYSUT1');
      ON ENDFILE(SYSUT1D) EOFSYSUT1='1'B;
    END;

  ON ENDPAGE(SYSPRINT) PUT FILE (SYSPRINT) PAGE EDIT
     ('  USER       BIN      USE   MAX  JOBS','') (A,SKIP(2),A);
  SIGNAL ENDPAGE(SYSPRINT);

  IF ANYOUT THEN
    IF RECORDOUT
      THEN OPEN FILE (SYSUT2S) TITLE ('SYSUT2');
      ELSE OPEN FILE (SYSUT2D) TITLE ('SYSUT2');

     /*   READ AND SORT KEYWORD FILE   */

  CALL PLISRTD(SORTCMD,RECORDCMD,SORTSTORAGE,SORTRC,GETRCD,PUTRCD);

  IF SORTRC > 0 THEN DO;
    PUT FILE(SYSPRINT) EDIT('***** SORT FAILED *****') (A);
  END;

  IF RECORDIN
    THEN CLOSE FILE (SYSUT1S);
    ELSE CLOSE FILE (SYSUT1D);

  IF ANYOUT THEN
     IF RECORDOUT
        THEN CLOSE FILE (SYSUT2S);
        ELSE CLOSE FILE (SYSUT2D);

  ON ENDPAGE(SYSPRINT) SYSTEM;
  PUT FILE (SYSPRINT) SKIP(3) EDIT ('***',COUNT,' USERS.') (A,F(6),A);
  PUT FILE (SYSPRINT) SKIP EDIT ('***',TOTSPUSD,' TRACKS USED,',
     TOTSPMAX,' TRACKS ALLOWED.')  (A,F(6));
  CLOSE FILE (SYSPRINT);
  END KEYDUMP;
*PROCESS AG,A,C,F(I),M,STG;
  /*
    ***************************************************
    *                                                 *
    *         S C I P SMF PROCESSING SYSTEM           *
    *               VERSION I                         *
    *                                                 *
    *         CLASS I - STANFORD PROPRIETARY          *
    *                                                 *
    ***************************************************
                                                      */

    /* $START DOC$  ------------------------------------------

        THIS ROUTINE ACCESSES THE KEYWORD FILE TO OBTAIN RECORDS
        FOR THE CALLER.  AN AREA FOR THE KEYWORD RECORD IS INPUT
        TO THE ROUTINE TO BE USED FOR THE KEYWORD RECORD AS WELL
        AS THE FILE TO BE USED.

        THE FUNCTIONS DEFINED BY THIS ROUTINE ARE AS FOLLOWS:

    1.  KWREAD    -   READ A RECORD FROM THE KEYWORD FILE.

        INPUTS:       ADDRESS OF KEYWORD RECORD TO BE FILLED IN
                      KEYWORD FILE PARAMETER
                      NUMBER OF RECORDS IN THE KEYWORD FILE VIA
                      A COMPILE TIME CONSTANT.

        ALGORITHM:    THE GROUP AND INITIALS FIELD IN THE
                      KEYWORD RECORD ARE USED TO SEARCH THE
                      KEYWORD FILE FOR THE RECORD REQUIRED.
                      THE GROUP AND INITIALS FIELDS ARE USED
                      TO COMPUTE THE STARTING REGION NUMBER
                      OF THE RECORD.  THE FOLLOWING IS DONE
                      THE LAST CHARACTER OF THE GROUP FIELD
                      IS CONCATENATED TO THE INITIALS FIELD
                      TO FORM A 4 CHARACTER INTERMEDIATE
                      VALUE.  THIS VALUE IS CONVERTED TO A
                      INTEGER VIA THE UNSPEC FUNCTION.  THE
                      INTEGER SO DERIVED IS DIVIDED BY THE
                      NUMBER OF RECORDS IN THE KEYWORD FILE
                      AND THE REMAINDER OF THE DIVISION IS USED
                      AS THE STARTING REGION NUMBER.

         OUTPUT:      THE FUNCTION RETURNS FOUR RETURN CODES
                      AS FOLLOWS:
                      0  -  THE RECORD HAS BEEN SUCCESSFULLY
                            READ AND IS NOW AT THE LOCATION
                            SPECIFIED BY KEYPTR.
                      4  -  THE RECORD HAS BEEN SUCCESSFULLY
                            READ AND IS AT THE LOCATION
                            SPECIFIED BY KEYPTR.  HOWEVER THE
                            ACCOUNT HAD THE INVALID BIT FLAG
                            ON WHEN READ.
                      8  -  NO RECORD WAS FOUND IN THE FILE.
                      12 -  THE KEYWORD FILE WAS FULL.
                      16 -  AN UNRECOVERABLE ERROR, EITHER
                            I/O ERROR OR LOGIC ERROR DETECTED.
    2.  KWREPL   -    REPLACE A RECORD IN THE KEYWORD FILE.

     INPUTS:          ADDRESS OF KEYWORD RECORD TO BE FILLED IN
                      AND FILE PARAMETER.  NOTE THAT THIS RECORD
                      MUST HAVE BEEN PREVIOUSLY READ VIA THE
                      KWREAD ROUTINE .

     ALGORITHM:       THE GROUP AND INITIALS FIELD IN THE KEYWORD
                      RECORD ARE USED TO SEARCH THE KEYWORD FILE
                      FOR THE RECORD REQUIRED.  THE SAME HASH
                      TECHNIQUE DESCRIBED IN THE KWREAD ROUTINE
                      IS EMPLOYED.  THE KEY COMPUTED AND THE
                      REGION NUMBER DERIVED DRIVE THE REWRITE
                      OPERATION.

     OUTPUT:          THE FUNCTION RETURNS FIVE RETURN CODES
                      AS FOLLOWS:
                      0  -  THE RECORD HAS SUCCESSFULLY BEEN
                            REPLACED.
                      4  -  (THIS RETURN SHOULD NOT HAPPEN)
                      8  -  (THIS RETURN SHOULD NOT HAPPEN)
                      12 -  THE KEYWORD FILE IS FULL
                      16 -  LOGIC ERROR OR I/O ERROR


    3.  KWWRITE  -    WRITE A NEW RECORD INTO THE KEYWORD FILE

     INPUT:           ADDRESS OF KEYWORD RECORD TO ADD, FILE
                      PARAMETER, NUMBER OF RECORDS IN THE
                      KEYWORD FILE FROM A COMPILE TIME
                      CONSTANT.

     ALGORITHM:       THE GROUP AND INITIALS FIELD IN THE
                      KEYWORD RECORD ARE USED AS THE KEY AND
                      TO GENERATE THE RELATIVE REGION NUMBER
                      OF THE NEW RECORD.  THE GROUP,INITIALS
                      AND KEYWORD ARE ENCODED TO MAINTAIN
                      SOME SEMBLANCE OF SECURITY.  THE RECORD
                      IS THEN WRITTEN INTO THE FILE.

     OUTPUT:          THE FUNCTION RETURN FOUR RETURN CODES
                      AS FOLLOWS:
                      0  -  THE RECORD HAS BEEN WRITTEN
                      4  -  (SHOULD NOT HAPPEN)
                      8  -  THE RECORD ALREADY EXISTS
                      12 -  THE KEYWORD FILE IS FULL
                      16 -  LOGIC OR I/O ERROR. REQUEST NOT
                            DONE.
        ---------------------------------------------  $END DOC$  */

    KWREAD:  PROCEDURE (KEYPTR,KFILE) RETURNS(BINARY FIXED(15));

      DECLARE
        KFILE FILE ,

        ONCODE BUILTIN ;
      DECLARE
        (KEYPTR,INPPTR) POINTER;

      DECLARE
        1  KEYRECORD BASED(KEYPTR),
           %INCLUDE RECORD(KEYREC);

      DECLARE
        KWBUF CHARACTER(KWR_REC_SIZE),
          KWKEY CHAR(KWR_KEY_LEN) DEFINED KWBUF POS(KWR_KEY_POS),
          KWREC CHAR(KWR_REC_LEN) DEFINED KWBUF POS(KWR_REC_POS),
          KWSCRAM CHAR(8) DEFINED KWBUF POS(1),
        REGN# BINARY FIXED(31),
        KWRTRN BINARY FIXED(15),
        RTN_CODE(50:58) BINARY FIXED(15) INITIAL
          (16,8,8,16,16,16,12,12,12),
        (ENCODE,DECODE) BIT(64) ;



    HASH: PROCEDURE(KEYKEY) RETURNS(BINARY FIXED(31));
      DECLARE KEYKEY CHARACTER(KWR_KEY_LEN),
        TEMP CHARACTER(4) ,
        HASH# BINARY FIXED(31) ;

      TEMP = SUBSTR(KEYKEY,KWR_KEY_LEN,1)||SUBSTR(KEYKEY,1,3);
      UNSPEC(HASH#) = UNSPEC(TEMP) ;
      HASH# = MOD(HASH#,KWR_FILE_SIZE) + 1 ;
      /* NOTE THAT THIS KWR_FILE_SIZE SHOULD BE A PRIME OF
         THE FORM 4N-1                                     */
      RETURN (HASH#) ;
    END HASH ;

    ON KEY(KFILE) KWRTRN = RTN_CODE(ONCODE);

      INPPTR = ADDR(KWBUF) ;    /* POINT AT RECORD         */
      KWKEY = INIT||GROUP ;
      REGN# = HASH(KWKEY) ;     /* SELECT REGION NUMBER    */
      KWRTRN = 0 ;
      ENCODE,DECODE=UNSPEC('TTMCCTAG');
      UNSPEC(KWSCRAM)=BOOL(UNSPEC(KWSCRAM),ENCODE,'0110'B);
      READ FILE(KFILE) INTO (KWREC) KEY(KWKEY||REGN#) ;
      IF KWRTRN = 0 THEN
        BEGIN ;
          UNSPEC(KWSCRAM)=BOOL(UNSPEC(KWSCRAM),DECODE,'0110'B);
          KEYPTR->KEYRECORD = INPPTR ->KEYRECORD ;
          IF ~VALID_ACCT THEN KWRTRN = 4 ;
        END ;
      RETURN (KWRTRN) ;

      KWREPL: ENTRY(KEYPTR,KFILE) RETURNS(BINARY FIXED(15));

      ON KEY(KFILE) KWRTRN = RTN_CODE(ONCODE) ;
      ENCODE = UNSPEC('TTMCCTAG') ;
      KWKEY = INIT||GROUP ;
      KWRTRN = 0 ;
      REGN# = HASH(KWKEY) ;
      INPPTR = ADDR(KWBUF) ;   /* POINT AT THE RECORD */
      INPPTR -> KEYRECORD = KEYPTR -> KEYRECORD ;
      UNSPEC(KWSCRAM)=BOOL(UNSPEC(KWSCRAM),ENCODE,'0110'B);
      KWRTRN = 0 ;             /* ASSUME ALL GOES OK */
      REWRITE FILE(KFILE) FROM (KWREC) KEY(KWKEY||REGN#) ;
      RETURN(KWRTRN) ;

      KWWRITE: ENTRY(KEYPTR,KFILE) RETURNS(BINARY FIXED(15));

      ON KEY(KFILE) KWRTRN = RTN_CODE(ONCODE) ;
      ENCODE = UNSPEC('TTMCCTAG') ;
      KWKEY = INIT||GROUP ;
      KWRTRN = 0 ;
      REGN# = HASH(KWKEY) ;     /* POINT AT THE RECORD */
      INPPTR = ADDR(KWBUF) ;
      INPPTR -> KEYRECORD = KEYPTR -> KEYRECORD ;
      UNSPEC(KWSCRAM)=BOOL(UNSPEC(KWSCRAM),ENCODE,'0110'B);
      WRITE FILE(KFILE) FROM (KWREC) KEYFROM(KWKEY||REGN#) ;
      RETURN(KWRTRN) ;
    END KWREAD ;
/*
//GO.SORTWK01 DD UNIT=SYSDA,SPACE=(TRK,(40,40))
//GO.SORTWK02 DD UNIT=SYSDA,SPACE=(TRK,(40,40))
//GO.SORTWK03 DD UNIT=SYSDA,SPACE=(TRK,(40,40))
//GO.SYSOUT   DD SYSOUT=A
//GO.PLIDUMP  DD SYSOUT=A
//GO.SYSUDUMP DD SYSOUT=A
//GO.SYSUT2 DD DSN=WYL.GG.JDN.KEYFILE,DISP=(NEW,CATLG),
//             DCB=(RECFM=F,LRECL=197,BLKSIZE=197,KEYLEN=5),
//             SPACE=(CYL,50,,CONTIG),UNIT=SYSDA,VOL=SER=PUB022
//GO.SYSUT1 DD *,DCB=BLKSIZE=80
ååÜå Å „ ˇˇÏr952r    “      dLOCAL   1181         {bÄí∑ask…  ’Û  –     X
       –k¡ƒ∫ﬁLç 8                                                              
                                                                                
/*
