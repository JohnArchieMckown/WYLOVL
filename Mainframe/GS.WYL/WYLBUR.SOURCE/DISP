DISP     TITLE 'WYLBUR''s Dispatcher'                                           
*******************************************************************             
*                                                                 *             
*     WYLBUR/370 - Release VI - Class I - Stanford Proprietary    *             
*                                                                 *             
*******************************************************************             
         HIBAL                                                                  
*                                                                               
         SYSDEFN ,                 Define installation values                   
*                                                                               
WYLDISP  CSECT                                                                  
*                                                                               
         REGS  FSR,,,,,,JCBR,BR,(WAR,LSR),PAR,PBR,CPR,CVR,SPR,RAR               
*                                                                               
         USING JCB                 Global assumption                            
*                                                                               
DISP     IDENT 2193                15:11:43 07/12/02  (SLP)                     
*                                                                               
XA       EQU   X'80000000'         31-bit addressing mode flag                  
*                                                                               
RSCWAIT  EQU   4                                                                
RSCWRTN  EQU   8                                                                
RSCQJCB  EQU   12                                                               
RSCHAVE  EQU   0                                                                
RSCJCBQD EQU   4                                                                
RSCBUSY  EQU   8                                                                
RSCOK    EQU   0                                                                
*                                                                               
STKCHUNK EQU   16                  Stack allocation multiple                    
HPCHUNK  EQU   8                   Heap allocation multiple                     
*                                                                               
         PUSH  DSECTS                                                           
         COPY  CONTROL             Copy CV/CP                                   
         TITLE 'DSECTS'                                                         
         CVT   DSECT=YES                                                        
         EJECT                                                                  
USERCVT  RECORD 'USERCVT'                                                       
         EJECT                                                                  
         DCBD                                                                   
         EJECT                                                                  
         IHAASCB                                                                
         EJECT                                                                  
         IKJTCB                                                                 
         EJECT                                                                  
         IHAPSA                                                                 
         EJECT                                                                  
         IHAFRRS                                                                
         EJECT                                                                  
         IHASRB                                                                 
         EJECT                                                                  
         IECDIOCM                                                               
         EJECT                                                                  
         IECDIOSB                                                               
IOSBSIZE EQU   IOSEND-IOSB                                                      
         EJECT                                                                  
         COPY  RSCGROUP                                                         
CELLBLOK RECORD BEGIN                                                           
         CELLBLOK DSECT=YES                                                     
         END                                                                    
         EJECT                                                                  
JCB      RECORD BEGIN                                                           
         COPY  JCB                                                              
         END                                                                    
         EJECT                                                                  
UCE      RECORD BEGIN                                                           
         COPY  UCE                                                              
         END                                                                    
         POP   DSECTS                                                           
         EJECT                                                                  
*box                                                                            
*                                                                               
*        Waiting ECB Entry                                                      
*                                                                               
WECB     RECORD BEGIN                                                           
WECBID   DC    C'WECB'                                                          
WECBLINK DC    A(0)                Next WECB ptr                                
WECBJCBP DC    A(0)                Owning JCB ptr                               
WECBECBP DC    A(0)                ECB ptr                                      
         END                                                                    
         EJECT                                                                  
PCB      RECORD BEGIN                                                           
PCBSTART DS    0D                  Reworked, 4/85, Niz                          
*box                                                                            
*                                                                               
*        Page Control Block                                                     
*                                                                               
         DC    CL4'PCB '           Self identification                          
*                                                                               
PCBLINK  DS    A                   Next page buffer (or zero)                   
*                                                                               
PCBBUFP  DS    A                   Data buffer ptr                              
*-                                                                              
*-   The following two DS statements will generate an assembly error            
*-       if CVPINDEX is not equal to the PCB offset to PCBBUFP.                 
*-                                                                              
         DS    0SL2((PCBBUFP-PCBSTART)-CVPINDEX)                                
         DS    0SL2(CVPINDEX-(PCBBUFP-PCBSTART))                                
*                                                                               
PCBQF    DS    A                   Ptr to next buffer on queue                  
PCBQB    DS    A                   Ptr to prev buffer on queue                  
*                                                                               
PCBQCLCK DS    XL8                 Clock when buffer put on queue               
*                                                                               
PCBSFL   FLAG  ,                   Status flags                                 
         FLAG  PCBFLOW             - Buffer has real pages below 16M            
***                                                                             
***  Page ownership information.                                                
***                                                                             
*-                                                                              
*-       A page buffer is owned by a user if PCBPTP is non-zero.                
*-         The PT entry has a pointer to the user's JCB.  There is              
*-         no longer any distinction between an "owned" and "full"              
*-         buffer.                                                              
*-                                                                              
PCBFL    FLAG                                                                   
         FLAG  PCBFIO              - I/O in progress                            
         FLAG  PCBFIOWR            - I/O is a page write                        
         FLAG  PCBFMARK            - Page has been changed                      
         FLAG  PCBFJUNK            - Pageno has been junked                     
         FLAG  PCBFLOCK            - Buffer is locked in this page              
*                                                                               
PCBFL2   FLAG                                                                   
         FLAG  PCBFSYNC            - Synchronous I/O mode                       
*-                                                                              
*-       Because PCBFPOST can be updated by multiple processors                 
*-         (on MP systems) it must be a separate byte flag.  See                
*-         370 POPS notes on multi-cpu considerations for OI, NI                
*-         and XI.  (This avoids using MVS OIL and NIL macros.)                 
*-                                                                              
PCBIOFL  FLAG                                                                   
         FLAG  (PCBFPOST,X'FF',EQ)  - I/O posted complete                       
*                                                                               
PCBPTP   DS    A                   Page Table entry ptr                         
*                                                                               
PCBDEBUG DS    A                   Debugging information                        
*                                                                               
PCBPOSTL DS    A                   I/O completion posted queue                  
PCBXECB  DS    F                   ECB (for sync mode only)                     
*                                                                               
PCBCLEAR EQU   PCBFL,*-PCBFL,C'X'  Ownership fields                             
*-                                                                              
*-       I/O control information.                                               
*-                                                                              
PCBCLCK  DS    XL8                 TOD clock when I/O started                   
*                                                                               
         DS    0D                                                               
PCBSRB   DS    XL(SRBSIZE)         STARTIO SRB                                  
*                                                                               
         DS    0D                                                               
PCBIOSB  DS    XL(IOSBSIZE)        STARTIO IOSB                                 
PCBCOD   EQU   PCBIOSB+(IOSCOD-IOSB),1,C'X'  I/O completion code                
         END                                                                    
         EJECT                                                                  
***                                                                             
***  Page Buffer  (Allocated above the 16M line in MVS/XA)                      
***                                                                             
PBUF     RECORD BEGIN                                                           
         DS    CL4'PBUF'           Self identification                          
PBUFPCBP DS    A                   PCB ptr                                      
*-                                                                              
*-       Channel program area.                                                  
*-         (Format 1 CCW's are used in MVS/XA.)                                 
*-                                                                              
PCCWSECT CCW   X'23',PBUFSECT,X'40',1        .Set Sector (or Nop)               
PCCWSID  CCW   X'31',PBUFSEEK+3,X'40',5      .Search                            
PCCWTIC  CCW   X'08',*-8,0,0                 .Tic *-8                           
PCCWRW   CCW   X'06',PBUFIDAL,X'04',CVPIOSZ  .Read/Write data                   
PCCWS    EQU   PCCWSECT,*-PCCWSECT,C'X'                                         
*                                                                               
PBUFSEEK DS    XL8                 Seek value (MBBCCHHR)                        
PBUFSECT DS    X                   Sector number if RPS device                  
PBUFIDAL DS    ((CVPIOSZ+2047)/2048)A  Indirect Address List                    
*                                                                               
         DS    D                   Reserved                                     
*-                                                                              
*-       I/O buffer starts here.                                                
*-                                                                              
PBUFX    DS    0D                  ********                                     
*-                                                                              
*- System data buffer prefix (copied to the start of the I/O buffer).           
*-                                                                              
PBUFID   DS    CL4                 Page buffer type id                          
PBUFFL   FLAG                                                                   
         FLAG  PBUFFRCV            - This page is needed for rcvy               
         DS    XL3                 Reserved                                     
PBUFSYS  EQU   PBUFID,*-PBUFID,C'X'                                             
         DS    0SL2(L'PBUFSYS-CVPXSZ,CVPXSZ-L'PBUFSYS)  Verify                  
*-                                                                              
*-       User data buffer.                                                      
*-                                                                              
PBUFUSER DS    XL(CVPSZ)           User data buffer                             
PBUFBUF  EQU   PBUFX,*-PBUFX,C'X'  Total I/O buffer                             
*                                                                               
PBUFEND  DS    CL8'PENDBUF'        End of buffer                                
         END                                                                    
         EJECT                                                                  
PFCB     RECORD BEGIN                                                           
         COPY  PFCB                                                             
         END                                                                    
         EJECT                                                                  
PT       RECORD BEGIN              Page Table Entry                             
PTPNO    DS    F                   Page number                                  
PTPFCBP  DS    A                   PFCB ptr                                     
*  Format when PT entry is available (and linked through PFCBAPQH).             
PTFREE   DS    F                   Zero means PT entry is free                  
PTLINKP  DS    A                   Next available PT ptr                        
*  Format when PT entry is in use.                                              
         ORG   PTFREE                                                           
PTJCBP   DS    A                   JCB ptr of owner                             
PTPCBP   DS    A                   PCB ptr (or zero if not in core)             
PTNEXT   EQU   *                                                                
         END                                                                    
*                                                                               
         DS    0SL2(L'PT-16,16-L'PT)                                            
PTSHIFT# EQU   4                   2**PTSHIFT# = L'PT                           
*                                                                               
*                                                                               
         MACRO                                                                  
&L       GETPT &N                  Get PT entry from pageno                     
&L       SLL   &N,PTSHIFT#                                                      
         AL    &N,CVXPTP                                                        
         MEND                                                                   
*                                                                               
         MACRO                                                                  
&L       QBUFON &STCK=YES                                                       
.*                                                                              
.*  Queue a buffer in R4 onto the buffer chain before the pointer               
.*    in R15.  The buffer chains are forward and backward chains to             
.*    make it easy to add or delete members of the chain.                       
.*                                                                              
&L       L     R0,PCBQB-PCB(,R15)  Get back pointer                             
         ST    R4,PCBQB-PCB(,R15)  Set back ptr to new entry                    
         STM   R15,R0,PCBQF-PCB(R4)  Set ptrs for new entry                     
         LR    R15,R0              Put ptr is reg for index                     
         ST    R4,PCBQF-PCB(,R15)  Set for ptr of prev to new                   
         AIF   ('&STCK' NE 'YES').EXIT                                          
         STCK  PCBQCLCK-PCB(R4)    Save TOD when buffer put on queue            
.EXIT    MEND                                                                   
*                                                                               
         MACRO                                                                  
&L       QBUFOFF                                                                
.*                                                                              
.*  Dequeue the buffer in R4 from its current queues by updating                
.*    the forward and backward pointers of the entries pointed to               
.*    by this entry.                                                            
.*                                                                              
&L       L     R15,PCBQF-PCB(,R4)  Get forward entry                            
         L     R1,PCBQB-PCB(,R4)   Get backward entry                           
         ST    R15,PCBQF-PCB(,R1)  Update forw entry of prev                    
         ST    R1,PCBQB-PCB(,R15)  Update back entry of next                    
*                                                                               
         CLEAR R1                                                               
         ST    R1,PCBQF-PCB(,R4)   No forward ptr                               
         ST    R1,PCBQB-PCB(,R4)   No backwards ptr                             
         MEND                                                                   
         TITLE 'WYLBUR''s Dispatcher'                                           
WYLDISP  CSECT                                                                  
*                                                                               
*box                                                                            
*                                                                               
*  DISPINIT -- Routine to initialize dispatcher.                                
*    (Called from INIT at initialization.)                                      
*                                                                               
DISPINIT XPROC                                                                  
*-                                                                              
*-       If we are running with memory pages only then we will                  
*-         never need to reference the PFCBs (or PTs).  As a                    
*-         safety measure, we clear the pointer to the PFCB here.               
*-                                                                              
         IF    CVFMEMPAGE,BEGIN    Memory pages only...                         
         CLEAR CVFPFCB,CVLPFCB,CVSPFCB  No PFCBs                                
         CLEAR (CVEMBUFQ,8),(CVBUFQ,8)  No buffer queue either                  
         CLEAR CVMAXPNO            No max pageno                                
         END                                                                    
*                                                                               
         ELSE BEGIN                                                             
*-                                                                              
*-                                                                              
*-       Fix STARTIO appendage.                                                 
*-                                                                              
         SETMSG L:=A(IOFIX),L:=A(IOFIXEND-IOFIX)                                
         ACALL FIX                 Fix STARTIO termination routine              
*                                                                               
         SETMSG CV,LH:=AL2(CVSIZE)                                              
         ACALL FIX                 Fix CV (ref'd by appendage)                  
*-                                                                              
*-       Allocate page table.                                                   
*-                                                                              
         CLEAR R5                  Total page count                             
         L     R6,CVFPFCB                                                       
         WHILE (R6,LT,CVLPFCB),BEGIN  Go through PFCBs...                       
         WITH  (PFCB,R6)                                                        
         ST    R5,PFCBFPNO         Save first pageno in PFCB                    
         A     R5,PFCBNP           Accumulate total page count                  
         LA    R6,PFCBNEXT                                                      
         END                                                                    
         ST    R5,CVMAXPNO         Save maximum page number                     
*                                                                               
         MH    R5,=AL2(L'PT)       Page table size                              
         LR    R0,R5                                                            
         GETMAIN RU,LV=(0),LOC=ANY  Get page table                              
         ST    R1,CVPTP            Save page table ptr                          
         SH    R1,=AL2(L'PT)       Calc virtual origin                          
         ST    R1,CVXPTP           Save page table - L'PT origin                
         ZOT   L:CVPTP,(R5)        Initialize all PT entries                    
*-                                                                              
*-       Set page numbers in page table entries.                                
*-                                                                              
         LA    R4,1                Starting page number                         
         L     R5,CVPTP            Starting PT entry                            
         WHILE (R4,LE,CVMAXPNO),BEGIN   Go through entries...                   
         WITH  (PT,R5)                                                          
         ST    R4,PTPNO            Set page number                              
*                                                                               
         LA    R5,PTNEXT           Next PT entry                                
         LA    R4,@R4+1            Next page number                             
         END                                                                    
*-                                                                              
*-       Link up page table entries.                                            
*-                                                                              
         L     R5,CVPTP            Page Table start (for loop)                  
         L     R6,CVFPFCB                                                       
         WHILE (R6,LT,CVLPFCB),BEGIN  Go through PFCBs...                       
         WITH  (PFCB,R6)                                                        
*                                                                               
         LT    R0,PFCBNP           Number of pages                              
         IF    POS,BEGIN           Build PT for pages...                        
         ST    R5,PFCBAPQH         First available PT ptr                       
*                                                                               
         LR    R2,R5                                                            
         L     R3,PFCBNP           Number of pages                              
         DECR  R3                  Minus one (omit last PT)                     
         MH    R3,=AL2(L'PT)                                                    
         AR    R3,R2               Last PT                                      
*                                                                               
         WHILE (R2,LT,R3),BEGIN    Link available PTs...                        
         WITH  (PT,R2)                                                          
         ST    R6,PTPFCBP          Save PFCB ptr                                
         CLEAR PTFREE              Indicate free                                
         LA    R15,PTNEXT          Next PT                                      
         ST    R15,PTLINKP         Set forward ptr                              
         LR    R2,R15                                                           
         END                                                                    
*                                                                               
         WITH  (PT,R3),BEGIN       Fix up last PT...                            
         ST    R6,PTPFCBP          Save PFCB ptr                                
         CLEAR PTFREE              Indicate free                                
         CLEAR PTLINKP             No forward ptr                               
*                                                                               
         LA    R5,PTNEXT           First PT entry for next PFCB                 
         END                                                                    
         END                                                                    
*                                                                               
         LA    R6,PFCBNEXT         Next PFCB ptr                                
         END                                                                    
*-                                                                              
*-       Initialize buffer queue pointers.                                      
*-                                                                              
         LA    R1,CVEMBUFQ-(PCBQF-PCB)  Set                                     
         LR    R0,R1               Empty buffer                                 
         STM   R0,R1,CVEMBUFQ      Queue empty                                  
*                                                                               
         LA    R1,CVBUFQ-(PCBQF-PCB)  Set                                       
         LR    R0,R1               Buffer                                       
         STM   R0,R1,CVBUFQ        Queue empty                                  
*-                                                                              
*-       Now get the desired number of page buffers.                            
*-                                                                              
         LH    R2,CVNIPG           Number of pages to get initially             
         IF    (R2,NEG),'LH R2,CVPGMAX'  Get maximum number of pages            
         WHILE (R2,POS),BEGIN      Get page buffers...                          
         ACALL GETPCB              Allocate/initialize a page buffer            
         DECR  R2                                                               
         END                                                                    
         END                                                                    
*                                                                               
*  Initialize the stack and heap cell blocks                                    
*                                                                               
         LA    R1,CVSTACK#         Max stack (in K)                             
         CLEAR R0                                                               
         LA    R2,STKCHUNK         Stack allocation mult (in K)                 
         DR    R0,R2               Number of cell blocks needed                 
         IF    (R0,NZ),'LA R1,1(,R1)'                                           
         LR    R3,R1               Save for loop                                
         M     R0,=A(L'CELLBLOK)                                                
         GETMAIN RU,LV=(1),LOC=ANY  Get cell blocks                             
         LR    R6,R1               Copy address                                 
         ST    R1,CVSTKCEL         Save it in the CV                            
         LR    R1,R2               Get stack quantum                            
         M     R0,=F'1024'         Convert to bytes in R1                       
         LR    R2,R1               Save size quantum for loop                   
         WHILE (R3,GT,0),BEGIN                                                  
         WITH  (CELLBLOK,R6)                                                    
         MVC   CELLBLOK,MODLCELL                                                
         ST    R1,CELSIZE                                                       
         AR    R1,R2                                                            
         BCTR  R3,0                                                             
         LA    R6,L'CELLBLOK(,R6)                                               
         END                                                                    
*                                                                               
         LA    R1,CVHEAP#          Max allocation (in K)                        
         CLEAR R0                                                               
         LA    R2,HPCHUNK          Allocation mult (in K)                       
         DR    R0,R2               Number of cell blocks needed                 
         IF    (R0,NZ),'LA R1,1(,R1)'                                           
         LR    R3,R1               Save for loop                                
         M     R0,=A(L'CELLBLOK)                                                
         GETMAIN RU,LV=(1),LOC=ANY  Get cell blocks                             
         LR    R6,R1               Copy address                                 
         ST    R1,CVHEAPCL         Save it in the CV                            
         LR    R1,R2               Get stack quantum                            
         M     R0,=F'1024'         Convert to bytes in R1                       
         LR    R2,R1               Save size quantum for loop                   
         LA    R0,45               Subpool for heap blocks                      
         WHILE (R3,GT,0),BEGIN                                                  
         WITH  (CELLBLOK,R6)                                                    
         MVC   CELLBLOK,MODLCELL                                                
         ST    R0,CELSUBP                                                       
         ST    R1,CELSIZE                                                       
         AR    R1,R2                                                            
         BCTR  R3,0                                                             
         LA    R6,L'CELLBLOK(,R6)                                               
         END                                                                    
         PEND                                                                   
MODLCELL CELLBLOK SIZE=1,SUBPOOL=40                                             
         QLTORG ,                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  Start up after initialization.                                               
*                                                                               
         ENTRY STARTUP                                                          
STARTUP  BASE                                                                   
         CLEAR CPR                 No CP yet                                    
*                                                                               
         IF    CVFRCVY,'XTRACE STARTUPR'                                        
         ELSE  'XTRACE STARTUP'                                                 
*                                                                               
         L     R0,=A(TIMESUP)      Put exit addr in R0                          
         L     R1,=A(TIMEVAL)      Put interval address in R1                   
         STIMER TASK,(0),TUINTVL=(1)  Start timer                               
         STCK  CVCLOCK             Save time of start                           
*                                                                               
         CLEAR CVOLDJCB,CVCURJCB   No current user                              
*-                                                                              
*-       Jump into the dispatcher.                                              
*-                                                                              
         BASE  BASE                Reset base for search                        
*-                                                                              
*-       If recovery mode wasn't set before no one will be on the               
*-         SETUPQ, and it will get reset.                                       
*-                                                                              
         SET   CVFRCVY             Set recovery mode                            
         B     SEARCH                                                           
*                                                                               
         DROP  BR                                                               
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
BASE     LABEL ,                   Base point for dispatcher                    
*-                                                                              
*-       Entry to dispatcher                                                    
*-                                                                              
         ENTRY DISPATCH                                                         
DISPATCH BASE                                                                   
         BASE  BASE                Common base                                  
         CLEAR CVSPIEAD            Make sure SPIE intercept is zero             
*                                                                               
         XTRACE UNDISP,REGS=RAR                                                 
*-                                                                              
*-       Verify that we are still in 31-bit mode.                               
*-                                                                              
         BASR  R15,0               Sets high bit if AMODE 31                    
         LTR   R15,R15             Are we or aren't we?                         
         IF    ^NEG,BEGIN          Not in 31-bit mode...                        
         IF    ^CVFXA31,EXIT       It's cool, scram                             
         KAPUT AMODERR,'AMODE logic error.'                                     
         END                                                                    
*                                                                               
         L     R8,CVDSTK           Use dispatcher                               
         LR    R13,R8              ... stack                                    
*                                                                               
         L     JCBR,CVCURJCB                                                    
*                                                                               
         FAIL  (CP,NE,'CP'),CPERR1,'Dispatcher CP error.'                       
*-                                                                              
*-       Stop charging the user now that we are in the dispatcher.              
*-                                                                              
         ACALL GETCPU              Get time used during this disp.              
         IF    CVFVISTA,'CLEAR R0'  !! BECAUSE VLOGON DOES WAITS !!!            
         LR    R15,R0                                                           
         LR    R1,R0                                                            
*                                                                               
         AL    R0,JCBWCPU          Accumulate total user CPU time               
         ST    R0,JCBWCPU                                                       
*                                                                               
         LT    R2,JCBUCEP          Get current charge component ptr             
         IF    NZ,BEGIN            Accumulate sub-totals...                     
         WITH  (UCE,R2)                                                         
         AL    R1,UCEWCPU          Accumulate component CPU time                
         ST    R1,UCEWCPU                                                       
         END                                                                    
*                                                                               
         AL    R15,CVTIME          Global total user CPU time                   
         ST    R15,CVTIME                                                       
*                                                                               
         SET   CVFDISP             Now running in dispatcher mode               
*                                                                               
         IF    CVFPGROT,'ACALL PDEBUG'  Jumble page ptrs                        
*-                                                                              
*-       Finish un-dispatching this user.                                       
*-                                                                              
*                                                                               
         FAIL  ^JCBAFRUN,DISPERR1,'Dispatcher error.'                           
         CLEAR JCBAFRUN            No longer running                            
         CLEAR JCBFATTNFREE        Reset dispatch reason flag                   
*                                                                               
         STCK  CVDSPCLK            Current TOD clock (GMT)                      
         VCALL LOCALTOD                                                         
         STM   R0,R1,CPCLCK        Update user's current TOD clock              
*-                                                                              
*-       Put user's pages back on buffer queue.                                 
*-                                                                              
         LT    R15,JCBPTA          Get page ptr                                 
         IF    NZ,BEGIN            There is a page...                           
         CLEAR (CPREGS+(PAR*4),4)  (This address is re-calc'd later)            
         WITH  (PT,R15),'L R4,PTPCBP'                                           
*-                                                                              
*-       We have to allow for the case when the PCB (buffer) is not             
*-       yet allocated; since PGETA will SETUP a user this way and              
*-       then un-dispatch and dispatch the user to get the                      
*-       dispatcher to do the page-in.                                          
*-                                                                              
*-       We only have to allow for this for PAR; since this logic               
*-       is only used by PGETA.                                                 
*-                                                                              
         IF    (R4,Z),EXIT         Buffer isn't allocated, scram                
*                                                                               
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR01,'Dispatcher PCB error.'                  
         FAIL  (PCBQF,NZ),DISPERR2,'Dispatcher error.'                          
*-                                                                              
*-       We also have to allow for the case when the PCB (buffer)               
*-       has I/O going on it; PGETA will SETUP a user this way.                 
*-                                                                              
*-       We only have to allow for this for PAR; since this logic               
*-       is only used by "PGETA".                                               
*-                                                                              
         IF    PCBFIO,EXIT         I/O going, scram                             
*                                                                               
         LA    R15,CVBUFQ-(PCBQF-PCB)  Dummy first link                         
         QBUFON ,                  Put buffer back on queue                     
         END                                                                    
*                                                                               
         LT    R15,JCBPTB          Get page ptr                                 
         IF    NZ,BEGIN            There is a page...                           
         CLEAR (CPREGS+(PBR*4),4)  (This address is re-calc'd later)            
         IF    (R15,EQ,JCBPTA),EXIT  Already taken care of, scram               
         WITH  (PT,R15),'L R4,PTPCBP'                                           
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR02,'Dispatcher PCB error.'                  
         FAIL  (PCBQF,NZ),DISPER2X,'Dispatcher error.'                          
         FAIL  PCBFIO,DISPER3X,'Dispatcher error.'                              
*                                                                               
         LA    R15,CVBUFQ-(PCBQF-PCB)  Dummy first link                         
         QBUFON ,                  Put buffer back on queue                     
         END                                                                    
*-                                                                              
*-       Save the user's current stack.                                         
*-                                                                              
         LT    R2,CPREGS+(R13*4)   Current stack                                
         IF    NZ,BEGIN                                                         
         S     R2,CVSTACK          Size of user stack                           
         FAIL  NEG,STKERR1,'Stack logic error.'                                 
         END                                                                    
*                                                                               
         IF    (R2,GT,CVSTACKL),BEGIN  Stack overflow...                        
         CLEAR R2                                                               
         ST    R2,CPREGS+(R13*4)   No stack now                                 
         MVC   CPREGS+(R14*4)(4),=V(STKOVER)  Stack ovfl                        
         END                                                                    
*-                                                                              
*-       Note: changing the stack "chunk" size from 4K to 16K                   
*-         (below) was a big performance improvement.  1/90, Niz                
*-                                                                              
         LR    R3,R2                                                            
         A     R3,=A((STKCHUNK*1024)-1)                                         
         N     R3,=A(-(STKCHUNK*1024))                                          
*                                                                               
         LT    R0,JCBSTKX          Stack memory len                             
         IF    (R0,NE,R3),BEGIN    Stack size has changed...                    
         ACALL RELSTACK            Release the old stack                        
         IF    (R3,NZ),BEGIN       Get new stack memory...                      
         LR    R0,R3                                                            
         ACALL GETSTACK                                                         
         END                                                                    
         END                                                                    
*                                                                               
         IF    (R2,NZ),BEGIN       Save user stack...                           
         MOVEL L:JCBSTKX+4,L:CVSTACK,(R2)  Save stack                           
         END                                                                    
         ST    R2,JCBSTKL          Save actual stack length                     
*-                                                                              
*-       Save the user's current heap.                                          
*-                                                                              
         LT    R2,CPHEAPCR         Current heap                                 
         IF    NZ,BEGIN                                                         
         S     R2,CVHEAP           Size of user heap                            
         FAIL  NEG,HEAPERR1,'Heap logic error.'                                 
         END                                                                    
*                                                                               
         FAIL  (R2,GT,CVHEAPL),HEAPERR2,'Heap logic error.'                     
*                                                                               
         LR    R3,R2                                                            
         A     R3,=A((HPCHUNK*1024)-1)                                          
         N     R3,=A(-(HPCHUNK*1024))  Quantize heap to 8K chunks               
*                                                                               
         LM    R0,R1,JCBHEAPX      Heap memory len, loc                         
         IF    (R0,NE,R3),BEGIN    Heap size has changed...                     
         IF    (R0,NZ),'ACALL RELHEAP'                                          
         IF    (R3,NZ),BEGIN       Get new heap memory...                       
         LR    R0,R3                                                            
         ACALL HEAPGET                                                          
         END                                                                    
         END                                                                    
*                                                                               
         IF    (R2,NZ),BEGIN       Save user heap...                            
         MOVEL L:JCBHEAPX+4,L:CVHEAP,(R2)  Save heap                            
         END                                                                    
         ST    R2,JCBHEAPL         Save actual heap length                      
*-                                                                              
*-       Switch to dispatcher mode (CURJCB=0).                                  
*-                                                                              
         MVC   CVOLDJCB,CVCURJCB   Save previous user's JCB ptr                 
         CLEAR CVCURJCB            Running in dispatcher mode                   
         EJECT                                                                  
*-                                                                              
*-       We are now in dispatcher mode (CVCURJCB=0) and using                   
*-         the dispatcher's stack.                                              
*-                                                                              
         ENTRY DISPCONT                                                         
DISPCONT BASE                                                                   
         BASE  BASE                                                             
*-                                                                              
*-       While we were in dispatcher mode we queued some DEBUGGING              
*-          messages; handle starting up the debugger line now.                 
*-                                                                              
         IF    CVFDEBUGIO,BEGIN    DEBUG messages waiting...                    
         CLEAR CVFDEBUGIO          Reset                                        
         VCALL DEBDISP             Dispatch debugger now                        
         END                                                                    
*-                                                                              
*-       Start global checkpoint I/O if needed.                                 
*-                                                                              
DISPCHIO BEGIN ,                   CHECKPOINT I/O CHECKS                        
*-                                                                              
*-       Wait until at least 10 seconds have elapsed before writing             
*-         out the checkpoint record again.                                     
*-                                                                              
*-       CAUTION: Treat all halfword values as unsigned 16 bit                  
*-                integers.                                                     
*-                                                                              
         L     R15,CVDSPCLK        Current time (lsb is seconds)                
         SL    R15,CVCHKCLK        No. of seconds since last                    
         IF    (R15,LLT,10),EXIT   Keep waiting, scram                          
         IF    (CVCHKUC,EQ,CVCHKPUC),EXIT    CHECKPOINT NOT NEEDED              
         IF    CVFNCHK,EXIT                  NO CHECKPOINTING                   
         IF    CVCHKECB.X'80',EXIT           I/O NOT COMPLETE                   
         IF    (CVCHKECB,Z),EXIT             I/O NOT COMPLETE                   
         IF    (CVCHKECB.X'7F',MIXED),BEGIN  I/O ERROR OCCURRED                 
*-                                                                              
*-       An error has occurred during checkpoint I/O.  Inform                   
*-       console and then disable further attempts at checkpoint                
*-       I/O.                                                                   
*-                                                                              
         SET   CVFNCHK             Disable further checkpointing                
         SEGDEF L:CVWTOSGP         Load and define console segcb                
         SEG   'I/O error on checkpoint record, '                               
         SEG   'checkpointing disabled.'                                        
         SET   CVWTOFACTION        Make it an action message                    
         XWTO  ,                   Issue message to console                     
         SEGDEF DUMMY              Safety disable                               
         CLEAR CVWTOFACTION        Clear action message                         
         EXIT  DISPCHIO            Exit checkpoint i/o process                  
         END   ,                                                                
*                                                                               
         MVC   CVCHKPUC,CVCHKUC    Update count                                 
         MVC   CVCHKCLK,CVDSPCLK   Current time                                 
*                                                                               
         L     R14,CVCHKBUF        Checkpoint i/o buffer address                
         LA    R15,L'CVCHKPFX      Length of chkpt prefix                       
         LA    R0,CVCHKPFX         Address of prefix                            
         LR    R1,R15              Copy length                                  
         MVCL  R14,R0              Move in prefix                               
         L2    R15,CVCHKTLN        Length of checkpoint table                   
         L     R0,CVCHKTAB         Address of checkpoint table                  
         LR    R1,R15              Copy length                                  
         MVCL  R14,R0              Move in initial table                        
         LA    R15,L'CVCHKSFX      Length of suffix                             
         LA    R0,CVCHKSFX         Address of suffix                            
         LR    R1,R15              Copy length                                  
         MVCL  R14,R0              Copy in suffix                               
         SPACE ,                                                                
         CLEAR CVCHKECB            Clear Checkpoint I/O ECB                     
         L     R1,CVCHKIOB                                                      
         EXCP  (1)                 Start new checkpoint I/O                     
         INCR  R15,CVCHKNIO                                                     
         END                                                                    
         EJECT                                                                  
*-                                                                              
*-       Process posts.                                                         
*-                                                                              
SEARCH   CLEAR R15                                                              
         ST    R15,CVECB           Reset main ECB                               
*-                                                                              
*-       Process MILTEN posts.                                                  
*-                                                                              
         VCALL MILPOST             Check out MILTEN posts                       
*-                                                                              
*-       Process resource group posts.                                          
*-                                                                              
         LM    R3,R5,CVRSG         Load the rsg ptr                             
         USING RSCGROUP,R3                                                      
SRCHLOOP IF    RSG1ACTV,BEGIN                                                   
         LA    R2,RSGQACFW-(RSC@NEXT-RESOURCE)                                  
         USING RESOURCE,R2                                                      
         WHILE (R2,NE,RSGQACBK),BEGIN                                           
         L     R2,RSC@NEXT         Get next                                     
         IF    RSC1ACTV,BEGIN      Only look at active rscs                     
         LA    R1,RSC$ECB          Assume ECB (not ECB addr)                    
         IF    RSC1@ECB,'L R1,RSC$ECB'                                          
         TM    @R1,X'40'           Is it posted?                                
         IF    NZ,BEGIN                                                         
         LT    RAR,RSG@POST        Is there a post routine?                     
         IF    NZ,BEGIN                                                         
         LR    R0,R2               Copy rsc pointer                             
         LR    R1,R3               Copy rscgroup ptr                            
         BASR  RAR,RAR                                                          
         END   ELSE,BEGIN                                                       
         CLEAR RSC1ACTV            No longer active                             
         L     JCBR,RSC@JCB        Get JCB pointer                              
         CLEAR (JCBWFL,JCBWFSIZ)   Post caller (clear wait flgs)                
         IF    ^JCBAPDSP,'SETUP (JCBR)'                                         
         END                                                                    
         END                                                                    
         END                                                                    
         END                                                                    
         END                                                                    
         BXLE  R3,R4,SRCHLOOP      Loop through groups                          
         DROP  RSCGROUP,RESOURCE                                                
*-                                                                              
*-       Process timer posts.                                                   
*-                                                                              
         SET   CVLOCK1.CVL1TQJ,MODE=LOCKED,REF=CV   Lock to run q               
TIMRPOST IF    ('LT JCBR,CVTIMRQ',NZ),BEGIN  Someone posted...                  
         L     R15,JCBTIMQL        Next entry                                   
         CS    JCBR,R15,CVTIMRQ    Dequeue this entry                           
         BNZ   TIMRPOST            Try again                                    
*                                                                               
         CLEAR JCBTIMID            Reset timer id                               
         MVC   JCBTIMQL,=F'-1'     Reset timer queue link ptr                   
*                                                                               
         IF    JCBFTBRK,BEGIN      We want to TBREAK...                         
         CLEAR JCBFTBRK            Neatness                                     
         LH    R0,JCBSEQ           Our session number                           
         VCALL TBREAK              Interrupt read                               
         B     TIMRPOST            Loop back                                    
         END                                                                    
*                                                                               
         CLEAR (JCBWFL,JCBWFSIZ)   Clear wait flags                             
         IF    ^JCBAPDSP,'SETUP (JCBR)'  Post caller                            
         B     TIMRPOST                                                         
         END                                                                    
         CLEAR CVLOCK1.CVL1TQJ,MODE=LOCKED,REF=CV   Unlock when done            
*-                                                                              
*-       Process user ECBs which have been posted.                              
*-                                                                              
WECBCHK  CLEAR R4                  No previous WECB yet                         
         LA    R5,CVWECBQH-(WECBLINK-WECB)  Dummy queue head                    
         LOOP  BEGIN                                                            
         WITH  (WECB,R5)                                                        
         WHILE ('LT R5,WECBLINK',NZ)                                            
         L     R2,WECBECBP                                                      
         IF    @R2.X'40',BEGIN     ECB has been posted...                       
         L     JCBR,WECBJCBP       This user's JCB ptr                          
         CLEAR (JCBWFL,JCBWFSIZ)   Clear wait flags                             
         IF    ^JCBAPDSP,'SETUP (JCBR)'  Post caller                            
*                                                                               
         IF    (R4,Z),'MVC CVWECBQH,WECBLINK'  New queue head                   
         ELSE  'MVC @R4+(WECBLINK-WECB)(4),WECBLINK'  Dequeue us                
         IF    (WECBLINK,Z),'ST R4,CVWECBQT'  New queue tail                    
*                                                                               
         MVC   WECB(4),=C'FECB'    Zap control block ID                         
         MVC   WECBLINK,=F'-1'     Safety                                       
         LA    R1,WECB                                                          
         VCALL FREECORE            Free WECB                                    
         B     WECBCHK             Restart from the top                         
         END                                                                    
*                                                                               
         LR    R4,R5               Save previous WECB ptr                       
         END                                                                    
*-                                                                              
*-       Call external post routines.                                           
*-                                                                              
         LR    R2,CPR                                                           
         CLEAR CPR                 (Safety)                                     
*                                                                               
         VCALL PATHPOST            User paths                                   
         VCALL NPATPOST            Network connections                          
*                                                                               
         IF    ('LT R15,CVVTAMQH',NZ),'VCALL VTAMDISP'  VTAM stuff              
*                                                                               
         LR    CPR,R2                                                           
*-                                                                              
*-       Process the completion of any page I/O.                                
*-                                                                              
*-       Important note:  This is a bit subtle, the following line              
*-         must be "CVPOSTQH,NE,=F'0'" and not "CVPOSTQH,NZ"                    
*-         because we need to avoid doing an OC instruction on                  
*-         memory that may be updated by multiple CPUs.                         
*-                                                                              
         IF    (CVPOSTQH,NE,=F'0'),'ACALL PIODONE'  Page I/O done               
*-                                                                              
*-       Write out really old changed pages.                                    
*-                                                                              
         L     R15,CVDSPCLK                                                     
         S     R15,CVOLDCLK        Calc elapsed seconds                         
         IF    (R15,LGE,2),BEGIN   Every 2 seconds...                           
         MVC   CVOLDCLK,CVDSPCLK   Update periodic clock                        
         ACALL CHECKOUT            Do required checkpointing                    
         END                                                                    
*-                                                                              
*-       Setup any ready users.                                                 
*-                                                                              
         L     R5,=V(SETRSG)       Get the setup resource group ptr             
         USING RSCGROUP,R5                                                      
         IF    RSG1QUED,BEGIN      Skip if noone is setupable                   
         B     SETNXT              Go enter loop                                
         LOOP  BEGIN                                                            
         L     JCBR,JCBQF          Get next JCB                                 
         ACALL ALLOC               Go allocate his pages                        
         IF    NZ,TRYRUN           Br allo failed                               
         CLEAR JCBWFRSC            No longer waiting for rsc                    
         DQJCB (JCBR)              Take off of setup queue                      
         LTH   R0,JCB#PIO          Check for queue                              
         IF    NZ,'PAGEQ (JCBR)'   On pageio queue                              
         ELSE  BEGIN               Add user to RUN queue...                     
         RUNQ  (JCBR)                                                           
         INCR  R15,CVRUNCUR        Kick run queue depth                         
         END                                                                    
*                                                                               
SETNXT   LA    JCBR,RSGQJCFW-(JCBQF-JCBSTART)  Point at first                   
         UNTIL (JCBR,EQ,RSGQJCBK),END  Repeat until empty                       
         CLEAR RSG1QUED            No longer queued                             
         END                                                                    
         DROP  RSCGROUP                                                         
*-                                                                              
*-       Run first user on run queue.                                           
*-                                                                              
         USING RSCGROUP,R5                                                      
TRYRUN   L     R5,=V(RUNRSG)       Get run resource                             
         IF    RSG1QUED,BEGIN      Anyone queued?                               
         L     JCBR,RSGQJCFW       Get first on queue                           
         LA    R3,RSGQJCFW-(JCBQF-JCB)                                          
         DECR  R15,CVRUNCUR        Decrement run queue depth                    
         DQJCB (JCBR)              Take off of runq                             
         IF    (R3,EQ,RSGQJCFW),'CLEAR RSG1QUED'                                
         CLEAR JCBAPDSP            No longer pending dispatch                   
         CLEAR JCBWFRSC            No wait for resource                         
*-                                                                              
*-       New user just logged on.                                               
*-                                                                              
         LT    CPR,JCBCPX          User's CP                                    
         IF    Z,BEGIN             New user just logged on...                   
         ST    JCBR,CVCURJCB       Current JCB                                  
         ST    JCBR,CVOLDJCB       Set old JCB too                              
*                                                                               
         VCALL GETCP               Get a new CP                                 
         ST    CPR,JCBCPX          Save CP ptr                                  
*                                                                               
         L     R14,=V(INITUSER)    Entry point for a new user                   
         ST    R14,CPREGS+(R14*4)  Set dispatch addr                            
         ST    CPR,CPREGS+(CPR*4)  Save our CP ptr                              
         ST    CVR,CPREGS+(CVR*4)  Save CV ptr                                  
         B     GORUN               Go run users                                 
         END                                                                    
*-                                                                              
*-       Run the user.                                                          
*-                                                                              
         LT    R15,JCBDSPP                                                      
         IF    NZ,BEGIN            Another user is waiting...                   
         CLEAR JCBDSPP             Reset ptr                                    
         WITH  (JCB,R15)                                                        
         CLEAR JCBWFDSP            No longer waiting                            
         LTH   R0,JCBWFL           Ok to setup?                                 
         IF    Z,BEGIN             Setup if so                                  
         LT    R0,JCBQF            Already queued?                              
         FAIL  NZ,RUNERR1,'JCB RUNQ logic error'                                
         SETUP (R15)               Setup JCB                                    
         END                                                                    
         END                                                                    
*                                                                               
         ST    JCBR,CVCURJCB       We are the current user                      
*-                                                                              
*-       For test systems zap stack/heap/dir on every dispatch to               
*-         help flush out logic errors that might only occur under              
*-         load otherwise.                                                      
*-                                                                              
         IF    CVFPGROT,BEGIN      It's a test system...                        
         L     R0,CVSTACK                                                       
         L     R1,CVSTACKL                                                      
         CLEAR R14                                                              
         L     R15,=A(X'81000000')                                              
         MVCL  R0,R14              Zap current stack                            
*                                                                               
         L     R0,CVHEAP                                                        
         L     R1,CVHEAPL                                                       
         CLEAR R14                                                              
         L     R15,=A(X'81000000')                                              
         MVCL  R0,R14              Zap current heap                             
*                                                                               
         MVC   CVOLDJCB,=F'-1'     Force "different user" logic                 
         END                                                                    
*-                                                                              
*-       Dispatching a different user than last time.                           
*-                                                                              
         L     CPR,JCBCPX          Get user's CP ptr                            
         FAIL  (CP,NE,'CP'),CPERR2,'Dispatcher CP error.'                       
*                                                                               
         IF    (JCBR,NE,CVOLDJCB),BEGIN  Dispatching diff user...               
         ST    JCBR,CVOLDJCB       Set old JCB too                              
*-                                                                              
*-       Restore user's stack.                                                  
*-                                                                              
         IF    ('LT R2,JCBSTKL',NZ),BEGIN                                       
         MOVEL L:CVSTACK,L:JCBSTKX+4,(R2)  Restore stack                        
         END                                                                    
*-                                                                              
*-       Restore user's heap.                                                   
*-                                                                              
         IF    ('LT R2,JCBHEAPL',NZ),BEGIN                                      
         MOVEL L:CVHEAP,L:JCBHEAPX+4,(R2)  Restore heap                         
         END                                                                    
         END                                                                    
*                                                                               
*                                                                               
GORUN    INCR  R15,CVNDISP         Count number of dispatches                   
*-                                                                              
*-       Fix up page registers if they currently have pages in them.            
*-                                                                              
         LT    R15,JCBPTA          Is there a page A?                           
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R15),'L R15,PTPCBP'                                          
         WITH  (PCB,R15)                                                        
         FAIL  (PCB,NE,'PCB'),PCBERR03,'Dispatcher PCB error.'                  
         FAIL  PCBFIO,DISPERX2,'Dispatcher error.'                              
         MVC   CPREGS+(PAR*4)(4),CVPINDEX(R15)  Update PAR                      
         END                                                                    
*                                                                               
         LT    R15,JCBPTB          Is there a page B?                           
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R15),'L R15,PTPCBP'                                          
         WITH  (PCB,R15)                                                        
         FAIL  (PCB,NE,'PCB'),PCBERR04,'Dispatcher PCB error.'                  
         FAIL  PCBFIO,DISPERX4,'Dispatcher error.'                              
         MVC   CPREGS+(PBR*4)(4),CVPINDEX(R15)  Update PBR                      
         END                                                                    
*                                                                               
*                                                                               
*************************                                                       
***  User is running  ***                                                       
*************************                                                       
*                                                                               
*  Start user CPU time clock.                                                   
*                                                                               
         ACALL GETCPU              Go get CPU time                              
         ST    R1,CVRCPUTM         Save start cpu time                          
         CLEAR CVFDISP             Now running in user mode                     
*-                                                                              
*-       Restore user registers and warp out.                                   
*-                                                                              
         LM    R0,R15,CPREGS       Pick up user regs                            
         XTRACE DISP,REGS=RAR      ********                                     
         BR    RAR                 Return to user                               
         END                                                                    
*                                                                               
         DROP  RSCGROUP                                                         
         EJECT                                                                  
*-                                                                              
*-       Run through the I/O queue.                                             
*-                                                                              
         DROP  JCBR                No longer need to address JCB                
WAIT     L     R15,CVECBLST        Point at ECB list                            
         MVI   @R15,0              Reset first address                          
*-                                                                              
*-       Run through resource queue.                                            
*-                                                                              
         CLEAR R2                  Zero ECB entry counter                       
*                                                                               
         LM    R3,R5,CVRSG         Get the group loop                           
         USING RSCGROUP,R3                                                      
WAITLOOP IF    RSG1ACTV,BEGIN      If resources in use                          
         LA    R6,RSGQACFW-(RSC@NEXT-RESOURCE)                                  
         WITH  (RESOURCE,R6)                                                    
         WHILE (R6,NE,RSGQACBK),BEGIN                                           
         L     R6,RSC@NEXT         Get next resource                            
         IF    RSC1ACTV,BEGIN                                                   
         LA    R1,RSC$ECB          Assume ECB (not ECB addr)                    
         IF    RSC1@ECB,'L R1,RSC$ECB'  Get ECB addr                            
         LCALL ADDECB              Go put it on the ECB list                    
         END                                                                    
         END                                                                    
         END                                                                    
         BXLE  R3,R4,WAITLOOP      Go through all groups                        
         DROP  RSCGROUP                                                         
*-                                                                              
*-       Add ECBs on user ECB queue.                                            
*-                                                                              
         LA    R5,CVWECBQH-(WECBLINK-WECB)  Dummy queue head                    
         LOOP  BEGIN                                                            
         WITH  (WECB,R5)                                                        
         WHILE ('LT R5,WECBLINK',NZ)                                            
         L     R1,WECBECBP         Get ECB ptr                                  
         LCALL ADDECB              Go put it on the ECB list                    
         END                                                                    
*-                                                                              
*-       Special recovery check.                                                
*-                                                                              
         IF    (R2,Z),BEGIN        No ECBs happens in rcvy...                   
         IF    (^CVFRCVY,AND,^CVFPUSR),EXIT  Not recovery, scram                
*                                                                               
         IF    (CVNUSERS,Z),RECDONE  All done with recovery, scram              
         END                                                                    
*-                                                                              
*-       Nothing at all is ready, wait.                                         
*-                                                                              
         LA    R1,CVECB            Main ECB                                     
         LCALL ADDECB              Always add main ECB to list                  
*                                                                               
         LA    R1,@R2(R15)         Point at end of list                         
         S     R1,=F'4'            Back down to last                            
         MVI   @R1,X'80'           Terminate list                               
         LR    R1,R15              Copy pointer                                 
*-                                                                              
*-       WAIT.                                                                  
*-                                                                              
         XPUSH ,,8,PTR=R2                                                       
         STCK  @R2                 Save TOD                                     
         WAIT  ECBLIST=(1)         WYLBUR is waiting                            
         STCK  CVDSPCLK            New TOD                                      
         LM    R0,R1,CVDSPCLK                                                   
         SDL   R0,@R2              Voluntary wait time                          
         ADL   R0,CVWTCLK          Keep running total                           
         STM   R0,R1,CVWTCLK       Save total wait time                         
         XPOP  ,,8                                                              
         B     SEARCH                                                           
         EJECT                                                                  
*-                                                                              
*-       Routine to put an ECB on the list.                                     
*-                                                                              
ADDECB   ST    R1,@R15(R2)         Put on list                                  
         LA    R2,@R2+4            Up count                                     
         TM    @R1,X'40'           Is it posted?                                
         BZR   RAR                 Br if not return                             
         B     SEARCH              Abort build - go loop for work               
*                                                                               
*                                                                               
RECDONE  IF    CVFRCVY,BEGIN       Recovery is done...                          
         CLEAR CVFRCVY             No longer doing recovery                     
         IF    ('LT R15,RECVCNT',NZ),BEGIN                                      
         BTD   RCVNUM,,(R15)                                                    
         XWTO  RCVMSG              Tell oper recovery is done                   
RCVMSG   DATA  BEGIN                                                            
RCVNUM   DC    CL4'?',C' user(s) processed.'                                    
         END                                                                    
         END                                                                    
         END                                                                    
*                                                                               
         IF    CVFNOR,BEGIN        Go away now...                               
         CLEAR R15                 Rc=0                                         
         VCALL SHUTDOWN            Terminate normally now                       
         END                                                                    
*                                                                               
         IF    CVFCMDS,BEGIN       Execute initial commands...                  
         CLEAR CVFCMDS             Only do this once                            
         VCALL INITCMDS            Set up pseudo-user (see INIT)                
         B     SEARCH                                                           
         END                                                                    
*                                                                               
         CLEAR CVFPUSR             Reset pseudo-user flag (if on)               
*                                                                               
         CLEAR CVOLDJCB            No previous JCB                              
         MVC   CVCURJCB,CVLJCB     Dummy JCB for init stuff                     
         VCALL TERMINIT            Do milten initialization                     
*                                                                               
         IF    ^CVFTEST,BEGIN      Production version...                        
         L     R6,CVTPTR                                                        
         WITH  (CVT,R6)                                                         
         LT    R5,CVTUSER          SCIP CVT ptr                                 
         IF    Z,EXIT              None, scram                                  
         WITH  (USERCVT,R5)                                                     
         IF    (USERCVT,NE,'SCIP'),EXIT  Not ours, scram                        
         MODESET KEY=ZERO          ********                                     
         SET   USEHSPFL.HSPFWYL    Wylbur is up                                 
         MODESET KEY=NZERO         ********                                     
         END                                                                    
*                                                                               
         XWTO  'Ready.'            Notify operator                              
*                                                                               
         IF    ^CVFTEST,BEGIN                                                   
         IF    (CVMSG,NZ),BEGIN    Display msg...                               
         SEG   '***** ',,L:CVWTOSGP                                             
         SEGT  CVMSG                                                            
         XWTO                                                                   
         END                                                                    
*                                                                               
         IF    (CVWORD,NZ),BEGIN   Word is set...                               
         XWTO  'System word is set.'                                            
         END                                                                    
         END                                                                    
*                                                                               
         CLEAR CVFINIT             Out of initialization now                    
         B     SEARCH                                                           
*                                                                               
         QLTORG                                                                 
*                                                                               
RECVCNT  DC    F'0'                Count of users recovered                     
         EJECT                                                                  
***                                                                             
***  EOSDISP -- Enter dispatcher when we have logged off.                       
***                                                                             
         ENTRY EOSDISP                                                          
EOSDISP  BASE                                                                   
         BASE  BASE                Common dispatcher base                       
*                                                                               
         L     R8,CVDSTK           Switch to dispatcher...                      
         LR    R13,R8              ...stack                                     
*                                                                               
         XTRACE EOSDISP                                                         
*                                                                               
         L     JCBR,CVCURJCB                                                    
         USING JCB                                                              
*                                                                               
         FAIL  ^JCBAFRUN,EOSDISP1,'EOSDISP logic error.'                        
         FAIL  (CP,NE,'CP'),CPERR3,'Dispatcher CP error.'                       
         FAIL  ((JCBPTA,NZ),OR,(JCBPTB,NZ)),PAERR,'EOSDISP error.'              
*-                                                                              
*-       Free user resources.                                                   
*-                                                                              
         VCALL PJUNKALL            Junk all remaining pages                     
*                                                                               
         CLEAR JCBAFRUN            User is no longer running                    
         SET   JCBWFSO             Waiting for logon now                        
         CLEAR JCBFATTN+JCBFPATN+JCBFNATN+JCBAFALO   Tidy up                    
*                                                                               
         CLEAR JCBCPX              No CP any more                               
         VCALL FREECP              Make it official                             
*                                                                               
         LT    R0,JCBSTKX          Stack memory length                          
         IF    (R0,NZ),'ACALL RELSTACK'                                         
         CLEAR JCBSTKL             No stack memory now                          
*                                                                               
         LT    R0,JCBHEAPX         Heap memory len                              
         IF    (R0,NZ),'ACALL RELHEAP'                                          
         CLEAR JCBHEAPL            No heap memory now                           
*                                                                               
         CLEAR JCBR,CVCURJCB,CVOLDJCB  No current user                          
*-                                                                              
*-       Shutdown if reload is pending and no one is logged on.                 
*-                                                                              
         IF    CVFRLOAD,BEGIN      Reload pending...                            
         IF    (CVNUSERS,Z),BEGIN                                               
         XWTO  'Reloading'                                                      
         LA    R15,20              OS return code                               
         VCALL SHUTDOWN            Go away                                      
         DC    H'0'                (No return)                                  
         END                                                                    
         END                                                                    
*                                                                               
         B     DISPCONT            Re-join common code                          
*                                                                               
         DROP  BR                                                               
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  GETSTACK -- Routine to allocate stack space for user                         
*                                                                               
*    On entry:                                                                  
*      R0   - indicates the amount of stack space to get                        
*      JCBR - points to the user's JCB                                          
*                                                                               
GETSTACK PROC                                                                   
         WITH  JCB                                                              
         LR    R3,R0               Save for later                               
         LR    R15,R0                                                           
         CLEAR R14                                                              
         D     R14,=A(STKCHUNK*1024)                                            
         BCTR  R15,0               Array index relative to 0                    
         M     R14,=A(L'CELLBLOK)  Convert index to offset                      
         A     R15,CVSTKCEL                                                     
         ACALL GETPOOL                                                          
         LR    R0,R3                                                            
         STM   R0,R1,JCBSTKX       Save new stack memory len, loc               
         INCR  R15,CVSTKGET        Count 'em                                    
         L     R15,CVSTKMEM        Total STACK space used                       
         A     R15,JCBSTKX         Add in this piece                            
         ST    R15,CVSTKMEM        Save new total                               
         PEND                                                                   
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  RELSTACK -- Routine to free stack space for user                             
*                                                                               
*    On entry:                                                                  
*      JCBR - points to the user's JCB                                          
*                                                                               
RELSTACK PROC                                                                   
         WITH  JCB                                                              
         LM    R0,R1,JCBSTKX       Stack memory len, loc                        
         IF    (R0,NZ),BEGIN       Free old stack memory...                     
         INCR  R15,CVSTKFRE        Count 'em                                    
         L     R15,CVSTKMEM        Total STACK space used                       
         S     R15,JCBSTKX         Deduct from total                            
         ST    R15,CVSTKMEM        Save new total                               
         CLEAR JCBSTKX                                                          
         LR    R15,R0                                                           
         CLEAR R14                                                              
         D     R14,=A(STKCHUNK*1024)                                            
         BCTR  R15,0               Array index relative to 0                    
         M     R14,=A(L'CELLBLOK)  Convert index to offset                      
         A     R15,CVSTKCEL                                                     
         ACALL FREEPOOL                                                         
         END                                                                    
         PEND                                                                   
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  HEAPGET -- Routine to allocate heap space for user                           
*                                                                               
*    On entry:                                                                  
*      R0   - indicates the amount of heap space to get                         
*      JCBR - points to the user's JCB                                          
*                                                                               
HEAPGET  PROC                                                                   
         WITH  JCB                                                              
         LR    R3,R0               Save for later                               
         LR    R15,R0                                                           
         CLEAR R14                                                              
         D     R14,=A(HPCHUNK*1024)                                             
         BCTR  R15,0               Array index relative to 0                    
         M     R14,=A(L'CELLBLOK)  Convert index to offset                      
         A     R15,CVHEAPCL                                                     
         ACALL GETPOOL                                                          
         LR    R0,R3                                                            
         STM   R0,R1,JCBHEAPX      Save new heap memory len, loc                
         L     R15,CVSTKMEM        Total HEAP (STACK) space used                
         A     R15,JCBHEAPX        Add in this piece                            
         ST    R15,CVSTKMEM        Save new total                               
         INCR  R15,CVHEAPGT        Count 'em                                    
         PEND                                                                   
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  RELHEAP -- Routine to free heap space for user                               
*                                                                               
*    On entry:                                                                  
*      JCBR - points to the user's JCB                                          
*                                                                               
RELHEAP PROC                                                                    
         WITH  JCB                                                              
         LM    R0,R1,JCBHEAPX      Heap memory len, loc                         
         IF    (R0,NZ),BEGIN       Free old heap memory...                      
         INCR  R15,CVHEAPFR        Count 'em                                    
         L     R15,CVSTKMEM        Total HEAP (STACK) space used                
         S     R15,JCBHEAPX        Deduct from total                            
         ST    R15,CVSTKMEM        Save new total                               
         CLEAR JCBHEAPX                                                         
         LR    R15,R0                                                           
         CLEAR R14                                                              
         D     R14,=A(HPCHUNK*1024)                                             
         BCTR  R15,0               Array index relative to 0                    
         M     R14,=A(L'CELLBLOK)  Convert index to offset                      
         A     R15,CVHEAPCL                                                     
         ACALL FREEPOOL                                                         
         END                                                                    
         PEND                                                                   
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  ALLOC -- Routine to allocate the user's page buffers.                        
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - ok                                                                   
*      4 - can't allocate this user (no more buffers)                           
*                                                                               
ALLOC    PROC                                                                   
         WITH  JCB                                                              
*                                                                               
         FAIL  JCBAFRUN,SETQERR,'Setup of already setup user.'                  
*                                                                               
         SET   JCBAFRUN            User wants to run                            
         CLEAR JCB#PIO             Clear the page I/O count                     
*-                                                                              
*-       Check for too many users waiting to run.                               
*-                                                                              
         LH    R15,CVRUNCUR        Current run queue depth                      
         IF    (R15,GE,CVRUNMAX),BEGIN  Too many users...                       
         IF    (R15,POS),ALLOCNC   Don't allocate this user                     
         END                                                                    
*-                                                                              
*-       Allocate page A.                                                       
*-                                                                              
         LT    R5,JCBPTA           Do we have a page A?                         
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R5)                                                          
         LT    R4,PTPCBP                                                        
         IF    NZ,BEGIN            Page is in core...                           
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR05,'Dispatcher PCB error.'                  
         IF    PCBFIO,'INCR R15,JCB#PIO'  Need to wait for this I/O             
         ELSE  'QBUFOFF'           Take buffer off queue                        
         END                                                                    
         ELSE  BEGIN               Page is not in core...                       
         LA    R1,PT               Page                                         
         LCALL ALLOCPCB            Get buffer                                   
         BNZ   ALLOCNC             Can't (rare)                                 
*                                                                               
         L     R15,PTPCBP                                                       
         ACALL PREAD               Start the page read                          
         INCR  R15,JCB#PIO         Kick active page I/O count                   
         END                                                                    
         END                                                                    
*-                                                                              
*-       Allocate page B.                                                       
*-                                                                              
         LT    R5,JCBPTB           Do we have a page B?                         
         IF    NZ,BEGIN            Yes...                                       
         IF    (R5,EQ,JCBPTA),EXIT  We've already taken care of it              
         WITH  (PT,R5)                                                          
         LT    R4,PTPCBP                                                        
         IF    NZ,BEGIN            Page is in core...                           
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR06,'Dispatcher PCB error.'                  
         IF    PCBFIO,'INCR R15,JCB#PIO'  Need to wait for this I/O             
         ELSE  'QBUFOFF'           Take buffer off queue                        
         END                                                                    
         ELSE  BEGIN               Page is not in core...                       
         LA    R1,PT               Page                                         
         LCALL ALLOCPCB            Get buffer                                   
         IF    NZ,BEGIN            Can't get a buffer...                        
*-                                                                              
*-       If we can't get a buffer for page B, then we must                      
*-         un-allocate page A's buffer.                                         
*-                                                                              
         LT    R5,JCBPTA           Is there a page A?                           
         IF    NZ,BEGIN            Yes...                                       
         LT    R4,PTPCBP           Was it allocated?                            
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PCB,R4)                                                         
         IF    PCBFIO,EXIT         I/O in progress, scram                       
         LA    R15,CVBUFQ-(PCBQF-PCB)  Dummy first Q entry                      
         QBUFON ,                  Put buffer back on queue                     
         END                                                                    
         END                                                                    
         B     ALLOCNC                                                          
         END                                                                    
*                                                                               
         L     R15,PTPCBP                                                       
         ACALL PREAD               Start the page read                          
         INCR  R15,JCB#PIO         Kick active page I/O count                   
         END                                                                    
         END                                                                    
*                                                                               
         CLEAR R15                 A-ok                                         
         EXIT                                                                   
*-                                                                              
*-       If we get here it means that we can't allocate the                     
*-         required buffers to be able to run this user.  Failing               
*-         to allocate this user doesn't necessarily mean that                  
*-         WYLBUR will serialize, since there could already be                  
*-         many allocated users on the RUN queue.                               
*-                                                                              
ALLOCNC  INCR  R15,CV#SNC          Can't snatch condition                       
*                                                                               
         CLEAR JCBAFRUN            Not ready to run now                         
         CLEAR JCB#PIO             Reset active page I/O count                  
*                                                                               
         LA    R15,4               Can't allocate rc                            
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  ALLOCPCB -- Routine to allocate a page buffer (PCB) to the                   
*    page-number specified.                                                     
*                                                                               
*    On entry:                                                                  
*      R1 - PT entry ptr                                                        
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - allocated                                                            
*      4 - can't allocate                                                       
*                                                                               
ALLOCPCB PROC                                                                   
         WITH  JCB                 (Entry assumption)                           
         LR    R5,R1                                                            
         WITH  (PT,R5)                                                          
*-                                                                              
*-       Allocate new buffer for page that's not in core.                       
*-                                                                              
         LA    R15,CVEMBUFQ-(PCBQF-PCB)  Dummy first empty Q link               
         IF    ('C R15,CVEMBUFQ+4',NE),BEGIN  Buffer on empty Q...              
         INCR  R15,CV#SNEM         Count empty buffer snatch                    
         L     R4,CVEMBUFQ         Take first empty buffer                      
         B     PACTAKE             Go make it ours                              
         END                                                                    
*-                                                                              
*-       If there are no empty buffers, take someone else's buffer.             
*-         We will take the least recently used buffer (do NOT try              
*-         to improve on this unless you are really sure!).  If the             
*-         least recently used buffer is changed then queue it to               
*-         be written and keep looking.  Buffers belonging to user's            
*-         who have already been setup are NOT on any queue.                    
*-         This avoids any searching for a "good" buffer.                       
*-                                                                              
*-       It's amazing how well this simple algorithm works.                     
*-                                                                              
         WITH  (PCB,R4)                                                         
*                                                                               
         LOOP  BEGIN               Snatch a buffer...                           
         LA    R4,CVBUFQ-(PCBQF-PCB)  Dummy first buffer entry                  
         WHILE ('C R4,CVBUFQ+4',NE)  Go through queue                           
         L     R4,PCBQF            Get first/next PCB                           
*                                                                               
         IF    ^PCBFMARK,PACTAKEB  Take the buffer, scram                       
*                                                                               
         QBUFOFF ,                 Take buffer off queue                        
*                                                                               
         LR    R15,R4                                                           
         ACALL PWRITE              Write buffer                                 
         END                                                                    
*-                                                                              
*-       We don't have any buffers left to take.                                
*-                                                                              
         LA    R15,4               Can't allocate RC                            
         EXIT                                                                   
*-                                                                              
*-       We have the buffer we want to take, now make it ours.                  
*-                                                                              
PACTAKEB INCR  R15,CV#SNB          Count buffer snatch                          
PACTAKE  FAIL  (PCB,NE,'PCB'),PCBERR07,'Dispatcher PCB error.'                  
         FAIL  PCBFIO,ALLOX2,'ALLOCPCB error.'                                  
         QBUFOFF ,                 Take buffer off queue                        
*                                                                               
         LT    R15,PCBPTP                                                       
         IF    NZ,BEGIN            Belongs to someone else...                   
         WITH  (PT,R15),'CLEAR PTPCBP'  Doesn't belong any more                 
         END                                                                    
*                                                                               
         CLEAR PCBCLEAR            Reset ownership info                         
*                                                                               
         ST    R5,PCBPTP           Save PT ptr in PCB                           
         ST    R4,PTPCBP           Save PCB ptr in PT                           
*                                                                               
         CLEAR R15                 A-ok                                         
         PEND                                                                   
*                                                                               
         QLTORG                                                                 
         TITLE 'Resource Management -- Obtain a Resource'                       
*                                                                               
* the following routine is used to obtain a  resource  for                      
* use.   a  resource is obtained by searching for the name                      
* of the resource type in the resource group  list.   when                      
* the  resource  type  is found the free resource queue is                      
* searched for a free resource; the free resource is taken                      
* off the free queue and queued to the active queue.   the                      
* current  JCB  is then set in the owners slot and the ECB                      
* and flags are cleared.  return is made  to  the  caller.                      
* the entry parameters are as follows:                                          
*                                                                               
*     register           contents                                               
*        0                JCB addr of requestor                                 
*        1                address of resource name                              
*       15                resource obtain request:                              
*                                                                               
*  the following obtain requests are defined:                                   
*                                                                               
*       4   -   wait for the resource if unavailable                            
*       8   -   return if resource is unavailable                               
*      12   -   queue JCB & return if resource unavail                          
* upon return from the resource obtain routine the                              
* exit parameters are as follows:                                               
*                                                                               
*      register          contents                                               
*         0               address of resource entry block                       
*         1               address of resource                                   
*        15               return code as follows:                               
*                         0  - R0,R1 are set as above                           
*                         4  - JCB was queued                                   
*                              and return was made                              
*                         8  - resources busy|attn                              
*                                                                               
GETRSC   XENTER TRACE=NO                                                        
RSCBASE  IF    ('LTR JCBR,R0',Z),'L JCBR,CVCURJCB'  Use current                 
         USING JCB                                                              
         LTR   R2,R15              Save request code                            
         IF    NEG,BEGIN           If no attn abort signaled then               
         SET   JCBFARB             Set no attn can abort wait                   
         LPR   R2,R2               Make request positive                        
         END                                                                    
         LCALL FINDRSC             Go find resource/set up rsc reg.             
* note: no return from routine is made if resource request invalid              
         USING RSCGROUP,R5                                                      
HAVRGRP  INCR  R0,RSG#AUSE         Count number of use attempts                 
         CH    R2,=AL2(RSCQJCB)    Just a QJCB request?                         
         BE    QUERJCB             Br if so                                     
         L     R4,RSGQFRFW         Assume there is one free                     
         LTH   R3,RSG#FREE         Is there one?                                
         BP    HAVRSC              Br if there is                               
         FAIL  NEG,JCBQ,'Queueing error.'                                       
         CH    R2,=AL2(RSCWRTN)    Unwilling to wait/queue JCB?                 
         BE    ITSBUSY             Br if so, take busy exit                     
QUERJCB  SET   RSG1QUED            Set rscgroup has a queued JCB                
         LT    R0,JCBQF            Already queued?                              
         FAIL  NZ,JCBQ,'Queueing error.'                                        
         LT    RAR,RSG@QUER        Check for queueing routine                   
         BZ    QUEJCB              Br if not one                                
         LR    R1,JCBR             Point at JCB                                 
         LR    R0,R5               Copy resource group pointer                  
         BASR  RAR,RAR             Go queue JCB                                 
         B     QUEDJCB             Br all queued                                
*                                                                               
QUEJCB   LA    R15,RSGQJCFW-(JCBQF-JCB)  point at queue head                    
         QJCB  (JCBR)              Go queue up the JCB                          
QUEDJCB  SET   JCBWFRSC            Set waiting for resource                     
         LCALL JCBQCNT             Go count number of JCBs in queue             
         CH    R0,RSG#MXJC         Is it largest ever?                          
         BNH   *+8                 br if not, don't update                      
         STH   R0,RSG#MXJC         Save largest ever seen                       
         CH    R2,=AL2(RSCQJCB)    Queue JCB request?                           
         BE    RSMJCBQD            Br all queued                                
         INCR  R0,RSG#WAIT         Count number of waits                        
         PAUSE JCBWFRSC            Wait for resource to free up                 
         IF    JCBFARB,HAVRGRP     Br if attn not allowed                       
         IF    JCBFATTN,ITSBUSY    Branch if attention                          
         B     HAVRGRP             Go try again                                 
*                                                                               
RSMJCBQD LA    R15,RSCJCBQD        Set we did it                                
         B     RSMRTRN             Go return                                    
*                                                                               
HAVRSC   CLEAR JCBFARB             Allow attentions again                       
         USING RESOURCE,R4                                                      
         INCR  R0,RSG#IMFR         Count number given                           
         LA    R15,RSGQFRFW-(RSC@NEXT-RESOURCE)  point at start                 
*        if the group is asynchronous and no resources are on                   
*        the free queue, then search the active queue for a rsc.                
         IF    (RSG1ASYN,AND,(R15,EQ,RSGQFRBK)),BEGIN                           
         LA    R4,RSGQACFW-(RSC@NEXT-RESOURCE)  start of active                 
         WHILE (R4,NE,RSGQACBK),BEGIN  look for active rsc free                 
         LT    R4,RSC@NEXT                                                      
         IF    RSC1ASYN,BEGIN      Is it asynchronous?                          
         IF    ('LT R0,RSC@JCB',Z),QRSCFND                                      
         END                                                                    
         END                                                                    
         KAPUT JCBQ,'Queueing error.'                                           
         END   ELSE,BEGIN                                                       
QRSCTOA  DQRSC (R4)                Go dequeue resource                          
         LA    R15,RSGQACFW-(RSC@NEXT-RESOURCE)                                 
         QRSC  (R4)                Go put on active queue                       
         END                                                                    
QRSCFND  DECR  R3                                                               
         STH   R3,RSG#FREE         Save new free count                          
         INCR  R0,RSG#ACTV         Bump count of active                         
         SET   RSG1ACTV            Set rscgroup is active                       
         IF    ^RSC1ASYN,'MVI RSC$ECB,0'  clear  if not asynch                  
         INCR  R0,RSC#USE          Count resource uses                          
         ST    JCBR,RSC@JCB        Save new owner                               
         LR    R0,R5               Return rsc block address                     
         LR    R1,R4               Get address                                  
         LA    R15,RSCHAVE         Set have                                     
         B     RSMRTRN                                                          
*                                                                               
ITSBUSY  LA    R15,RSCBUSY         Resource is busy                             
         B     RSMRTRN             Go return to caller                          
         TITLE 'Resource Management - Return Resource to Pool'                  
*                                                                               
* the following routine is used to return a resource  that                      
* the  current  JCB  owns.  this is done by looking up the                      
* resource name in  the  resource  group  list,  and  then                      
* looking  up  the JCB in the active resource queue.  when                      
* (if) found, the resource is  dequeued  from  the  active                      
* queue  and requeued onto the free queue.  then the queue                      
* of waiting JCBs is examined to find the first JCB on the                      
* queue waiting for the resource.  this  JCB  is  dequeued                      
* from  the  JCB queue and is assigned the freed resource.                      
* the JCB is then queued to the setup queue and return  is                      
* made  to  the  caller.   the  entry  parameters  are  as                      
* follows:                                                                      
*                                                                               
*    register           contents                                                
*      0                 JCB address of requestor                               
*      1                 pointer to resource name                               
*                                                                               
* upon return from the  resource  free  routine  the  exit                      
* registers are set as follows:                                                 
*                                                                               
*    register     -     contents                                                
*      0                 arbitrary                                              
*      1                 arbitrary                                              
*     2-8                same as on entry                                       
*     15                 return code as follows                                 
*                         0  -  resource returned ok                            
*                         4  -  JCB doesn't own resource                        
*                                                                               
FREERSC  XENTER R2,R8,TRACE=NO     Return used resource                         
         BASE  RSCBASE             Common base                                  
         IF    ('LTR JCBR,R0',Z),'L JCBR,CVCURJCB'                              
         LCALL FINDRSC             Go find resource                             
* note: no return is made if resource not found                                 
*                                                                               
FRERGRP  LA    R4,RSGQACFW-(RSC@NEXT-RESOURCE)                                  
         WHILE (R4,NE,RSGQACBK),BEGIN  loop until end                           
         L     R4,RSC@NEXT                                                      
         C     JCBR,RSC@JCB        Is this the owner?                           
         BE    FREEJCB             Go free it if so                             
         END                                                                    
         LA    R15,8               Resource not held                            
         B     RSMRTRN                                                          
*                                                                               
FREEJCB  CLEAR RSC@JCB             Clear owner                                  
         DECR  R15,RSG#ACTV        Reduce active count                          
         IF    ^RSC1ASYN,BEGIN     If not asynchronous resource                 
         DQRSC (R4)                Take off active queue                        
         L     R15,RSGQFRFW        Pnt at free q                                
*          note that we place the newly free resource on the                    
*          top of the free queue.  this is done to reduce paging                
*          of large resources (like iowas).  we will reuse this                 
*          resource as the next resource.                                       
         QRSC  (R4)                Put on free queue                            
         LTH   R15,RSG#ACTV        Test number active                           
         FAIL  NEG,JCBQ,'Queueing error.'                                       
         IF    Z,'CLEAR RSG1ACTV'  Clear group active                           
         CLEAR RSC1ACTV            Resource no longer active                    
         END                                                                    
         INCR  R0,RSG#FREE         Bump the free count                          
         LA    R15,RSCOK           Set ok                                       
         IF    ^RSG1QUED,RSMRTRN   Return if none queued                        
         LTH   R3,RSG#FREE         Get number free                              
         FAIL  ^POS,JCBQ,'Queueing error.'                                      
         LR    R2,JCBR             Save user freeing resource                   
         LA    JCBR,RSGQJCFW-(JCBQF-JCBSTART)  Point at start                   
         WHILE (JCBR,NE,RSGQJCBK),BEGIN                                         
         L     JCBR,JCBQF          Get the next JCB                             
         DQJCB (JCBR)              Take this one off of queue                   
         IF    (R2,P),BEGIN        if we haven't waited user                    
         ST    R2,JCBDSPP          Save next user ptr                           
         LCR   R2,R2               Invert                                       
         END                                                                    
         CLEAR JCBWFRSC            No longer waiting for resource               
         IF    ('LTH R0,JCBWFL',Z),'SETUP (JCBR)'  setup if no wait             
         BCT   R3,*+8              Skip if not last free rsc                    
         B     L1                  Jump out of loop                             
         LA    JCBR,RSGQJCFW-(JCBQF-JCBSTART)                                   
         END                                                                    
L1       LR    JCBR,R2             Copy                                         
         LA    R2,RSGQJCFW-(JCBQF-JCBSTART)                                     
         IF    (R2,EQ,RSGQJCBK),'CLEAR RSG1QUED'                                
         IF    (JCBR,M),BEGIN      If we dispatched                             
         LCR   JCBR,JCBR           Make it positive                             
         PAUSE JCBWFDSP            Wait for other user                          
         END                                                                    
         LA    R15,RSCOK           Thanks, resource returned                    
         B     RSMRTRN             Return to caller                             
         TITLE 'Resource Management - Find Resource Group'                      
*                                                                               
*               find resource group                                             
*                                                                               
* this routine finds a resource group for the caller. upon                      
* entry R1 contains the address of an 8 byte resource name                      
* upon exit R0 is loaded with the resource group pointer if                     
* it was found.  R15 contains a return code indicating the                      
* validity of R0 as follows:                                                    
*        R15    0  -  R0 contains valid rscgroup pointer                        
*              12  -  R0 contains entry value, unknown rscgroup                 
*                                                                               
FNDRSCG  XENTER TRACE=NO                                                        
         BASE  RSCBASE             Common base                                  
         LCALL FINDRSC             Go find rscgroup                             
         LR    R0,R5               Copy resource                                
         LA    R15,RSCOK           Set ok                                       
         B     RSMRTRN             Go return                                    
         TITLE 'Resource Management - Find Resource Group Block'                
*box                                                                            
*                                                                               
*  find the resource pointed at in R1                                           
*                                                                               
FINDRSC  FAIL ((R1,NP),OR,(R1,GT,=Y(CVRLAST))),BADRSG,'Rsc error.'              
         DECR  R1                  Down one                                     
         MH    R1,=AL2(L'RSCGROUP) Get offset                                   
         AL    R1,CVFRSG           Point at it                                  
         LR    R5,R1               Copy R1                                      
         BR    RAR                                                              
*                                                                               
RSMRTRN  XEXIT ,,LTR               Return with cc set                           
         TITLE 'Resource Management Queueing Routines'                          
*-                                                                              
*-       Queue this JCB just before the JCB pointed at by R15.                  
*-                                                                              
         WITH  (JCB,R1),BEGIN                                                   
         ENTRY QJCB                                                             
QJCB     L     R0,JCBQB-JCB(,R15)  Get back pointer                             
         ST    R1,JCBQB-JCB(,R15)  Set new back pointer                         
         STM   R15,R0,JCBQF        Store link pointers                          
         LR    R15,R0              Copy back pointer                            
         ST    R1,JCBQF-JCB(,R15)  Set new forward pointer                      
         BR    RAR                                                              
*-                                                                              
*-       Dequeue this JCB off of its queue.                                     
*-                                                                              
         ENTRY DQJCB                                                            
DQJCB    L     R15,JCBQF           Get forward pointer                          
         L     R0,JCBQB            Get back pointer                             
         ST    R0,JCBQB-JCB(,R15)  Set new back pointer                         
         FLIP  (R15,R0)            Flip the ptrs                                
         ST    R0,JCBQF-JCB(,R15)  Set new forward pointer                      
         SR    R0,R0               Zero for stores                              
         ST    R0,JCBQF            Zero forward pointer                         
         ST    R0,JCBQB            And backward pointer                         
         BR    RAR                 Return to caller                             
         DROP  JCB                                                              
*-                                                                              
*-       Count the number of JCBs on this queue.                                
*-                                                                              
JCBQCNT  LA    R15,RSGQJCFW-(JCBQF-JCB)  point at first ptr                     
         CLEAR R0                  Zero counter                                 
         WHILE (R15,NE,RSGQJCBK),BEGIN                                          
         WITH  (JCB,R15),BEGIN                                                  
         L     R15,JCBQF           Get next pointer                             
         AL    R0,CVONE            Add in count                                 
         END                                                                    
         END                                                                    
         BR    RAR                 Return to caller                             
         END                                                                    
*-                                                                              
*-       Queue resource before resource pointed to in R15.                      
*-                                                                              
         ENTRY QRSC                                                             
QRSC     L     R0,RSC@PREV-RESOURCE(,R15)                                       
         ST    R1,RSC@PREV-RESOURCE(,R15)  save new back                        
         STM   R15,R0,RSC@NEXT-RESOURCE(R1)                                     
         LR    R15,R0              Copy pointer                                 
         ST    R1,RSC@NEXT-RESOURCE(,R15)                                       
         BR    RAR                 Return to caller                             
*-                                                                              
*-       Dequeue resource in R1.                                                
*-                                                                              
         ENTRY DQRSC                                                            
DQRSC    L     R15,RSC@PREV-RESOURCE(R1)  get previous ptr                      
         L     R0,RSC@NEXT-RESOURCE(R1)  get next pointer                       
         ST    R0,RSC@NEXT-RESOURCE(,R15)                                       
         FLIP  (R0,R15)            Flip ptrs                                    
         ST    R0,RSC@PREV-RESOURCE(,R15)                                       
         CLEAR (@R1+RSC@NEXT-RESOURCE,8)  clear links                           
         BR    RAR                                                              
*                                                                               
         DROP  RESOURCE,RSCGROUP,JCB,BR                                         
         EJECT                                                                  
*box                                                                            
*                                                                               
*  WAITECB -- Routine to wait for the ECB specified to be posted.               
*                                                                               
*    On entry:                                                                  
*      R0 - options:                                                            
*             0 = don't come back until posted                                  
*             1 = attn can interrupt wait                                       
*      R1 - ECB ptr                                                             
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - posted                                                               
*      4 - attn/logoff interrupted wait                                         
*                                                                               
WAITECB  XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LR    R4,R0               Save options                                 
         LR    R3,R1               Save ECB ptr                                 
*-                                                                              
*-       Build WECB queue entry and add it to the queue.                        
*-                                                                              
         LA    R0,L'WECB                                                        
         VCALL GETCORE             Get WECB entry                               
         LR    R5,R1                                                            
         WITH  (WECB,R5),BEGIN                                                  
         CLEAR WECB                                                             
         MVC   WECB(4),=C'WECB'                                                 
         MVC   WECBJCBP,CVCURJCB   Save current JCB ptr                         
         ST    R3,WECBECBP         Save ECB ptr                                 
*                                                                               
         L     R2,CVWECBQT         Get last WECB entry                          
         IF    (R2,Z),BEGIN        Nothing on queue...                          
         ST    R1,CVWECBQH         We are the only entry                        
         ST    R1,CVWECBQT                                                      
         END                                                                    
         ELSE  BEGIN               Add to end of queue...                       
         WITH  (WECB,R2),'ST R1,WECBLINK'  Link us to prev                      
         ST    R1,CVWECBQT         We are the new queue tail                    
         END                                                                    
         END                                                                    
*-                                                                              
*-       Wait for completion.                                                   
*-                                                                              
         IF    (R4,Z),'PAUSE JCBWFECB'  Normal ECB wait                         
         ELSE  'PAUSE JCBWWFECB'   Weak wait (attn will interrupt)              
*                                                                               
         CLEAR R2                  Assume A-ok                                  
         IF    JCBFATTNFREE,'LA R2,4'  Attn freed the resource wait             
*-                                                                              
*-       We have to remove our WECB entry from the queue.                       
*-                                                                              
WTEFREE  CLEAR R4                  No previous WECB yet                         
         LA    R5,CVWECBQH-(WECBLINK-WECB)  Dummy queue head                    
         LOOP  BEGIN                                                            
         WITH  (WECB,R5)                                                        
         WHILE ('LT R5,WECBLINK',NZ)  Go through queue...                       
         IF    (WECBJCBP,EQ,CVCURJCB),BEGIN  It's our entry...                  
         IF    (R4,Z),'MVC CVWECBQH,WECBLINK'  New queue head                   
         ELSE  'MVC @R4+(WECBLINK-WECB)(4),WECBLINK'  Dequeue us                
         IF    (WECBLINK,Z),'ST R4,CVWECBQT'  New queue tail                    
*                                                                               
         MVC   WECB(4),=C'XECB'    Zap id                                       
         MVC   WECBLINK,=F'-1'     Safety                                       
         LA    R1,WECB                                                          
         VCALL FREECORE            Release memory                               
         B     WTEFREE             Restart loop                                 
         END                                                                    
*                                                                               
         LR    R4,R5               Save previous WECB ptr                       
         END                                                                    
*                                                                               
         LR    R15,R2                                                           
         PEND                                                                   
         TITLE 'WYLBUR''s Dispatcher'                                           
*box                                                                            
*                                                                               
*  CHECKOUT -- Routine to force changed pages which have not been               
*    referenced for a long time to be written out.                              
*                                                                               
*    This is really just a way to write out old changed pages                   
*    during non-peak times.  During peak times the ALLOC routine                
*    will force old pages to be written out.                                    
*                                                                               
CKWA     RECORD BEGIN                                                           
CKNIO    DS    F                   Number of I/O scheduled                      
         END                                                                    
*-                                                                              
CHECKOUT PROC  CKWA                                                             
         CLEAR CKWA                                                             
*                                                                               
         IF    CVFMEMPAGE,EXIT     No paging system, scram                      
*                                                                               
         LA    R4,CVBUFQ-(PCBQF-PCB)  Dummy first link                          
         LR    R3,R4                                                            
         L     R5,CVBUFQ           First entry                                  
         WHILE (R5,NE,R3),BEGIN    Go through buffer queue...                   
         LR    R4,R5               Next PCB                                     
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR09,'Dispatcher PCB error.'                  
         L     R5,PCBQF            Get link now (for loop)                      
*-                                                                              
*-       Only look at changed pages.                                            
*-                                                                              
         IF    PCBFMARK,BEGIN      Page has changed...                          
         FAIL  (PCBPTP,Z),CHECKER2,'CHECKOUT logic error.'                      
         FAIL  PCBFIO,CHECKER3,'CHECKOUT logic error.'                          
*                                                                               
         L     R6,PCBBUFP                                                       
         SH    R6,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R6)                                                        
*-                                                                              
*-       We are processing the owned queue pages from oldest to                 
*-         newest so as soon as we find a changed pages that is too             
*-         new to be written, we can stop searching the queue.                  
*-                                                                              
         L     R15,CVDSPCLK                                                     
         S     R15,PCBQCLCK        Number of seconds since change               
         IF    (R15,LT,CVPCSEC),CKOEXIT  Too new, stop looking                  
         L     R15,PCBPTP                                                       
         WITH  (PT,R15),'L JCBR,PTJCBP'                                         
         WITH  JCB                                                              
*                                                                               
         QBUFOFF ,                 Take buffer off queue                        
*                                                                               
         LA    R15,PCB                                                          
         ACALL PWRITE              Write the page                               
         INCR  R15,CV#COUT         Count the checkpoint I/O                     
*-                                                                              
*-       Avoid queueing a huge number of pages all to be written                
*-         simultaniously; so after we've queued a few we can                   
*-         stop.  The next time this routine is called (two seconds             
*-         later) we'll queue some more pages.                                  
*-                                                                              
         INCR  R15,CKNIO           Count number of I/O's we started             
         IF    (R15,GE,CVPCMAX#),CKOEXIT  That's enough, more later             
         END                                                                    
         END                                                                    
*                                                                               
CKOEXIT  PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FORCEOUT -- Routine to write changed pages back out to disk                  
*    for complete ACTIVE file recovery.                                         
*                                                                               
FORCEOUT XPROC                                                                  
         IF    CVFMEMPAGE,EXIT     No paging system, scram                      
*                                                                               
         IF    ^CVFFORCE,BEGIN     Once...                                      
         SET   CVFFORCE            We've gone through this once                 
*-                                                                              
*-       Go through page buffers.                                               
*-                                                                              
         LA    R5,CVPCBQH-(PCBLINK-PCB)  Dummy first link                       
         LOOP  BEGIN                                                            
         WITH  (PCB,R5)                                                         
         WHILE ('LT R5,PCBLINK',NZ)  Go through PCBs...                         
         IF    (PCB,EQ,'PCB'),BEGIN  Valid PCB control block...                 
         L     R4,PCBBUFP          User data buffer                             
         SH    R4,=AL2(PBUFUSER-PBUF)  Backup to PBUF control block             
         WITH  (PBUF,R4)                                                        
         IF    (PBUF,NE,'PBUF'),EXIT  Not a good buffer, scram                  
         LT    R2,PCBPTP                                                        
         IF    NZ,BEGIN            Owned buffer...                              
         WITH  (PT,R2)                                                          
         IF    PCBFIO,EXIT         I/O in progress, forget it                   
         IF    ^PCBFMARK,EXIT      Not changed                                  
         IF    ^PBUFFRCV,EXIT      Not needed for recovery                      
*                                                                               
         L     R1,PTPNO            Get pageno                                   
         LA    R15,PCB                                                          
         ACALL SAWRITE             Write this page out (and wait)               
         END                                                                    
         END                                                                    
         END                                                                    
         END                                                                    
*                                                                               
         PEND                                                                   
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PIODONE -- Routine to process the completion of page I/O.                    
*                                                                               
PIODONE  PROC                                                                   
*-                                                                              
*-       Get a page off of appendage's completion queue.                        
*-                                                                              
*-       (Note: the page completion queue works like a LIFO stack,              
*-          below we pop an item off the stack)                                 
*-                                                                              
PIOLOOP  LM    R4,R5,CVPOSTQH      Get posted queue pntr, lock                  
         IF    (R4,Z),PIOEXIT      Nothing, scram                               
*                                                                               
         L     R14,PCBPOSTL-PCB(R4) Get link to next PCB in queue...            
         LA    R15,1(R5)            Reset lock                                  
         CDS   R4,R14,CVPOSTQH      Point queue head to next PCB                
         BNZ   PIOLOOP              If lock changed, try again                  
*                                                                               
         WITH  (PCB,R4)                                                         
         L     R3,PCBPTP           Page table entry ptr                         
         FAIL  (R3,Z),PIOPROB7,'PIODONE logic error.'                           
         WITH  (PT,R3)                                                          
         FAIL  (R4,NE,PTPCBP),PIOPROB8,'PIODONE logic error.'                   
         L     R5,PTPFCBP          Get our PFCB ptr                             
         WITH  (PFCB,R5)                                                        
*                                                                               
         FAIL  (PCB,NE,'PCB'),PCBERR10,'Dispatcher PCB error.'                  
         FAIL  ^PCBFIO,PIOPROB1,'PIODONE logic error.'                          
         FAIL  ^PCBFPOST,PIOPROB2,'PIODONE logic error.'                        
         FAIL  (PCBQF,NZ),PIOPROB3,'PIODONE logic error.'                       
*                                                                               
         CLEAR PCBFPOST            Clear posted flag                            
         MVC   PCBPOSTL,=F'-1'     Safety                                       
*-                                                                              
*-       Check for I/O error.                                                   
*-                                                                              
         IF    (PCBCOD,NE,X'7F'),BEGIN  I/O error...                            
         LCALL PIOERROR            Write out I/O error messages                 
         B     PIOLOOP             Loop back                                    
         END                                                                    
*-                                                                              
*-       Keep paging statistics.                                                
*-                                                                              
         INCR  R0,CVNPIO           Count the page I/O                           
*                                                                               
         L     R2,PCBBUFP                                                       
         SH    R2,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R2),BEGIN                                                  
         LA    R1,CV#MSC           Assume miscellaneous page type               
         IF    (PBUFID,EQ,'TEXT'),'LA R1,CV#TXT'                                
*                                                                               
         LA    R15,1                                                            
         A     R15,@R1+4           Kick page I/O count                          
         ST    R15,@R1+4           Save new count                               
*                                                                               
         IF    ('CLI PCCWRW,X"05"',EQ),BEGIN  Page write...                     
         LA    R15,1                                                            
         A     R15,@R1+8           Kick page write count                        
         ST    R15,@R1+8           Save new count                               
         END                                                                    
         END                                                                    
*                                                                               
         INCR  R0,PFCBNIO          Count the page I/O on this PFCB              
         STCK  @R13                Current TOD                                  
         LM    R0,R1,@R13                                                       
         SDL   R0,PCBCLCK          I/O elapsed time                             
         ADL   R0,PFCBCLK          Total I/O time                               
         STM   R0,R1,PFCBCLK       Save total I/O time                          
*-                                                                              
*-       Finish up processing page I/O completion.                              
*-                                                                              
         CLEAR PCBFIO              Clear I/O                                    
         CLEAR PCBFMARK            Page is no longer changed                    
*-                                                                              
*-       Page I/O for a junked buffer has completed; release the                
*-         pageno and add the buffer to the empty queue.                        
*-                                                                              
         IF    PCBFJUNK,BEGIN      We need to junk this pageno...               
         CLEAR PCBFIOWR            Reset I/O option flag                        
         CLEAR PTFREE              Pageno is available now                      
         MVC   PTLINKP,PFCBAPQH    Link up free PT's                            
         ST    R3,PFCBAPQH         We are the new free PT queue head            
*                                                                               
         DECR  R15,PFCBCP          Decr current count                           
*                                                                               
         CLEAR PCBCLEAR            Clear ownership info                         
         L     R2,PCBBUFP                                                       
         SH    R2,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R2),'CLEAR PBUFSYS'  Clear buffer prefix                   
*                                                                               
         LA    R15,CVEMBUFQ-(PCBQF-PCB)  Dummy first link                       
         QBUFON ,                  Put on empty buffer queue                    
*                                                                               
         B     PIOLOOP             Loop back                                    
         END                                                                    
*                                                                               
         L     JCBR,PTJCBP         Get our JCB ptr                              
         FAIL  (JCBR,Z),PIOPROB9,'PIODONE logic error.'                         
         WITH  JCB                                                              
*-                                                                              
*-       Put the user on the run queue if his PAR and PBR pages                 
*-         have completed I/O.                                                  
*-                                                                              
         IF    JCBAFRUN,BEGIN      We are trying to run this guy...             
         IF    ((R3,NE,JCBPTA),AND,(R3,NE,JCBPTB)),EXIT  Not PA/PB              
         CLEAR PCBFIOWR            Reset I/O option flag                        
*                                                                               
         LTH   R0,JCB#PIO          Get active I/O count                         
         FAIL  NP,PDONEQR,'Logic error in setup I/O.'                           
         BCT   R0,PIONTDN          Br if I/O not done                           
         CLEAR JCBWFRSC            No longer waiting for rsc                    
         DQJCB (JCBR)              Take off of pagio queue                      
         RUNQ  (JCBR)              And put on run queue                         
         INCR  R15,CVRUNCUR        Kick run queue depth                         
         CLEAR R0                  Make sure zero                               
PIONTDN  STH   R0,JCB#PIO          Save new I/O count                           
*                                                                               
         B     PIOLOOP             Loop back                                    
         END                                                                    
*-                                                                              
*-       Owned buffer I/O completion.                                           
*-                                                                              
*-       Note:  QBUFON puts the buffer on the queue before the                  
*-         entry in R15.  Normally we put the buffer at the end of              
*-         the LRU queue, and when we need to take a buffer we will             
*-         take a buffer from the top (i.e., the oldest).                       
*-                                                                              
*-         However, if we are writing out an old buffer to free                 
*-         the buffer, then we want to put it back at the end of                
*-         the queue, so it can be snatched by the next person                  
*-         who needs a page.                                                    
*-                                                                              
         LA    R15,CVBUFQ-(PCBQF-PCB)  Dummy first entry                        
         IF    PCBFIOWR,BEGIN      This was a page write...                     
         L     R15,PCBQF-PCB(,R15)  Get 2nd entry ptr                           
         CLEAR PCBFIOWR            Reset I/O option                             
         QBUFON STCK=NO                                                         
         B     PIOLOOP             Loop back                                    
         END                                                                    
*                                                                               
         QBUFON ,                  Put on buffer queue                          
         B     PIOLOOP             Loop back                                    
*                                                                               
PIOEXIT  PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PIOERROR -- Routine to process a page I/O error.  All we do is               
*    write a message to the operator and return.  Because we've                 
*    never decremented the user's active page I/O count, he won't               
*    run again.                                                                 
*                                                                               
*    If page I/O errors happen more often, this logic should be                 
*    improved to try and recover the user.                                      
*                                                                               
*    On entry:                                                                  
*      R4 - PCB ptr                                                             
*                                                                               
PIOERROR PROC                                                                   
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR11,'Dispatcher PCB error.'                  
*-                                                                              
*-       Check for too many I/O errors.                                         
*-                                                                              
         INCR  R15,IOERRCNT        Count the paging error                       
         FAIL  (R15,GT,10),IOERROR,'Paging I/O errors.'                         
*-                                                                              
*-       Write out page I/O error messages to operator.                         
*-                                                                              
         MVC   DRERSYS,CVNAME      Put system name in message                   
*                                                                               
         L     R15,PCBPTP                                                       
         WITH  (PT,R15),'L R15,PTPNO'  Get pageno                               
         BTD   DRERPNO,,(R15)      Page no.                                     
*                                                                               
         L     R3,PCBBUFP          PBUF ptr                                     
         SH    R3,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R3),BEGIN                                                  
         BTX   DREROPCD,,LC:PCCWRW  Put in opcode                               
         BTX   DRERSEEK,8,PBUFSEEK                                              
         BTX   DRERSEEK+8,8,PBUFSEEK+4                                          
         END                                                                    
*                                                                               
         LA    R3,PCBIOSB          IOSB has error info                          
         WITH  (IOSB,R3),BEGIN                                                  
         BTX   DRERCODE,,IC:IOSCOD  I/O completion code                         
         BTX   DRERCSW,8,L:IOSFCSW   CSW                                        
         BTX   DRERCSW+8,8,L:IOSFCSW+4                                          
         BTX   DRERSNS,4,LH:IOSSNS  Put in sense bytes                          
         END                                                                    
*                                                                               
         L     R15,PCBPTP                                                       
         WITH  (PT,R15),'L JCBR,PTJCBP'  Unlucky user                           
         WITH  JCB,BEGIN                                                        
         MVC   DRERACCT(2),JCBACCT+3  gg                                        
         MVC   DRERACCT+3(3),JCBACCT  uuu                                       
         BTD   DRERSEQ,,LH:JCBSEQ  Line number                                  
         END                                                                    
*                                                                               
         LA    R1,DRERM1           Issue first wto                              
         WTO   MF=(E,(1))                                                       
*                                                                               
         LA    R1,DRERM2           Issue second wto                             
         WTO   MF=(E,(1))                                                       
*                                                                               
         PEND                                                                   
*                                                                               
IOERRCNT DC    F'0'                I/O error count                              
*                                                                               
DRERM1   DS    0F                                                               
         DC    AL2(DRERM1L)                                                     
         DC    X'8000'             Routing & desc codes present                 
         DC    C'*** '                                                          
DRERSYS  DC    CL8'WYLBUR'                                                      
         DC    C' *** Paging I/O error on page '                                
DRERPNO  DC    C'?????'                                                         
         DC    C' for '                                                         
DRERACCT DC    C'gg.uuu'                                                        
         DC    C' on line '                                                     
DRERSEQ  DC    C'???'                                                           
DRERM1L  EQU   *-DRERM1                                                         
         DC    X'0000'             Descriptor codes                             
         DC    X'4140'             Routcde=(2,8,10)                             
DRERM2   DC    0F'0',AL2(DRERM2L)                                               
         DC    X'8000'             Routing & desc codes present                 
         DC    C'*** '                                                          
DREROPCD DC    C'??'                                                            
         DC    C','                                                             
DRERCODE DC    C'??'                                                            
         DC    C','                                                             
DRERCSW  DC    C'????????????????'                                              
         DC    C','                                                             
DRERSNS  DC    C'????'                                                          
         DC    C','                                                             
DRERSEEK DC    C'????????????????'                                              
DRERM2L  EQU   *-DRERM2                                                         
         DC    X'0000'             Descriptor codes                             
         DC    X'4140'             Routcde=(2,8,10)                             
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  MGETNEW -- Routine to get a new "memory page" in PAR.                        
*                                                                               
*    A memory page is a WYLBUR page that is kept in virtual                     
*    memory, not part of WYLBUR's paging system.  Memory pages                  
*    are used to keep information global for all users.                         
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - ok; R0 = pageno;                                                     
*              PAR = new page data ptr                                          
*      4 - no more memory; R0/PAR = zero                                        
*                                                                               
*    Historical note:                                                           
*      Prior to 7/86, pagenos were halfword numbers.  Now they                  
*      are fullwords.  If the high-order bit is on, then the                    
*      "pageno" is actually just the address of a memory page.                  
*      If the high-order bit is off, then it is pageno of a                     
*      disk page.  Code that never gets memory pages can still                  
*      get away with saving just a halfword for a pageno, but it                
*      is a bad idea.  In the future, all pagenos should be                     
*      considered to be fullword quantities.                                    
*                                                                               
MGETNEW  XPROC                                                                  
         PFREE PAR                 Free any previous page                       
*                                                                               
         LH    R0,=AL2(CVPSZ)                                                   
         VCALL GETCORE             Get memory for page                          
*                                                                               
         L     R2,CVMPGMEM         Memory page byte count                       
         AR    R2,R0               Keep it accurate                             
         ST    R2,CVMPGMEM                                                      
*                                                                               
         LR    PAR,R1              Set page register                            
         LR    R0,R1                                                            
         O     R0,=A(X'80000000')  Indicate memory page address                 
         PRETURN (R0)              Return pageno to caller                      
         LA    PAR,0(PAR)          Return positive page address                 
         CLEAR R15                 Set good return code                         
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PGETNEW -- Routine to get a new page in PAR.                                 
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - ok; R0 = pageno;                                                     
*              PAR = new page data ptr                                          
*      4 - no more pages; R0/PAR = zero                                         
*                                                                               
PGETNEW  XPROC                                                                  
*-                                                                              
*-       In memory mode, there is no paging system so we always                 
*-         need to do an MGETNEW instead of PGETNEW.                            
*-                                                                              
         IF    CVFMEMPAGE,BEGIN    Memory mode...                               
         VCALL MGETNEW             Do memory style PGETNEW                      
         PRETURN (R0)              Return "pageno"                              
         EXIT  PGETNEW             Scram                                        
         END                                                                    
*                                                                               
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         PFREE PAR                 Free any previous page                       
*-                                                                              
*-       Allocate a new page number.                                            
*-                                                                              
         ACALL PALLOC              Get a new page number                        
         LR    R5,R0               Save pageno (for later)                      
         IF    Z,'LA R15,4'        No more pages                                
*                                                                               
         ELSE  BEGIN               Allocate a page buffer...                    
         LR    R1,R0                                                            
         GETPT R1                  Get PT ptr                                   
         WITH  (PT,R1)                                                          
         FAIL  (PTPCBP,NZ),PGETNEW1,'PGETNEW error.'                            
         FAIL  (JCBR,NE,PTJCBP),PGETNEW2,'PGETNEW error.'                       
         ST    R1,JCBPTA           Save PT ptr                                  
*-                                                                              
*-       Allocate a page buffer (if possible).                                  
*-                                                                              
         ACALL ALLOCPCB            Allocate PCB                                 
         IF    Z,BEGIN             Got a PCB...                                 
         L     R4,PTPCBP                                                        
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR16,'Dispatcher PCB error.'                  
         L     PAR,CVPINDEX(R4)    Page buffer ptr                              
         END                                                                    
*                                                                               
         ELSE  BEGIN               No buffers available now...                  
         SETUP (JCBR)                                                           
         PAUSE ,                   Let dispatcher allocate page                 
         END                                                                    
         CLEAR R15                 A-ok                                         
         END                                                                    
*                                                                               
         LR    R0,R5                                                            
         PRETURN (R0)              Return pageno                                
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PGETA -- Routine to get a page in PAR.                                       
*                                                                               
*    On entry:                                                                  
*      R0 - page-number of page to get                                          
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - ok (PAR = page data ptr)                                             
*                                                                               
PGETA    XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         FAIL  (JCB#PIO,NZ),PGETAD,'PGET error.'                                
***                                                                             
***  Get a regular page.                                                        
***                                                                             
         LTR   R5,R0               Page number to get                           
         IF    POS,BEGIN           Regular page...                              
         FAIL  (R5,GT,CVMAXPNO),PGETERR1,'PGET error.'                          
         GETPT R5                                                               
         WITH  (PT,R5)                                                          
         FAIL  (JCBR,NE,PTJCBP),PGETERR7,'PGET error.'                          
         IF    (R5,EQ,JCBPTA),PGETDONE  Already set, scram                      
*                                                                               
*  06/05/2000: MPD. FAIL if we ever to try to get the PAGE B                    
*                   page into PAGE A. I think this should never                 
*                   happen, and if it did, it might explain a                   
*                   DISPATCHER failsoft in the QBUFOFF below                    
*                   where the foward and backward pointers                      
*                   were both 0 (which should never happen                      
*                   unless the PCB was owned and therefore                      
*                   on no queue at all).                                        
*                                                                               
         FAIL  (R5,EQ,JCBPTB),"PGETA called to get PAGE B"                      
*                                                                               
         PFREE PAR                 Free previous page                           
         FAIL  (JCBPTA,NZ),PGETERR2,'PGET error.'                               
         ST    R5,JCBPTA           Set new page pointer                         
*                                                                               
         LT    R4,PTPCBP                                                        
         IF    Z,BEGIN             Not in core...                               
         SETUP (JCBR)                                                           
         PAUSE ,                   Dispatcher will read page                    
         FAIL  (PTPCBP,Z),PGETERR9,'PGET error.'                                
         B     PGETDONE                                                         
         END                                                                    
*                                                                               
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR17,'Dispatcher PCB error.'                  
*-                                                                              
*-       Must wait for I/O if I/O is going.                                     
*-                                                                              
         IF    PCBFIO,BEGIN        Dispatcher will wait for I/O...              
         SETUP (JCBR)                                                           
         PAUSE ,                   A trip through the dispatcher                
         L     R4,PTPCBP           (Dispatch could have changed PCB)            
         FAIL  PCBFIO,PGETERR3,'PGET error.'                                    
         B     PGETDONE                                                         
         END                                                                    
*-                                                                              
*-       Take buffer off buffer queue and scram.                                
*-                                                                              
         QBUFOFF ,                 Take buffer off queue                        
*                                                                               
         L     PAR,PCBBUFP         Load page data ptr                           
         B     PGETCHK                                                          
         END                                                                    
***                                                                             
***  Get a memory page.                                                         
***                                                                             
         IF    NEG,BEGIN           Memory page...                               
         N     R5,=A(X'7FFFFFFF')  Positive for page address                    
*                                                                               
         IF    (PAR,EQ,R5),PGETDONE  Already set, scram                         
*                                                                               
         PFREE PAR                 Free previous page                           
         FAIL  (JCBPTA,NZ),PGETERR4,'PGET error.'                               
*-                                                                              
*-       Note:  For memory pages, JCBPTA is zero because memory                 
*-         pages exist in memory only and are never moved or paged              
*-         out by WYLBUR.  Hence the dispatcher does not need to                
*-         worry about re-locating the page register when it is                 
*-         pointing to a memory page.                                           
*-                                                                              
         LR    PAR,R5              Set page data ptr                            
*-                                                                              
*-       When getting a memory page it is important to never return             
*-         to through the WYLBUR dispatcher (i.e., don't call                   
*-         SLICECHK).  This is so that the higher level logic won't             
*-         have to worry about being interrupted in the middle of a             
*-         low level operation.  See comments in RECS for a more                
*-         detailed discussion of the possible pitfalls.                        
*-                                                                              
         B     PGETDONE                                                         
         END                                                                    
***                                                                             
***  Page number is zero.                                                       
***                                                                             
         KAPUT PGETERR5,'PGET error.'                                           
*                                                                               
PGETCHK  ACALL SLICECHK            Check for timeslice expiration               
PGETDONE LABEL ,                                                                
         LA    PAR,0(PAR)          Return positive page address                 
         CLEAR R15                 Return good CC                               
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PGETB -- Routine to get a page in PBR.                                       
*                                                                               
*    On entry:                                                                  
*      R0 - page-number of page to get                                          
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - ok (PBR = page data ptr)                                             
*                                                                               
PGETB    XPROC                                                                  
         PFLIP ,                   Flip current PAR in PBR                      
         ACALL PGETA               Get page in PAR                              
         PFLIP ,                   Switch back                                  
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PNUMA -- Routine to return PAR's page number (or zero).                      
*                                                                               
*    On exit:                                                                   
*      R0 - pageno                                                              
*                                                                               
PNUMA    XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LT    R2,JCBPTA                                                        
         IF    NZ,BEGIN            Regular page...                              
         WITH  (PT,R2)                                                          
         L     R0,PTPNO            Return pageno                                
         END                                                                    
*                                                                               
         ELSE  BEGIN               Memory/no page...                            
         LTR   R0,PAR                                                           
         IF    NZ,BEGIN            Pageno is addr with hi-bit on                
         O     R0,=A(X'80000000')                                               
         END                                                                    
         END                                                                    
*                                                                               
         PRETURN (R0)                                                           
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PNUMB -- Routine to return PBR's page number (or zero).                      
*                                                                               
*    On exit:                                                                   
*      R0 - pageno                                                              
*                                                                               
PNUMB    XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LT    R2,JCBPTB                                                        
         IF    NZ,BEGIN            Regular page...                              
         WITH  (PT,R2)                                                          
         L     R0,PTPNO            Return pageno                                
         END                                                                    
*                                                                               
         ELSE  BEGIN               Memory/no page...                            
         LTR   R0,PBR                                                           
         IF    NZ,BEGIN            Pageno is addr with hi-bit on                
         O     R0,=A(X'80000000')                                               
         END                                                                    
         END                                                                    
*                                                                               
         PRETURN (R0)                                                           
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*                                                                               
*  PCHK -- Routine to check the validity of a page number.                      
*                                                                               
*                                                                               
*  On Entry:                                                                    
*       R0 - page number to check                                               
*                                                                               
*  On exit:                                                                     
*       R15 - cc=zero, if page number ok                                        
*             cc=nz, if invalid page number                                     
*                                                                               
*   Note: we check to see that page number is not too big                       
*         or too small, that it is owned, and owned by caller                   
*         of this routine.  no more.                                            
*                                                                               
*                                                                               
PCHK     XPROC                                                                  
         LA    R15,4               assume page number invalid                   
*                                                                               
         IF    ((R0,POS),AND,(R0,LE,CVMAXPNO)),BEGIN                            
         LR    R1,R0                                                            
         GETPT R1                  Get PT entry ptr                             
         WITH  (PT,R1)                                                          
         IF    (PTFREE,NZ),BEGIN           If not free                          
         IF    (PTJCBP,EQ,CVCURJCB),BEGIN    If owned by caller                 
         CLEAR R15                              Page number ok.                 
         END                                                                    
         END                                                                    
         END                                                                    
*                                                                               
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PTEMP -- Routine to put pageno in temporary directory.                       
*                                                                               
*    On entry:                                                                  
*      R0 - pageno                                                              
*                                                                               
PTEMP    XENTER                                                                 
         IF    (R0,NZ),BEGIN                                                    
         LH    R2,CPTEMPNP         Current dir offset                           
         IF    (R2,LT,CPTEMPP#*2),BEGIN  We have room...                        
         STH   R0,CPTEMPPG(R2)                                                  
         LA    R2,@R2+2                                                         
         STH   R2,CPTEMPNP                                                      
         END                                                                    
         ELSE  BEGIN               No more room...                              
         PJUNK (R0)                                                             
         CLEAR R0                                                               
         END                                                                    
         END                                                                    
         LTR   R0,R0               Set cc                                       
         XEXIT                                                                  
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PUNTEMP -- Routine to remove pageno from temporary directory.                
*                                                                               
*    On entry:                                                                  
*      R0 - pageno                                                              
*                                                                               
PUNTEMP  XENTER                                                                 
         CLEAR R2                                                               
         LH    R5,CPTEMPNP                                                      
         LR    R3,R5                                                            
         SH    R3,=AL2(2+1)        Remaining len-1 (for MVC)                    
         WHILE (R2,LT,R5),BEGIN    Loop thru all temp pages                     
         LA    R15,CPTEMPPG(R2)                                                 
         L2    R4,@R15             R4 - temp pageno entry                       
         IF    (R0,EQ,R4),BEGIN    If correct entry, delete from list           
         LA    R15,CPTEMPPG(R2)                                                 
         IF    (R3,POS),'EX R3,"MVC @R15(0),@R15+2"'                            
         SH    R5,=AL2(2)                                                       
         STH   R5,CPTEMPNP                                                      
         B     PUNTEXIT                                                         
         END                                                                    
         LA    R2,@R2+2                                                         
         SH    R3,=AL2(2)                                                       
         END                                                                    
         KAPUT PUNTERR,'PUNTEMP logic error.'                                   
PUNTEXIT XEXIT                                                                  
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PJNKTMP -- Routine to junk pageno in temporary directory.                    
*                                                                               
PJNKTMP  XENTER                                                                 
         PFREE PAR                                                              
         PFREE PBR                                                              
         CLEAR R2                                                               
         WHILE (R2,LT,CPTEMPNP),BEGIN                                           
         LA    R3,CPTEMPPG(R2)                                                  
         PJUNK L2:@R3                                                           
         LA    R2,@R2+2                                                         
         END                                                                    
         CLEAR CPTEMPNP                                                         
         XEXIT                                                                  
         DROP  BR                                                               
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PMARKA -- Routine to mark PAR page as changed.                               
*                                                                               
PMARKA   XPROC                                                                  
         L     JCBR,CVCURJCB       Are we running in user mode?                 
         WITH  JCB                                                              
*                                                                               
         LT    R2,JCBPTA           Is there a PAR buffer?                       
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R2),'L R4,PTPCBP'  Get page's PCB ptr                        
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR12,'Dispatcher PCB error.'                  
*                                                                               
         IF    ^PCBFMARK,BEGIN     Not yet marked...                            
         SET   PCBFMARK            Mark as changed                              
*-                                                                              
*-       Keep track of when the first change in a recovery page                 
*-         happens.                                                             
*-                                                                              
         L     R5,PCBBUFP                                                       
         SH    R5,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R5)                                                        
         END                                                                    
         END                                                                    
*                                                                               
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PMARKB -- Routine to mark PBR page as changed.                               
*                                                                               
PMARKB   XPROC                                                                  
         PFLIP ,                   Flip PAR and PBR                             
         ACALL PMARKA              Mark PAR (formerly PBR)                      
         PFLIP ,                   Flip back                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PLOCKA -- Routine to mark PAR page as unmovable.                             
*                                                                               
PLOCKA   XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LT    R2,JCBPTA           Is there a PAR buffer?                       
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R2),'L R4,PTPCBP'  Get page's PCB ptr                        
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR99,'Dispatcher PCB error.'                  
*                                                                               
         SET   PCBFLOCK            Lock page buffer in place                    
         END                                                                    
         PEND                                                                   
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  PLOCKB -- Routine to mark PBR page as unmovable.                             
*                                                                               
PLOCKB   XPROC                                                                  
         PFLIP ,                                                                
         VCALL PLOCKA                                                           
         PFLIP ,                                                                
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PUNLOCKA -- Routine to mark PAR page as movable again.                       
*                                                                               
PUNLOCKA XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LT    R2,JCBPTA           Is there a PAR buffer?                       
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R2),'L R4,PTPCBP'  Get page's PCB ptr                        
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR98,'Dispatcher PCB error.'                  
*                                                                               
         CLEAR PCBFLOCK            Clear buffer lock                            
         END                                                                    
         PEND                                                                   
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  PUNLOCKB -- Routine to mark PBR page as movable again.                       
*                                                                               
PUNLOCKB XPROC                                                                  
         PFLIP ,                                                                
         VCALL PUNLOCKA                                                         
         PFLIP ,                                                                
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PTYPEA -- Routine to set the page type of the PAR page.                      
*                                                                               
*    On entry:                                                                  
*      R1 - 4 char page type (complemented if RECOVERY=YES)                     
*                                                                               
PTYPEA   XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LT    R2,JCBPTA           Do we have a page A?                         
         IF    NZ,BEGIN            Yes...                                       
         WITH  (PT,R2),'L R4,PTPCBP'  Get PCB ptr                               
*                                                                               
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR97,'Dispatcher PCB error.'                  
*                                                                               
         L     R5,PCBBUFP                                                       
         FAIL  (R5,NE,PAR),PTYPEX,'PTYPE logic error.'                          
         SH    R5,=AL2(PBUFUSER-PBUF)  Backup to PBUF proper                    
         WITH  (PBUF,R5)                                                        
         FAIL  (PBUF,NE,'PBUF'),PBUFERR1,'Dispatcher PBUF error.'               
*                                                                               
         IF    (R1,NEG),BEGIN                                                   
         SET   PBUFFRCV            Page is needed for recovery                  
         LCR   R1,R1                                                            
         END                                                                    
*                                                                               
         MVC   PBUFID,@R1          Save page type                               
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PTYPEB -- Routine to set the page type of the PBR page.                      
*                                                                               
*    On entry:                                                                  
*      R1 - 4 char page type (complemented if RECOVERY=YES)                     
*                                                                               
PTYPEB   XPROC                                                                  
         PFLIP ,                                                                
         VCALL PTYPEA                                                           
         PFLIP ,                                                                
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PDEBUG -- Local routine used only for debugging test systems.                
*    This routine moves the user's PAR and PBR page pointers to                 
*    a new location every time it is called.  This helps to                     
*    discover situations where a page pointer COULD change in a                 
*    heavily loaded system.                                                     
*                                                                               
PDEBUG   PROC                                                                   
         IF    ^CVFPGROT,PDEBEXIT   Not a test system, scram                    
*                                                                               
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*-                                                                              
*-       Switch any PAR buffer.                                                 
*-                                                                              
         IF    (JCBPTA,NZ),BEGIN   Switch PAR...                                
         L     R6,CVEMBUFQ         Empty buffer ptr                             
         IF    ('C R6,CVEMBUFQ+4',EQ),EXIT  None, scram                         
*                                                                               
         LR    R5,PAR                                                           
         SH    R5,=AL2(PBUFUSER-PBUF)  PBUF ptr                                 
         WITH  (PBUF,R5)                                                        
         FAIL  (PBUF,NE,'PBUF'),PBUG1,'PDEBUG logic error.'                     
         LH    R15,=AL2(PBUFEND-PBUF)                                           
         AR    R15,R5                                                           
         FAIL  (@R15,NE,'PENDBUF'),PBUG2,'PDEBUG logic error.'                  
*                                                                               
         L     R4,PBUFPCBP                                                      
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR18,'Dispatcher PCB error.'                  
         FAIL  (PCBPTP,Z),PBUG4,'PDEBUG logic error.'                           
         FAIL  PCBFIO,PBUG6,'PDEBUG logic error.'                               
         FAIL  PCBFJUNK,PBUG7,'PDEBUG logic error.'                             
         FAIL  (PCBQF,NZ),PBUG9,'PDEBUG logic error.'                           
*                                                                               
         IF    PCBFLOCK,EXIT       Can't move, scram                            
*-                                                                              
*-       Move data into new PBUF/PCB.                                           
*-                                                                              
         MVC   PCBCLEAR-PCB(L'PCBCLEAR,R6),PCBCLEAR  Copy info                  
         CLEAR PCBCLEAR            Zap it                                       
*                                                                               
         L     R2,PCBBUFP-PCB(R6)                                               
         SH    R2,=AL2(PBUFUSER-PBUF)                                           
         FAIL  (@R2,NE,'PBUF'),PBUG10,'PDEBUG logic error.'                     
         MOVEL PBUFSYS-PBUF(R2),PBUFSYS,LH:=AL2(CVPIOSZ)  Copy data             
         CLEAR PBUFSYS             Zap old system buffer                        
         LA    R0,PBUFUSER                                                      
         LH    R1,=AL2(CVPSZ)      Pad with x'81's                              
         CLEAR R14                                                              
         L     R15,=A(X'81000000')                                              
         MVCL  R0,R14              Zap old buffer                               
*                                                                               
         LA    R15,CVEMBUFQ-(PCBQF-PCB)                                         
         QBUFON ,                  Add buffer to empty queue                    
*                                                                               
         LR    R4,R6               New PCB ptr                                  
         L     R15,PCBPTP                                                       
         WITH  (PT,R15),BEGIN                                                   
         FAIL  (PTFREE,Z),PBUG11,'PDEBUG logic error.'                          
         ST    R4,PTPCBP           Point to correct PCB                         
         END                                                                    
*                                                                               
         QBUFOFF ,                 Remove new buffer from queue                 
*                                                                               
         L     PAR,PCBBUFP         Set new PAR ptr                              
         END                                                                    
*-                                                                              
*-       Switch any PBR buffer.                                                 
*-                                                                              
         IF    (JCBPTB,NZ),BEGIN   Switch PBR...                                
         L     R6,CVEMBUFQ         Empty buffer ptr                             
         IF    ('C R6,CVEMBUFQ+4',EQ),EXIT  None, scram                         
*                                                                               
         LR    R5,PBR                                                           
         SH    R5,=AL2(PBUFUSER-PBUF)  PBUF ptr                                 
         WITH  (PBUF,R5)                                                        
         FAIL  (PBUF,NE,'PBUF'),PBUGB1,'PDEBUG logic error.'                    
         LH    R15,=AL2(PBUFEND-PBUF)                                           
         AR    R15,R5                                                           
         FAIL  (@R15,NE,'PENDBUF'),PBUGB2,'PDEBUG logic error.'                 
*                                                                               
         L     R4,PBUFPCBP                                                      
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR19,'Dispatcher PCB error.'                  
         FAIL  (PCBPTP,Z),PBUGB4,'PDEBUG logic error.'                          
         FAIL  PCBFIO,PBUGB6,'PDEBUG logic error.'                              
         FAIL  PCBFJUNK,PBUGB7,'PDEBUG logic error.'                            
         FAIL  (PCBQF,NZ),PBUGB9,'PDEBUG logic error.'                          
*                                                                               
         IF    PCBFLOCK,EXIT       Can't move, scram                            
*-                                                                              
*-       Move data into new PBUF/PCB.                                           
*-                                                                              
         MVC   PCBCLEAR-PCB(L'PCBCLEAR,R6),PCBCLEAR  Copy info                  
         CLEAR PCBCLEAR            Zap it                                       
*                                                                               
         L     R2,PCBBUFP-PCB(R6)                                               
         SH    R2,=AL2(PBUFUSER-PBUF)                                           
         FAIL  (@R2,NE,'PBUF'),PBUGB10,'PDEBUG logic error.'                    
         MOVEL PBUFSYS-PBUF(R2),PBUFSYS,LH:=AL2(CVPIOSZ)  Copy data             
         CLEAR PBUFSYS             Zap old system buffer                        
         LA    R0,PBUFUSER                                                      
         LH    R1,=AL2(CVPSZ)      Pad with x'81's                              
         CLEAR R14                                                              
         L     R15,=A(X'81000000')                                              
         MVCL  R0,R14              Zap old buffer                               
*                                                                               
         LA    R15,CVEMBUFQ-(PCBQF-PCB)                                         
         QBUFON ,                  Add buffer to empty queue                    
*                                                                               
         LR    R4,R6               New PCB ptr                                  
         L     R15,PCBPTP                                                       
         WITH  (PT,R15),BEGIN                                                   
         FAIL  (PTFREE,Z),PBUGB11,'PDEBUG logic error.'                         
         ST    R4,PTPCBP           Point to correct PCB                         
         END                                                                    
*                                                                               
         QBUFOFF ,                 Remove new buffer from queue                 
*                                                                               
         L     PBR,PCBBUFP         Set new PBR ptr                              
         END                                                                    
PDEBEXIT PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PALLOC -- Routine to allocate a page slot.                                   
*                                                                               
*    On exit:                                                                   
*      R0 (and CC) - pageno or zero if there are no more pages                  
*                                                                               
PALLOC   XENTER                                                                 
         L     JCBR,CVCURJCB                                                    
         USING JCB                                                              
*                                                                               
         IF    (JCBNPG,GE,CVPPG),BEGIN  Time to get secondary page...           
         LT    R2,CVSPFCB          Start at secondary point                     
         IF    Z,EXIT              No secondary point defined, scram            
         WITH  (PFCB,R2)                                                        
         CLEAR R5                  Init for loop                                
         L     R4,=A(X'7FFFFFFF')  Dummy max                                    
NDPF     CL    R4,PFCBCP           Cur pages under min?                         
         BNH   DHPT                No                                           
         L     R3,PFCBCP           Get current page count                       
         CL    R3,PFCBNP           Compare to max for file                      
         BNL   DHPT                Br if already full                           
         LR    R4,R3               Save cur page count                          
         LR    R5,R2               Save PFCB ptr                                
DHPT     IF    PFCBFGND,BEGIN      End of group...                              
         IF    (R5,Z),EXIT         No space in this group                       
         B     PACOM               Join common code                             
         END                                                                    
         LA    R2,PFCBNEXT         Next page file                               
         CL    R2,CVLPFCB                                                       
         BL    NDPF                Br if more to search                         
         END                                                                    
*                                                                               
         L     R2,CVFPFCB          Run through page files                       
         WITH  (PFCB,R2),BEGIN                                                  
         CLEAR R5                                                               
         L     R4,=A(X'7FFFFFFF')                                               
NPTSRCH  CL    R4,PFCBCP           Cur pages under minimum fnd                  
         BNH   HPT                 Br if not                                    
         L     R3,PFCBCP           Get current page count                       
         CL    R3,PFCBNP           Compare to max for file                      
         BNL   HPT                 Br if already full                           
         LR    R4,R3               Save current page count                      
         LR    R5,R2               Save PFCB addr.                              
HPT      IF    PFCBFGND,NDPTSRCH   At end of group, scram                       
NXPT     LA    R2,PFCBNEXT         Next page file                               
         CL    R2,CVLPFCB                                                       
         BL    NPTSRCH             Br if more to search                         
*                                                                               
NMPG     CLEAR R0                  Set for no more pages                        
         B     PAEXIT              Scram                                        
*                                                                               
NDPTSRCH LTR   R5,R5               Any space in this group                      
         BZ    NXPT                Br no to do next group                       
         END                                                                    
*                                                                               
         USING PFCB,R5                                                          
*-                                                                              
*-       Get available PT entry.                                                
*-                                                                              
PACOM    LT    R4,PFCBAPQH         First available PT entry                     
         IF    Z,'CLEAR R0; B PAEXIT'  No more pages                            
*                                                                               
         WITH  (PT,R4),BEGIN                                                    
         FAIL  (R5,NE,PTPFCBP),PALLOY,'PALLOC logic error.'                     
         FAIL  (PTFREE,NZ),PALLOX,'PALLOC logic error.'                         
         MVC   PFCBAPQH,PTLINKP    Dequeue this PT entry                        
*                                                                               
         ST    JCBR,PTJCBP         Save our JCB ptr in PT entry                 
         CLEAR PTPCBP              Buffer not in core                           
         END                                                                    
*-                                                                              
*-       Compute page number.                                                   
*-                                                                              
         CLEAR R14                                                              
         LR    R15,R4                                                           
         S     R15,CVPTP           Compute page no.                             
         D     R14,=A(L'PT)                                                     
         LA    R0,@R15+1           Page number                                  
*                                                                               
         INCR  R2,PFCBCP                                                        
         IF    (R2,LGT,PFCBMP),'ST R2,PFCBMP'                                   
         INCR  R2,JCBNPG           Kick user's no. of pages                     
*                                                                               
*PERF*   LCALL BUFCHK              Validity check pageno & buffers              
*                                                                               
PAEXIT   LTR   R0,R0                                                            
         XEXIT                                                                  
         DROP  JCB,PFCB,BR                                                      
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PFREEA -- Routine to release PAR register.                                   
*                                                                               
PFREEA   XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LT    R5,JCBPTA           Do we have a page A?                         
         IF    NZ,BEGIN            Yes...                                       
         FAIL  (JCBPTA,Z),PFREEA8,'PFREE error.'                                
         WITH  (PT,R5)                                                          
         L     R4,PTPCBP           Page's PCB ptr                               
         WITH  (PCB,R4)                                                         
         FAIL  (PCB,NE,'PCB'),PCBERR20,'Dispatcher PCB error.'                  
         LA    R15,CVBUFQ-(PCBQF-PCB)  Dummy first entry                        
         QBUFON ,                  Add it to buffer queue                       
*                                                                               
         CLEAR PAR,JCBPTA                                                       
         END                                                                    
*                                                                               
         ELSE  BEGIN               Memory/No page...                            
         FAIL  (JCBPTA,NZ),PFREEA9,'PFREE error.'                               
         CLEAR PAR                                                              
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PFREEB -- Routine to release PBR register.                                   
*                                                                               
PFREEB   XPROC                                                                  
         PFLIP ,                                                                
         ACALL PFREEA                                                           
         PFLIP ,                                                                
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PJUNK -- Routine to junk a page.  Junking a page means that you              
*   (the current user) no longer want to own the page.                          
*                                                                               
*   On entry:                                                                   
*     R0 - pageno to junk                                                       
*                                                                               
PJUNK    XPROC                                                                  
*-                                                                              
*-       Free up memory pageno.                                                 
*-                                                                              
         IF    (R0,NEG),BEGIN      Memory pageno...                             
         LR    R1,R0               Address IS pageno                            
         VCALL FREECORE            Free the memory                              
*                                                                               
         L     R2,CVMPGMEM         Memory page byte count                       
         SH    R2,=AL2(CVPSZ)      Keep it accurate                             
         ST    R2,CVMPGMEM                                                      
*                                                                               
         B     PJNKEXIT                                                         
         END                                                                    
*                                                                               
*                                                                               
         L     JCBR,CVCURJCB       Our JCB ptr                                  
         WITH  JCB                                                              
*-                                                                              
*-       Free up our PT entry.                                                  
*-                                                                              
         FAIL  ((R0,NP),OR,(R0,GT,CVMAXPNO)),PJUNKERR                           
*                                                                               
         LR    R3,R0                                                            
         GETPT R3                                                               
         WITH  (PT,R3),BEGIN                                                    
         L     R5,PTPFCBP                                                       
         WITH  (PFCB,R5)                                                        
*                                                                               
         IF    (R3,EQ,JCBPTA),'PFREE PAR'                                       
         IF    (R3,EQ,JCBPTB),'PFREE PBR'                                       
*                                                                               
         LT    R4,PTPCBP           PCB ptr                                      
         IF    NZ,BEGIN            PCB is in core...                            
         WITH  (PCB,R4)                                                         
*                                                                               
         FAIL  (PCB,NE,'PCB'),PCBERR22,'Dispatcher PCB error.'                  
         FAIL  (R3,NE,PCBPTP),PJUNK1,'PJUNK logic error.'                       
         FAIL  (R0,NE,PTPNO),PJUNK2,'PJUNK logic error.'                        
         FAIL  (JCBR,NE,PTJCBP),PJUNK3,'PJUNK logic error.'                     
*-                                                                              
*-      If I/O is going on PCB don't do anything until it completes.            
*-       We set the PCBFJUNK flag and the PIODONE routine takes care            
*-         of junking the page when the I/O completes.                          
*-                                                                              
         IF    PCBFIO,BEGIN        Can't junk until I/O completes               
         SET   PCBFJUNK            Junk page when I/O completes                 
         CLEAR PTJCBP              No longer owned by this JCB                  
         DECR  R15,JCBNPG          Decr user's page count                       
         B     PJNKEXIT            Scram                                        
         END                                                                    
         END                                                                    
*-                                                                              
*-       Free up page number.                                                   
*-                                                                              
         CLEAR PTFREE              Pageno is available now                      
         MVC   PTLINKP,PFCBAPQH    Link up free PTs                             
         ST    R3,PFCBAPQH         We are the new free PT queue head            
*                                                                               
         DECR  R15,JCBNPG          Decr user's page count                       
         DECR  R15,PFCBCP          Decr current count                           
         END                                                                    
*-                                                                              
*-       Free any PCB.                                                          
*-                                                                              
         IF    (R4,NZ),BEGIN       PCB is in core...                            
         WITH  (PCB,R4)                                                         
         FAIL  (PCBQF,Z),PJUNK6,'PJUNK logic error.'                            
         CLEAR PCBCLEAR            Clear ownership info                         
         QBUFOFF ,                 Remove PCB from buffer queue                 
*                                                                               
         L     R2,PCBBUFP                                                       
         SH    R2,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R2),'CLEAR PBUFSYS'  Clear buffer prefix                   
*                                                                               
         LA    R15,CVEMBUFQ-(PCBQF-PCB)  Dummy first empty link                 
         QBUFON ,                  Add PCB to queue                             
         END                                                                    
*                                                                               
*PERF*   LCALL BUFCHK              Validity check pageno & buffers              
*                                                                               
PJNKEXIT PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PJUNKA -- Routine to free and junk the page pointed to by PAR.               
*                                                                               
PJUNKA   XPROC                                                                  
         IF    (PAR,NZ),BEGIN      We have a page...                            
         PNUM  PAR                 Get pageno (for PJUNK)                       
         PFREE PAR                 Free page register                           
         PJUNK (R0)                Junk the page                                
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PJUNKALL -- Routine to junk ALL the user's remaining pages.                  
*                                                                               
*    This is called when the user is logging off to do a final                  
*    cleanup.                                                                   
*                                                                               
PJUNKALL XPROC                                                                  
*-                                                                              
*-       Go through page table and free any of our pages.                       
*-                                                                              
         LA    R4,1                Starting page number                         
         L     R5,CVPTP            Starting PT entry                            
         WHILE (R4,LE,CVMAXPNO),BEGIN   Go through entries...                   
         WITH  (PT,R5)                                                          
*-                                                                              
*-       Junk our pages only!                                                   
*-                                                                              
         IF    (PTJCBP,EQ,CVCURJCB),BEGIN  Our page...                          
         PJUNK L:PTPNO                                                          
         END                                                                    
*                                                                               
*                                                                               
         LA    R5,PTNEXT           Next PT entry                                
         LA    R4,@R4+1            Next page number                             
         END                                                                    
*                                                                               
         PEND                                                                   
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PRCVYCHK -- Routine to check the pageno and tell the caller                  
*    if it is already allocated.  This routine is used by RECS                  
*    during WYLBUR recovery to see if the pages in the record                   
*    group are valid.                                                           
*                                                                               
*    On entry:                                                                  
*      R0 - pageno                                                              
*                                                                               
*    On exit, R15 (and cc):                                                     
*     -4 - bad pageno                                                           
*      0 - ok                                                                   
*      4 - page is already allocated                                            
*                                                                               
PRCVYCHK XPROC                                                                  
         LH    R15,=H'-4'          Assume bad pageno                            
*                                                                               
         IF    (R0,POS),BEGIN      Check pageno...                              
         IF    (R0,GT,CVMAXPNO),EXIT  Not valid, scram                          
         LR    R2,R0                                                            
         GETPT R2                                                               
         WITH  (PT,R2)                                                          
         IF    (PTFREE,NZ),'LA R15,4'  Already allocated                        
         ELSE  'CLEAR R15'         Not allocated                                
         END                                                                    
*                                                                               
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PRCVYSET -- Routine to mark the pageno as allocated to                       
*    the current user.  This routine is called by RECS to                       
*    rebuild a record group for WYLBUR recovery.                                
*                                                                               
*    On entry:                                                                  
*      R0 - pageno                                                              
*                                                                               
*    On exit, R15 (and cc):                                                     
*     -4 - bad pageno                                                           
*      0 - ok                                                                   
*      4 - page is already allocated                                            
*                                                                               
PRCVYSET XPROC                                                                  
         L     JCBR,CVCURJCB                                                    
         WITH  JCB                                                              
*                                                                               
         LH    R15,=H'-4'          Assume bad pageno                            
*                                                                               
         IF    (R0,POS),BEGIN      Check pageno...                              
         IF    (R0,GT,CVMAXPNO),EXIT  Not valid, scram                          
         LR    R1,R0                                                            
         GETPT R1                                                               
         WITH  (PT,R1)                                                          
*                                                                               
         IF    (PTFREE,NZ),'LA R15,4; B RCVYEXIT'  Already alloc'd              
*                                                                               
         L     R5,PTPFCBP                                                       
         WITH  (PFCB,R5)                                                        
*-                                                                              
*-       Fix up PT entry so that we now own this pageno.                        
*-                                                                              
         LA    R3,PFCBAPQH-(PTLINKP-PT)  Dummy first link                       
         LOOP  BEGIN                                                            
         LR    R2,R3               Save previous ptr                            
         WITH  (PT,R3)                                                          
         LT    R3,PTLINKP          Get next free PT entry ptr                   
         FAIL  Z,RCVYPERR,'RCVYPALO logic error.'                               
         IF    (R1,EQ,R3),BEGIN    We found our entry...                        
         MVC   PTLINKP-PT(4,R2),PTLINKP  Dequeue our entry                      
         B     RCVYCOM             Continue                                     
         END                                                                    
         END                                                                    
*                                                                               
RCVYCOM  ST    JCBR,PTJCBP         We own this PT entry now                     
         CLEAR PTPCBP              No PCB is in core                            
*                                                                               
         INCR  R15,JCBNPG          Kick user's page count                       
*                                                                               
         INCR  R15,PFCBCP          Count the allocated page                     
         IF    (R15,LGT,PFCBMP),'ST R15,PFCBMP'  Maximum allocated              
*                                                                               
         CLEAR R15                 Set good rc                                  
         END                                                                    
RCVYEXIT PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  BUFCHK -- Local routine to verify that the page number is NOT                
*    in the buffer queue.  This is simply a validity check and can              
*     be commented out to improve performance.                                  
*                                                                               
*    On entry:                                                                  
*      R0 - page number                                                         
*                                                                               
BUFCHK   PROC                                                                   
*-                                                                              
*-       Check buffer queue.                                                    
*-                                                                              
         LA    R4,CVBUFQ-(PCBQF-PCB)                                            
         WHILE ('C R4,CVBUFQ+4',NE),BEGIN  Check buffer queue...                
         WITH  (PCB,R4)                                                         
         L     R4,PCBQF            First/next buffer                            
         L     R5,PCBPTP                                                        
         FAIL  (R5,Z),BUFCHK1,'Dispatcher error.'                               
         WITH  (PT,R5)                                                          
         FAIL  (R4,NE,PTPCBP),BUFCHK2,'Dispatcher error.'                       
         FAIL  (PTJCBP,Z),BUFCHK3,'Dispatcher error.'                           
*                                                                               
         IF    (R0,EQ,PTPNO),BEGIN  Oops...                                     
         L2    R2,PCBFL                                                         
         L     R3,PTJCBP                                                        
         SET   CVFNORET            (Temporary)                                  
         KAPUT BUFERR,'Owned page error.'                                       
         END                                                                    
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*                                                                               
*  DBGREAD - debug page read.                                                   
*                                                                               
*  this routine will read any page specified by caller.                         
*  if page is not in core, page is read with stand alone read                   
*  routine (SAREAD).                                                            
*                                                                               
*  on entry:                                                                    
*       R0 - pageno                                                             
*       PAR - a page pointer (page contents destoryed)                          
*                                                                               
*  on exit:                                                                     
*       R1 - JCB of pages owner (zero if none)                                  
*       PAR - page pointer, contains contents of page specified                 
*       R15 - CC=0, successful read                                             
*             CC=NZ, read unsucessful, error message tseg'd                     
*                                                                               
*                                                                               
DBGREAD  XENTER                                                                 
         IF    ((R0,NP),OR,(R0,GT,CVMAXPNO)),BEGIN                              
         TSEG  'Invalid page number specified. '                                
         LA    R15,4                                                            
         B     DBGDONE                                                          
         END                                                                    
         LR    R1,R0               index into page table                        
         DECR  R1                                                               
         MH    R1,=AL2(L'PT)                                                    
         AL    R1,CVPTP            R1 - pt entry pointer                        
         USING PT,R1                                                            
         L     R6,PTJCBP           R6 - page owner jcb                          
*-                                                                              
*-       If page in core, move to par buffer.                                   
*-                                                                              
         IF    ((PTJCBP,NE,0),AND,(PTPCBP,NE,0)),BEGIN                          
         L     R4,PTPCBP                                                        
         WITH  (PCB,R4),BEGIN                                                   
         FAIL  (PCB,NE,'PCB'),PCBERR25,'Dispatcher PCB error.'                  
*        FAIL  (PCBPTP,Z),PBUG4,'DBGREAD logic error.'                          
*        FAIL  PCBFJUNK,PBUG7,'DBGREAD logic error.'                            
*        FAIL  (PCBQF,NZ),PBUG9,'DBGREAD logic error.'                          
         IF    PCBFIO,BEGIN                                                     
         TSEG  'I/O in progress on specified page. '                            
         LA    R15,4                                                            
         B     DBGDONE                                                          
         END                                                                    
         L     R5,PCBBUFP                                                       
         SH    R5,=AL2(PBUFUSER-PBUF)  PBUF ptr                                 
         WITH  (PBUF,R5),BEGIN                                                  
         FAIL  (PBUF,NE,'PBUF'),PBUG1,'DBGREAD logic error.'                    
         LH    R15,=AL2(PBUFEND-PBUF)                                           
         AR    R15,R5                                                           
         FAIL  (@R15,NE,'PENDBUF'),PBUG2,'DBGREAD logic error.'                 
         COMMENT                                                                
         COMMENT                   Move page contents to PAR page               
         LR    R0,PAR                                                           
         L     R1,=A(CVPSZ)                                                     
         LA    R2,PBUFUSER                                                      
         LR    R3,R1                                                            
         MVCL  R0,R2                                                            
         END   , WITH (R5,PBUF)                                                 
         END   , WITH (R4,PCB)                                                  
         CLEAR R15                                                              
         B     DBGDONE                                                          
         END   ,                   end of page in core                          
         DROP  R1                                                               
*-                                                                              
*-       If page not in core, read it in via stand alone read.                  
*-                                                                              
         LR    R5,PAR                                                           
         SH    R5,=AL2(PBUFUSER-PBUF)  PBUF ptr                                 
         WITH  (PBUF,R5),BEGIN                                                  
         FAIL  (PBUF,NE,'PBUF'),PBUG1,'DBGREAD logic error.'                    
         LH    R15,=AL2(PBUFEND-PBUF)                                           
         AR    R15,R5                                                           
         FAIL  (@R15,NE,'PENDBUF'),PBUG2,'DBGREAD logic error.'                 
         L     R4,PBUFPCBP                                                      
         WITH  (PCB,R4),BEGIN                                                   
         FAIL  (PCB,NE,'PCB'),PCBERR26,'Dispatcher PCB error.'                  
*        FAIL  (PCBPTP,Z),PBUG4,'DBGREAD logic error.'                          
         FAIL  PCBFIO,PBUG6,'DBGREAD logic error.'                              
*        FAIL  PCBFJUNK,PBUG7,'DBGREAD logic error.'                            
*        FAIL  (PCBQF,NZ),PBUG9,'DBGREAD logic error.'                          
         COMMENT                                                                
         LR    R15,R4              R15 - PCB                                    
         LR    R1,R0               R1 - pageno                                  
         ACALL SAREAD              Read specified page                          
         FAIL  NZ,SARDERR,'SAREAD failed. Invalid page number. '                
         CLEAR R15                                                              
         END   , WITH (PCB,R4)                                                  
         END   , WITH (PBUF,R5)                                                 
*                                                                               
DBGDONE  LABEL ,                                                                
         LR    R1,R6               RETRUN R1 -JCB, R15 -CC                      
         XEXIT ,,LTR                                                            
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  SAREAD -- Routine to read a page and wait for the I/O                        
*    completion.  This routine is ONLY called for debuging and                  
*    active file recovery.                                                      
*                                                                               
*    On entry:                                                                  
*      R1 - pageno to read                                                      
*      R15- PCB ptr                                                             
*                                                                               
*    On exit:                                                                   
*      R0 - pointer to page                                                     
*      R15- cc=zero, read ok                                                    
*           cc=nz, page number out of range                                     
*           (all other read errors result in failsoft)                          
*                                                                               
SAREAD   XENTER                                                                 
         LR    R5,R15                                                           
*                                                                               
         FAIL  CVFMEMPAGE,SAREAD,'SAREAD MEMPAGE logic error.'                  
*                                                                               
         IF    ((R1,NP),OR,(R1,GE,CVMAXPNO)),BEGIN                              
         LA    R15,4                                                            
         B     SARDDONE                                                         
         END                                                                    
*                                                                               
         WITH  (PCB,R5),BEGIN                                                   
         FAIL  (PCB,NE,'PCB'),PCBERR27,'Dispatcher PCB error.'                  
         FAIL  PCBFIO,SARDERR,'SAREAD logic error.'                             
*                                                                               
         L     R3,PCBPTP           Old PT entry ptr                             
*                                                                               
         GETPT R1                                                               
         ST    R1,PCBPTP           Set PT entry ptr                             
*                                                                               
         SET   PCBFSYNC            Synchronous request                          
         CLEAR PCBXECB             Make sure ECB is clear                       
         LA    R0,X'06'            Read CCW opcode                              
         LA    R15,PCB             Buffer ptr                                   
         LCALL SIO                 Do the I/O                                   
         WAIT  ECB=PCBXECB                                                      
*                                                                               
         ST    R3,PCBPTP           Restore old PT entry ptr                     
*                                                                               
         FAIL  (PCBCOD,NE,X'7F'),SARDERR,'Page I/O error.'                      
         CLEAR PCBFSYNC            Clear synchronous flag                       
         CLEAR PCBFIO,PCBFPOST     Clear I/O flags                              
         CLEAR PCBXECB                                                          
         L     R0,PCBBUFP          Return R0 - page pointer                     
         END                                                                    
         CLEAR R15                                                              
*                                                                               
SARDDONE LABEL ,                                                                
         XEXIT ,,LTR                                                            
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  SAWRITE -- Routine to write a page and wait for the I/O                      
*    completion.  This routine is ONLY called from initialization.              
*                                                                               
*    On entry:                                                                  
*      R1 - pageno to write                                                     
*      R15- PCB ptr                                                             
*                                                                               
SAWRITE  XENTER                                                                 
         LR    R5,R15                                                           
*                                                                               
         FAIL  CVFMEMPAGE,SAWRITE,'SAWRITE MEMPAGE logic error.'                
*                                                                               
         WITH  (PCB,R5),BEGIN                                                   
         FAIL  (PCB,NE,'PCB'),PCBERR28,'Dispatcher PCB error.'                  
         FAIL  PCBFIO,SAWRERR,'SAWRITE logic error.'                            
*                                                                               
         L     R3,PCBPTP           Old PT entry ptr                             
*                                                                               
         GETPT R1                                                               
         ST    R1,PCBPTP           Set PT entry ptr                             
*                                                                               
         SET   PCBFSYNC            Synchronous request                          
         CLEAR PCBXECB             Make sure ECB is clear                       
         LA    R0,X'05'            Write CCW opcode                             
         LA    R15,PCB             Buffer ptr                                   
         LCALL SIO                 Do the I/O                                   
         WAIT  ECB=PCBXECB                                                      
*                                                                               
         ST    R3,PCBPTP           Restore old PT entry ptr                     
*                                                                               
         FAIL  (PCBCOD,NE,X'7F'),SAWRERR,'Page I/O error.'                      
         CLEAR PCBFSYNC            Clear synchronous flag                       
         CLEAR PCBFIO,PCBFPOST     Clear I/O flags                              
         CLEAR PCBXECB                                                          
         END                                                                    
         XEXIT                                                                  
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  SLICECHK -- Routine to check if this user's timeslice has                    
*    expired.                                                                   
*                                                                               
SLICECHK XPROC                                                                  
         STCK  @R13                                                             
         LM    R2,R3,@R13          Current TOD clock                            
         SDL   R2,CVDSPCLK         Elapsed time this dispatch                   
*                                                                               
         IF    CVFPGROT,'LA R2,1'  Force page switching                         
*-                                                                              
*-       A user's maximum elapsed timeslice has expired.                        
*-                                                                              
         IF    ((R2,NZ),OR,(R3,LGT,CVSLICE)),BEGIN                              
         INCR  R5,CVNSLICE         Count timeslice expiration                   
         L     JCBR,CVCURJCB                                                    
         SETUP (JCBR)                                                           
         PAUSE                                                                  
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PAGEMON -- Routine to periodically allocate/free page buffers                
*    based on WYLBUR's current activity.  This routine must be                  
*    called by in "user mode" (i.e., not by the dispatcher                      
*    itself since we may have to wait the user when releasing                   
*    pages).                                                                    
*                                                                               
PAGEMON  XPROC                                                                  
         FAIL  (PAR,NZ),PMONERR,'Page monitoring error.'                        
*                                                                               
         IF    CVFMEMPAGE,EXIT     No paging system, scram                      
*                                                                               
         STCK  @R13                Current time of day                          
         L     R15,@R13                                                         
         S     R15,PMONCLK         Number of seconds since last time            
         IF    (R15,LLT,CVPGSECS),EXIT  Too soon, scram                         
         MVC   PMONCLK,@R13        Save new clock                               
*                                                                               
         ACALL CALCPGC             Re-calculate paging configuration            
*-                                                                              
*-       Time to check paging activity again.                                   
*-                                                                              
         CLEAR R5                  Signed page get/free count                   
         LH    R2,CV#IOSEC         Current page I/O's per second                
         IF    (R2,GT,CVPGHI),BEGIN  Too high...                                
         LA    R5,50               Number of new pages to get                   
         AH    R5,CVNPG            Desired new total count                      
         CEIL  R5,CVPGMAX          Not too much now                             
         SH    R5,CVNPG            Number of new pages to get                   
         END                                                                    
*                                                                               
         IF    (R2,LT,CVPGLO),BEGIN  Too low...                                 
         LH    R5,CVNPG                                                         
         SH    R5,=H'5'            Number of pages to reduce                    
         FLOOR R5,CVPGMIN          Not too small now                            
         SH    R5,CVNPG            Neg number                                   
         END                                                                    
*-                                                                              
*-       R5 is the signed number of pages to get/free.                          
*-                                                                              
         IF    (R5,NZ),BEGIN       Save monitoring info...                      
         STH   R5,CVPGADJ          Save adjustment page count                   
         MVC   CVPGCLK,PMONCLK     Save time of day                             
         END                                                                    
*                                                                               
         LTR   R5,R5               Get more pages?                              
         IF    POS,BEGIN           Add page buffers...                          
         WHILE (R5,POS),BEGIN      Add a page at a time...                      
         ACALL GETPCB              Add a page                                   
         DECR  R5                                                               
         END                                                                    
         END                                                                    
*                                                                               
         ELSE  BEGIN               Delete page buffers...                       
         LPR   R5,R5               Number of pages to delete                    
         WHILE (R5,POS),BEGIN      Delete a page at a time...                   
         ACALL FREEPCB             Free a page                                  
         IF    NZ,BEGIN            No empty pages...                            
         VCALL PGETNEW             Get a new page                               
         IF    Z,'PFREE PAR,EMPTY'  Free it and put page on emptyQ              
         END                                                                    
         ELSE  'DECR R5'                                                        
         END                                                                    
         END                                                                    
         PEND                                                                   
*                                                                               
PMONCLK  DC    F'0'                Clock at last monitor check                  
         EJECT                                                                  
*box                                                                            
*                                                                               
*  CALCPGC -- Routine to calculate the desired paging buffer                    
*    configuration.                                                             
*                                                                               
CALCPGC  XPROC                                                                  
*-                                                                              
*-       Switch from page-fixed page buffers to virtual page                    
*-         buffers during the low usage (non-day) hours.                        
*-                                                                              
         IF    CVPGFAUTO,BEGIN     Automaticly switch...                        
         LA    R2,99               Assume non-day setting                       
*                                                                               
         IF    ^CVFTEST,BEGIN      Only check for day if prod...                
         L     R15,CVTPTR                                                       
         WITH  (CVT,R15),'L R15,CVTUSER'                                        
         IF    ((R15,NZ),AND,(@R15,EQ,'SCIP')),BEGIN                            
         WITH  (USERCVT,R15),'LC R2,USEBLOCK'  Current time-block               
         END                                                                    
         END                                                                    
*                                                                               
         CLEAR CVPGFVIRT+CVPGFREAL                                              
         IF    ((R2,Z),OR,(R2,EQ,4)),'SET CVPGFREAL'  Day/peak                  
         ELSE  'SET CVPGFVIRT'     All other blocks                             
         END                                                                    
*-                                                                              
*-       Check to see how much real memory is currently available               
*-         to determine if we should use the large or small                     
*-         configuration.                                                       
*-                                                                              
         L     R4,CVTPTR                                                        
         WITH  (CVT,R4),'L R3,CVTRCEP'  SRM RCE ptr                             
         L     R2,@R3+4            RCEPOOL = memory online & avail              
         SRL   R2,8                Amount in megabytes                          
*-                                                                              
*-       Large configuration.                                                   
*-                                                                              
         IF    (R2,GT,CVPGMEG),BEGIN  Large configuration...                    
         MVC   CVPGMIN,CVPGLMIN    Set large min                                
         MVC   CVPGMAX,CVPGLMAX    Set large max                                
         END                                                                    
*-                                                                              
*-       Small configuration.                                                   
*-                                                                              
         ELSE  BEGIN               Small configuration...                       
         MVC   CVPGMIN,CVPGSMIN    Set small min                                
         IF    (CVPGMIN,Z),'MVC CVPGMIN,CVPGLMIN'  Or use large min             
         MVC   CVPGMAX,CVPGSMAX    Set small max                                
         IF    (CVPGMAX,Z),'MVC CVPGMAX,CVPGLMAX'  Or use large max             
         END                                                                    
*-                                                                              
*-       Check for reasonableness.                                              
*-                                                                              
         IF    (CVPGMAX,LT,CVPGMIN),'MVC CVPGMAX,CVPGMIN'                       
*                                                                               
         IF    (CVPGMAX,LT,10),'MVC CVPGMAX,=H"10"'  Too little                 
         IF    (CVPGMIN,LT,10),'MVC CVPGMIN,=H"10"'  Ditto                      
*                                                                               
         IF    (CVPGMAX,GT,8000),'MVC CVPGMAX,=H"8000"'  Too large              
         IF    (CVPGMIN,GT,8000),'MVC CVPGMIN,=H"8000"'  Ditto                  
*                                                                               
         CLEAR R15                 Neatness                                     
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  PREAD -- Local routine to queue a page read.                                 
*                                                                               
*    On entry:                                                                  
*      R15- PCB ptr                                                             
*                                                                               
PREAD    XENTER R2,R8,,LOCAL                                                    
         LA    R0,X'06'            Read CCW opcode                              
         BASE  SIOBASE                                                          
         B     SIOCOM                                                           
*                                                                               
         DROP  BR                                                               
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  PWRITE -- Local routine to queue a page write.                               
*                                                                               
*    On entry:                                                                  
*      R15- PCB ptr                                                             
*                                                                               
PWRITE   XENTER R2,R8,,LOCAL                                                    
         LA    R0,X'05'            Write CCW opcode                             
         BASE  SIOBASE                                                          
         B     SIOCOM                                                           
*                                                                               
         DROP  BR                                                               
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  SIO -- Routine to start a page I/O operation.                                
*                                                                               
*    On entry:                                                                  
*      R0 - CCW read/write opcode                                               
*      R15- PCB ptr                                                             
*                                                                               
SIO      XENTER R2,R8,,LOCAL                                                    
*                                                                               
         BASE                                                                   
SIOBASE  LABEL                                                                  
*                                                                               
SIOCOM   FAIL  CVFMEMPAGE,SIOERR,'MEMPAGE logic error.'                         
*                                                                               
         LR    R4,R15              Copy PCB ptr                                 
         USING PCB,R4                                                           
         FAIL  (PCB,NE,'PCB'),PCBERR29,'Dispatcher PCB error.'                  
*                                                                               
         IF    (PCBQF,NZ),BEGIN    Could be trouble...                          
         IF    PCBFSYNC,EXIT       Ok if SAREAD/SAWRITE                         
         KAPUT SIOERR,'Dispatcher error.'                                       
         END                                                                    
*                                                                               
         L     R5,PCBBUFP                                                       
         SH    R5,=AL2(PBUFUSER-PBUF)                                           
         USING PBUF,R5                                                          
         FAIL  (PBUF,NE,'PBUF'),PBUFERR9,'PBUF logic error.'                    
*                                                                               
         STC   R0,PCCWRW           Set read/write CCW opcode                    
         IF    (R0,EQ,X'05'),'SET PCBFIOWR'  I/O operation is write             
*                                                                               
         L     R15,PCBPTP                                                       
         WITH  (PT,R15),BEGIN                                                   
         L     R1,PTPNO            Our pageno                                   
         L     R2,PTPFCBP          Our PFCB ptr                                 
         END                                                                    
*                                                                               
         USING PFCB,R2                                                          
*                                                                               
         CLEAR R0                  Compute ttrn                                 
         S     R1,PFCBFPNO         Relative to first PFCB pageno                
         DECR  R1                                                               
         D     R0,PFCBRPT                                                       
         AL    R0,=F'1'                                                         
*                                                                               
         MVC   PCBIOSB+(IOSUCB-IOSB)(4),PFCBUCBP  UCB ptr in IOSB               
*                                                                               
         MVI   PCCWSECT,X'03'      NOP CCW (for non-RPS)                        
         IF    PFCBFRPS,BEGIN      RPS device...                                
         MVI   PCCWSECT,X'23'      Set Sector CCW                               
         LR    R3,R0               Put record no. in R3                         
         IC    R3,PFCBSECT-1(R3)   Pick up sector value                         
         STC   R3,PBUFSECT         Save in PBUF for set sector                  
         END                                                                    
*                                                                               
         SLL   R0,8                                                             
         SLL   R1,16                                                            
         OR    R0,R1               Ttrz                                         
         LA    R1,PFCBDCB          Point to DCB                                 
         DROP  PFCB                                                             
         L     R1,DCBDEBAD-IHADCB(,R1)  DEB addr                                
         LA    R2,PBUFSEEK                                                      
         XPUSH R9,R15              IECPCNVT only preserves R3-R8                
         LR    R3,R13                                                           
         L     R15,16                                                           
         L     R15,28(,R15)        Ep to conversion routine                     
         BASR  R14,R15             Go convert                                   
         LR    R13,R3              Restore                                      
         XPOP  R9,R15              ..our regs                                   
*-                                                                              
*-       Do the STARTIO.                                                        
*-                                                                              
         FAIL  PCBFIO,SIO,'SIO logic problem.'                                  
         SET   PCBFIO              I/O now in progress                          
*                                                                               
         IF    ^PCBFSYNC,BEGIN     Asynchronous I/O...                          
         FAIL  (PCBQF,NZ),SIO2,'SIO queue problem.'                             
         CLEAR PCBPOSTL            Clear link                                   
         END                                                                    
*                                                                               
         MODESET MODE=SUP          ********                                     
*                                                                               
         LA    R15,PCBIOSB         IOSB ptr                                     
         WITH  (IOSB,R15),BEGIN                                                 
         SET   (IOSFLA.IOSACHN,EQ) Set chain & clear error                      
         MVC   IOSEEK,PBUFSEEK     Set seek address                             
         MVC   IOSEEKA,PBUFSEEK    Ditto                                        
         CLEAR IOSPROC             CLEAR                                        
         CLEAR IOSERP                ERROR                                      
         CLEAR IOSIPIB                 FIELDS                                   
         END                                                                    
*                                                                               
         STCK  PCBCLCK             Save TOD clock when I/O starts               
*                                                                               
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  Get into key zero                     
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,RELATED=SIO             
         STM   R0,R15,@R13         Save regs                                    
         LA    R1,PCBSRB           SRB pointer                                  
         STARTIO SRB=(1),TCB=SRB                                                
         LM    R0,R15,@R13         Restore regs                                 
         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,RELATED=SIO                        
         MODESET KEYADDR=(2)       Back to our key                              
*                                                                               
         MODESET MODE=PROB         ********                                     
         XEXIT                                                                  
         DROP  PCB,PBUF,BR                                                      
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  GETCOREX -- Same as GETCORE, but lets the caller specify the                 
*              subpool.                                                         
*                                                                               
*    WYLBUR Subpool usage:                                                      
*          10   -- GETCORE requests.                                            
*          15   -- GETCORE requests satisfied from CELL POOLS                   
*          20   -- Storage for CPs.                                             
*          30   -- Storage for PBUFs (page buffers).                            
*          40   -- Storage for stacks                                           
*          45   -- Storage for heaps                                            
*          50   -- TTYPE entries.               <== to do                       
*          60   -- IOWAs (disk/subtask buffers).                                
*          70   -- Spelling Dictionary.         <== to do                       
*          80   -- SHOW CATALOG jumbo buffer.                                   
*          90   -- HCMDs (history command entries).                             
*                                                                               
*    On entry:                                                                  
*      R0 - no. of bytes needed                                                 
*      R15 - subpool number (GETCOREX entry only)                               
*                                                                               
*    On exit:                                                                   
*      R1 - addr of memory                                                      
*      R0 - no. of bytes obtained (ge needed)                                   
*                                                                               
GETCOREX XPROC                                                                  
         LR    R6,RAR              Save callers addr                            
         LR    R3,R15              Save desired subpool number                  
*                                                                               
         AH    R0,=H'7'                                                         
         N     R0,=F'-8'           Doubleword                                   
         AH    R0,=H'16'           Overhead                                     
         LR    R4,R0               Save length for later                        
*gen                                                                            
         GETMAIN RU,LV=(0),SP=(R3),LOC=ANY  Get memory                          
*nogen                                                                          
         MVC   @R1(3),=C'MEM'      Identifier                                   
         STC   R3,@R1+3            Save subpool number                          
*                                                                               
         ST    R4,@R1+4            Len                                          
         ST    R6,@R1+8            Caller's addr (for debugging)                
         LA    R15,@R1(R4)                                                      
         SH    R15,=H'4'                                                        
         MVC   @R15(4),=C'MEND'    Ending identifier                            
*                                                                               
         L     R2,CVMEMTOT         Keep count of bytes...                       
         AR    R2,R4               ...allocated                                 
         ST    R2,CVMEMTOT         ...by GETCORE                                
*                                                                               
         LA    R1,@R1+12           Skip past overhead prefix                    
         LR    R0,R4                                                            
         SH    R0,=H'16'           Deduct overhead                              
*                                                                               
         INCR  R15,CV#CNT1         Count 'em                                    
*                                                                               
         PRETURN (R0,R1)           Return len, loc                              
         CLEAR R15                 Always good rc                               
         PEND                                                                   
         QLTORG ,                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  GETCORE -- Routine to get memory.                                            
*                                                                               
*    On entry:                                                                  
*      R0 - no. of bytes needed                                                 
*      R15 - subpool number (GETCOREX entry only)                               
*                                                                               
*    On exit:                                                                   
*      R1 - addr of memory                                                      
*      R0 - no. of bytes obtained (ge needed)                                   
*                                                                               
GETCORE  XPROC                                                                  
         AH    R0,=H'7'                                                         
         N     R0,=F'-8'           Doubleword                                   
*                                                                               
         IF    (R0,LE,=F'1024'),BEGIN Use a cell pool                           
         LA    R15,CEL0TO1K                                                     
         USING CELLBLOK,R15                                                     
         AH    R0,=H'16'           Account for memory overhead                  
         WHILE (R0,GT,CELSIZE),BEGIN                                            
         LA    R15,L'CELLBLOK(,R15)                                             
         END                                                                    
         DROP  R15                                                              
         LR    R6,R15              Copy for later                               
         ACALL GETPOOL                                                          
*                                                                               
* Set up memory overhead data                                                   
*                                                                               
         MVC   @R1(4),=C'POOL'     Identifier                                   
         ST    R0,@R1+4            Actual len                                   
         ST    R6,@R1+8            Save cell block address                      
         LR    R15,R1                                                           
         AR    R15,R0                                                           
         SH    R15,=H'4'                                                        
         MVC   @R15(4),=C'MEND'    Ending identifier                            
*                                                                               
         LA    R1,@R1+12           Skip past overhead prefix                    
         SH    R0,=H'16'           Deduct overhead                              
         END                                                                    
         ELSE  BEGIN                                                            
         LA    R15,10              Use subpool 10                               
         ACALL GETCOREX                                                         
         END                                                                    
*                                                                               
         PRETURN (R0,R1)           Return len, loc                              
         CLEAR R15                 Always good rc                               
         PEND                                                                   
*                                                                               
* Arrays of cell blocks used for quick allocation of certain                    
* memory sizes.                                                                 
*                                                                               
CEL0TO1K CELLBLOK SIZE=32+16,SUBPOOL=15  For up to 1K allocations               
         CELLBLOK SIZE=64+16,SUBPOOL=15                                         
         CELLBLOK SIZE=128+16,SUBPOOL=15                                        
         CELLBLOK SIZE=256+16,SUBPOOL=15                                        
         CELLBLOK SIZE=512+16,SUBPOOL=15                                        
         CELLBLOK SIZE=1024+16,SUBPOOL=15                                       
         QLTORG ,                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FREECORE -- Routine to release memory.                                       
*                                                                               
*    On entry:                                                                  
*      R1 - address of memory being released                                    
*                                                                               
FREECORE XPROC                                                                  
         LR    R6,RAR              Save caller's addr                           
         SH    R1,=H'12'           Backup for prefix                            
         L     R4,@R1+4            Get length                                   
         LA    R15,@R1(R4)                                                      
         SH    R15,=H'4'                                                        
         FAIL  (@R15,NE,'MEND'),FREECORE,'Freecore overrun error.'              
*                                                                               
         IF    (@R1,EQ,'POOL'),BEGIN                                            
         L     R15,@R1+8           Get cell block address                       
         ACALL FREEPOOL                                                         
         END                                                                    
*                                                                               
         ELSE  BEGIN                                                            
         FAIL  (@R1,NE,'MEM'),FREECORE,'Freecore error.'                        
         LC    R3,@R1+3            Subpool number                               
*                                                                               
         MVC   @R1(3),=C'FRM'      Tag as free                                  
         ST    R6,@R1+8                                                         
         MVC   @R15(4),=C'FEND'    Ending tag                                   
         FREEMAIN RU,A=(R1),LV=(R4),SP=(R3)  Release memory                     
*                                                                               
         L     R2,CVMEMTOT         Keep count of bytes...                       
         SR    R2,R4               ...allocated                                 
         ST    R2,CVMEMTOT         ...by GETCORE                                
*                                                                               
         INCR  R15,CV#CNT2         Count 'em                                    
         END                                                                    
*                                                                               
         CLEAR R1                                                               
         PRETURN (R1)              Return loc of zero (tidy)                    
*                                                                               
         CLEAR R15                 Always good rc                               
         PEND                                                                   
         QLTORG ,                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  GETPOOL -- Get a cell from a pool.                                           
*                                                                               
*    On entry:                                                                  
*      R15 - points to cell block.                                              
*                                                                               
*    On exit:                                                                   
*      R0 - size of cell                                                        
*      R1 - addr of cell                                                        
*                                                                               
*    Note: This code is from the IBM ESA/390 Principles                         
*          of Operation pg A-48 with embellishments for                         
*          counters.                                                            
*                                                                               
*          When we make use of trimming the free list                           
*          back, we'll need to switch to the Perform                            
*          Locked Operation instruction.                                        
*                                                                               
GETPOOL  XPROC                                                                  
         FAIL  (@R15,NE,'CELLBLOK'),GETPOOL,'Not a cell block'                  
         LR    R6,R15                                                           
         WITH  (CELLBLOK,R6)                                                    
         LM    R2,R3,CELFHDR                                                    
GTPLAGN  LABEL                                                                  
         IF    (R2,NZ),BEGIN                                                    
         L     R0,0(,R2)                                                        
         LR    R1,R3               Copy the counter                             
         CDS   2,0,CELFHDR         Update the free list                         
         BNE   GTPLAGN             Try again if update failed                   
         LR    R1,R2               Copy address to R1                           
*                                                                               
*  Update the count of free cells                                               
*                                                                               
         LA    R2,1                Update the count of                          
         L     R3,CELFCNT            free cells                                 
GTPUPD0  LR    R4,R3                                                            
         SR    R4,R2                                                            
         CS    R3,R4,CELFCNT                                                    
         BNE   GTPUPD0                                                          
         END                                                                    
*                                                                               
         ELSE  BEGIN                                                            
         L     R0,CELSIZE          Size we need                                 
         L     R3,CELSUBP          and subpool                                  
*gen                                                                            
         GETMAIN RU,LV=(0),SP=(R3),LOC=ANY  Get memory                          
*nogen                                                                          
         LA    R2,1                Update the count of                          
         L     R3,CEL#GET            GETMAINs                                   
GTPUPD1  LR    R4,R3                                                            
         AR    R4,R2                                                            
         CS    R3,R4,CEL#GET                                                    
         BNE   GTPUPD1                                                          
         END                                                                    
*                                                                               
* Update the count of GETs for this pool                                        
*                                                                               
         LA    R2,1                Update the count of                          
         L     R3,CEL#REQ            requests                                   
GTPUPD2  LR    R4,R3                                                            
         AR    R4,R2                                                            
         CS    R3,R4,CEL#REQ                                                    
         BNE   GTPUPD2                                                          
*                                                                               
         L     R0,CELSIZE                                                       
         PRETURN (R0,R1)                                                        
         PEND                                                                   
         QLTORG ,                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FREEPOOL -- Release cell                                                     
*                                                                               
*    On entry:                                                                  
*      R1  - address of cell being released                                     
*      R15 - address of cell block                                              
*                                                                               
*    Note: This code is from the IBM ESA/390 Principles                         
*          of Operation pg A-48 with embellishments for                         
*          counters.                                                            
*                                                                               
*          When we make use of trimming the free list                           
*          back, we'll need to switch to the Perform                            
*          Locked Operation instruction.                                        
*                                                                               
FREEPOOL XPROC                                                                  
         FAIL  (@R15,NE,'CELLBLOK'),FREEPOOL,'Not a cell block'                 
         LR    R6,R15                                                           
         WITH  (CELLBLOK,R6)                                                    
         LR    R2,R1               Copy address                                 
         LM    R0,R1,CELFHDR                                                    
FREEAGN  ST    R0,0(,R2)           Link element to list head                    
         LR    R3,R1                                                            
         BCTR  R3,0                Decrement header counter                     
         CDS   0,2,CELFHDR         Put at head of list                          
         BNE   FREEAGN             Try again if failed                          
*                                                                               
*  Update the count of free cells                                               
*                                                                               
         LA    R2,1                Update the count of                          
         L     R3,CELFCNT            free cells                                 
FREEUPD0 LR    R4,R3                                                            
         AR    R4,R2                                                            
         CS    R3,R4,CELFCNT                                                    
         BNE   FREEUPD0                                                         
*                                                                               
         PEND                                                                   
         QLTORG ,                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  GETCPU -- Routine to calculate CPU time used.                                
*                                                                               
*    On exit:                                                                   
*      R0 - CPU time used since last dispatch (in TU's)                         
*      R1 - total WYLBUR CPU time used (in TU's)                                
*                                                                               
*    Note:  1 TU = 1/38400 second                                               
*                                                                               
GCPUWA   RECORD BEGIN                                                           
         XSA   R2,R8                                                            
*                                                                               
GCPUAJST DS    D           [Order] Needed to be able to align DOUB              
GCPUDOUB DS    D           [Order] Double word work area                        
         END                                                                    
*-                                                                              
GETCPU   XENTER R2,R8,L'GCPUWA                                                  
         USING GCPUWA,WAR                                                       
*-                                                                              
*-       Use CPUTIMER if possible (it's faster).                                
*-                                                                              
         IF    CVFXA,BEGIN         CPUTIMER only available in XA...             
         LA    R2,GCPUDOUB         Put result here                              
         N     R2,=A(-8)           Align (may use GCPUAJST area)                
         LR    R1,R2               For CPUTIMER                                 
         CPUTIMER TU,(1)           Get remaining time in TU's                   
         L     R0,@R2+4                                                         
         END                                                                    
*                                                                               
         ELSE  BEGIN               TTIMER...                                    
         TTIMER ,                  Read remaining time in R0                    
         END                                                                    
*                                                                               
         IF    (R15,NZ),'CLEAR R0,R1; B GTTEXIT'  Trouble, scram                
*                                                                               
         LCR   R1,R0                                                            
         AL    R1,TIMEVAL          Calc amount used in this interval            
         AL    R1,CVSCPUTM         Add in total at last stimer                  
         ST    R1,CVTCPUTM         Save total time used                         
         IF    (R0,LLT,TIMELOW),BEGIN  Restart timer...                         
         STIMER TASK,TIMESUP,TUINTVL=TIMEVAL  Restart timer                     
         MVC   CVSCPUTM,CVTCPUTM   Save cputime @ stimer                        
         L     R1,CVTCPUTM         Get total cputime wylbur used                
         END                                                                    
         LR    R0,R1                                                            
         SL    R0,CVRCPUTM         Time used during this dispatch               
         IF    NEG,'CLEAR R0'      Can't be negative                            
         S     R0,GTOVER           Deduct CPU time needed for GETCPU            
         IF    NEG,'CLEAR R0'      Can't be negative                            
*  Check for overhead mode...                                                   
         IF    (CPFEXEC,AND,CPFXAUTHLIB,AND,CPFXOVER),'CLEAR R0'                
GTTEXIT  XEXIT                                                                  
         DROP  GCPUWA,BR                                                        
*                                                                               
GTOVER   DC    F'5'                Deduct time used by GETCPU itself            
         SPACE 2                                                                
TIMESUP  BASE  ,                   Timer expired -- abend                       
         ABEND 322,DUMP            Looping looping (can't use kaput)            
         DROP  BR                                                               
*                                                                               
TIMEVAL  DC    A(180*300*128)      Set timer of 180 secs                        
TIMELOW  DC    A(120*300*128)      Restart timer if less than 120 secs          
         EJECT                                                                  
*box                                                                            
*                                                                               
*  GETPCB -- Routine to allocate and initialize a new PCB.                      
*    (Also called from MODE for SET WPAGES command.)                            
*                                                                               
GETPCB   XPROC                                                                  
         MODESET MODE=SUP          ********                                     
*-                                                                              
*-       Allocate PCB (which contains SRB/IOSB).                                
*-                                                                              
*- Get PCB from subpool 228: CSA, non-pageable, not fetch protected.            
*-                                                                              
         GETMAIN RU,LV=L'PCB,SP=228,LOC=ANY  Get PCB                            
         LR    R6,R1                                                            
         WITH  (PCB,R6)                                                         
         CLEAR PCB                 Initialize PCB                               
         MVC   PCB(4),=CL4'PCB'    Set self-identification                      
*                                                                               
*  Get data buffer above the 16M line, and initialize IDAL.                     
*                                                                               
         GETMAIN RU,LV=L'PBUF,BNDRY=PAGE,LOC=ANY,SP=30  I/O buf                 
         LR    R5,R1                                                            
         WITH  (PBUF,R5)                                                        
         ACALL FIX                 Page fix memory                              
*-                                                                              
*-       Count this buffer as below the 16 megabyte line if any of              
*-         the real addresses are below the line (remember one                  
*-         PBUF is multiple 4K MVS pages).                                      
*-                                                                              
         CLEAR R15                 Flag:  Assume all above 16M                  
         LR    R2,R5                                                            
         A     R2,=A(L'PBUF)       End of PBUF                                  
         LR    R1,R5                                                            
         WHILE (R1,LT,R2),BEGIN    Go through MVS pages...                      
         LRA   R3,@R1              Get real addr                                
         N     R3,=A(X'FF000000')                                               
         IF    Z,'LA R15,@R15+1'   Count VS page below the line                 
         A     R1,=F'4096'         Next VS page                                 
         END                                                                    
*                                                                               
         IF    (R15,NZ),BEGIN      We have pages below the line...              
         SET   PCBFLOW             PBUF is below the 16M line                   
         INCR  R0,CVNPG16M         Count buffer with low pages                  
         END                                                                    
*-                                                                              
*-       Initialize PBUF.                                                       
*-                                                                              
         ZOT   PBUF,LH:=AL2(L'PBUF)  Initialize buffer                          
         MVC   PBUF(4),=C'PBUF'    Set self-identification                      
         LA    R15,PBUF                                                         
         AH    R15,=AL2(PBUFEND-PBUF)                                           
         MVC   @R15(L'PBUFEND),=CL8'PENDBUF'  End of buffer id                  
*                                                                               
         LA    R15,PBUFUSER        User data buffer                             
         ST    R15,PCBBUFP         Save buffer ptr in PCB                       
*                                                                               
         ST    R6,PBUFPCBP         Save PCB ptr in buffer                       
*-                                                                              
*-       Set up channel program.                                                
*-                                                                              
         IF    CVFXA,BEGIN         Format 1 CCWs...                             
         MVC   PCCWS,MODXCCWS      Move in model fmt1 CCWs                      
         LRA   R15,PBUFSECT                                                     
         ST    R15,PCCWSECT+4      Fix up Set Sector                            
         LRA   R15,PBUFSEEK+3                                                   
         ST    R15,PCCWSID+4       Fix up Search Id Equal                       
         LRA   R15,PCCWSID                                                      
         ST    R15,PCCWTIC+4       Fix up Tic                                   
         LRA   R15,PBUFIDAL                                                     
         ST    R15,PCCWRW+4        Fix up Read/Write                            
         END                                                                    
*                                                                               
         ELSE  BEGIN               Format 0 CCWs...                             
         MVC   PCCWS,MODLCCWS      Move in model fmt0 CCWs                      
         LRA   R15,PBUFSECT                                                     
         ST3   R15,PCCWSECT+1      Fix up Set Sector                            
         LRA   R15,PBUFSEEK+3                                                   
         ST3   R15,PCCWSID+1       Fix up Search Id Equal                       
         LRA   R15,PCCWSID                                                      
         ST3   R15,PCCWTIC+1       Fix up Tic                                   
         LRA   R15,PBUFIDAL                                                     
         ST3   R15,PCCWRW+1        Fix up Read/Write                            
         END                                                                    
*                                                                               
         LA    R2,PBUFIDAL         Start of IDAL list                           
         LA    R3,PBUFBUF          Start of I/O buffer                          
         LR    R4,R3                                                            
         AH    R4,=AL2(L'PBUFBUF)  End of I/O buffer                            
         WHILE (R3,LT,R4),BEGIN    Build IDAL...                                
         LRA   R15,@R3                                                          
         FAIL  NZ,GETPCB,'GETPCB logic error.'                                  
         ST    R15,@R2             Save real address                            
         LA    R2,@R2+4            Next IDA entry                               
         N     R3,=A(X'7FFFF800')  Align to 2K boundry                          
         LA    R3,@R3+2048         Next 2K segment                              
         END                                                                    
*-                                                                              
*-       Initialize SRB/IOSB.                                                   
*-                                                                              
         LA    R4,PCBSRB           STARTIO SRB                                  
         WITH  (SRB,R4),BEGIN                                                   
         LA    R3,PCBIOSB          STARTIO IOSB                                 
         WITH  (IOSB,R3)                                                        
*                                                                               
         MVC   SRBID,=C'SRB '      Self-identication                            
         L     R15,CVASCBP                                                      
         ST    R15,SRBASCB         Save our ASCB ptr                            
         WITH  (ASCB,R15),'LH  R1,ASCBASID'                                     
         STH   R1,SRBPASID         ... and ASCB id                              
         MVC   SRBPTCB,CVTCBP      Save our TCB ptr                             
         MVC   SRBPKF,CVKEY        Set storage key                              
         ST    R3,SRBPARM          SRB parm points to IOSB                      
*                                                                               
         ST    R4,IOSSRB           Save SRB ptr in IOSB                         
*                                                                               
         IF    CVFXA,'SET IOSOPT2.IOSF'  Format 1 CCWs being used               
         LA    R15,PCCWS           Start of channel program                     
         ST    R15,IOSVST          Save virtual channel program ptr             
         LRA   R15,@R15                                                         
         ST    R15,IOSRST          Save real channel program ptr                
*                                                                               
         MVI   IOSDVRID,IOSMISID   Set misc IOS driver ID                       
         MVC   IOSASID,SRBPASID    Set ASCB id                                  
         MVC   IOSPGAD,=A(IOTERM)  I/O termination routine                      
         IF    CVFXA,'SET IOSPGAD.X"80"'  Set AMODE 31 for MVS/XA               
         MVC   IOSCKEY,CVKEY       Set CCW area key                             
         MVC   IOSPKEY,CVKEY       Set termination routine key                  
         SET   IOSPKEY.IOSLCL      Schedule at ASCB's priority                  
         ST    R6,IOSUSE           Set PCB ptr as IOSB parm                     
         L     R15,=A(DUMMYRET)    Dummy return routine                         
         IF    CVFXA,'O R15,=A(XA)'  Set AMODE 31 for MVS/XA                    
         ST    R15,IOSNRM          Normal end appendage                         
         ST    R15,IOSABN          Abnormal end appendage                       
         SET   IOSFMSK.X'80'       Set file mask                                
         END                                                                    
*-                                                                              
*-       Finally, link up PCB and add it to the empty queue.                    
*-                                                                              
         MVC   PCBLINK,CVPCBQH     Our forward link is old head                 
         ST    R6,CVPCBQH          We are the new first buffer                  
*                                                                               
         LA    R4,PCB              QBUFON assumption                            
         LA    R15,CVEMBUFQ-(PCBQF-PCB)  Dummy first link                       
         QBUFON ,                  Add new PCB to empty queue                   
*                                                                               
         INCR  R15,CVNPG           Total number of page buffers                 
*                                                                               
         MODESET MODE=PROB         ********                                     
         PEND                                                                   
         SPACE 2                                                                
***                                                                             
***  Model channel program for page I/O (must match PCCWS exactly).             
***                                                                             
*-                                                                              
*-       FORMAT 0 CCWs  (for MVS/SP, when data is below 16M line)               
*-                                                                              
MODLSTRT CCW   X'23',*-*,X'40',1                .Set Sector/Nop                 
         CCW   X'31',*-*,X'40',5                .Search id equal                
         CCW   X'08',*-*,0,0                    .Tic *-8                        
         CCW   X'06',*-*,X'04',CVPIOSZ          .Read/Write data                
MODLCCWS EQU   MODLSTRT,*-MODLSTRT,C'X'                                         
         SPACE 2                                                                
*-                                                                              
*-       FORMAT 1 CCWs  (for MVS/XA, when data is above 16M line)               
*-                                                                              
         DS    0D                                                               
MODXSTRT DC    X'23',X'40',AL2(1),A(*-*)        .Set Sector/Nop                 
         DC    X'31',X'40',AL2(5),A(*-*)        .Search id equal                
         DC    X'08',X'00',AL2(0),A(*-*)        .Tic *-8                        
         DC    X'06',X'04',AL2(CVPIOSZ),A(*-*)  .Read/Write Date                
MODXCCWS EQU   MODXSTRT,*-MODXSTRT,C'X'                                         
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FREEPCB -- Routine to free a page buffer.                                    
*    (Also called from MODE for SET WPAGES command.)                            
*                                                                               
*    On exit, R15 (and cc):                                                     
*      0 - ok                                                                   
*      4 - can't free a PCB, none on empty queue                                
*                                                                               
FREEPCB  XPROC                                                                  
         IF    CVFMEMPAGE,EXIT     No paging system, scram                      
*-                                                                              
*-       Free the first buffer on the empty queue.                              
*-                                                                              
         LA    R15,4               Assume the worst                             
*                                                                               
         LA    R1,CVEMBUFQ-(PCBQF-PCB)  Dummy first link                        
         IF    ('C R1,CVEMBUFQ',NE),BEGIN  At least one buffer...               
         L     R4,CVEMBUFQ         First buffer on empty queue                  
         WITH  (PCB,R4)                                                         
*-                                                                              
*-       Remove buffer from the empty queue.                                    
*-                                                                              
         QBUFOFF ,                 Take buffer off of empty queue               
*-                                                                              
*-       Remove buffer from the PCB linked list.                                
*-                                                                              
         LA    R6,CVPCBQH-(PCBLINK-PCB)  Dummy first link                       
         LOOP  BEGIN                                                            
         LR    R5,R6               Save previous ptr                            
         WITH  (PCB,R6)                                                         
         WHILE ('LT R6,PCBLINK',NZ)                                             
         IF    (R4,EQ,R6),BEGIN    This entry is our buffer...                  
         MVC   PCBLINK-PCB(4,R5),PCBLINK  Dequeue our buffer                    
         B     FPCBGO                                                           
         END                                                                    
         END                                                                    
         KAPUT FREEPCB1,'FREEPCB logic error.'                                  
*-                                                                              
*-       Finally, FREEMAIN the page buffer.                                     
*-                                                                              
FPCBGO   LA    R1,PCB                                                           
         LCALL JUNKPCB             FREEMAIN PCB                                 
*                                                                               
         DECR  R15,CVNPG           Keep buffer count accurate                   
*                                                                               
         CLEAR R15                 Set OK return code                           
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  DISPSTOP -- Routine to free page buffers (called at                          
*    termination).  This routine must always be called, even for                
*    abormal termination to free the PCBs in CSA.                               
*                                                                               
DISPSTOP XPROC                                                                  
*-                                                                              
*-       Free all PCBs.                                                         
*-                                                                              
         L     R5,CVPCBQH          First PCB on queue                           
         CLEAR CVPCBQH             Reset queue head                             
*                                                                               
         WHILE ('LTR R6,R5',NZ),BEGIN  Go through queue...                      
         WITH  (PCB,R6)                                                         
         L     R5,PCBLINK          Save next PCB ptr                            
*                                                                               
         LA    R1,PCB                                                           
         LCALL JUNKPCB             FREEMAIN PCB                                 
         END                                                                    
*                                                                               
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  JUNKPCB -- Local routine to FREEMAIN PCB.                                    
*                                                                               
*    On entry:                                                                  
*      R1 - PCB ptr                                                             
*                                                                               
JUNKPCB  PROC                                                                   
         LR    R6,R1                                                            
         WITH  (PCB,R6)                                                         
*                                                                               
         IF    (PCB,EQ,'PCB'),BEGIN  Free the PCB...                            
*-                                                                              
*-       Wait for I/O to complete.                                              
*-                                                                              
         IF    PCBFIO,BEGIN        I/O is active...                             
         IF    PCBFPOST,EXIT       It's OK, scram                               
         STIMER WAIT,BINTVL==A(5*100)  Five seconds                             
         IF    PCBFPOST,EXIT       It's done now                                
         WTO   'Page I/O didn''t complete!'                                     
         B     JPCBERR             Forget it                                    
         END                                                                    
*-                                                                              
*-       Check PCB validity.                                                    
*-                                                                              
         L     R5,PCBBUFP          Page buffer ptr                              
         SH    R5,=AL2(PBUFUSER-PBUF)                                           
         WITH  (PBUF,R5)                                                        
         IF    (PBUF,NE,'PBUF'),JPCBERR  Hmmm... forget it                      
         LR    R15,R5                                                           
         AH    R15,=AL2(PBUFEND-PBUF)                                           
         IF    (@R15,NE,'PENDBUF'),JPCBERR  Forget it                           
*                                                                               
         IF    PCBFLOW,'DECR R0,CVNPG16M'  Buffer was below 16M line            
*                                                                               
         MVC   PCB(4),=C'OPCB'     Reset ident fields                           
         MVC   PCBLINK,=F'-1'                                                   
         MVC   PCBBUFP,=F'-1'                                                   
         MVC   PBUF(4),=C'OBUF'                                                 
         MVC   @R15(8),=C'OENDBUF'                                              
*                                                                               
         SETMSG PCB                 Free loc, len                               
         LA    R15,228             Subpool 228                                  
         FREEMAIN RU,LV=(0),A=(1),SP=(15)  Free PCB                             
*                                                                               
         SETMSG PBUF,LH:=AL2(L'PBUF)                                            
         ACALL UNFIX               Unfix PBUF                                   
         FREEMAIN RU,LV=L'PBUF,A=(R5),SP=30  Free PBUF                          
         B     JPCBEXIT                                                         
         END                                                                    
*-                                                                              
*-       Leave PCB without releasing the memory.                                
*-                                                                              
JPCBERR  QSNAP 'Can''t free PCB'                                                
         QSNAP (R6)                                                             
*                                                                               
JPCBEXIT PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FMTWBUF -- Routine to display owned page buffer queue.                       
*    (Called by the SHOW WBUF command).                                         
*                                                                               
*    On entry:                                                                  
*      R15 - max number of buffers to display                                   
*                                                                               
WBUFWA   RECORD BEGIN                                                           
WBUFFMT  DS    CL20                Formatting area                              
         END                                                                    
*-                                                                              
FMTWBUF  XPROC WBUFWA                                                           
         IF    CVFMEMPAGE,EXIT     No paging system, forget it                  
*                                                                               
         LR    R5,R15              Max number of bufs to display                
*                                                                               
         TSEG  'Number of empty buffers: '                                      
*                                                                               
         CLEAR R15                 Empty buffer count                           
         LA    R4,CVEMBUFQ-(PCBQF-PCB)  Dummy first empty Q link                
         WHILE ('C R4,CVEMBUFQ+4',NE),BEGIN  Go through buffer...               
         WITH  (PCB,R4)                                                         
         LA    R15,@R15+1          Kick counter                                 
         L     R4,PCBQF            Next buffer                                  
         END                                                                    
         TNUM  (R15)                                                            
         TCR                                                                    
         TCR                                                                    
*                                                                               
         TSEG  'Owned buffer queue (in snatch order):',,CR                      
         TCR                                                                    
*-                                                                              
*-       Display queue from oldest to most recent (in the same                  
*-         order as we would "snatch" old pages).                               
*-                                                                              
         LA    R4,CVBUFQ-(PCBQF-PCB)  Dummy first buffer entry                  
*                                                                               
         WHILE (R5,POS),BEGIN      Go through queue...                          
         IF    ('C R4,CVBUFQ+4',EQ),EXIT  All done, scram                       
         WITH  (PCB,R4)                                                         
*                                                                               
         MVC   CVSPIEAD,=A(WBUFERR)  Catch S0C4's when queue changes            
         L     R4,PCBQF            Get first/next PCB                           
         CLEAR CVSPIEAD            Reset                                        
*                                                                               
         SETMSG ' '                                                             
         IF    PCBFMARK,'SETMSG "*"'  Changed flag                              
         TSEG  (R1),(R0)                                                        
*                                                                               
         THEX  (R4),8              PCB address                                  
*                                                                               
         STCK  @R13                                                             
         L     R15,@R13                                                         
         S     R15,PCBQCLCK        Buffer age (in seconds)                      
         IF    (NEG,OR,(PCBQCLCK,Z)),'LH R15,=H"-1"'  Odd                       
         IF    (R15,LT,120),BEGIN  Seconds...                                   
         TNUM  (R15),6                                                          
         TSEG  ' seconds    '                                                   
         END                                                                    
         ELSE  BEGIN               Convert to minutes...                        
         CLEAR R14                                                              
         D     R14,=F'6'           Convert to minutes * 10                      
         IF    (R14,GE,3),'INCR R15'  Round                                     
         BTR   WBUFFMT,(6,1),(R15)  "n.n minutes"                               
         TSEG  (R1),(R0)                                                        
         TSEG  ' minutes    '                                                   
         END                                                                    
*                                                                               
         MVC   CVSPIEAD,=A(WBUFERR)  Catch S0C4's when queue changes            
         L     R15,PCBPTP          Page table entry                             
         WITH  (PT,R15),'L R3,PTJCBP'  JCB ptr from PT                          
         CLEAR CVSPIEAD            Reset                                        
*                                                                               
         IF    (R3,NZ),BEGIN       Display owner...                             
         WITH  (JCB,R3)                                                         
         TSEG  'Line'                                                           
         TNUM  LH:JCBSEQ,4                                                      
         TSEG  ' '                                                              
         TSEG  JCBGRP                                                           
         TSEG  '.'                                                              
         TSEG  JCBUSER                                                          
         END                                                                    
*                                                                               
         TSEG  '  @'                                                            
         MVC   CVSPIEAD,=A(WBUFERR)  Catch S0C4's when queue changes            
         L     R2,PCBBUFP          Buffer address                               
         CLC   @R2(L'WBUFFMT),CVBLANKS  Dummy test to force S0C4                
         CLEAR CVSPIEAD            Reset                                        
         THEX  (R2),8                                                           
         IF    (R2,NZ),BEGIN       Format first few bytes...                    
         TSEG  ': '                                                             
         MVC   WBUFFMT,@R2         Copy first few bytes                         
         L     R15,=V(DOTTBL)                                                   
         TR    WBUFFMT,@R15        Change binary chars to dots                  
         TSEG  WBUFFMT                                                          
         END                                                                    
*                                                                               
         TCR                                                                    
*                                                                               
         DECR  R5                  One less buffer to display                   
         END                                                                    
*                                                                               
         IF    (R5,NP),'TSEG "(...more...)",,CR'                                
         PEND                                                                   
*-                                                                              
*-       SPIE exit routine for FMTWBUF.                                         
*-                                                                              
WBUFERR  PROC                                                                   
         TCCR                                                                   
         TSEG  'Buffer queue changed; command output stopped.'                  
         B     CVNEXT                                                           
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FMTPGQ -- Routine to format page queue.                                      
*                                                                               
*    On entry:                                                                  
*      R15 - queue head ptr                                                     
*      R1,R0 - queue type msg                                                   
*                                                                               
FMTPGQ   XPROC                                                                  
         IF    CVFMEMPAGE,EXIT     No paging system, forget it                  
*                                                                               
         LR    R2,R15                                                           
         XPUSH R0,R1                                                            
         TCR                                                                    
         TCR                                                                    
         XPOP  R0,R1                                                            
         TSEG  (R1),(R0)                                                        
         TSEG  ':'                                                              
         MVC   CPSEGINDF,CPSEGLENF Set indentation for cont lines               
         L     R3,@R2+4            Last entry                                   
         SH    R2,=Y(PCBQF-PCB)    Dummy first entry                            
         IF    (R2,EQ,R3),'TSEG " Empty"'                                       
         ELSE  BEGIN                                                            
         CLEAR R5                  Loop counter                                 
         WITH  (PCB,R2)                                                         
         LOOP  BEGIN                                                            
         L     R2,PCBQF            Next page                                    
         TSEG  CVBLANKS,1                                                       
         LT    R15,PCBPTP                                                       
         IF    NZ,BEGIN                                                         
         WITH  (PT,R15),'L R15,PTPNO'                                           
         END                                                                    
         THEX  (R15),8             Page no.                                     
         TSEG  ' ('                                                             
         THEX  (R2),8              PCB addr                                     
         TSEG  ')'                                                              
         LA    R5,@R5+1            Count number of buffers                      
         IF    (R5,GT,1000),BEGIN  We are in a loop...                          
         TSEG  ' ***TRUNCATED***'                                               
         CLEAR R2,R3               Get us out of the loop                       
         END                                                                    
         TMARK                                                                  
         UNTIL (R2,EQ,R3)                                                       
         END                                                                    
         END                                                                    
         TCR                                                                    
         CLEAR CPSEGINDF                                                        
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  KEYZERO -- Routine to change to PSW key zero.                                
*                                                                               
         ENTRY KEYZERO                                                          
KEYZERO  MODESET EXTKEY=ZERO                                                    
         BR    RAR                                                              
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  KEYNZERO -- Routine to change back to our Address Space key.                 
*                                                                               
         ENTRY KEYNZERO                                                         
KEYNZERO LR    R15,R2                                                           
         LC    R2,CVKEY                                                         
         MODESET KEYADDR=(2)       Our key                                      
         LR    R2,R15                                                           
         BR    RAR                                                              
         EJECT                                                                  
*box                                                                            
*                                                                               
*  LOCK -- Routine to lock out other tasks and appendage SRBs                   
*    (which hold the LOCAL lock) from running by obtaining the                  
*    LOCAL lock.                                                                
*                                                                               
LOCK     XPROC                                                                  
         MODESET EXTKEY=ZERO,SAVEKEY=(2)                                        
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=X              
         MODESET KEYADDR=(2)                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  UNLOCK -- Routine to allow other tasks and appendage SRBs                    
*    (which hold the LOCAL lock) to run by releasing the                        
*    LOCAL lock.                                                                
*                                                                               
UNLOCK   XPROC                                                                  
         MODESET EXTKEY=ZERO,SAVEKEY=(2)                                        
         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=X                         
         MODESET KEYADDR=(2)                                                    
         PEND                                                                   
         EJECT                                                                  
FIXWA    RECORD BEGIN                                                           
         XSA   R2,R8                                                            
FIXECB   DS    A                                                                
         END                                                                    
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  FIX -- Routine to page-fix memory.                                           
*                                                                               
*    On entry:                                                                  
*      R1,R0 - starting addr, len                                               
*                                                                               
FIX      XENTER R2,R8,L'FIXWA                                                   
         USING FIXWA,WAR                                                        
*                                                                               
         FAIL  (R0,NP),FIXERR,'PGFIX logic error.'                              
         LR    R15,R1                                                           
         AR    R15,R0              Ending address+1                             
*                                                                               
         CLEAR FIXECB                                                           
         LA    R0,FIXECB                                                        
*                                                                               
         IF    CVFXA,BEGIN         MVS/XA version...                            
         DECR  R15                 Actual ending address                        
*-                                                                              
*-       If you are assembling this for an MVS/SP system, then the              
*-         following "PGSER" macro may generate an assembly error.              
*-         Since PGSER is only executed if the system is MVS/XA                 
*-         then PGSER line can be safely commented out.                         
*-                                                                              
         PGSER R,FIX,A=(1),EA=(15),ECB=(0),LONG=Y  Fix pages (XA)               
         END                                                                    
*                                                                               
         ELSE  BEGIN               MVS/SP version...                            
         PGFIX R,A=(1),EA=(15),ECB=(0)  Fix pages (SP version)                  
         END                                                                    
*                                                                               
         IF    (R15,NZ),BEGIN      Something unusual...                         
         FAIL  (R15,NE,8),PGFIX,'PGFIX error'                                   
         WTO   'Page fix wait.'                                                 
         WAIT  ECB=FIXECB                                                       
         END                                                                    
*                                                                               
         CLEAR R15                 Return code                                  
         XEXIT                                                                  
         DROP  FIXWA,BR                                                         
         EJECT                                                                  
*box                                                                            
*                                                                               
*  UNFIX -- Routine to free previously page-fixed memory.                       
*                                                                               
*    On entry:                                                                  
*      R1,R0 - starting addr, len                                               
*                                                                               
UNFIX    XENTER                                                                 
         FAIL  (R0,NP),UNFIXERR,'PGFREE logic error.'                           
         LR    R15,R1                                                           
         AR    R15,R0              Ending address+1                             
*                                                                               
         IF    CVFXA,BEGIN         MVS/XA version...                            
         DECR  R15                 Actual ending address                        
*-                                                                              
*-       If you are assembling this for an MVS/SP system, then the              
*-         following "PGSER" macro may generate an assembly error.              
*-         Since PGSER is only executed if the system is MVS/XA                 
*-         then PGSER line can be safely commented out.                         
*-                                                                              
         PGSER R,FREE,A=(1),EA=(15)  Unfix pages (XA version)                   
         END                                                                    
*                                                                               
         ELSE  BEGIN               MVS/SP version...                            
         PGFREE R,A=(1),EA=(15)    Unfix pages (SP version)                     
         END                                                                    
*                                                                               
         CLEAR R15                 Return code                                  
         XEXIT                                                                  
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  AMODE31 -- Routine to switch to 31-bit addressing mode if                    
*    we are running MVS/XA.                                                     
*                                                                               
*    Note:  This may be called from a subtask (be sure not to                   
*           have TRACE=YES on the XENTER).                                      
*                                                                               
AMODE31  XENTER R2,R8,TRACE=NO                                                  
         IF    CVFXA,BEGIN         XA mode...                                   
         LA    R2,A31GO                                                         
         IF    CVFXA31,BEGIN       We want 31-bit mode...                       
         O     R2,=A(X'80000000')  31 bit mode wanted                           
         END                                                                    
         BSM   0,R2                                                             
*                                                                               
A31GO    LABEL                                                                  
         END                                                                    
         XEXIT R2,R8                                                            
         DROP  BR                                                               
         EJECT                                                                  
*box                                                                            
*                                                                               
*  AMODE24 -- Routine to switch back to 24-bit addressing mode.                 
*                                                                               
*    Note:  This may be called from a subtask (be sure not to                   
*           have TRACE=YES on the XENTER).                                      
*                                                                               
AMODE24  XENTER R2,R8,TRACE=NO                                                  
         IF    CVFXA,BEGIN         XA mode...                                   
         LA    R2,A24GO                                                         
         BSM   0,R2                Return to 24 bit mode                        
*                                                                               
A24GO    LABEL                                                                  
         END                                                                    
         XEXIT R2,R8                                                            
         DROP  BR                                                               
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
         DROP  CP,CV               (No addressability in appendage)             
*                                                                               
IOFIX    LABEL                     Start of fixed memory                        
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  DUMMYRET -- STARTIO IOS appendage routines.  Do nothing here                 
*    (the termination routine does all the work).                               
*                                                                               
DUMMYRET CLEAR R15                 Good return code                             
         BSM   0,R14               Return                                       
         SPACE 2                                                                
*box                                                                            
*                                                                               
*  IOTERM -- STARTIO IOS termination rotuine.  Entered to                       
*    finish the processing of an I/O request.  We need to move                  
*    the PCB to our posted queue and then post WYLBUR.  We also                 
*    need to call the IOS purge processor (IECVQCNT) to tell IOS                
*    that this I/O operation has completed.                                     
*                                                                               
*    This IOS exit routine runs under an SRB, enabled, with the                 
*    local lock held.                                                           
*                                                                               
IOTERM   LABEL                                                                  
         USING *,BR                                                             
         LR    BR,R15                                                           
         LR    R9,R1                                                            
         USING IOSB,R9                                                          
         LR    R6,R14              Save return address                          
         L     R4,IOSUSE           Get PCB ptr                                  
         USING PCB,R4                                                           
*                                                                               
         L     CVR,=V(CV)                                                       
         USING CV                                                               
*                                                                               
         IF    (PCB,NE,'PCB'),'DC H"0"'  FAIL (sort of)                         
         IF    ^PCBFIO,'DC H"0"'   FAIL (sort of)                               
         SET   PCBFPOST            I/O posted complete                          
*-                                                                              
*-       Just post PCBXECB if in synchronous mode.                              
*-                                                                              
         IF    PCBFSYNC,BEGIN      Synchronous mode...                          
         LA    R11,PCBXECB         Our ECB                                      
         B     IOTJOIN             Re-join common code                          
         END                                                                    
*-                                                                              
*-       Add PCB to posted queue.                                               
*-                                                                              
*-       (Note: the page completion queue works like a LIFO stack,              
*-          below we push an item on the stack)                                 
*-                                                                              
         IF    (PCBPOSTL,NZ),'DC H"0"'  FAIL (sort of)                          
*                                                                               
IOTQL    LM    R14,R15,CVPOSTQH     Posted queue head, lock                     
         ST    R14,PCBPOSTL-PCB(R4) Save link to next in current PCB            
         LA    R5,1(R15)            Reset lock                                  
         CDS   R14,R4,CVPOSTQH      Point queue head to current PCB             
         BNZ   IOTQL                If lock changed, try again                  
*-                                                                              
*-       Post WYLBUR's ECB.                                                     
*-                                                                              
         LA    R11,CVECB           Addr of main ECB                             
*                                                                               
IOTJOIN  MODESET EXTKEY=ZERO,SAVEKEY=(2)  Get into key zero                     
*-                                                                              
*-       Note: "REGS=USE" is really important on SETLOCK!  It means             
*-         use (clobber) R15-R1, instead of clobbering R11-R13.                 
*-                                                                              
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,LOCKOK)                           
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND,RELATED=IOP             
*                                                                               
LOCKOK   L     R15,@R11            Is it waiting?                               
         IF    (R15,NM),BEGIN      No...                                        
         L     R0,=A(X'40000000')  Set post bit                                 
         CS    R15,R0,@R11         Try a fast post                              
         BZ    IOPURGE             All done, scram                              
         B     LOCKOK              Loop back and try it again                   
         END                                                                    
*                                                                               
         CLEAR R10                 Post code                                    
         L     R15,CVTPTR                                                       
         WITH  (CVT,R15),'L  R15,CVT0PT02'  Post routine                        
*  R11 has the ECB pointer.                                                     
         BASR  R14,R15             Go post                                      
*-                                                                              
*-       Do purge/quiesce processing.                                           
*-                                                                              
IOPURGE  IF    ('LT R1,IOSIPIB',NZ),BEGIN  Purge I/O...                         
         CLEAR R0                  Indicate local lock held                     
         L     R15,CVTPTR                                                       
         WITH  (CVT,R15),'L R15,CVTIXAVL'  IOS vector table                     
         WITH  (IOCOM,R15),'L R15,IOCQCNT'  Purge/Quiesce                       
         BASSM R14,R15                                                          
         END                                                                    
*                                                                               
         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,RELATED=IOP                        
         MODESET KEYADDR=(2)       Back to our key                              
         BSM   0,R6                Return                                       
*                                                                               
         DROP  IOSB,PCB,BR                                                      
*                                                                               
         QLTORG                                                                 
*                                                                               
         VLTORG                                                                 
*                                                                               
*                                                                               
IOFIXEND EQU   *                   End of fixed memory                          
         END   .                                                                
