UTIL     TITLE 'WYLBUR''s Misc. Utility Routines'                               
*******************************************************************             
*                                                                 *             
*     WYLBUR/370 - Release VI - Class I - Stanford Proprietary    *             
*                                                                 *             
*******************************************************************             
         HIBAL                                                                  
*                                                                               
WYLUTIL  CSECT                                                                  
UTIL     IDENT 2025                11:49:37 01/25/02  (SLP)                     
         REGS  FSR,,,,,,,BR,(WAR,LSR),PAR,PBR,CPR,CVR,SPR,RAR                   
         SPACE 2                                                                
         SYSDEFN ,                 Define installation params                   
         SPACE 2                                                                
*                                                                               
         PUSH  DSECTS                                                           
         COPY  CONTROL             Copy cv/cp                                   
         TITLE 'DSECTS'                                                         
         COPY  RTNCODES                                                         
         EJECT                                                                  
JCB      RECORD BEGIN                                                           
         COPY  JCB                                                              
         END                                                                    
         EJECT                                                                  
*                                                                               
         POP   DSECTS                                                           
         EJECT                                                                  
*box                                                                            
*                                                                               
*                                                                               
*   SCNIGNOR - CHECK IF JUNK AT END OF COMMAND LINE                             
*                                                                               
*   ON ENTRY:                                                                   
*       SCAN CONTROL BLOCK                                                      
*                                                                               
*   ON EXIT:                                                                    
*       IF ANY JUNK ON LINE, WE TSEG IGNORE MESSAGE ON NEW LINE                 
*       R15 - CC=ZERO, NOTHING FOUND ON LINE                                    
*             CC=NZ, TEXT FOUND ON LINE, IGNORE MSG TSEG'D                      
*                                                                               
*                                                                               
SCNIGNOR XPROC  ,                                                               
         SCINFO ,                                                               
         ACALL IGNOREND                                                         
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*                                                                               
*   SCNCHECK - CHECK IF JUNK AT END OF COMMAND LINE                             
*                                                                               
*   ON ENTRY:                                                                   
*       SCAN CONTROL BLOCK                                                      
*                                                                               
*   ON EXIT:                                                                    
*       IF ANY JUNK ON LINE, WE TSEG ERROR MESSAGE ON NEW LINE                  
*       R15 - CC=ZERO, NOTHING FOUND ON LINE                                    
*             CC=NZ, TEXT FOUND ON LINE, ERROR MSG TSEG'D                       
*                                                                               
*                                                                               
SCNCHECK XPROC  ,                                                               
         SCINFO ,                                                               
         ACALL CHECKEND                                                         
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*                                                                               
*  IGNOREND - IGNORE JUNK AT END OF COMMAND LINE                                
*                                                                               
*  ON ENTRY:                                                                    
*       R1,R0 - LOC, LEN OF REMAINING STRING                                    
*                                                                               
*  ON EXIT:                                                                     
*       IF ANYTHING LEFT ON LINE,,, A MESSAGE IS TSEG'D:                        
*           kdkdl --  ignored.                                                  
*       R15 - CC=ZERO, NOTHING FOUND ON LINE                                    
*             CC=NZ, TEXT FOUND ON LINE, IGNORE MSG TSEG'D                      
*                                                                               
*                                                                               
IGNOREND XPROC  ,                                                               
         IF    (R0,POS),BEGIN      IF MORE TEXT,,                               
         WHILE ((R0,POS),AND,(@R1,EQ,' ')),BEGIN   SKIP BLANKS                  
         LA    R1,1(R1)                                                         
         DECR  R0                                                               
         END                                                                    
         IF    ((R0,POS),AND,(@R1,NE,';')),BEGIN      IF JUNK,                  
         XPUSH R0,R1                                                            
         TCCR                                                                   
         XPOP  R0,R1                                                            
         CEIL  R0,30                                                            
         TSEG  (R1),(R0)                                                        
         TSEG  '  -- ignored. ',,CR                                             
         LA    R15,4                                                            
         END                                                                    
         ELSE  BEGIN ,             IF NO JUNK,                                  
         CLEAR R15                                                              
         END                                                                    
         END                                                                    
         ELSE  BEGIN ,             IF NO JUNK,                                  
         CLEAR R15                                                              
         END                                                                    
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*                                                                               
*  CHECKEND - CHECK END IF JUNK AT END OF COMMAND LINE                          
*                                                                               
*                                                                               
*  ON ENTRY:                                                                    
*       R1,R0 - LOC, LEN OF REMAINING STRING                                    
*                                                                               
*   ON EXIT:                                                                    
*       IF ANY JUNK ON LINE, WE TSEG ERROR MESSAGE ON NEW LINE                  
*       R15 - CC=ZERO, NOTHING FOUND ON LINE                                    
*             CC=NZ, TEXT FOUND ON LINE, ERROR MSG TSEG'D                       
*                                                                               
*                                                                               
*                                                                               
CHECKEND XPROC  ,                                                               
         IF    (R0,POS),BEGIN      IF MORE TEXT,,                               
         WHILE ((R0,POS),AND,(@R1,EQ,' ')),BEGIN   SKIP BLANKS                  
         LA    R1,1(R1)                                                         
         DECR  R0                                                               
         END                                                                    
         IF    ((R0,POS),AND,(@R1,NE,';')),BEGIN      IF JUNK,                  
         XPUSH R0,R1                                                            
         TCCR                                                                   
         XPOP  R0,R1                                                            
         CEIL  R0,30                                                            
         TSEG  (R1),(R0)                                                        
         TSEG  '  -- invalid. ',,CR                                             
         LA    R15,4                                                            
         END                                                                    
         ELSE  BEGIN ,             IF NO JUNK                                   
         CLEAR R15                                                              
         END                                                                    
         END                                                                    
         ELSE  BEGIN ,             IF NO JUNK                                   
         CLEAR R15                                                              
         END                                                                    
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  YESREQ/YESRTN/YESRTNH/YESNO -- Routine to prompt for permission.             
*                                                                               
*    On entry:                                                                  
*                                                                               
*      R1,R0 - prompt loc, len                                                  
*              (If len is complimented then don't add "(Yes/No)".)              
*                                                                               
*    A reply of YES, Y, OK, or the prompt word is accepted as an                
*    affirmative response.                                                      
*                                                                               
*    YESREQ:                                                                    
*      Only returns if affirmative response given.                              
*                                                                               
*    YESNO:                                                                     
*      Returns if a Yes or a No response is given.                              
*      On exit, R15 (and CC):                                                   
*         -4 - attn                                                             
*          0 - affirmative                                                      
*          4 - no                                                               
*                                                                               
*    YESRTN:                                                                    
*      On exit, R15 (and CC):                                                   
*         -4 - attn                                                             
*          0 - affirmative                                                      
*          4 - neg response given (R1,R0-loc,len)                               
*                                                                               
*    YESRTNH:                                                                   
*      On exit, R15 (and CC):                                                   
*         -4 - attn                                                             
*          0 - affirmative                                                      
*          4 - neg response given (R1,R0-loc,len)                               
*          8 - HELP (or ?) specified                                            
*                                                                               
YESWA    RECORD BEGIN                                                           
YESFLAG  FLAG                                                                   
         FLAG  YESFRTN             - always return to caller                    
         FLAG  YESFYESNO           - return if Yes or No                        
         FLAG  YESFHELP            - return if Help                             
YESLEN   DS    H                   Prompt length                                
YESTEXT  DS    CL120                                                            
         END                                                                    
*                                                                               
*                                                                               
YESNO    XPROC YESWA                                                            
         LA    R6,YESWA                                                         
         CLEAR YESFLAG                                                          
         SET   YESFYESNO           Return Yes or No                             
         ACALL YESCOMN             Go to common code                            
         PRETURN (R0,R1)                                                        
         PEND  ,                                                                
*                                                                               
YESRTN   XPROC YESWA                                                            
         LA    R6,YESWA                                                         
         CLEAR YESFLAG                                                          
         SET   YESFRTN             Always return                                
         ACALL YESCOMN             Go to common code                            
         PRETURN (R0,R1)                                                        
         PEND  ,                                                                
*                                                                               
YESRTNH  XPROC YESWA                                                            
         LA    R6,YESWA                                                         
         CLEAR YESFLAG                                                          
         SET   YESFHELP            Return if HELP                               
         SET   YESFRTN             Always return                                
         ACALL YESCOMN             Go to common code                            
         PRETURN (R0,R1)                                                        
         PEND  ,                                                                
*                                                                               
YESREQ   XPROC YESWA                                                            
         LA    R6,YESWA                                                         
         CLEAR YESFLAG                                                          
         ACALL YESCOMN                                                          
         PRETURN (R0,R1)                                                        
         PEND  ,                                                                
*                                                                               
YESCOMN  PROC  ,                                                                
         USING YESWA,R6                                                         
         LR    R2,R0               Save as flag (later)                         
         LPR   R0,R0                                                            
         TSEG  (R1),(R0)                                                        
         IF    (R2,^NEG),'TSEG " (Yes/No)"'                                     
*-                                                                              
*-       Save the prompt text in case we have to re-prompt...                   
*-                                                                              
         L     R15,CPSEGLENF                                                    
         S     R15,CPSEGMRKF       Length since last mark                       
         CEIL  R15,L'YESTEXT                                                    
         STH   R15,YESLEN                                                       
         L     R1,CPSEGLOC                                                      
         A     R1,CPSEGLENF                                                     
         SR    R1,R15              Start of prompt text                         
         MOVE  R15,YESTEXT,@R1     Save the text                                
*                                                                               
         CLEAR R0                                                               
YESLOOP  TREAD (R1),(R0),Q         Go prompt user                               
         BNZ   YESATTN                                                          
         SCINIT (R1),(R0)                                                       
         SCAN  YESRQPRT            Expecting YES/NO                             
*                                                                               
         XPUSH R15,R1              OLD SCANNER COMPATABILITY                    
         SCINFO ,                                                               
         OSCINIT (R1),(R0)                                                      
         XPOP  R15,R1                                                           
*                                                                               
         IF    (R15,NEG),YESAGAIN                                               
         IF    (R15,EQ,4),YESYES                                                
         IF    (R15,EQ,8),YESNOPE                                               
         IF    (R15,EQ,12),YESQUIT                                              
         IF    (R15,EQ,16),YESNULL                                              
         IF    (R15,EQ,20),YESAGAIN                                             
         IF    (R15,EQ,24),BEGIN   HELP...                                      
         IF    YESFHELP,'LA R15,8; B YESEXIT'  Help rc                          
         B     YESAGAIN            Write general message                        
         END                                                                    
         IF    YESFRTN,BEGIN       Return invalid responses...                  
         LA    R15,4               Not yes                                      
         B     YESEXIT                                                          
         END                                                                    
*                                                                               
YESAGAIN TSEG  'Answer YES or NO.',,CR                                          
         SETMSG YESTEXT,LH:YESLEN                                               
         B     YESLOOP                                                          
*                                                                               
YESNULL  IF    YESFRTN,BEGIN                                                    
         LA    R15,4                                                            
         B     YESEXIT                                                          
         END                                                                    
         TSEG  'Answer YES or NO.',,CR                                          
         SETMSG YESTEXT,LH:YESLEN                                               
         B     YESLOOP                                                          
*                                                                               
YESYES   CLEAR R15                 Ok                                           
         B     YESEXIT                                                          
*                                                                               
YESNOPE  IF    (YESFRTN+YESFYESNO,Z),CVNOACTN  Abort command                    
         LA    R15,4               Not yes return code                          
         B     YESEXIT                                                          
*                                                                               
YESQUIT  IF    (YESFRTN+YESFYESNO,Z),CVNOACTN  Abort command                    
         LH    R15,=H'-4'          Set return code                              
         B     YESEXIT                                                          
*                                                                               
YESATTN  IF    (YESFRTN+YESFYESNO,Z),CVNOACTN  Abort command                    
         LH    R15,=H'-4'          Set return code                              
         B     YESEXIT                                                          
*                                                                               
YESEXIT  LABEL                                                                  
         PRETURN (R0,R1)                                                        
         PEND                                                                   
*-                                                                              
*-       YES/NO scan table.                                                     
*-                                                                              
YESRQPRT SCKW  ,YESHMMM,NULL                                                    
         SCKW  YES,YESDO                                                        
         SCKW  Y,YESDO                                                          
         SCKW  OK,YESDO                                                         
         SCKW  N,YESABORT                                                       
         SCKW  NO,YESABORT                                                      
         SCKW  Q,YESQ                                                           
         SCKW  QUIT,YESQ,A                                                      
         SCKW  HELP,YESHELP,A                                                   
         SCKW  ?,YESHELP                                                        
         SCKW  ,YESDUUHH                                                        
*-                                                                              
YESDO    PROC                                                                   
         LA    R15,4                                                            
         PEND                                                                   
*                                                                               
YESABORT PROC                                                                   
         LA    R15,8                                                            
         PEND                                                                   
*                                                                               
YESQ     PROC                                                                   
         LA    R15,12                                                           
         PEND                                                                   
*                                                                               
YESHMMM  PROC                                                                   
         LA    R15,16                                                           
         PEND                                                                   
*                                                                               
YESDUUHH PROC                                                                   
         LA    R15,20                                                           
         PEND                                                                   
*                                                                               
YESHELP  PROC                                                                   
         LA    R15,24                                                           
         PEND                                                                   
*                                                                               
         DROP  YESWA                                                            
         TITLE 'Locate Previous Line and Format For List'                       
* LOCLIST locates the line in the file before the line number                   
* pointed to by R1 on input.  The located line is formatted for                 
* listing according to the settings of the flags in CPLFLG5 by                  
* the LISTLINE routine.                                                         
*                                                                               
LOCLIST  XPROC  ,                                                               
         L     R15,@R1             Line-number                                  
         ST    R15,CPLCNO                                                       
         VCALL PREVLNO             Get previous lineno                          
         IF    NEG,BEGIN           No previous...                               
         TSEG  'No previous line.',,CR                                          
         END                                                                    
*                                                                               
         ELSE  BEGIN               List previous...                             
         L     R15,CPLCNO                                                       
         XPUSH ,,&LINESZ,PTR=R1                                                 
         VCALL GETLINE             Get this line                                
         ACALL LISTLINE            List the line                                
         END                                                                    
*                                                                               
         PEND  ,                                                                
         TITLE 'Utility Routines'                                               
* LISTLINE -- formats the output line based on                                  
*          setting of list options in CPLFLG5.                                  
* input  R0 - length of line to list                                            
*        R1 - address of start of line to list                                  
*        CPLCNO - line number of line to list                                   
*                                                                               
*box                                                                            
*                                                                               
*  LISTLINE -- Routine to format the output line based on list                  
*    option settings in CP local flags.                                         
*                                                                               
*    On entry:                                                                  
*      R1,R0 - line text location, length                                       
*      CPLCNO - line number of line to list                                     
*                                                                               
LISTLINE XPROC  ,                                                               
         LR    R3,R1                                                            
         LR    R2,R0                                                            
*                                                                               
         IF    CPLFLG5.CPFNONUM,'SETMSG CVBLANKS,11'                            
         ELSEIF CPLFLG5.CPFUNUM,'CLEAR R0'                                      
         ELSE  BEGIN               Numbered...                                  
         L     R0,CPLCNO                                                        
         VCALL CVEXNO                                                           
         TSEG  CPDOUB,9            Lineno                                       
         SETMSG CVBLANKS,2                                                      
         END                                                                    
         TSEG  (R1),(R0)                                                        
*                                                                               
         IF    (^CPLFLG5.CPFNTEX,OR,CPLFLG5.CPFNONUM),BEGIN                     
         TSEG  (R3),(R2)           Line text                                    
         END                                                                    
*                                                                               
         IF    ^CPFNONL,'TCR'                                                   
         PEND  ,                                                                
         TITLE 'ADDER Routine'                                                  
* ADDER adds a line no. in R0 to a delta in R1 with lineno addition.            
* R0 negative on illegal (too-high) result                                      
*                                                                               
ADDER    XPROC ,                                                                
         AR    R0,R1               Add nos.                                     
         L     R6,CVHILNO          Load high value                              
         CLR   R6,R0               Less than high                               
         BH    LNOK                Good with return condition code set          
         LNR   R0,R6               Set no good                                  
LNOK     LABEL ,                                                                
         PRETURN (R0)                                                           
*$ HELP HELP HELP,,, MUST RETURN CC SET VIA R0 .. OR WHATEVER                   
         LTR   R0,R0                                                            
         PEND  *                                                                
         TITLE 'Delta Select Routine'                                           
* Select a suitable delta based on the value in R1.                             
*        if R1 is 0 then .001 is used                                           
*        if R1>=CPDELTA then CPDELTA is used                                    
*        Otherwise the delta is chosen from a table as the first value          
*        not greater than R1 from the list 1.000, .500, .200, .100,             
*        .050, .020, .010, .005, .002, and .001.                                
* The delta chosen is returned in R1                                            
*                                                                               
SELDELTA XPROC ,                                                                
         LTR   R1,R1               Is value positive                            
         BNP   SEL001              No, use .001                                 
         C     R1,CPDELTA          Is R1>=CPDELTA                               
         BNL   SELDEL              Yes, use CPDELTA                             
         LA    R6,SELTBLE          Point to table                               
SELOOP   CH    R1,@R6              Use this entry?                              
         BNL   SELGOT              Yes                                          
         LA    R6,@R6+2            Point to next entry                          
         B     SELOOP              Loop                                         
*                                                                               
SEL001   LA    R1,1                Use .001                                     
         B     SELEXIT             Go return                                    
*                                                                               
SELDEL   L     R1,CPDELTA          Use CPDELTA                                  
         B     SELEXIT             Go return                                    
*                                                                               
SELGOT   LH    R1,@R6              Set r1 to selected table value               
*                                                                               
SELEXIT  PRETURN (R1)              Return                                       
         PEND  ,                                                                
*                                                                               
SELTBLE  DC    H'1000,500,200,100,50,20,10,5,2,1'  possible deltas              
         TITLE 'Utility Routine'                                                
*  Compute next lower multiple of a delta.                                      
*-                                                                              
*-       (R0) = line no.                                                        
*-       (R1) = delta                                                           
*-                                                                              
*-       returns R0 = next lower multiple                                       
*-                                                                              
LOWMULT  XPROC  ,                                                               
         LR    R3,R0               Line no.                                     
         CLEAR R2                                                               
         DR    R2,R1               Divide by delta                              
         MR    R2,R1               Multiply by delta                            
         LR    R0,R3               Put result in R0                             
         PRETURN (R0)                                                           
         PEND  ,                                                                
         TITLE 'CVEXNO Routine'                                                 
* CVEXNO  converts internal lineno to 9-digits with/without                     
*              a decimal point.  9 digits are in CPDOUB                         
*                                                                               
*      expects R0 - internal lineno                                             
*      returns R1 - address of lineno                                           
*              R0 - lineno len                                                  
CVEXWA   RECORD BEGIN                                                           
CVEXWORK DS    XL16                Work area                                    
         END                                                                    
*-                                                                              
CVEXNO   XPROC CVEXWA                                                           
         CVD   R0,CPDOUB           Convert to decimal                           
         TM    CPLFLG5,CPNFINT     Is decimal point wanted                      
         BZ    CVEXNO1             No                                           
         MVC   CVEXWORK(8),CPDOUB  Move converted number                        
         UNPK  CPDOUB(9),CVEXWORK+3(5)  UNPK to cpdoub                          
         OI    CPDOUB+8,X'F0'      Set zone                                     
         MVI   CPDOUB,C' '         Set first char to blank                      
         LA    R1,CPDOUB+1                                                      
         LA    R0,8                                                             
         B     EXEXIT              Exit from cvexno                             
*                                                                               
CVEXNO1  MVC   CVEXWORK(11),EXEDTMSK  Move edit mask                            
         LA    R1,CVEXWORK+6       In case no significance                      
         EDMK  CVEXWORK(11),CPDOUB+3  Edit line no.                             
         MVC   CPDOUB(9),CVEXWORK+2  Move result to CPDOUB                      
         LA    R0,CVEXWORK+2                                                    
         SR    R1,R0                                                            
         LCR   R0,R1                                                            
         LA    R1,CPDOUB(R1)       First sig char                               
         AH    R0,=H'9'            Len                                          
         LA    R3,CPDOUB+8         Trail zero pointer                           
EXTRIM   CLI   @R3,C'0'            Trailing zero?                               
         BNE   EXDONE              No                                           
         MVI   @R3,C' '            Set blank                                    
         DECR  R0                  Keep len accurate                            
         BCT   R3,EXTRIM           Reduce trailing ptr                          
EXDONE   IF    (@R3,EQ,'.'),'DECR R0'  remove trailing dot                      
         IF    ((@R1,EQ,'0'),AND,(R0,GT,2)),'LA R1,@R1+1; DECR R0'              
EXEXIT   MVI   CPDOUB+9,C' '       Last char is always blank                    
         PRETURN (R0,R1)                                                        
         PEND  ,                                                                
*                                                                               
EXEDTMSK DC    C' ',X'202020202120',C'.',X'202020'  edit mask                   
*                                                                               
         QLTORG                                                                 
         TITLE 'Utility Routines'                                               
*box                                                                            
*                                                                               
*  DETAB -- Local routine to expand tabs to blanks.                             
*                                                                               
*    On entry:                                                                  
*      R1  - input line loc                                                     
*      R0  - input line len (complimented if ASCII data)                        
*      R15 - maximum buffer length                                              
*                                                                               
*    On exit:                                                                   
*      R15 (and cc) -  0=ok; 4=truncated                                        
*      R1,R0 - expanded line loc, len                                           
*         (line is expanded in place)                                           
*                                                                               
DTABWA   RECORD BEGIN                                                           
DTABFLAG FLAG                                                                   
         FLAG  DTABFASCII          - ASCII data (off means EBCDIC)              
*                                                                               
DTABTRTP DS    A                   TRT stop table ptr                           
DTABRC   DS    F                   Return code                                  
DTABMAXL DS    F                   Maximum allowable return length              
DTABINIT EQU   DTABFLAG,*-DTABFLAG,C'X'                                         
*                                                                               
DTABSG   SEGCB                                                                  
DTABBUF  DS    XL2000              Big work buffer                              
         END                                                                    
*-                                                                              
DETAB    XPROC DTABWA                                                           
         CLEAR DTABINIT            Initialize                                   
         ST    R15,DTABMAXL        Save maximum length                          
*                                                                               
         LA    R15,DTABEBCT        Assume EBCDIC TRT table                      
         IF    (R0,NEG),BEGIN      It's ASCII data...                           
         SET   DTABFASCII          Data is in ASCII                             
         LA    R15,DTABASCT        ASCII TRT table                              
         LPR   R0,R0                                                            
         PRETURN (R0)                                                           
         END                                                                    
         ST    R15,DTABTRTP        Save TRT table ptr                           
*                                                                               
         LR    R5,R1               Orig data ptr                                
         LR    R4,R0               Orig data len                                
*-                                                                              
*-       Quick check to see if there are ANY tabs in the line.                  
*-                                                                              
         IF    (R4,LE,256),BEGIN   Not too long...                              
         LTR   R3,R4                                                            
         BNP   DTABEXIT                                                         
         L     R15,DTABTRTP                                                     
         DEX   R3,'TRT @R5(0),@R15' Look for a tab character                    
         BZ    DTABEXIT            No tab characters, scram                     
         END                                                                    
*-                                                                              
*-       Expand tabs in work buffer using the seg routines.                     
*-                                                                              
         SEGINIT DTABBUF,,DTABSG                                                
         WHILE (R4,POS),BEGIN                                                   
         LR    R2,R4                                                            
         CEIL  R2,256                                                           
         L     R15,DTABTRTP        Stop on TAB trt table                        
         DEX   R2,'TRT @R5(0),@R15' Look for TAB character                      
         IF    Z,BEGIN             No more tabs remain...                       
         SEG   (R5),(R4)           Add last bit                                 
         B     DTABCOPY                                                         
         END                                                                    
*                                                                               
         SR    R1,R5               Number of chars before tab                   
         LR    R2,R1                                                            
*                                                                               
         SEG   (R5),(R2)           Add text before tab                          
         L     R0,DTABSGLENF                                                    
         A     R0,=F'8'                                                         
         N     R0,=F'-8'                                                        
         S     R0,DTABSGLENF       Number of spaces until next stop             
         LA    R1,CVBLANKS         EBCDIC blanks                                
         IF    DTABFASCII,'LA R1,=8X"20"'  ASCII blanks                         
         SEG   (R1),(R0)           Add blank padding                            
*                                                                               
         LA    R2,@R2+1            Number of chars incl tab char                
         LA    R5,@R5(R2)          Kick input ptr                               
         SR    R4,R2               Adjust remaining length                      
         END                                                                    
*-                                                                              
*-       Copy the buffer back to the original input area.                       
*-                                                                              
DTABCOPY PRESTORE (R1)             Restore R1 on entry                          
         L     R2,DTABSGLENF       Seg buffer length                            
         IF    (R2,GT,DTABMAXL),'MVC DTABRC,=F"4"; L R2,DTABMAXL'               
         MOVEL @R1,L:DTABSGLOC,(R2)                                             
*                                                                               
         LR    R0,R2                                                            
         PRETURN (R0)              Return updated length                        
*                                                                               
DTABEXIT L     R15,DTABRC          Return code                                  
         PEND  ,                                                                
*                                                                               
         SEGDEF DUMMY                                                           
*-                                                                              
*-       Stop on EBCDIC TAB Table                                               
*-                                                                              
DTABEBCT DC    XL256'00'                                                        
         ORG   DTABEBCT+X'05'      EBCDIC TAB char                              
         DC    X'FF'                                                            
         ORG                                                                    
*-                                                                              
*-       Stop on ASCII TAB Table                                                
*-                                                                              
DTABASCT DC    XL256'00'                                                        
         ORG   DTABASCT+X'09'      ASCII TAB char (msb off)                     
         DC    X'FF'                                                            
         ORG   DTABASCT+X'89'      ASCII TAB char (msb on)                      
         DC    X'FF'                                                            
         ORG                                                                    
*                                                                               
         QLTORG                                                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  FORMATL -- Routine to change special binary characters to                    
*    our multiple character representation.                                     
*                                                                               
*    On entry:                                                                  
*      R1,R0  - input line loc, len                                             
*      R2     - complimented if TEXTONLY wanted:                                
*                 1 = generic table                                             
*                 2 = APPLEASCII table                                          
*                                                                               
*      R15    - maximum buffer length                                           
*                                                                               
*    On exit:                                                                   
*      R15 (and cc) -  0=ok; 4=truncated                                        
*      R1,R0 - expanded line loc, len                                           
*         (line is expanded in place)                                           
*                                                                               
FMTWA    RECORD BEGIN                                                           
FMTFLAG  FLAG                                                                   
         FLAG  FMTFTEXTONLY        - Do TEXTONLY conversion                     
*                                                                               
FMTTABP  DS    A                   TRT stop table ptr                           
FMTRC    DS    F                   Return code                                  
FMTMAXL  DS    F                   Maximum allowable return length              
FMTINIT  EQU   FMTFLAG,*-FMTFLAG,C'X'                                           
*                                                                               
FMTSG    SEGCB                                                                  
FMTBUF   DS    XL2000              Big work buffer                              
         END                                                                    
*-                                                                              
FORMATL  XPROC FMTWA                                                            
         CLEAR FMTINIT             Initialize                                   
         ST    R15,FMTMAXL         Save maximum length                          
*                                                                               
         IF    (R2,NEG),'SET FMTFTEXTONLY; LCR R2,R2'  TEXTONLY                 
*                                                                               
         L     R15,=A(FMTTAB)      Universal table                              
         IF    (R2,EQ,2),'L R15,=A(APPLETAB)'  APPLEASCII tbl                   
         ST    R15,FMTTABP         Save TRT table ptr                           
*                                                                               
         LR    R5,R1               Orig data ptr                                
         LR    R4,R0               Orig data len                                
*-                                                                              
*-       Quick check to see if there are ANY special characters                 
*-         in the line.                                                         
*-                                                                              
         IF    (R4,LE,256),BEGIN   Not too long...                              
         LTR   R3,R4                                                            
         BNP   FMTEXIT                                                          
         L     R15,FMTTABP                                                      
         DEX   R3,'TRT @R5(0),@R15' Look for special chars                      
         BZ    FMTEXIT             No special chars, scram                      
         END                                                                    
*-                                                                              
*-       Format special characters by building a new copy of the                
*-         line with the seg routines.                                          
*-                                                                              
         SEGINIT FMTBUF,,FMTSG                                                  
         WHILE (R4,POS),BEGIN                                                   
         LR    R3,R4                                                            
         CEIL  R3,256                                                           
         L     R15,FMTTABP         Stop on special chars                        
         CLEAR R2                  Low byte of R2 set by TRT                    
         DEX   R3,'TRT @R5(0),@R15' Look for special char                       
         IF    Z,BEGIN             No more specials remain...                   
         SEG   (R5),(R4)           Add last bit                                 
         B     FMTCOPY                                                          
         END                                                                    
*                                                                               
         SR    R1,R5               Number of chars before special               
         LR    R3,R1                                                            
*                                                                               
         SEG   (R5),(R3)           Add text before special                      
         SEG   '<'                                                              
         DECR  R2                                                               
         SLL   R2,3                Offset times 8 (see ACHAR macro)             
         L     R1,FMTTABP                                                       
         LA    R1,@R1+256          Origin for messages                          
         LC    R0,@R1(R2)          Get message text length                      
         SEG   @R1+3(R2),(R0)      Add message text                             
         SEG   '>'                                                              
*                                                                               
         LA    R3,@R3+1            Number of chars incl tab char                
         LA    R5,@R5(R3)          Kick input ptr                               
         SR    R4,R3               Adjust remaining length                      
         END                                                                    
*                                                                               
FMTCOPY  L     R2,FMTSGLENF        Seg buffer length                            
*-                                                                              
*-       If the caller wants the TEXTONLY form then call                        
*-         TEXTONLY to do the conversion now (before the                        
*-         line gets truncated to the caller's maximum                          
*-         length).                                                             
*-                                                                              
         IF    FMTFTEXTONLY,BEGIN  Now convert to TEXTONLY...                   
         SETMSG L:FMTSGLOC,(R2)     Line data with our symbols                  
         LA    R15,L'FMTBUF        Maximum allowed length                       
         ACALL TEXTONLY            Now do TEXTONLY conversion                   
         LR    R2,R0               Save new line length                         
         END                                                                    
*-                                                                              
*-       Copy the buffer back to the original input area.                       
*-                                                                              
         IF    (R2,GT,FMTMAXL),'MVC FMTRC,=F"4"; L R2,FMTMAXL'                  
         PRESTORE (R1)             Restore R1 on entry                          
         MOVEL @R1,L:FMTSGLOC,(R2)                                              
*                                                                               
         LR    R0,R2                                                            
         PRETURN (R0)              Return updated length                        
*                                                                               
FMTEXIT  L     R15,FMTRC           Return code                                  
         PEND                                                                   
*                                                                               
         QLTORG                                                                 
*                                                                               
         SEGDEF DUMMY                                                           
         EJECT                                                                  
*box                                                                            
*                                                                               
*  UNFORML -- Routine to change our multiple character                          
*    representation of special characters to the corresponding                  
*    binary character.                                                          
*                                                                               
*    On entry:                                                                  
*      R1,R0  - input line loc, len                                             
*      R2     - 1 = generic table                                               
*             - 2 = APPLEASCII table                                            
*      R15    - maximum buffer length                                           
*                                                                               
*    On exit:                                                                   
*      R15 (and cc) -  0=ok; 4=truncated                                        
*      R1,R0 - expanded line loc, len                                           
*         (line is expanded in place)                                           
*                                                                               
UFMTWA   RECORD BEGIN                                                           
UFMTFLAG FLAG                                                                   
*                                                                               
UFMTTABP DS    A                   ACHAR special char ptr                       
UFMTRC   DS    F                   Return code                                  
UFMTMAXL DS    F                   Maximum allowable return length              
UFMTSAVE DS    2A                  Save ptrs                                    
UFMTINIT EQU   UFMTFLAG,*-UFMTFLAG,C'X'                                         
*                                                                               
UFMTENT  DS    CL32                Working table entry text area                
UFMTTOK  DS    CL32                User's special sequence                      
UFMTTOKL DS    CL32                Same as UFMTTOK but all lower                
*                                                                               
UFMTSG   SEGCB                                                                  
UFMTBUF  DS    XL2000              Big work buffer                              
         END                                                                    
*-                                                                              
UNFORML  XPROC UFMTWA                                                           
         LA    R6,UFMTWA                                                        
         WITH  (UFMTWA,R6)                                                      
*                                                                               
         CLEAR UFMTINIT            Initialize                                   
         ST    R15,UFMTMAXL        Save maximum length                          
*                                                                               
         L     R15,=A(APPLETAB)    Assume APPLEASCII table for now              
         ST    R15,UFMTTABP        Save table ptr                               
*                                                                               
         LR    R5,R1               Orig data ptr                                
         LR    R4,R0               Orig data len                                
         STM   R4,R5,UFMTSAVE      Save orig ptrs                               
*-                                                                              
*-       Quick check to see if there are ANY special sequences                  
*-         in the line.                                                         
*-                                                                              
         WHILE (R4,POS),BEGIN      Go through line...                           
         LR    R15,R4                                                           
         CEIL  R15,256             Max length we can TRT                        
         L     R14,=A(FORMSTRT)                                                 
         DEX   R15,'TRT @R5(0),@R14' Look for "<" character                     
         IF    Z,'SH R4,=H"256"'   We didn't stop                               
*                                                                               
         ELSE  BEGIN               We stopped...                                
         IF    (@R1,EQ,'<:'),UFMTSCAN  We found something                       
         SR    R1,R5               Number of chars scanned                      
         LA    R1,@R1+1            Plus 1                                       
         AR    R5,R1               Skip past this stuff                         
         SR    R4,R1               Keep remaining length accurate               
         END                                                                    
         END                                                                    
*                                                                               
         B     UFMTEXIT            Nothing special, scram                       
*-                                                                              
*-       There is at least one special sequence in this line                    
*-         so process the line.                                                 
*-                                                                              
UFMTSCAN LM    R4,R5,UFMTSAVE      Restore orig data ptrs                       
         SEGINIT UFMTBUF,,UFMTSG   Initialize seg buffer                        
*                                                                               
UFMTLOOP IF    (R4,POS),BEGIN      Go through line...                           
         LR    R15,R4                                                           
         CEIL  R15,256                                                          
         L     R14,=A(FORMSTRT)                                                 
         DEX   R15,'TRT @R5(0),@R14'  Look for "<" character                    
         IF    Z,BEGIN             All done...                                  
         SEG   (R5),(R4)           Add last bit                                 
         B     UFMTCOPY                                                         
         END                                                                    
*                                                                               
         SR    R1,R5               Number of chars up to special                
         LR    R2,R1                                                            
*                                                                               
         SEG   (R5),(R2)           Add text before special                      
*                                                                               
         AR    R5,R2               Skip past data just processed                
         SR    R4,R2               Keep length accurate                         
*                                                                               
         IF    (R4,LT,4),BEGIN     Not enough characters remain...              
         SEG   (R5),(R4)           Add last bit                                 
         B     UFMTCOPY                                                         
         END                                                                    
*                                                                               
         IF    (@R5,NE,'<:'),BEGIN  Not our special sequence...                 
         SEG   @R5,1               Add the "<" to buffer                        
         LA    R5,@R5+1            Kick ptr                                     
         SH    R4,=H'1'            Adjust remaining length                      
         B     UFMTLOOP            Go keep checking                             
         END                                                                    
*                                                                               
         LR    R3,R5               Copy data ptrs                               
         LR    R2,R4                                                            
*-                                                                              
*-       Look for the end of the "<:" sequence.                                 
*-                                                                              
         WHILE (R2,POS),BEGIN      Validate characters...                       
         IF    (@R3,EQ,'>'),BEGIN  End of formatting command...                 
         SR    R3,R5                                                            
         SETMSG (R5),(R3)           Formatting command                          
         LA    R1,@R1+1            Skip past leading "<"                        
         DECR  R0                  Keep length accurate                         
         SEGLD ,                   Pass seg control block ptr                   
         ACALL UFORMTOK            Process formatting command                   
*                                                                               
         LA    R3,@R3+1            Skip past cmd (including ">")                
         AR    R5,R3               Kick ptr...                                  
         SR    R4,R3               ...and decr length                           
         B     UFMTLOOP            All done, go process more chars              
         END                                                                    
*                                                                               
         LC    R1,@R3              Get char                                     
         L     R14,=A(FORMCTAB)                                                 
         LC    R15,@R14(R1)        Non-zero if invalid character                
         IF    (R15,NZ),BEGIN      Invalid character...                         
         SR    R3,R5                                                            
         SEG   (R5),(R3)           Add text                                     
         AR    R5,R3               Kick ptr...                                  
         SR    R4,R3               ...and decr length                           
         B     UFMTLOOP                                                         
         END                                                                    
*                                                                               
         LA    R3,@R3+1            Next char                                    
         DECR  R2                                                               
         END                                                                    
*-                                                                              
*-       Sequence started with "<:" but never ended.                            
*-                                                                              
         SEG   (R5),(R4)           Add remainder of line                        
         B     UFMTCOPY            All done                                     
         END                                                                    
*-                                                                              
*-       Copy the buffer back to the original input area.                       
*-                                                                              
UFMTCOPY PRESTORE (R1)             Restore R1 on entry                          
         L     R2,UFMTSGLENF       Seg buffer length                            
         IF    (R2,GT,UFMTMAXL),'MVC UFMTRC,=F"4"; L R2,UFMTMAXL'               
         MOVEL @R1,L:UFMTSGLOC,(R2)                                             
*                                                                               
         LR    R0,R2                                                            
         PRETURN (R0)              Return updated length                        
*                                                                               
UFMTEXIT L     R15,UFMTRC          Return code                                  
         PEND                                                                   
*                                                                               
         SEGDEF DUMMY                                                           
         EJECT                                                                  
*box                                                                            
*                                                                               
*  UFORMTOK -- Local routine to convert a special character                     
*    sequence to a binary character if possible.                                
*                                                                               
*    On entry:                                                                  
*      R1,R0 - special character text loc, len                                  
*                                                                               
UFORMTOK PROC                                                                   
         WITH  (UFMTWA,R6)         Entry assumption                             
         SEGDEF UFMTSG                                                          
*                                                                               
         XPUSH R0,R1               Needed if unrec                              
*                                                                               
         LR    R15,R0                                                           
         CEIL  R15,L'UFMTTOK                                                    
         MVC   UFMTTOK,CVBLANKS    Pre-blank                                    
         MOVE  R15,UFMTTOK,@R1                                                  
         MVC   UFMTTOKL,UFMTTOK    Lower case version of TOK                    
         L     R15,CVLOWTBL                                                     
         TR    UFMTTOKL,@R15       Convert to all lower case                    
*                                                                               
         L     R5,UFMTTABP         Special processing table ptr                 
         LA    R5,@R5+256          Skip past TRT table                          
*-                                                                              
*-       Go through our special sequence table looking for a match.             
*-                                                                              
         WHILE (@R5,NE,X'FF'),BEGIN  Go through table...                        
         LC    R3,@R5              Get length byte                              
         LR    R15,R3                                                           
         CEIL  R15,L'UFMTENT                                                    
         MVC   UFMTENT,CVBLANKS    Pre-blank                                    
         MOVE  R15,UFMTENT,@R5+3   Copy table entry text                        
         L     R15,CVLOWTBL                                                     
         TR    UFMTENT,@R15        Make sure it's all lower case                
*-                                                                              
*-       We found the sequence so write out the binary character.               
*-                                                                              
         IF    ('CLI @R5+2,ACHAR$ANY',EQ),BEGIN  Case insensitive...            
         IF    (UFMTTOKL,EQ,UFMTENT),USEQMAT  Matched                           
         END                                                                    
*                                                                               
         ELSEIF ('CLI @R5+2,ACHAR$LOWER',EQ),BEGIN  All lower...                
         IF    (UFMTTOK,EQ,UFMTENT),USEQMAT  Matched                            
         END                                                                    
*                                                                               
         ELSEIF ('CLI @R5+2,ACHAR$UPPER',EQ),BEGIN  Any upper...                
         IF    (UFMTTOKL,EQ,UFMTENT),BEGIN                                      
         IF    (UFMTTOK,NE,UFMTTOKL),USEQMAT                                    
         END                                                                    
         END                                                                    
*                                                                               
         LA    R5,@R5+3+7(R3)      Next entry ptr                               
         N     R5,=A(-8)           Align to next doubleword                     
         END                                                                    
*-                                                                              
*-       It's not one of our sequences.                                         
*-                                                                              
         SEG   '<'                                                              
         XPOP  R0,R1               Restore orig token ptrs                      
         SEG   (R1),(R0)           Write out original text                      
         SEG   '>'                                                              
         B     USEQEXIT            All done                                     
*-                                                                              
*-       It was our sequence so now write out the binary value.                 
*-                                                                              
USEQMAT  SEG   @R5+1,1             Add the character                            
*                                                                               
USEQEXIT PEND                                                                   
*                                                                               
         QLTORG                                                                 
*                                                                               
         SEGDEF DUMMY                                                           
         EJECT                                                                  
*box                                                                            
*                                                                               
*        Special formatting character table.                                    
*                                                                               
         ASCGEN ,                  Define EBCDIC/ASCII tables                   
*                                                                               
ACHAR$ANY   EQU 0,,C'N'            Either upper or lower case is OK             
ACHAR$LOWER EQU 1,,C'N'            Lower case only                              
ACHAR$UPPER EQU 2,,C'N'            Upper case only                              
*                                                                               
         MACRO                                                                  
&L       ACHAR &ASCVAL,&TEXT,&CASE=ANY                                          
         GBLA  &$EBC(256)          (Defined by ASCGEN macro)                    
         GBLB  &AINIT                                                           
         GBLB  &ATRT(256)          TRT table                                    
         GBLC  &AFLAGS(256)        Flags                                        
         GBLC  &AMSG(256)          Message table                                
.*                                                                              
&L       DS    0D                                                               
.*                                                                              
         AIF   (&AINIT).INITED                                                  
&AINIT   SETB  1                                                                
.*                                                                              
&I       SETA  0                                                                
.INITLP  AIF   (&I GT 255).INITED                                               
&I       SETA  &I+1                                                             
&ATRT(&I)   SETB 0                                                              
&AFLAGS(&I) SETC ''                                                             
&AMSG(&I)   SETC ''                                                             
         AGO   .INITLP                                                          
.INITED  ANOP                                                                   
.*                                                                              
         AIF   ('&ASCVAL' EQ '' AND '&TEXT' EQ '').GEN                          
&LAB     SETC  '$$$VAL&SYSNDX'                                                  
&LAB     EQU   0,&ASCVAL   Second parameter should be a constant                
&V       SETA  L'&LAB              Get numeric value of char                    
&V       SETA  &$EBC(1+&V)+1       Convert ASCII to EBCDIC                      
         AIF   (NOT &ATRT(&V)).AOK                                              
         MNOTE 8,'Already defined as "&AMSG(&V)".'                              
         MEXIT                                                                  
.*                                                                              
.AOK     ANOP                                                                   
&ATRT(&V)   SETB  1                                                             
&AFLAGS(&V) SETC  'ACHAR$&CASE'                                                 
&AMSG(&V)   SETC  '&TEXT'                                                       
         MEXIT                                                                  
.*                                                                              
.*       Generate TRT table and messages.                                       
.*                                                                              
.GEN     ANOP                                                                   
&W       SETC  '$$$TEXT&SYSNDX.T'                                               
.*                                                                              
&I       SETA  0                                                                
.TRTLP   AIF   (&I GT 255).TRTDONE                                              
&I       SETA  &I+1                                                             
         AIF   (NOT &ATRT(&I)).TRTZ                                             
         DC    AL1(&W.&I)                                                       
         AGO   .TRTLP                                                           
.TRTZ    DC    AL1(0)                                                           
         AGO   .TRTLP                                                           
.*                                                                              
.TRTDONE ANOP                                                                   
&W       DS    0D                  Message text base                            
&I       SETA  0                                                                
.TXTLP   AIF   (&I GT 255).TXTDONE                                              
&I       SETA  &I+1                                                             
         AIF   (NOT &ATRT(&I)).TXTLP                                            
         DS    0D                  8 byte boundry                               
&W.&I    EQU   (*-&W)/8+1          Offset in 8 byte chunks+1                    
         DC    AL1(L'&W.&I.T)      Message length                               
         DC    AL1(&I-1)           Character value (in EBCDIC)                  
         DC    AL1(&AFLAGS(&I))    Flags                                        
         AIF   ('&AMSG(&I)' EQ '''''').NULLTXT                                  
&W.&I.T  DC    C&AMSG(&I)          Message text                                 
         AGO   .TXTLP                                                           
.NULLTXT ANOP                                                                   
&W.&I.T  EQU   0,0,C'N'            No message text                              
         AGO   .TXTLP                                                           
.*                                                                              
.TXTDONE ANOP                                                                   
         DC    X'FF'               End of table marker                          
         DS    0SL2((&W+255*8)-*)  Error if too many messages!                  
&AINIT   SETB  0                   No longer init'd                             
         MEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*        General special character table.                                       
*                                                                               
FMTTAB   ACHAR X'00',':@'         Control-@                                    
         ACHAR X'01',':A'           "  "  A                                    
         ACHAR X'02',':B'           "  "  B                                    
         ACHAR X'03',':C'           "  "  C                                    
         ACHAR X'04',':D'           "  "  D                                    
         ACHAR X'05',':E'           "  "  E                                    
         ACHAR X'06',':F'           "  "  F                                    
         ACHAR X'07',':G'           "  "  G                                    
         ACHAR X'08',':H'           "  "  H                                    
***      ACHAR X'09',':I'           "  "  I                                    
         ACHAR X'0A',':J'           "  "  J                                    
         ACHAR X'0B',':K'           "  "  K                                    
         ACHAR X'0C',':L'           "  "  L                                    
         ACHAR X'0D',':M'           "  "  M                                    
         ACHAR X'0E',':N'           "  "  N                                    
         ACHAR X'0F',':O'           "  "  O                                    
         ACHAR X'10',':P'           "  "  P                                    
         ACHAR X'11',':Q'           "  "  Q                                    
         ACHAR X'12',':R'           "  "  R                                    
         ACHAR X'13',':S'           "  "  S                                    
         ACHAR X'14',':T'           "  "  T                                    
         ACHAR X'15',':U'           "  "  U                                    
         ACHAR X'16',':V'           "  "  V                                    
         ACHAR X'17',':W'           "  "  W                                    
         ACHAR X'18',':X'           "  "  X                                    
         ACHAR X'19',':Y'           "  "  Y                                    
         ACHAR X'1A',':Z'           "  "  Z                                    
         ACHAR X'1B',':['           "  "  [                                    
         ACHAR X'1C',':\'           "  "  \                                    
         ACHAR X'1D',':]'           "  "  ]                                    
         ACHAR X'1E',':'           "  "                                      
         ACHAR X'1F',':_'           "  "  _                                    
         ACHAR X'7F',':DEL'        ASCII rubout char                            
         ACHAR ,                   End of table                                 
*                                                                               
         COPY  ACHARSYM            Copy APPLEASCII table                        
         EJECT                                                                  
*box                                                                            
*        Formatting character entry (see FCHAR macro below).                    
*                                                                               
FCHAR    RECORD BEGIN                                                           
FCHARNEXT DS   A                   Next FCHAR ptr (0=end)                       
FCHARFLG FLAG                                                                   
         FLAG  (FCHARFANY,0,EQ)    - Match either upper or lower                
         FLAG  (FCHARFUPPER,1,EQ)  - Match only if any upper case               
         FLAG  (FCHARFLOWER,2,EQ)  - Match only if all lower case               
FCHARLEN DS    X                   Length of sequence                           
FCHARSEQ DS    0C                  Sequence text (variable)                     
FCHARTLEN DS   X                   Length of TEXT sequence                      
FCHARTEXT DS   0C                  TEXT sequence                                
         END                                                                    
         SPACE 2                                                                
*box                                                                            
*                                                                               
*        The Special Character processing table is defined                      
*          with the FCHAR macro.  The format is:                                
*                                                                               
*              FCHAR  sequence,                                                 
*                       TEXT='plain text string to use',                        
*                       ALT='x'   Ignored by Wylbur.                            
*                       CASE={ANY|UPPER|LOWER}                                  
*                                 Specifies that the sequence                   
*                                 must be in upper, lower or                    
*                                 any case.                                     
*                                                                               
         MACRO                                                                  
&L       FCHAR &CHARS,&TEXT=,&ALT=,&CASE=ANY                                    
         GBLA  &FCHARCNT                                                        
         GBLC  &FCHARLAB                                                        
&L       DS    0F                                                               
*                                                                               
         AIF   ('&CHARS' EQ '').ENDTAB                                          
.*                                                                              
&FCHARLAB LABEL                                                                 
&CHLAB   SETC  '$$$FCHAR&FCHARCNT'                                              
.*                                                                              
&FCHARCNT SETA &FCHARCNT+1                                                      
&FCHARLAB SETC '$$$FCHAR&FCHARCNT'                                              
.*                                                                              
         DC    A(&FCHARLAB)        Next FCHAR entry ptr                         
.*                                                                              
         DC    AL1(L'FCHARF&CASE)  Case flag                                    
.*                                                                              
         DC    AL1(L'&CHLAB.C)                                                  
&CHLAB.C DC    C&CHARS             Character string user types                  
         AIF   ('&TEXT' NE '').GOTTEXT                                          
         DC    AL1(0)              No text we can display                       
         AGO   .TEXTCOM                                                         
.GOTTEXT ANOP                                                                   
         DC    AL1(L'&CHLAB.T)                                                  
&CHLAB.T DC    C&TEXT              Character string we display                  
.TEXTCOM ANOP                                                                   
.*                                                                              
         MEXIT                                                                  
.*                                                                              
.ENDTAB  ANOP                                                                   
&FCHARLAB EQU  0                   End of table                                 
         MEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TEXTONLY -- Routine to convert a line with our multiple character            
*    special symbols in them to the generic representation.                     
*                                                                               
*    On entry:                                                                  
*      R1,R0  - input line loc, len                                             
*      R15    - maximum buffer length                                           
*                                                                               
*    On exit:                                                                   
*      R15 (and cc) -  0=ok; 4=truncated                                        
*      R1,R0 - expanded line loc, len                                           
*         (line is expanded in place)                                           
*                                                                               
TFMTWA   RECORD BEGIN                                                           
TFMTFLAG FLAG                                                                   
*                                                                               
TFMTRC   DS    F                   Return code                                  
TFMTMAXL DS    F                   Maximum allowable return length              
TFMTSAVE DS    2A                  Save ptrs                                    
TFMTINIT EQU   TFMTFLAG,*-TFMTFLAG,C'X'                                         
*                                                                               
TFMTENT  DS    CL32                Working table entry text area                
TFMTTOK  DS    CL32                User's special sequence                      
TFMTTOKL DS    CL32                Same as UFMTTOK but all lower                
*                                                                               
TFMTSG   SEGCB                                                                  
TFMTBUF  DS    XL2000              Big work buffer                              
         END                                                                    
*-                                                                              
TEXTONLY XPROC TFMTWA                                                           
         LA    R6,TFMTWA                                                        
         WITH  (TFMTWA,R6)                                                      
*                                                                               
         CLEAR TFMTINIT            Initialize                                   
         ST    R15,TFMTMAXL        Save maximum length                          
*                                                                               
         LR    R5,R1               Orig data ptr                                
         LR    R4,R0               Orig data len                                
         STM   R4,R5,TFMTSAVE      Save orig ptrs                               
*-                                                                              
*-       Quick check to see if there are ANY special sequences                  
*-         in the line.                                                         
*-                                                                              
         WHILE (R4,POS),BEGIN      Go through line...                           
         LR    R15,R4                                                           
         CEIL  R15,256             Max length we can TRT                        
         L     R14,=A(FORMSTRT)                                                 
         DEX   R15,'TRT @R5(0),@R14'  Look for "<" character                    
         IF    Z,'SH R4,=H"256"'   We didn't stop                               
*                                                                               
         ELSE  BEGIN               We stopped...                                
         IF    (@R1,EQ,'<:'),TFMTSCAN  We found something                       
         SR    R1,R5               Number of chars scanned                      
         LA    R1,@R1+1            Plus 1                                       
         AR    R5,R1               Skip past this stuff                         
         SR    R4,R1               Keep remaining length accurate               
         END                                                                    
         END                                                                    
*                                                                               
         B     TFMTEXIT            Nothing special, scram                       
*-                                                                              
*-       There is at least one special sequence in this line                    
*-         so process the line.                                                 
*-                                                                              
TFMTSCAN LM    R4,R5,TFMTSAVE      Restore orig data ptrs                       
         SEGINIT TFMTBUF,,TFMTSG   Initialize seg buffer                        
*                                                                               
TFMTLOOP WHILE (R4,POS),BEGIN      Go through line...                           
         LR    R15,R4                                                           
         CEIL  R15,256                                                          
         L     R14,=A(FORMSTRT)                                                 
         DEX   R15,'TRT @R5(0),@R14'  Look for "<" character                    
         IF    Z,BEGIN             All done...                                  
         SEG   (R5),(R4)           Add last bit                                 
         B     TFMTCOPY                                                         
         END                                                                    
*                                                                               
         SR    R1,R5               Number of chars up to special                
         LR    R2,R1                                                            
*                                                                               
         SEG   (R5),(R2)           Add text before special                      
*                                                                               
         AR    R5,R2               Skip past data just processed                
         SR    R4,R2               Keep length accurate                         
*                                                                               
         IF    (R4,LT,4),BEGIN     Not enough characters remain...              
         SEG   (R5),(R4)           Add last bit                                 
         B     TFMTCOPY                                                         
         END                                                                    
*                                                                               
         IF    (@R5,NE,'<:'),BEGIN  Not our special sequence...                 
         SEG   @R5,1               Add the "<" to buffer                        
         LA    R5,@R5+1            Kick ptr                                     
         SH    R4,=H'1'            Adjust remaining length                      
         B     TFMTLOOP            Go keep checking                             
         END                                                                    
*                                                                               
         LR    R3,R5               Copy data ptrs                               
         LR    R2,R4                                                            
*-                                                                              
*-       Look for the end of the "<:" sequence.                                 
*-                                                                              
         WHILE (R2,POS),BEGIN      Validate characters...                       
         IF    (@R3,EQ,'>'),BEGIN  End of formatting command...                 
         SR    R3,R5                                                            
         SETMSG (R5),(R3)           Formatting command                          
         LA    R1,@R1+1            Skip past leading "<"                        
         DECR  R0                  Keep length accurate                         
         SEGLD ,                   Pass seg control block ptr                   
         ACALL TEXTTOK             Process formatting command                   
*                                                                               
         LA    R3,@R3+1            Skip past cmd (including ">")                
         AR    R5,R3               Kick ptr...                                  
         SR    R4,R3               ...and decr length                           
         B     TFMTLOOP            All done, go process more chars              
         END                                                                    
*                                                                               
         LC    R1,@R3              Get char                                     
         L     R14,=A(FORMCTAB)                                                 
         LC    R15,@R14(R1)        Non-zero if invalid character                
         IF    (R15,NZ),BEGIN      Invalid character...                         
         SR    R3,R5                                                            
         SEG   (R5),(R3)           Add text                                     
         AR    R5,R3               Kick ptr...                                  
         SR    R4,R3               ...and decr length                           
         B     TFMTLOOP                                                         
         END                                                                    
*                                                                               
         LA    R3,@R3+1            Next char                                    
         DECR  R2                                                               
         END                                                                    
*                                                                               
         SEG   (R5),(R4)           Add the remainder of the line                
         B     TFMTCOPY            All done                                     
         END                                                                    
*-                                                                              
*-       Copy the buffer back to the original input area.                       
*-                                                                              
TFMTCOPY PRESTORE (R1)             Restore R1 on entry                          
         L     R2,TFMTSGLENF       Seg buffer length                            
         IF    (R2,GT,TFMTMAXL),'MVC TFMTRC,=F"4"; L R2,TFMTMAXL'               
         MOVEL @R1,L:TFMTSGLOC,(R2)                                             
*                                                                               
         LR    R0,R2                                                            
         PRETURN (R0)              Return updated length                        
*                                                                               
TFMTEXIT L     R15,TFMTRC          Return code                                  
         PEND                                                                   
*                                                                               
         SEGDEF DUMMY                                                           
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TEXTTOK -- Local routine to process a special character                      
*    formatting sequence and convert it to a generic sequence.                  
*                                                                               
*    On Entry:                                                                  
*       R1,R0 - formatting command location, length                             
*                                                                               
TTOKWA   RECORD BEGIN                                                           
TTOKFLAG FLAG                                                                   
         FLAG  TTOKFDISPLAYONLY    - Don't do sequence                          
*                                                                               
TTOKPTRS DS    2A                  Original sequence ptrs                       
TTOKSEQ  DS    CL32                Sequence as user typed it                    
TTOKSEQL DS    CL32                Sequence in all lower case                   
TTOKTOK  DS    CL32                Current working sequence                     
         END                                                                    
*-                                                                              
TEXTTOK  PROC  TTOKWA                                                           
         WITH  (TFMTWA,R6)         Entry assumption                             
*                                                                               
         CLEAR TTOKWA                                                           
         STM   R0,R1,TTOKPTRS      Original sequence ptrs                       
*                                                                               
         SEGDEF TFMTSG             Seg buffer                                   
*-                                                                              
*-       If a sequence begins with "<::" then we will                           
*-         display it as "<:" but not act on the                                
*-         formatting request.                                                  
*-                                                                              
         IF    (R0,GT,2),BEGIN     Long enough to be possible...                
         IF    (@R1,NE,'::'),EXIT                                               
         SET   TTOKFDISPLAYONLY    Special "skip" sequence                      
         LA    R1,@R1+1            Skip past first dot                          
         DECR  R0                  Adjust length                                
         END                                                                    
*                                                                               
         CEIL  R0,L'TTOKSEQ        Not too long now                             
         MVC   TTOKSEQ,CVBLANKS                                                 
         LR    R2,R0                                                            
         MOVE  R2,TTOKSEQ,@R1      Save sequence                                
*                                                                               
         MVC   TTOKSEQL,TTOKSEQ    Make copy of sequence                        
         L     R2,CVLOWTBL                                                      
         TR    TTOKSEQL,@R2        Translate to all lower                       
*-                                                                              
*-       Try to match our sequence with an entry in the                         
*-         FCHAR table.                                                         
*-                                                                              
         L     R4,=A(FCHARTBL)     Start of FCHAR table                         
         WITH  (FCHAR,R4)                                                       
         WHILE (R4,NZ),BEGIN       Go through FCHAR table...                    
         LC    R15,FCHARLEN        Get sequence length                          
         CEIL  R15,L'TTOKTOK       Not too long now                             
         MVC   TTOKTOK,CVBLANKS                                                 
         MOVE  R15,TTOKTOK,FCHARSEQ  Copy over sequence                         
         L     R15,CVLOWTBL                                                     
         TR    TTOKTOK,@R15        Convert to lower case                        
*-                                                                              
*-       Cheap debugging facility.                                              
*-                                                                              
         AGO   .NOBUGS                                                          
         SEG   '\TOK='                                                          
         SEGT  TTOKTOK                                                          
         SEG   ', FCHAR='                                                       
         SEGT  TTOKSEQ                                                          
         SEG   ','                                                              
         SEGT  TTOKSEQL                                                         
         SEG   ','                                                              
         SEGHX LC:FCHARFLG,2                                                    
         SEG   '\'                                                              
         SEG   X'15'                                                            
.NOBUGS  ANOP                                                                   
*                                                                               
         IF    FCHARFANY,BEGIN     Case insensitive...                          
         IF    (TTOKTOK,EQ,TTOKSEQL),TTOKMAT  Got it                            
         END                                                                    
*                                                                               
         ELSEIF FCHARFLOWER,BEGIN  All lower case only...                       
         IF    (TTOKTOK,EQ,TTOKSEQ),TTOKMAT  Got it                             
         END                                                                    
*                                                                               
         ELSEIF FCHARFUPPER,BEGIN  Any upper case...                            
         IF    (TTOKTOK,EQ,TTOKSEQL),BEGIN                                      
         IF    (TTOKTOK,NE,TTOKSEQ),TTOKMAT  Some upper--matched                
         END                                                                    
         END                                                                    
*                                                                               
         L     R4,FCHARNEXT        Get next FCHAR entry                         
         END                                                                    
*-                                                                              
*-       No match, display the exact text we were passed.                       
*-                                                                              
         SEG   '<'                                                              
         LM    R0,R1,TTOKPTRS      Original input text                          
         SEG   (R1),(R0)                                                        
         SEG   '>'                                                              
         B     TTOKEXIT            All done                                     
*-                                                                              
*-       We found a matched entry.                                              
*-                                                                              
TTOKMAT  IF    TTOKFDISPLAYONLY,BEGIN  Display sequence only...                 
         SEG   '<'                                                              
         LM    R0,R1,TTOKPTRS      Original input text                          
         LA    R1,@R1+1                                                         
         DECR  R0                                                               
         SEG   (R1),(R0)                                                        
         SEG   '>'                                                              
         B     TTOKEXIT            All done                                     
         END                                                                    
*-                                                                              
*-       Display text form for dumb terminals.                                  
*-                                                                              
         LA    R3,FCHARTLEN                                                     
         LC    R15,FCHARLEN                                                     
         AR    R3,R15              Actual "FCHARTLEN" addr                      
         LC    R2,@R3              Length of text to write                      
         LA    R1,@R3+1            Text data                                    
         SEG   (R1),(R2)                                                        
*                                                                               
TTOKEXIT PEND                                                                   
*                                                                               
         QLTORG                                                                 
*                                                                               
         SEGDEF DUMMY                                                           
         EJECT                                                                  
*-                                                                              
*-       Stop on "<" character.                                                 
*-                                                                              
FORMSTRT DC    XL256'00'                                                        
         ORG   FORMSTRT+C'<'       EBCDIC "<" char                              
         DC    X'FF'                                                            
         ORG                                                                    
*-                                                                              
*-       Acceptable characters inside "<" ... ">" sequence.                     
*                                                                               
FORMCTAB DC    256X'FF'                                                         
         ORG   FORMCTAB+C'a'                                                    
         DC    X'000000000000000000'    a-i                                     
         ORG   FORMCTAB+C'j'                                                    
         DC    X'000000000000000000'        j-r                                 
         ORG   FORMCTAB+C's'                                                    
         DC    X'0000000000000000'               s-z                            
         ORG   FORMCTAB+C'A'                                                    
         DC    X'000000000000000000'    A-I                                     
         ORG   FORMCTAB+C'J'                                                    
         DC    X'000000000000000000'        J-R                                 
         ORG   FORMCTAB+C'S'                                                    
         DC    X'0000000000000000'               S-Z                            
         ORG   FORMCTAB+C'0'                                                    
         DC    X'00000000000000000000'  0-9                                     
         ORG   FORMCTAB+C''                                                    
         DC    X'00000000000000'        .<(+|&                                 
         ORG   FORMCTAB+C'!'                                                    
         DC    X'0000000000000000'      !$*);^-/                                
         ORG   FORMCTAB+C','                                                    
         DC    X'000000FF00'            ,%_>?  (">" is n.g.)                    
         ORG   FORMCTAB+C'`'                                                    
         DC    X'00000000000000'        `:#@'="                                 
         ORG   FORMCTAB+C'\'                                                    
         DC    X'00'                    \                                       
         ORG   FORMCTAB+C'{'                                                    
         DC    X'00'                    {                                       
         ORG   FORMCTAB+C'}'                                                    
         DC    X'00'                    }                                       
         ORG   FORMCTAB+C'['                                                    
         DC    X'00'                    [                                       
         ORG   FORMCTAB+C']'                                                    
         DC    X'00'                    ]                                       
         ORG                                                                    
         EJECT                                                                  
*-                                                                              
*-       Special character sequence table.                                      
*-                                                                              
FCHARTBL DS    0D                  Start of FCHAR table                         
         COPY  FCHARSYM            Copy special character table                 
         FCHAR ,                   End of table                                 
         EJECT                                                                  
*box                                                                            
*                                                                               
*  CHARFMT -- Routine to seg line with "funny" charaters                        
*    converted to "#" characters.                                               
*                                                                               
*    On entry:                                                                  
*      R1,R0 - line loc,len                                                     
*                                                                               
CHARWA   RECORD BEGIN                                                           
CHARTEXT DS    XL64                                                             
         END                                                                    
*-                                                                              
CHARFMT  XPROC CHARWA                                                           
         LR    R6,R1                                                            
         LR    R5,R0                                                            
*                                                                               
         WHILE (R5,POS),BEGIN                                                   
         LR    R2,R5                                                            
         CEIL  R2,L'CHARTEXT                                                    
         LR    R15,R2                                                           
         MOVE  R15,CHARTEXT,@R6                                                 
         EX    R15,'TR CHARTEXT(0),CHARTR'                                      
         TSEG  CHARTEXT,(R2)                                                    
         LA    R6,@R6+L'CHARTEXT                                                
         SH    R5,=Y(L'CHARTEXT)                                                
         END                                                                    
         PEND  ,                                                                
*                                                                               
CHARTR   DC    X'7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B'                              
         DC    X'7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B'                              
         DC    X'7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B'                              
         DC    X'7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B'                              
         DC    X'407B7B7B7B7B7B7B7B7B4A4B4C4D4E4F'                              
         DC    X'507B7B7B7B7B7B7B7B7B7B5B5C5D5E7B'                              
         DC    X'60617B7B7B7B7B7B7B7B7B6B6C6D6E6F'                              
         DC    X'7B7B7B7B7B7B7B7B7B7B7A7B7C7D7E7F'                              
         DC    X'7B8182838485868788897B7B7B7B7B7B'                              
         DC    X'7B9192939495969798997B7B7B7B7B7B'                              
         DC    X'7B7BA2A3A4A5A6A7A8A97B7B7B7B7B7B'                              
         DC    X'7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B'                              
         DC    X'7BC1C2C3C4C5C6C7C8C97B7B7B7B7B7B'                              
         DC    X'7BD1D2D3D4D5D6D7D8D97B7B7B7B7B7B'                              
         DC    X'7B7BE2E3E4E5E6E7E8E97B7B7B7B7B7B'                              
         DC    X'F0F1F2F3F4F5F6F7F8F97B7B7B7B7B7B'                              
         EJECT                                                                  
*box                                                                            
*                                                                               
*  HEXFMT -- Routine to seg line in hex format.                                 
*                                                                               
*    On entry:                                                                  
*      R1,R0 - line loc, len (len complimented for mixed format)                
*      R15 - amount to indent on continuation lines                             
*                                                                               
*    On exit, R15 (and CC):                                                     
*      z - ok                                                                   
*      nz- attn (on twrite)                                                     
*                                                                               
HEXWA    RECORD BEGIN                                                           
HEXWORK  DS    D                                                                
         END                                                                    
*-                                                                              
HEXFMT   XPROC HEXWA                                                            
         LR    R6,R0               Save as flag                                 
*                                                                               
         LPR   R3,R0                                                            
         LR    R4,R1                                                            
         LR    R5,R15                                                           
*                                                                               
         WHILE (R3,POS),BEGIN                                                   
         BTX   HEXWORK,8,L:@R4                                                  
*                                                                               
         IF    (R6,NEG),BEGIN      Mixed EBCDIC and HEX format...               
         CLEAR R2                                                               
         CLEAR R15                                                              
         LOOP  BEGIN                                                            
         SRL   R2,1                /2                                           
         LC    R1,@R4(R2)          Get byte                                     
         SLL   R2,1                *2                                           
         VCALL GTMIXTBL            Returns =V(MIXTBL) in R15                    
         LR    R14,R15                                                          
         CLEAR R15                                                              
         IC    R15,@R14(R1)        0=char, FF=control                           
         IF    (R15,Z),BEGIN                                                    
         STC   R1,HEXWORK(R2)      Display as char                              
         LA    R15,C'_'                                                         
         STC   R15,HEXWORK+1(R2)                                                
         END                                                                    
         LA    R2,@R2+2                                                         
         UNTIL (R2,GE,8)                                                        
         END                                                                    
         END                                                                    
*                                                                               
         LA    R1,HEXWORK                                                       
         LR    R0,R3                                                            
         CEIL  R0,4                                                             
         AR    R0,R0                                                            
         LR    R15,R0                                                           
         A     R15,CPSEGLENF                                                    
         S     R15,CPSEGMRKF                                                    
*                                                                               
         IF    (R15,GT,CPSWID),BEGIN                                            
         XPUSH R0,R1                                                            
         TCR                                                                    
         BNZ   HEXFEXIT                                                         
         TSEG  CVBLANKS,(R5)       Indent                                       
         XPOP  R0,R1                                                            
         END                                                                    
*                                                                               
         TSEG  (R1),(R0),B                                                      
         LA    R4,@R4+4                                                         
         SH    R3,=Y(4)                                                         
         END                                                                    
*                                                                               
         TCR                                                                    
HEXFEXIT PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  MIXFMT -- Routine to seg line in mixed EBCDIC and HEX                        
*    format.                                                                    
*                                                                               
*    On entry:                                                                  
*      R1,R0 - line loc, len                                                    
*                                                                               
MIXFMT   XPROC  ,                                                               
         LR    R3,R0                                                            
         LR    R4,R1                                                            
*                                                                               
         WHILE (R3,POS),BEGIN                                                   
         VCALL GTMIXTBL            Returns =V(MIXTBL) in R15                    
         LR    R14,R15                                                          
         LR    R15,R3                                                           
         CEIL  R15,256                                                          
         LA    R1,@R4(R15)                                                      
         DTEX  R15,'TRT @R4(0),@R14'  Find control char                         
         SR    R1,R4               No. of EBCDIC chars                          
         LR    R0,R1                                                            
         LR    R1,R4                                                            
         AR    R4,R0               Update...                                    
         SR    R3,R0               ...ptrs                                      
         TSEG  (R1),(R0)                                                        
         IF    (R3,POS),BEGIN                                                   
         TSEG  '<'                                                              
         LA    R5,4                                                             
         LOOP  BEGIN                                                            
         VCALL GTMIXTBL            Returns =V(MIXTBL) in R15                    
         LR    R14,R15                                                          
         LC    R15,@R4             Control char                                 
         LC    R2,@R14(R15)                                                     
         IF    (R2,Z),EXIT         Not a control char, scram                    
         BTX   CPDOUB,2,(R15)                                                   
         TSEG  (R1),(R0)                                                        
         LA    R4,@R4+1                                                         
         DECR  R3                                                               
         DECR  R5                                                               
         IF    ((R3,POS),AND,(R5,NP)),'TSEG CVBLANKS,1; LA R5,4'                
         UNTIL (R3,^POS),END                                                    
         TSEG  '>'                                                              
         END                                                                    
         END                                                                    
*                                                                               
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  ESCFMT -- Routine to seg text and start a new line every time                
*    an "escape" character is found.  The caller passes up to four              
*    characters which are to be considered ESCAPE characters.                   
*                                                                               
*    On entry:                                                                  
*      R1,R0 - line loc, len                                                    
*      R15 - amount to indent continuation lines                                
*      R2 - four bytes of ESCAPE characters (a X'00' means ignore)              
*                                                                               
ESCWA    RECORD BEGIN                                                           
ESCTRT   DS    XL256               Working TRT table                            
         END                                                                    
*-                                                                              
ESCFMT   XPROC ESCWA                                                            
*-                                                                              
*-       Set up TRT table to stop on all "escape" characters.                   
*-                                                                              
         CLEAR ESCTRT              Initialize working TRT table                 
         WHILE (R2,NZ),BEGIN       Set ESC characters...                        
         LR    R3,R2                                                            
         N     R3,=A(X'FF')                                                     
         IF    NZ,BEGIN            Set stop byte in TRT table...                
         LA    R3,ESCTRT(R3)                                                    
         MVI   @R3,X'FF'           Stop on this character                       
         END                                                                    
*                                                                               
         SRL   R2,8                Next byte                                    
         END                                                                    
*                                                                               
         LR    R3,R0               Save len...                                  
         LR    R4,R1               ...loc                                       
         LR    R5,R15              ...and indentation                           
*-                                                                              
*-       Seg text.                                                              
*-                                                                              
         WHILE (R3,POS),BEGIN      Go through text...                           
         LR    R15,R3                                                           
         CEIL  R15,256                                                          
         LA    R1,@R4(R15)                                                      
         DTEX  R15,'TRT @R4(0),ESCTRT'  Find control char                       
         SR    R1,R4               No. of EBCDIC chars                          
         LR    R0,R1                                                            
         LR    R1,R4                                                            
         AR    R4,R0               Update...                                    
         SR    R3,R0               ...ptrs                                      
         IF    (R0,POS),'VCALL MIXFMT'  Write the text                          
         TCCR                                                                   
*                                                                               
         IF    (R3,POS),BEGIN      We stopped on an ESC...                      
         TSEG  CVBLANKS,(R5)       Do indentation                               
         TSEG  '<'                                                              
         LC    R15,@R4             Display the ESC character                    
         BTX   CPDOUB,2,(R15)                                                   
         TSEG  (R1),(R0)                                                        
         TSEG  '>'                                                              
*                                                                               
         LA    R4,@R4+1            Skip over the ESC character                  
         DECR  R3                  One less character now                       
         END                                                                    
         END                                                                    
*                                                                               
         TCCR                                                                   
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  HEXDUMP -- Routine to write a formatted hex dump.                            
*    Most commonly invoked by the HEXDUMP macro.                                
*                                                                               
*    On entry:                                                                  
*      R0  - length of area                                                     
*      R1  - address of area                                                    
*      R15 - option flag byte (see HXDFLAGS definition below)                   
*                                                                               
HXDWA    RECORD BEGIN                                                           
HXDSTART DS    A                   Start of data ptr                            
HXDTRT   DS    A                   Translate table address                      
*                                                                               
HXDFLAGS FLAG                                                                   
         FLAG  (HXDFLOFF,1)        - Show offset (not address)                  
         FLAG  (HXDFLASC,2)        - ASCII data format (not EBCDIC)             
*                                                                               
HXDUNPK  DS    XL2                 UNPK work area                               
*                                                                               
HXDADDR  DS    CL8                 Address                                      
         DS    CL2                                                              
HXDHEXDM DS    0CL(8*4+3)          Hex bytes (dump format)                      
HXDHEX   DS    CL(16*3+1)          Hex bytes (data format)                      
         DS    CL2                                                              
         DS    C                   '|'                                          
         DS    CL16                Char display                                 
         DS    C                   '|'                                          
HXDLINE  EQU   HXDADDR,*-HXDADDR,C'C'                                           
         END                                                                    
*-                                                                              
HEXDUMP  XPROC HXDWA                                                            
         ST    R1,HXDSTART         Save start address                           
         STC   R15,HXDFLAGS        Save option flags                            
*                                                                               
         LR    R6,R1               Init data pointer                            
         LR    R5,R0               Init data counter                            
*                                                                               
         MVC   HXDTRT,CVDOTTBL     EBCDIC fmt                                   
         L     R2,=A(ASCIITBL)                                                  
         IF    HXDFLASC,'ST  R2,HXDTRT'     ASCII fmt                           
*                                                                               
         TCCR  ,                   Start a new line                             
*                                                                               
         WHILE (R5,POS),BEGIN      Loop on data count                           
         MVC   HXDLINE,CVBLANKS    Init print line buffer                       
         LR    R15,R6              Data address                                 
*                                                                               
         IF    HXDFLOFF,BEGIN      If offset format...                          
         S     R15,HXDSTART        Get data offset                              
         MVI   HXDADDR+3,C'+'                                                   
         BTX   HXDADDR+4,4,(R15)   Format offset                                
         END                                                                    
         ELSE  BEGIN               Else display offset...                       
         BTX   HXDADDR,8,(R15)     Format address                               
         END                                                                    
*                                                                               
         LA    R2,HXDHEX           Init hex display pointer                     
         IF    ^HXDFLASC,BEGIN     If dump format...                            
         LA    R3,L'HXDHEXDM+2(R2)  Init char display pointer                   
         END                                                                    
         ELSE  BEGIN               Else data format...                          
         LA    R3,L'HXDHEX+2(R2)                                                
         END                                                                    
*                                                                               
         MVI   @R3,C'|'                                                         
         MVI   @R3+17,C'|'                                                      
         INCR  R3                                                               
         LA    R4,1                Loop counter for this line                   
         WHILE ((R4,LE,16),AND,(R5,P)),BEGIN                                    
         MVC   HXDUNPK(1),@R6      Copy byte                                    
         UNPK  @R2(3),HXDUNPK(2)   Format data byte (plus junk byte)            
         NC    @R2(2),=X'0F0F'                                                  
         TR    @R2(2),=C'0123456789ABCDEF'                                      
         MVI   @R2+2,C' '                                                       
         MVC   @R3(1),@R6          Move to char display                         
         L     R15,HXDTRT          Translate table address                      
         TR    @R3(1),@R15         Translate to text char                       
         LA    R2,@R2+2            Incr hex pointer                             
*                                                                               
         IF    HXDFLASC,BEGIN      If not dump format...                        
         INCR  R2                  Extra space                                  
         IF    (R4,EQ,8),'INCR R2'  Extra space after 8th byte                  
         END                                                                    
         ELSE  BEGIN                                                            
         LR    R0,R4                                                            
         N     R0,=F'3'                                                         
         IF    Z,'INCR R2'         Space after every 4th byte                   
         END                                                                    
*                                                                               
         INCR  R3                  Incr char pointer                            
         INCR  R6                  Incr data pointer                            
         DECR  R5                  Decr data counter                            
         INCR  R4                  Incr line loop counter                       
         END                                                                    
*                                                                               
         TSEG  HXDLINE,,CR         Write line                                   
         END                                                                    
*                                                                               
         PEND  ,                                                                
*-                                                                              
*-       ASCII translate table                                                  
*-                                                                              
ASCIITBL DC    32C'.'                 00-1F                                     
         DC    C' !"#$%&&''()*+,-./'  20-2F                                     
         DC    C'0123456789:;<=>?'    30-3F                                     
         DC    C'@ABCDEFGHIJKLMNO'    40-4F                                     
         DC    C'PQRSTUVWXYZ[\]_'    50-5F                                     
         DC    C'.abcdefghijklmno'    60-6F                                     
         DC    C'pqrstuvwxyz{|}^.'    70-7F                                     
         DC    32C'.'                 80-9F    (Same as 00-7F...)               
         DC    C' !"#$%&&''()*+,-./'  A0-AF                                     
         DC    C'0123456789:;<=>?'    B0-BF                                     
         DC    C'@ABCDEFGHIJKLMNO'    C0-CF                                     
         DC    C'PQRSTUVWXYZ[\]_'    D0-DF                                     
         DC    C'.abcdefghijklmno'    E0-EF                                     
         DC    C'pqrstuvwxyz{|}^.'    F0-FF                                     
         EJECT                                                                  
*box                                                                            
*                                                                               
*  SQSHRTN -- Routine to compress multiple blanks to a single                   
*    blank.                                                                     
*                                                                               
*    On entry:                                                                  
*      R1,R0 - string loc,len                                                   
*                                                                               
SQSHRTN  XPROC  ,                                                               
         IF    ('LTR R3,R0',POS),BEGIN  Compress blanks...                      
         LR    R2,R1               Set start position                           
FNDBLK   LA    R6,@R2+1            Set possible squash move point               
FNDNBLKL CLI   @R2,C' '            Loop for end of blanks                       
         BNE   FNDNBLK             Br if not blank                              
         LA    R2,@R2+1            Step to next position                        
         BCT   R3,FNDNBLKL         Decr count and loop                          
         SR    R2,R6               Blanks ended text - leave                    
         BNP   SQSHXIT             1 blank at end and                           
         SR    R0,R2               Exit squash                                  
         B     SQSHXIT                                                          
*                                                                               
FNDNBLK  LR    R4,R2               Get no of blanks                             
         SR    R4,R6               To squash                                    
         BNP   FNDBLKL             None, skip MVC and adjustment                
         EX    R3,'MVC @R6(0),@R2' Move text left                               
         SR    R0,R4               Update squashed count                        
         LR    R2,R6               Reset R2 to rest of line                     
FNDBLKL  CLI   @R2,C' '            Find start of next blank field               
         BE    FNDBLK              Got it, go try to squash                     
         LA    R2,@R2+1            Step to next char                            
         BCT   R3,FNDBLKL          Decr count and loop                          
         END                                                                    
SQSHXIT  PRETURN (R0,R1)                                                        
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  CHARCHK/CHARCHKA -- Routine to check string for valid alpha-                 
*    numeric characters.  "CHARCHKA" entry is used when the first               
*    character must be alphabetic.                                              
*                                                                               
*      On entry:                                                                
*        R1,R0 - string loc, len                                                
*                                                                               
*      On exit, R15 (and CC):                                                   
*        -4 - national chars (@,#,$) present                                    
*         0 - all chars ok                                                      
*         4 - invalid string                                                    
*                                                                               
*  Usage notes:                                                                 
*  CHARCHK has only 1 caller. It is used to check JES ID jobname                
*  option.  CHARCHKA is tested as follows, BNZ is used for a                    
*  ALpha followed by alphanumerics.  BP (error routine) is used                 
*  to check for valid JCL jobnames (ie nationals and alphas                     
*  are treated the same).  It might be clearer to change as                     
*  suggested below in the TO DO: comments.                                      
*                                                                               
*                                                                               
*  Note:                                                                        
*  Characters are not checked for case.  They may be in                         
*  upper, lower or mixed case.  If you want upper case,                         
*  then be sure the translation to upper case is done by                        
*  the calling routine.                                                         
*                                                                               
*                                                                               
*  To Do:                                                                       
*  Should make 3 routines:                                                      
*  CHARCHKA - Alpha 1st char, then alphanumerics, no nationals                  
*  CHARCHKB - Alpha 1st char, then alphanumerics, with                          
*   nationals the same as alphas. (B for Batch job names)                       
*  CHARCHK - alpha numeric or national                                          
*  The ACMD,JES,RJE call CHARCHKB (batch).                                      
*  the DOPT,OPT,EDIT call CHARCHKA.                                             
*  With the above strategy, we only chech Z,NZ after call.                      
*                                                                               
CHARCHKA XPROC  ,                                                               
         CLEAR R2                                                               
         CLEAR R15                                                              
         IF    (R0,POS),BEGIN                                                   
         IC    R2,@R1                                                           
         IC    R2,CHCKTAB(R2)                                                   
         IF    (R2,EQ,12),BEGIN    IF FIRST IS NATIONAL, OK                     
         L     R15,=A(-4)          BUT RETURN NEG                               
         END                                                                    
         ELSEIF (R2,NZ),BEGIN      IF FIRST NOT ALPHA OR NATIONAL               
         LA    R15,4               INVALID                                      
         B     CHKADONE                                                         
         END                                                                    
         DECR  R0                                                               
         INCR  R1                                                               
         END                                                                    
         WHILE (R0,POS),BEGIN                                                   
         IC    R2,@R1                                                           
         IC    R2,CHCKTAB(R2)                                                   
         IF    (R2,EQ,4),BEGIN                                                  
         LA    R15,4                                                            
         B     CHKADONE                                                         
         END                                                                    
         IF    (R2,EQ,12),BEGIN                                                 
         L     R15,=A(-4)                                                       
         END                                                                    
         DECR  R0                                                               
         INCR  R1                                                               
         END                                                                    
CHKADONE LABEL ,                                                                
         PEND  ,                                                                
*                                                                               
*                                                                               
*                                                                               
CHARCHK  XPROC  ,                                                               
         CLEAR R2                                                               
         CLEAR R15                                                              
         WHILE (R0,POS),BEGIN                                                   
         IC    R2,@R1                                                           
         IC    R2,CHCKTAB(R2)                                                   
         IF    (R2,EQ,4),BEGIN                                                  
         LA    R15,4                                                            
         B     CHKDONE                                                          
         END                                                                    
         IF    (R2,EQ,12),BEGIN                                                 
         L     R15,=A(-4)                                                       
         END                                                                    
         DECR  R0                                                               
         INCR  R1                                                               
         END                                                                    
CHKDONE  LABEL ,                                                                
         PEND  ,                                                                
*                                                                               
*                                                                               
*                                                                               
CHCKTAB  DC    256X'04'                                                         
         ORG   CHCKTAB+C'a'                                                     
         DC    9X'00'                                                           
         ORG   CHCKTAB+C'j'                                                     
         DC    9X'00'                                                           
         ORG   CHCKTAB+C's'                                                     
         DC    8X'00'                                                           
         ORG   CHCKTAB+C'A'                                                     
         DC    9X'00'                                                           
         ORG   CHCKTAB+C'J'                                                     
         DC    9X'00'                                                           
         ORG   CHCKTAB+C'S'                                                     
         DC    8X'00'                                                           
         ORG   CHCKTAB+C'0'                                                     
         DC    10X'08'                                                          
         ORG   CHCKTAB+C'@'                                                     
         DC    1X'0C'                                                           
         ORG   CHCKTAB+C'#'                                                     
         DC    1X'0C'                                                           
         ORG   CHCKTAB+C'$'                                                     
         DC    1X'0C'                                                           
         ORG                                                                    
*                                                                               
         EJECT                                                                  
         QLTORG                                                                 
         TITLE 'Convert Printable Date to Julian'                               
*box                                                                            
*                                                                               
*  CNVDATE -- Routine to convert printable date to julian form.                 
*    Either yy.ddd or mm/dd/yy format is acceptable.  (This                     
*    routine would be "CR", but it depends on CP/CV stuff and                   
*    the WYLBUR scanner).                                                       
*                                                                               
*  On entry,                                                                    
*    the scanner is set for the string which is the date                        
*                                                                               
*  On exit,                                                                     
*    R15 = yydddf  (as returned by TIME BIN)                                    
*                                                                               
CNVDATE  XPROC  ,                                                               
         SCAN  JDATPRT                                                          
         SCANCHK                                                                
JDATCOM  BTD   CPDOUB+2,3,(R6)                                                  
         OC    CPDOUB(5),=C'00000'                                              
         MVI   CPDOUB+5,C'F'       Sign                                         
         XTB   CPDOUB,6            Get yydddf                                   
         PEND                                                                   
*                                                                               
JULDAT   PROC  ,                                                                
         LR    R2,R0              Enter with yy.ddd*1000                        
         LR    R15,R0                                                           
         CLEAR R14                                                              
         D     R14,=A(1000)        Isolate yy                                   
         IF    (R15,Z),'VCALL NOTVALID'       YY too little                     
         IF    (R15,GT,99),'VCALL NOTVALID '  yy too big                        
         LR    R3,R15                                                           
         LA    R4,365              Max no of days in a year                     
         IF    ('LR R0,R15; N R0,=F"3"',Z),'LA R4,366'  leap                    
         BTD   CPDOUB,2,(R15)      Add yy                                       
         MH    R3,=Y(1000)                                                      
         SR    R2,R3               Isolate ddd                                  
         IF    Z,'VCALL NOTVALID'                                               
         IF    (R2,GT,R4),'VCALL NOTVALID'   ddd is too big                     
         LR    R6,R2                                                            
         PRETURN (R6)              Join common code                             
         LA    R15,4                                                            
         PEND  ,                                                                
*                                                                               
MONDAT   PROC  ,                                                                
         LR    R3,R0              Save month                                    
         PRETURN (R3)                                                           
         SETSCKWS DAYPRT                                                        
         CLEAR R15                                                              
         PEND  ,                                                                
*                                                                               
DAYDAT   PROC  ,                                                                
         LR    R4,R0              Save day                                      
         SETSCKWS YEARPRT                                                       
         PRETURN (R4)                                                           
         CLEAR R15                                                              
         PEND  ,                                                                
*                                                                               
YEARDAT  PROC  ,                                                                
         LR    R5,R0              Save year                                     
         BTD   CPDOUB,2,(R5)      Add yy                                        
         SLL   R3,1               Month*2 for offset                            
         LH    R6,SMONTHS-2(R3)                                                 
         LR    R15,R4                                                           
         IF    ('N R5,=F"3"',Z),BEGIN  leap year...                             
         LH    R6,LMONTHS-2(R3)                                                 
         IF    (R3,LE,2*2),EXIT    Jan or feb.. scram                           
         LA    R15,@R15+1          Account for leap day                         
         END                                                                    
         IF    (R4,GT,R6),'ERROR "INVALID DATE"'                                
         AH    R15,TMONTHS-2(R3)   Calc ddd                                     
         LR    R6,R15                                                           
         PRETURN (R6)                                                           
         LA    R15,4                                                            
         PEND  ,                                                                
*                                                                               
JDATPRT  SCKW  ,MONDAT,PI,12                                                    
         SCKW  ,JULDAT,LN                                                       
         SCKW  ,V(NOTVALID)                                                     
*                                                                               
DAYPRT   SCKW  /,DAYDAT,(P,PI),31                                               
         SCKW  ,V(NOTVALID)                                                     
*                                                                               
YEARPRT  SCKW  /,YEARDAT,(P,I),99                                               
         SCKW  ,V(NOTVALID)                                                     
*                                                                               
         DC    F'0'                REQUIRED, BUT NOT USED                       
SMONTHS  DC    H'31,28,31,30,31,30,31,31,30,31,30,31'                           
LMONTHS  DC    H'31,29,31,30,31,30,31,31,30,31,30,31'                           
TMONTHS  DC    H'0,31,59,90,120,151,181,212,243,273,304,334'                    
         EJECT                                                                  
*box                                                                            
*                                                                               
*  MINSEG -- Routine to TSEG the number of hours/minutes/seconds                
*    from a value in seconds.                                                   
*                                                                               
*    On entry:                                                                  
*      R15 - time in seconds                                                    
*              (actually, the time is in unit of the high order                 
*               word of the TOD clock; i.e 1.048576 second units)               
*                                                                               
MINSEG   XPROC  ,                                                               
         LR    R5,R15                                                           
         SRL   R15,5               Divide by 32                                 
         SR    R5,R15              Apply correction for seconds                 
*                                                                               
         LR    R4,R5               Time in seconds                              
*-                                                                              
*-       Show hours.                                                            
*-                                                                              
         CLEAR R2                                                               
         LR    R3,R4                                                            
         D     R2,=A(60*60)        R3 = number of hours                         
         IF    (R3,NZ),BEGIN       Show hours...                                
         TNUM  (R3)                                                             
         SETMSG ' hours'                                                        
         IF    (R3,EQ,1),'DECR R0'                                              
         TSEG  (R1),(R0)                                                        
         LR    R4,R2                                                            
         END                                                                    
*-                                                                              
*-       Show minutes.                                                          
*-                                                                              
         CLEAR R2                                                               
         LR    R3,R4                                                            
         D     R2,=A(60)           R3 = number of minutes                       
         IF    (R3,NZ),BEGIN       Show minutes...                              
         IF    (R5,GT,=A(60*60)),'TSEG " and "'                                 
         TNUM  (R3)                                                             
         SETMSG ' minutes'                                                      
         IF    (R3,EQ,1),'DECR R0'                                              
         TSEG  (R1),(R0)                                                        
         LR    R4,R2                                                            
         END                                                                    
*-                                                                              
*-       Show seconds if time is less than one minute.                          
*-                                                                              
         IF    (R5,LT,60),BEGIN    Show seconds...                              
         TNUM  (R5)                                                             
         SETMSG ' seconds'                                                      
         IF    (R5,EQ,1),'DECR R0'                                              
         TSEG  (R1),(R0)                                                        
         END                                                                    
*                                                                               
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TOEBCDIC -- Routine to translate ASCII text to EBCDIC.                       
*                                                                               
*    On entry:                                                                  
*      R1,R0 - text loc, len                                                    
*                                                                               
*    On exit:                                                                   
*      R1,R0 - translated text loc, len                                         
*              (the text is translated in place)                                
*                                                                               
TOEBCDIC XPROC  ,                                                               
         L     R2,CVEBCTBL         EBCDIC translate table                       
*                                                                               
         WHILE (R0,POS),BEGIN      Translate text...                            
         LR    R15,R0                                                           
         CEIL  R15,256                                                          
         DEX   R15,'TR @R1(0),@R2'  To EBCDIC                                   
*                                                                               
         LA    R1,@R1+256                                                       
         SH    R0,=H'256'                                                       
         END                                                                    
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TOEBC7 -- Routine to translate ASCII-7 text to EBCDIC.                       
*                                                                               
*    On entry:                                                                  
*      R1,R0 - text loc, len                                                    
*                                                                               
*    On exit:                                                                   
*      R1,R0 - translated text loc, len                                         
*              (the text is translated in place)                                
*                                                                               
TOEBC7   XPROC  ,                                                               
         L     R2,CVEB7TBL         EBCDIC translate table                       
*                                                                               
         WHILE (R0,POS),BEGIN      Translate text...                            
         LR    R15,R0                                                           
         CEIL  R15,256                                                          
         DEX   R15,'TR @R1(0),@R2' To EBCDIC                                    
*                                                                               
         LA    R1,@R1+256                                                       
         SH    R0,=H'256'                                                       
         END                                                                    
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TOASCII -- Routine to translate EBCDIC text to ASCII.                        
*                                                                               
*    On entry:                                                                  
*      R1,R0 - text loc, len                                                    
*                                                                               
*    On exit:                                                                   
*      R1,R0 - translated text loc, len                                         
*              (the text is translated in place)                                
*                                                                               
TOASCII  XPROC  ,                                                               
         L     R2,CVASCTBL         ASCII translate table                        
*                                                                               
         WHILE (R0,POS),BEGIN      Translate text...                            
         LR    R15,R0                                                           
         CEIL  R15,256                                                          
         DEX   R15,'TR @R1(0),@R2' To ASCII                                     
*                                                                               
         LA    R1,@R1+256                                                       
         SH    R0,=H'256'                                                       
         END                                                                    
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TOEVENP -- Routine to translate ASCII text to even parity                    
*    ASCII text.                                                                
*                                                                               
*    On entry:                                                                  
*      R1,R0 - text loc, len                                                    
*                                                                               
*    On exit:                                                                   
*      R1,R0 - translated text loc, len                                         
*              (the text is translated in place)                                
*                                                                               
TOEVENP  XPROC  ,                                                               
         L     R2,CVPARTBL         Even parity table                            
*                                                                               
         WHILE (R0,POS),BEGIN      Translate text...                            
         LR    R15,R0                                                           
         CEIL  R15,256                                                          
         DEX   R15,'TR @R1(0),@R2' To even parity                               
*                                                                               
         LA    R1,@R1+256                                                       
         SH    R0,=H'256'                                                       
         END                                                                    
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  TOUPPER -- Routine to convert text to all upper case.                        
*                                                                               
*    On entry:                                                                  
*      R1,R0 - text loc, len                                                    
*                                                                               
*    On exit:                                                                   
*      R1,R0 - translated text loc, len                                         
*              (the text is translated in place)                                
*                                                                               
TOUPPER  XPROC                                                                  
         L     R2,CVUPPTBL         Upper case only xl table                     
*                                                                               
         WHILE (R0,POS),BEGIN      Translate text...                            
         LR    R15,R0                                                           
         CEIL  R15,256                                                          
         DEX   R15,'TR @R1(0),@R2' To upper case only                           
*                                                                               
         LA    R1,@R1+256                                                       
         SH    R0,=H'256'                                                       
         END                                                                    
         PEND                                                                   
         EJECT                                                                  
*box                                                                            
*                                                                               
*  ENCRYPT -- Routine to encode                                                 
*                                                                               
ENCRYPT  XPROC  ,                                                               
         XPUSH R0,R1                                                            
         TSEG  'ENCRYPT '                                                       
         TSEG  'Text = "'                                                       
         XPOP  R0,R1                                                            
         TSEG  (R1),(R0)                                                        
         TSEG  '"',,CR                                                          
*                                                                               
         TSEG  'Key = "'                                                        
         TSEG  (R2),(R3)                                                        
         TSEG  '"',,CR                                                          
         TWRITE                                                                 
         PEND  ,                                                                
         EJECT                                                                  
*box                                                                            
*                                                                               
*  DECRYPT -- Routine to encode                                                 
*                                                                               
DECRYPT  XPROC  ,                                                               
         XPUSH R0,R1                                                            
         TSEG  'DECRYPT '                                                       
         TSEG  'Text = "'                                                       
         XPOP  R0,R1                                                            
         TSEG  (R1),(R0)                                                        
         TSEG  '"',,CR                                                          
*                                                                               
         TSEG  'Key = "'                                                        
         TSEG  (R2),(R3)                                                        
         TSEG  '"',,CR                                                          
         TWRITE                                                                 
         PEND  ,                                                                
*                                                                               
         QLTORG                                                                 
*                                                                               
         END   .                                                                
