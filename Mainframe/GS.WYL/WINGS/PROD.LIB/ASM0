; THIS EXECFILE IS USED TO ASSEMBLE A WINGS MODULE.
; based on IOPROGM.JCL#ASM...modified for MCL version of WINGS
;
;  Last Revision 13 Jan 94
;
;  VARIABLES
;
;  OLDESC      Escape char. save
;  OLDACT      Active file no. save
;
;  NAMEWK      Name work area
;  MYJOBID     Jobname to be used
;  STEMP1      Work var. for prompts
;  MODULE      Module name
;
;  MEMPTR      Pointer into member list (prompt mode)
;  MEMEND      End of member list
;  OBJDSN      DSN of object library
;  JCL1          Line where JCL will go (=1 if not prompt mode)
;
;  PROMPTMODE  Flag for prompt mode
;
xproc () begin
DECLARE STRING OLDESC NAMEWK MYJOBID MODULE OBJDSN STEMP1
DECLARE NUM MEMPTR MEMEND OLDACT
DECLARE BOOLEAN PROMPTMODE
JCL1 = 1
OLDACT = ACTNO
IF (LINES EQ 0) OLDACT=0
OBJDSN='WYL.GA.MCL.WINGS.OBJECT'
OLDESC =ESC   ; FOR LATER RESTORE
SET ESC '&'
MODULE =UPPER(PARM_STRING)
IF (MODULE EQ '*') BEGIN
   MODULE =MEM
   IF (CHANGES GT 0) BEGIN ; save it first
      RESAVE:
      TRY SAVE * REPLACE
      IF (TRYERR) BEGIN ; SAVE had error
         IF (TRYATTN) XPAUSE
         IF (IND(JOBNAME,'COND') NE 4) XPAUSE ; failure wasn't condense
         SYNCH * WAIT=60 ; wait for condense to end
         GOTO RESAVE
         END  ; end TRYERR code
      END  ;  end SAVE code
   END  ;  end * code

OPEN WINGS TITLE='JCL for WINGS assembly'
IF (MODULE NE '') GOTO VALIDATE
PROMPT_DSN:
TRY READ STRING MODULE UPPER PROMPT 'Module name? '
IF (TRYATTN) GOTO CLEANUP
IF (MODULE EQ '') GOTO PROMPT_DSN
; VALIDATE NAME
VALIDATE:
IF (PARM_STRING EQ '*') GOTO BUILD_JCL   ; JUST SAVED IT, MUST BE GOOD
IF (MODULE NE 'PROMPT') GOTO CHECK_DSN
;  PROMPT MODE
PROMPTMODE = TRUE;   SET PROMPT FLAG
DUM DIR ALL IN WYL.GA.MCL.WINGS.ASM
DEL '.' 1 ; these aren't source modules
POI FIRST(4) NOLIST ; -> FIRST MEMBER NAME
MEMPTR=*
MEMEND = LAST
REA STR MODULE USI &(MEMPTR) COL 1/8   ; GET FIRST MEMBER NAME
MODULE=STRIP(MODULE)
PROMPT_DO:
;  PROMPT
WRI ' '
JCL1 = END    ; JCL GOES HERE
LIS &(MEMPTR) UNN
WRI ' '
TRY REA STR STEMP1 UPP PRO 'Assemble &(MODULE)? '
IF (TRYATTN) GOTO CLEANUP
IF (STEMP1 EQ '') GOTO BUILD_JCL ; CR=YES
IF (IND('YESOK',STEMP1) NE 0) GOTO BUILD_JCL
IF (STEMP1 NE '?') GOTO LOOPBACK  ; NO, TRY NEXT
;  SEE WHEN LAST DONE
TRY COP 'TXT'2 (1) TO END FRO &(OBJDSN)#&(MODULE)   ; OBJECT MODULE HAS DATE/TIME IN MODULE ID
IF (TRYERR) BEGIN
   WRI 'Module &(MODULE) not in object library'
   GOTO PROMPT_DO
   END
P X'47F0' (1) IN LAST  NOL
IF (* LE 0) BEGIN
   WRI 'Unable to get date.'
   GOTO PROMPT_DO
   END
REA STR STEMP1 USI *
DEL &(JCL1)/LAST
 STEMP1 = SUB(STEMP1,IND(STEMP1,S'47F0')+4)
 N3 = NHEX(DIS(SUB(STEMP1,1,1)))   ; ID LENGTH
WRI 'ID is:  &(SUB(STEMP1,2,N3))'
GOTO PROMPT_DO
;
; NAME GIVEN, CHECK IT
CHECK_DSN:
DUM DIR LIKE &(MODULE) IN WYL.GA.MCL.WINGS.ASM
P '&(MODULE) ' NOL
IF (* GT 0) BEGIN
   DEL 0/LAST ; FOUND IT
   GOTO BUILD_JCL
   END
DEL 0/LAST
COMMENT "&(MODULE)":  Unknown name.
GOTO PROMPT_DSN
;  BUILD JCL
BUILD_JCL:
MYJOBID ='WIN#'||SUBSTR(MODULE,1,4)  ; JOB NAME
IF (SUBSTR(MODULE,1,3) EQ 'WIN') MYJOBID =MODULE       ;  FOR WINXXXXX NAMES, USE AS IS
;
;  NOW BUILD THE JCL.
;
PUTEND //&(MYJOBID) JOB ,'WINGS &(MODULE)-&(USER)'
PUTEND //*
PUTEND //*  Assemble Wings module: &(MODULE)
PUTEND //*
PUTEND /*JOBPARM FORMS=3HOL,PFORMAT=LAND,CHARS=BD13,FORMS=GBAR
PUTEND /*JOBPARM LINES=99,HOLD=OUTPUT,PURGE=NO,JCL=NO
PUTEND // EXEC PURGEOLD
PUTEND //UNPRESS EXEC IOPROGM,PARM='PUNCH OUTNUM'
PUTEND //SYSPRINT DD DUMMY
PUTEND //SYSPUNCH DD DSN=&&SOURCE,DISP=(,PASS),UNIT=VIO,
PUTEND // DCB=BLKSIZE=4000,SPACE=(4000,(300,10))
PUTEND //INPUT   DD DSN=WYL.GA.MCL.WINGS.ASM(&(MODULE)),DISP=SHR,
PUTEND //           FREE=CLOSE
PUTEND //ASM EXEC PGM=IEV90,REGION=5M,COND=(5,LT,UNPRESS.GO),
PUTEND // PARM=('TERM,DECIMAL,RENT,NOXREF,ESD,NODXREF,LINECOUNT(32767)')
PUTEND //STEPLIB  DD  DSN=SYS2.ASMH.SLACV29.LINKLIB,DISP=SHR
PUTEND //SYSLIN  DD DSN=&(OBJDSN)(&(MODULE)),DISP=SHR,
PUTEND //   DCB=BLKSIZE=3200,SPACE=(TRK,(20,5,5))
PUTEND //SYSIN    DD  DSN=&&SOURCE,DISP=(OLD,DELETE)
PUTEND //SYSLIB   DD  DSN=WYL.GA.MCL.WINGS.MACLIB,DISP=SHR
PUTEND //         DD  DSN=WYL.GG.SYS.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS3.IS.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS3.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS1.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS1.MODGEN,UNIT=DISK,DISP=SHR
PUTEND //         DD  DSN=SYS4.MACLIB,DISP=SHR
PUTEND //SYSTERM  DD  SYSOUT=T
PUTEND //SYSUT1   DD  DSN=&SYSUT1,UNIT=SYSDA,DCB=BLKSIZE=5100,
PUTEND //             SPACE=(8000,(500,90),,,ROUND)
PUTEND //SYSPRINT DD  DSN=&PRINT,UNIT=SYSDA,SPACE=(CYL,(5,5)),
PUTEND //             DCB=(RECFM=FB,LRECL=121,BLKSIZE=5100),DISP=(,PASS)
PUTEND //*
PUTEND //$EDIT  EXEC  PGM=ASMEDIT,REGION=4M,PARM='STMT,DATA'
PUTEND //STEPLIB  DD  DSN=WYL.GG.SYS.LINKLIB,DISP=SHR
PUTEND //ASMOUT   DD  DSN=&PRINT,DISP=(OLD,DELETE)
PUTEND //SYSPRINT DD  SYSOUT=A
;  CONDENSE EVERY FIFTH JOB
IF (RANDOM LE 0.200) PUTEND //CONDENSE EXEC CONDENSE,DSN='&(OBJDSN)'
;
RUN &(JCL1)/L
DEL &(JCL1)/L
LOOPBACK:
IF (~PROMPTMODE) GOTO CLEANUP  ; NOT "PROMPT" MODE
MEMPTR =MEMPTR+.001  ; POINT TO NEXT
IF (MEMPTR GT MEMEND) GOTO CLEANUP ; DONE
POI &(MEMPTR) (1) NOL;  Find next in range
MEMPTR=*
REA STR MODULE USI &(MEMPTR) COL 1/8
MODULE=STRIP(MODULE)
GOTO PROMPT_DO
;
CLEANUP:
; CLEAN UP
CLOSE
IF (OLDACT NE 0) PIC  &(OLDACT)
SET ESC '&(OLDESC)'
end;
