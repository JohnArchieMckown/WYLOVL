; THIS EXECFILE IS USED TO ASSEMBLE A WINGS MODULE.
; based on IOPROGM.JCL#ASM...modified for MCL version of WINGS
;
;  Last Revision 2002/06/04

;  VARIABLES
;
;  OLDESC      Escape char. save
;  OLDACT      Active file no. save
;
;  NAMEWK      Name work area
;  MYJOBID     Jobname to be used
;  STEMP1      Work var. for prompts
;  MODULE      Module name
;  OPTSTR      options string
;  LINKIT      Link Edit after assembly?
;
;  MEMPTR      Pointer into member list (prompt mode)
;  MEMEND      End of member list
;  OBJDSN      DSN of object library
;  JCL1          Line where JCL will go (=1 if not prompt mode)
;
;  PROMPTMODE  Flag for prompt mode
;
xproc () begin
DECLARE STRING OLDESC NAMEWK MYJOBID MODULE OBJDSN STEMP1 OPTSTR
DECLARE NUM MEMPTR MEMEND OLDACT
DECLARE BOOLEAN PROMPTMODE LINKIT
JCL1 = 0
OLDACT = ACTNO
IF (LINES EQ 0) OLDACT=0
OBJDSN='WYL.GA.MCL.WINGS.OBJECT'
OLDESC =ESC   ; FOR LATER RESTORE
SET ESC '&'
MODULE =UPPER(PARM_STRING)
N1=INDEX(MODULE,'\')   ; look for options separator
IF (N1 NE 0) BEGIN                 ;  found separator
   OPTSTR=SUB(MODULE,1,N1-1)       ;  the options
   MODULE=SUB(MODULE,N1+1)         ;  the module name
;  check options (link is only one now)
   IF (ABB('LINKEDIT',OPTSTR)) BEGIN ;  LINK
      LINKIT=TRUE
      END                          ;  (link)
   ELSE BEGIN                      ;  unrecognized opt
      WRI OPTSTR||':  Invalid option.'
      GOTO CLEANUP
      END                          ;  (invalid opt string)
   END                             ;  (separator)

IF (MODULE EQ '*') BEGIN
   MODULE =MEM
   IF (CHANGES GT 0) BEGIN ; save it first
      RESAVE:
      TRY SAVE * REPLACE
      IF (TRYERR) BEGIN ; SAVE had error
         IF (TRYATTN) XPAUSE
         IF (IND(JOBNAME,'COND') NE 4) XPAUSE ; failure wasn't condense
         SYNCH * WAIT=60 ; wait for condense to end
         GOTO RESAVE
         END  ; end TRYERR code
      END  ;  end SAVE code
   END  ;  end * code

OPEN WINGS TITLE='JCL for WINGS assembly'
IF (MODULE NE '') GOTO VALIDATE
PROMPT_DSN:
TRY READ STRING MODULE UPPER PROMPT 'Module name? '
IF (TRYATTN) GOTO CLEANUP
IF (MODULE EQ '') GOTO PROMPT_DSN
; VALIDATE NAME
VALIDATE:
IF (PARM_STRING EQ '*') GOTO BUILD_JCL   ; JUST SAVED IT, MUST BE GOOD
IF (MODULE NE 'PROMPT') GOTO CHECK_DSN
;  PROMPT MODE
PROMPTMODE = TRUE;   SET PROMPT FLAG
DUM DIR ALL IN WYL.GA.MCL.WINGS.ASM
DEL '.' 1 ; these aren't source modules
POI FIRST(4) NOLIST ; -> FIRST MEMBER NAME
MEMPTR=*
MEMEND = LAST
REA STR MODULE USI &(MEMPTR) COL 1/8   ; GET FIRST MEMBER NAME
MODULE=STRIP(MODULE)
PROMPT_DO:
;  PROMPT
WRI ' '
JCL1 = END    ; JCL GOES HERE
LIS &(MEMPTR) UNN
WRI ' '
TRY REA STR STEMP1 UPP PRO 'Assemble &(MODULE)? '
IF (TRYATTN) GOTO CLEANUP
IF (STEMP1 EQ '') GOTO BUILD_JCL ; CR=YES
IF (IND('YESOK',STEMP1) NE 0) GOTO BUILD_JCL
IF (STEMP1 NE '?') GOTO LOOPBACK  ; NO, TRY NEXT
;  SEE WHEN LAST DONE
TRY COP 'TXT'2 (1) TO END FRO &(OBJDSN)#&(MODULE)   ; OBJECT MODULE HAS DATE/TIME IN MODULE ID
IF (TRYERR) BEGIN
   WRI 'Module &(MODULE) not in object library'
   GOTO PROMPT_DO
   END
P X'47F0' (1) IN LAST  NOL
IF (* LE 0) BEGIN
   WRI 'Unable to get date.'
   GOTO PROMPT_DO
   END
REA STR STEMP1 USI *
DEL &(JCL1)/LAST
 STEMP1 = SUB(STEMP1,IND(STEMP1,S'47F0')+4)
 N3 = NHEX(DIS(SUB(STEMP1,1,1)))   ; ID LENGTH
WRI 'ID is:  &(SUB(STEMP1,2,N3))'
GOTO PROMPT_DO
;
; NAME GIVEN, CHECK IT
CHECK_DSN:
DUM DIR LIKE &(MODULE) IN WYL.GA.MCL.WINGS.ASM
P '&(MODULE) ' NOL
IF (* GT 0) BEGIN
   DEL 0/LAST ; FOUND IT
   GOTO BUILD_JCL
   END
DEL 0/LAST
COMMENT "&(MODULE)":  Unknown name.
GOTO PROMPT_DSN
;  BUILD JCL
BUILD_JCL:
MYJOBID ='WIN#'||SUBSTR(MODULE,1,4)  ; JOB NAME
IF (SUBSTR(MODULE,1,3) EQ 'WIN') MYJOBID =MODULE       ;  FOR WINXXXXX NAMES, USE AS IS
;
;  NOW BUILD THE JCL.
;
PUTEND //&(MYJOBID) JOB ,'WINGS &(MODULE)-&(USER)'
JCL1 = LAST
PUTEND //*
PUTEND //*  Assemble Wings module: &(MODULE)
PUTEND //*
PUTEND /*JOBPARM FORMS=GBAR,LINES=99,HOLD=OUTPUT
PUTEND // EXEC PURGEOLD
PUTEND //UNPRES EXEC IOPROGM,
PUTEND // PARM='PUNCH OUTNUM INTEGER'
PUTEND //SYSPRINT DD DUMMY
PUTEND //SYSTERM  DD SYSOUT=*
PUTEND //SYSPUNCH DD UNIT=VIO,DSN=&&SYSIN,DISP=(,PASS),AVGREC=K,
PUTEND // SPACE=(80,50)
PUTEND //INPUT    DD  DSN=WYL.GA.MCL.WINGS.ASM(&(MODULE)),DISP=SHR
PUTEND //ASM EXEC ASMSC,REGION=32M,TCLASS=T,
PUTEND // PARM=('TERM,RENT,NOXREF,NODXREF,LINECOUNT(32767)',
PUTEND // NORLD,'USING(WARN(11))')
PUTEND //SYSLIB   DD  DSN=WYL.GA.MCL.WINGS.MACLIB,DISP=SHR
PUTEND //         DD  DSN=WYL.GG.SYS.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS3.IS.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS3.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS1.MACLIB,DISP=SHR
PUTEND //         DD  DSN=SYS1.MODGEN,UNIT=DISK,DISP=SHR
PUTEND //         DD  DSN=SYS4.MACLIB,DISP=SHR
PUTEND //SYSLIN  DD DSN=&(OBJDSN)(&(MODULE)),DISP=SHR,
PUTEND //   DCB=BLKSIZE=3200,SPACE=(TRK,(20,5,5))
PUTEND //SYSPRINT DD  DSN=&PRINT,UNIT=SYSDA,SPACE=(CYL,(5,5)),
PUTEND //             DCB=(RECFM=FB,LRECL=133,BLKSIZE=6251),DISP=(,PASS)
PUTEND //SYSUT1 DD SPACE=(27992,(300,100)),BLKSIZE=27992
PUTEND //SYSIN DD DSN=&&SYSIN,DISP=OLD
PUTEND //*
PUTEND //$EDIT  EXEC  PGM=ASMEDIT,REGION=4M,PARM='STMT,DATA'
PUTEND //STEPLIB  DD  DSN=WYL.GA.MCL.LINKLIB,DISP=SHR
PUTEND //ASMOUT   DD  DSN=&PRINT,DISP=(OLD,DELETE)
PUTEND //SYSPRINT DD  DSN=WYL.GA.MCL.WINGS.LIST(&(MODULE)),DISP=SHR,
PUTEND //  BLKSIZE=27998
;  CONDENSE EVERY FIFTH JOB
IF (RANDOM LE 0.200) BEGIN
   PUTEND //CONDOBJ  EXEC CONDENSE,DSN='&(OBJDSN)'
   PUTEND //CONDLIST EXEC CONDENSE,DSN='WYL.GA.MCL.WINGS.LIST'
   END
IF (LINKIT) BEGIN
   PUTEND //ASMOK IF (ASM.ASM.RC LE 4) THEN
   PUTEND //LKED   EXEC  PGM=HEWLH096,
   PUTEND //             PARM='MAP,LIST,NCAL,LET,DCBS'
   PUTEND //SYSPRINT DD  SYSOUT=A
   PUTEND //SYSUT1   DD  UNIT=VIO,SPACE=(1024,(100,100))
   PUTEND //SYSLMOD  DD  UNIT=SYSDA,DISP=(,PASS),SPACE=(1024,(100,100,5)),
   PUTEND //             DCB=SYS2.WINGS.TEST.LINKLIB
   PUTEND //OBJECT   DD  DSN=WYL.GA.MCL.WINGS.OBJECT,DISP=SHR
   PUTEND //SYSLIN DD DSN=WYL.GA.MCL.WINGS.LKED,DISP=SHR
   PUTEND //COPY   EXEC  PGM=IEBCOPY
   PUTEND //SYSPRINT DD  SYSOUT=A
   PUTEND //IN       DD  DSN=*.LKED.SYSLMOD,DISP=(OLD,DELETE)
   PUTEND //OUT      DD  DSN=WYL.GA.MCL.LINKLIB,DISP=SHR
   PUTEND //SYSIN    DD  *
   PUTEND  C I=((IN,R)),O=OUT
   PUTEND  C I=OUT,O=OUT
   PUTEND //ASMOK  ENDIF
   END

RUN &(JCL1)/L
DEL &(JCL1)/L
LOOPBACK:
IF (~PROMPTMODE) GOTO CLEANUP  ; NOT "PROMPT" MODE
MEMPTR =MEMPTR+.001  ; POINT TO NEXT
IF (MEMPTR GT MEMEND) GOTO CLEANUP ; DONE
POI &(MEMPTR) (1) NOL;  Find next in range
MEMPTR=*
REA STR MODULE USI &(MEMPTR) COL 1/8
MODULE=STRIP(MODULE)
GOTO PROMPT_DO
;
CLEANUP:
; CLEAN UP
CLOSE
IF (OLDACT NE 0) PIC  &(OLDACT)
SET ESC '&(OLDESC)'
end;
