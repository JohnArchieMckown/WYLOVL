OSFILE   TITLE 'OSFILE - Disk I/O support'
********************************************************************
*** %%Module: wings asm osfile;                                    *
********************************************************************
***
***
***  WINGS -- OS FILE SERVER
***
***    Wings provides the OS file access for client programs such
***    as Wylbur.  It attaches multiple subtasks so I/O
***    processing is done by a dedicated subtask, this makes
***    waiting for events much easier than trying to multiplex
***    requests.
***
***    All communications to Wings is done by opening a Suzan path.
***
***    Created, 11/29/90, Parker Gillespie
***    Good Job PJ !
***
***
***    To do list:
***    WYLBUR MAIL needs to use wings.  (oh yeah!)
***    SHOW SPACE
***
***
***  Modifications:
***  2002/06/11  ml   improved logging of path seq errors
***  2002/06/05  ml   MSG->SETMSG, COMMENT -> *
***  2002/04/16  ml   fix storage mgmt in SHOW DIR SYNAD routine
***  2002/04/01  ml   wait .01 second before closing path
***  2002/03/19  ml   log path ECB, flags on path close
***  2002/01/30  ml   init path segcb AFTER pathopen gets bufl
***  2001/10/15  ml   allow rename of uncatlg'd dsn when other
***                   is in use (MVS 2.10)
***  2001/10/12  ml   check for HFS before reading directory
***  2001/10/11  ml   recover from open abend reading directory
***  2001/05/03  ml   allow B and M suffixes on RECFM, FIXED and
***                   VARIABLE keywords
***  1999/12/14  ml   honor PRIQTY on SAVE...REPLACE
***  1999/12/03  ml   correct error msgs for uncat sms or migrated
***  1999/11/30  ml   better error msg: SAV TEMP, catlgd on tape
***  1999/11/08  ml   CKTMPCAT look at storclas/mgmtclas
***  1999/11/04  ml   correct SYNAD use of R13; TEMP as STORCLAS
***  1999/10/30  ml   save R14 in DCB ABEND exit
***  1999/07/13  ml   fix display of volser for EXISTS W/old catlgd
***  1998/07/28  ml   comment out a few QSNAPS left in CMDCLEAN
***  1998/04/20  ml   FINDUCB/UCBFMT mods for UCB>16M, delete timeout
***  1998/03/05  ml   fileseq validity check in FILE_CATLG
***  1998/01/12  ml   timeout if busy, waiting, <bftime> elapsed
***                   RECAT implemented
***  1997/09/30  ml   FILESHOW,NTYPE=EXACT smash case in from/to/like
***  1997/09/02  ml   remove LSTAR=0 check on open
***  1997/08/19  ml   fix default NTYPE setting for FILESHOW
***                   Corrections to GDG reference syntax checking
***  1997/08/14  ml   CHKREAD, CHKWRITE replaced by common CHKRACFA;
***                   use UPDATE access for PDS member save/scr/ren
***  1997/08/04  ml   support for MAXNAMES on FILESHOW (wk area size)
***  1997/07/29  ml   fixes to dsn build code for $wyl.xxx, allow
***                   # within quoted name, fixes to FILPBDTYPE chk
***  1997/11/17  ml   FILESHOW,NTYPE=BOTH prevent duplicate listings
***  1997/07/25  ml   allow X'C0' and - in MVS DSNAME
***  1997/07/07  ml   check DS1LSTAR on open/read for empty ds
***  1997/06/13  ml   fix $dsn#* processing, no syntax check when
***                   parsing dsn for scratch
***  1997/05/16  ml   diagnose 0218 error (not mounted)
***  1997/05/13  ml   file_scratch error handling
***  1997/04/29  ml   return volume/catalog status in FILE_OPEN hdr
***  1997/01/21  ml   correct NTYPE handling in RENAME
***  1996/12/17  ml   RBINFO check in UPDOPEN
***  1996/12/13  ml   CKTMPCAT before CKREP
***  1996/11/22  ml   FILEWRIT mods for HSM
***  1996/11/20  ml   Use SRSETUP, EFSETUP in RENAME.  Delete WSELVOL
***  1996/11/13  ml   SRSETUP used in SCRATCH; TICKLEDS call, SMSINFO
***  1996/11/11  ml   CMDABORT macro, EFSETUP replace RDSETUP
***  1996/11/07  ml   create RDSETUP common READ, SHOWDIR stuff
***                   to do SVC99, OBTAIN; alloc before OBTAIN.
***  1996/11/04  ml   first pass of HSM fixes: alloc before obtain
***  1996/10/07  ml   CATALOG command, VERIFY VTYPE=WRITE option
***  1996/09/30  ml   corrections to FILPBDTYPE setting
***  1996/09/25  ml   further ERRID cleanup, fix save w/old catlg
***                   entry that points to requested vol
***  1996/09/22  ml   check expire date on SAVE...REPLACE
***  1996/09/18  ml   tweak Kbytes/Mbyte conversion factors for alloc
***                   delete FWESTAE code.
***  1996/09/16  ml   major cleanup of FILEWRIT logic re: new/old,
***                   vol/cat conflicts...remove DELCAT call, add
***                   check for SMS vol. substitution.  Delete
***                   SETDISP, VOVERIDE option, RSELVOL routine.
***  1996/07/30  ml   SAV ... ON <badvol> REP, ds catlg'd on goodvol,
***                   fail NOVOL
***  1996/07/29  ml   tweak CATLOC code, fix bug w/future GDG ref.
***  1996/07/25  ml   extensive cleanup of ERRSCB handling on
***                   branches to CMDCLEAN (ensure that ERRSCB has
***                   valid errmsg if TERRMSG is set)
***  1996/07/11  ml   OBTFMT1 give RC (not abort) if vol not mtd
***                   SAVE..REP, cat on badvol, uncat then save new
***  1996/07/03  ml   remove OSFILE_TERM, OSFILE_ABEND commands
***                   force reblock SAVE [EDIT, SEQ] REPLACE
***  1996/07/02  ml   PDEBUG option to trace path traffic
***  1996/07/01  ml   tweak scratch error messages
***  1996/06/03  ml   info-only extended msgs optional, not dflt
***  1996/05/10  ml   delete DYNERR, process SVC99 msgs if RC=0
***  1996/05/02  ml   UNIT_INFO
***  1996/04/22  ml   UPDOPEN code added
***  1996/04/16  ml   fix logspin logic: check at CMDCLEAN and
***                   at SETTIMER (if busy, settimer never hit)
***  1996/03/20  ml   minimum lines to spin off log at timeout
***  1996/03/19  ml   revised SCRVOL logic (allow multiple vols)
***  1996/03/18  ml   default to NOFWESTAE, option FWESTAE turns on
***  1996/03/01  ml   NOFWESTAE option; IEFDB476 format SVC99 error
***                   msgs; delete SCRFILE, SAVESCR, use SCRPS instead
***                   log spinoff on time/lines, set SYSOUT class,
***                   first pass removal of MODE 24 for OPEN etc.;
***                   DSNENQ function calls for internal enqueue;
***                   remove various unused procs.
***  1996/02/07  ml   diagnostic msg for "exists" error
***  1996/01/03  ml   put date (mm/yy) as well as time in log msgs
***                   change log format, use full line length
***                   print DCB exit routine for BLKSIZE
***  1995/11/16  ml   from/to/like in FSHOAREA; fix error msgs,
***                   change qualify logic
***  1995/11/14  ml   correct vol rept logic on save (report only
***                   if TVTPBVOL defined i.e. user specified vol.
***  1995/09/22  ml   improve "override RECFM/LRECL" logic
***  1995/09/18  ml   check for catlg conflict before rename
***  1995/09/14  ml   check for existence of file before RACF check
***  1995/08/10  ml   Allow override of RECFM/LRECL/BLKSIZE
***                   when doing read
***  1995/08/07  ml   Don't return DIFFVOL error for save OLD.
***                   Report if ALLOCATE forces volume change.
***  1995/07/19  ml   alloc ALLOC PRIQTY=0
***  1995/07/06  ml   turn off TVTXDBUG (used for tracing path
***                   traffic on scratch/allocate)
***  1995/06/27  ml   if LIB on PUB, do nonspecific volume req
***  1995/06/15  ml   patch to 57xx handling
***  1995/06/12  ml   handle 57xx (catalog) errors from SVC99
***                   default secondary for alloc sequential
***  1995/06/07  ml   check RACF access to NEWNAME; pass FILPB
***  1995/06/02  ml   fix SAVE...REP space check; get user path bufl
***  1995/05/30  ml   delete CKVOLTAB code.  Honor PRIQTY on save.
***                   fix ALOCUNIT default.  use FILEALLO on SAVE.
***  1995/05/26  ml   fix DSNVER core leak - TVTBUFP vs. RBSTART
***  1995/05/22  ml   recover from path sequence error
***  1995/05/21  ml   allocate/seq open and close
***  1995/05/19  ml   tweak SHO DIR fmt: move title 1 to left
***  1995/05/15  ml   trace scratch msgs; minor ISPF dir fmt cleanup
***  1995/05/10  ml   file allocated message
***  1995/05/09  ml   fix bad CMDERR in FILOSCAN; allow 0 secqty etc.
***  1995/05/03  ml   OLD format in SHOW DIR
***  1995/04/25  ml   TEMP override REPORT options
***  1995/04/21  ml   FILOSKIP bug fixes
***  1995/04/05  ml   FILESHOW work area changes, TVTOSFIL changes
***  1995/03/30  ml   combine VTOC_SHOW and FILE_SHOW
***  1995/03/24  ml   bug fix DCB OPEN exit: was setting LRECL=BLKSI
***                   for FB data when PDS scratch/rename
***  1995/03/20  ml   refinements to path seq logic
***  1995/03/14  ml   check for OPEN when cmd in progress
***  1995/03/07  ml   VTOC_SHOW first pass
***  1995/02/28  ml   handle old old (<1982) dir date format
***  1995/02/27  ml   pass FILPB to WFILALC in SAVE...NEW so SMS opts
***                   available for allocate
***  1995/02/15  ml   fix DYNBUF formatting in dumper
***  1995/02/09  ml   RENAME msg cleanup
***  1995/02/08  ml   HLASM compatibility, fix length of EX-@reg
***  1995/02/07  ml   improve end-of-command cleanup for new functions
***  1995/02/02  ml   RENAME command
***  1995/01/19  ml   output DCB open exit to set block size
***  1995/01/18  ml   correct edit format space calc, optimize blksize
***  1995/01/17  ml   clean up various error msgs (correct missing
***                   or extraneous quotes)
***  1995/01/12  ml   for FILESHOW, default LIKE to common substr
***                   of FROM and TO
***  1995/01/10  ml   for FILESHOW, LIKE same as NAME
***  1995/01/05  ml   Add EXCLUDE, THROUGH
***  1994/12/27  ml   FILESHOW TEMP logic
***  1994/12/23  ml   fixes to FILESHOW name logic
***  1994/12/08  ml   fixes to "last member" logic in showdir; delete
***                   "directory of" title, always report blocks
***  1994/11/30  ml   various corrections to ERRID assignments,
***                   "file not found" error messages
***  1994/11/29  ml   add MEMBERS option to SHOW DIR
***  1994/11/28  ml   move RACF stuff to MVSUTILS
***  1994/11/22  ml   fix bad dsorg msg
***  1994/11/21  ml   ERASE option on SCRATCH
***  1994/11/15  ml   more ALLOC fixes; allow MB; remove path auth
***                   kluge on use/save
***  1994/11/11  ml   fixes to ALLOCATE space-by-KB algorithm
***  1994/11/03  ml   change RECFM flags to use common inner macro
***  1994/11/02  ml   delete RACF profile on scratch; STCK TZ adjust
***  1994/11/01  ml   allow adjustable send buffer length
***  1994/10/31  ml   fix error recursion on RC=20 from SCOM SEND
***  1994/10/26  ml   fix scratch extra-opts scan, errmsg seg
***  1994/10/24  ml   fix "scratch, no vol found" err handling
***  1994/10/19  ml   corrections to "member not found" err codes.
***                   return FILE_SCRATCH after scratch.
***  1994/10/13  ml   add SMS errors to SVC99 error table
***  1994/10/07  ml   error if scratch member of sequential
***  1994/10/06  ml   FILE_SCRATCH EOF msg change; add scratch
***                   options scan
***  1994/09/06  ml   FILESHOW option redesign
***  1994/08/16  ml   enable DCB ABEND exit for reads, test for
***                   open abends.  Always unalloc on cmd cleanup.
***                   Remove FREE=CLOSE, do explicit unallocates.
***  1994/08/11  ml   further FILESHOW (sho cat/dsn) tweaks
***  1994/08/02  ml   SHOWCAT first pass
***  1994/07/26  ml   correct CNAME resolution (fully qual.)
***  1994/07/20  ml   tweaks to SHOW DIR format
***  1994/07/19  ml   add create date/time stamp in PDS
***  1994/07/07  ml   SHOW DIR fixes
***  1994/07/05  ml   SHOW DIR ALL, FROM, TO, LIKE
***  1994/06/29  ml   SHO DIR first pass fixup
***  1994/06/22  ml   fix SEGDSN for TSO, exact styles:  set
***                   FTYP stuff based on actual constructed dsn
***  1994/06/21  ml   various "check recfm/lrecl/blksize" fixes:
***                   maxblk=32760 (not 32512!), round BLKSI if FB
***  1994/06/21  ml   various fixes to ALLOCATE logic
***  1994/06/15  ml   fix "user unknown to RACF" error logic
***  1994/06/03  ml   move DYNPRT (print dynamic alloc info) to
***                   MVSUTILS
***  1994/06/02  ml   tweaks to allocate cmd
***  1994/05/31  ml   allocate command, first pass
***  1994/05/25  ml   misc. SCRATCH fixes
***  1994/05/20  ml   fix USE ... TEMP logic for RLG
***  1994/05/16  ml   fix "save # " bug (blank member)
***  1994/05/07  ml   scratch code fixes, NOENQ support
***  1994/05/02  ml   Add SCRATCH PDS MEMBER code
***  1994/04/30  ml   allow null record in VB READ
***  1994/04/26  ml   change mainloop time interval to 10 minutes
***  1994/04/11  ML   Handle RECFM=V,LRECL=0; trap negative RDW
***  1994/03/24  ml   RACF: Don't log 2nd access check, don't test
***                   for WRITE access if PASSCHK=YES and READ access
***  1994/03/15  ml   log date at startup, log server name
***  1994/02/17  ML   fix timing/post bug on patherr, path timeout
***  1994/02/16  ML   clean up STOW ERROR msg
***  1994/02/04  ML   clean up "member not specified" messages
***                   add timestamp at path open
***  1994/01/20  ML   further SYNAD cleanup, WRITE SYNAD fixes
***  1994/01/18  ML   enable file write SYNAD routine; clean up
***                   file read SYNAD messages
***  1994/01/14  ML   fix bad return fro FWESTAE, caused loop
***  1993/12/14  ML   allow MCL to debug!
***  1993/12/14  ML   fix blksize=0 on input
***  1993/11/28  CH   dsn format change bug fix
***  1993/11/28  CH   allow scr001 for rlg
***  1993/06/00  ch   wings racf cacheing fixed (make LRU)
***  1993/05/00  ch   installed in WYLBUR
***  1993/05/00  ch   wings racf cacheing fixed (allow refresh)
***  1993/05/00  ch   batch mode removed
***  1993/05/00  ch   volume table stuff removed
***  1993/05/00  ch   general cleanup/ comments ***
***  1993/04/00  ch   lib extents fix
***  1993/04/00  ch   wylbur suzan full queue emptied fix
***  1992/11/00  ch   installed in TESTWYL
***
***  1992/00/00       Monitor development
***  1992/00/00       Debugger development
***  1992/00/00       Wings development
***
***  1991/04/06  JDN  Filename scanning/data set construction
***  1991/03/22  SCH  Blocking/Deblocking routines
***  1990/11/30  PJG  Initial version (Based on about everything).
***
*******************************************************************
         SPACE 3
OSFILE   HIBAL ,                   Initialize HIBAL macro system
OSFILE   AMODE 31                  Initial 31-bit addressing mode
OSFILE   RMODE 24                  Reside below 16MB line
OSFILE   CSECT ,                   Define module control section
         IDENT 2080                16:01:07 03/21/2002 MCL
         SPACE 3
STACKSZ  EQU   32*1024,4,C'N'      Default save stack size
ESTAESZ  EQU   8*1024,4,C'N'       Default ESTAE stack size
         SPACE 3
         REGS  FSR,,,,,,,,WAR,BRR,BR,TVTR,(GVTR,LSR),SPR,RAR
         GBLC  &ZONE               Define local time zone
         GBLC  &ALTZONE            Define alternate time zone
         GBLA  &LINESZ             Maximum WYLBUR line size
         GBLA  &PRESSZ             Maximum length of pressed line

         SYSDEFN ,                 Include Stanford defaults
         EJECT ,
*box
*
*   CPROC differs from PROC in that it saves the current stack
*     and return address in the TVT so error exits can return
*     to the "command proc" caller.  See CMDCLEAN routine.
*
         MACRO
&L       CPROC &P1,&P2,&PTR=WAR,&BASE=YES,&TRACE=YES
&L       PROC  &P1,&P2,PTR=&PTR,BASE=&BASE,TRACE=&TRACE
         ST    WAR,TVTCMDAS        Current stack frame ptr
         MEND
         SPACE 2
*box
*
*   Define system mapping macros
*

         PRINT NOGEN
         CVT   DSECT=YES           Communications vector table
         IHASDWA                   Stae/dump work area
         DCBD  DEVD=DA,DSORG=PS    Data control bock
         LSPACE MF=(D,DATA)        Define LSPACE data return area
JFCBDSCT DSECT ,
         IEFJFCBN ,                Job file control block
DSCBDSCT DSECT ,
         IECSDSL1 (1,2,3,4,5,6)    VTOC data set control blocks
UCB      DSECT ,
         IEFUCBOB ,                Unit control block
         IEFZB4D0 ,                Dynamic allocation
         IEFZB4D2 ,                Dynamic allocation
         IEFZB476 EMDSEC1=YES,EMDSEC2=YES  dynalloc error msg areas
         IHAASCB ,                 Address Space Control Block
         IHAASXB ,                 Address Space Control Block Ext
         IHAACEE ,                 RACF access control env element
         IHADVCT ,                 Device characteristics table
         IHAEVNT ,                 Map EVENTS table format
         IHAEPIE ,                 EPIE Dsect
         IKJTCB DSECT=YES          Task control block
TIOTDSCT IEFTIOT1 ,                Task input/output table
         IEZDEB ,                  Data extent block
         IECDDCE ,                 Device characteristics table
DVTAREA  RECORD 'DVTAREA'
*
         PRINT GEN
         SPACE 2
*-
*-  Version info is zapped into the following area.
*-
VERSION  CSECT ,
         DC  CL235'Wings:OSFILE (&SYSDATE) (&SYSTIME) Version 4.01'
         TITLE 'Wings work areas'
         COPY  TPENTRY             TRAP ENTRY
         EJECT ,
         COPY  DVWA                GLOBAL DEBUG AREA
         EJECT ,
         COPY  LCLDBWA             LOCAL (ESPIE) DEBUG AREA
*
         TITLE 'Disk I/O support: Global vector table'
GVT      RECORD BEGIN
         COPY  GVT
         END   ,
         TITLE 'Disk I/O support: Mapping macros'
         COPY  UPATH               INCLUDE PATH MAPPING INFORMATION
         EJECT ,
         COPY  PDSDIR
         SPACE 3
         COPY  ERRTABLE            ERROR TABLE FORMAT DEFINITION
         SPACE 3
         COPY  SYMTAB
         SPACE 3
         COPY  TRCENTRY
         SPACE 3
         COPY  DYNTABLE
         SPACE 3
         COPY  WINGACEE
         SPACE 2
         COPY  DEVCAPCT

         COPY  SPACALC
         SPACE 2
         COPY  RACFEQU             COPY RACF ACCESS EQUATES
         SPACE 2
         COPY  RBINFO
         SPACE 2
         EJECT ,
         COPY  WGSLINE
         SPACE 2
*box
*
*        Generate error table map
*
         ETAB  MAP=YES             GENERATE ERROR TABLE MAP
         SPACE 3
*box
*
*  Define STOW options
*
STOW_ADD EQU   0,4,C'N'            Stow add option
STOW_REP EQU   1,4,C'N'            Stow replace option
STOW_DEL EQU   2,4,C'N'            Stow delete option
STOW_CNG EQU   3,4,C'N'            Stow change option
         SPACE
* Note that the above bit values are not arbitrary, see comments in
* the PDSSTOW routine.
         SPACE 3
*box
*
*        Define default blocksize, data set allocation overhead,
*        and percentage secondary allocation values.
*
* was 110% and 5%, rev 950118 ml...
DSOVERHD EQU   105,4,C'N' ml950118 Define data set overhead
DSSECAMT EQU   10,4,C'N'  ml950118 Define percentage secondary
         SPACE 3
*box
*
*  General ENQ/DEQ parameter lists
*
ENQFLAGS RECORD BEGIN
ENQFLAG  FLAG  ,                   Define option bit settings
         FLAG  (ENQTYPE,X'80')         ENQ type
         FLAG  (ENQSCOPE,X'48')        ENQ scope
         FLAG  (ENQRET,X'07')          ENQ ret= type

ENQE       EQU   ENQFLAG,X'80',C'N'    Type=exclusive
ENQS       EQU   ENQFLAG,X'00',C'N'    Type=shared
           SPACE ,
ENQSTEP    EQU   ENQFLAG,X'00',C'N'    Scope=step
ENQSYSTEM  EQU   ENQFLAG,X'40',C'N'    Scope=system
ENQSYSTEMS EQU   ENQFLAG,X'48',C'N'    Scope=systems
           SPACE ,
ENQNONE    EQU   ENQFLAG,X'00',C'N'    Ret=none
ENQHAVE    EQU   ENQFLAG,X'01',C'N'    Ret=have
ENQCHNG    EQU   ENQFLAG,X'02',C'N'    Ret=chng
ENQUSE     EQU   ENQFLAG,X'03',C'N'    Ret=use
ENQTEST    EQU   ENQFLAG,X'07',C'N'    Ret=test

         END   ,
         EJECT ,
*box
*
*  Map segment control block fields
*
         SPACE 2
SEGCB    RECORD 'SEGCB'
         SPACE 3
*box
*
*  Map scanner control block fields
*
         SPACE 2
         SCANCB TYPE=DSECT
         EJECT ,
*box
*
*  File parameter area
*
FILPB    RECORD 'FILPB'            File parameter block
*-
*-       XFILPB is just a copy of FILPB, so we can have
*-         addressability to two FILPBs at once.
*-
XFILPB   RECORD BEGIN
         FILPB PFX=XFILPB
         END
         TITLE 'Disk I/O support: Task vector table'
TVT      RECORD BEGIN
         COPY  TVT                 Basic TVT
         COPY  TVTOSFIL            TVT OS file extension
         END
         TITLE 'Disk I/O support: Initialization'
*box
*
*   Main entry point - initialization
*
*       The longest journey begins with a single step.
*       Please start here.
*
OSFILE   CSECT ,                   Define control section start
         USING GVT                 Global vector table ptr
         USING TVT                 Task vector table

         ENTRY STARTUP             Define module entry point
STARTUP  LABEL ,                   Module entry point
         STM   R14,R12,@R13+12     Save calling registers
         LR    BR,R15                Move program base register
         USING STARTUP,BR              Set addressabiltity
         LR    R6,R1                     Save VS parameter pointer
         LR    R7,R13                      Save VS save area address
*-
*-                                         Note: R6 and R7 must
*-                                         remain set until STARTUP
*-

         L     BRR,=A(OSFCOMMN)    Address of common routines
         USING OSFCOMMN,BRR        Declare addressability

*-
*-       Save VS save area address and allocate internal
*-       save stack mechanism.
*-
         GETMAIN RC,LV=STACKSZ,    Get a 32K stack                     X
               BNDRY=PAGE,LOC=(BELOW,ANY)
         IF    (R15,NZ),BEGIN      Insufficient memory for stack
         LA    R15,12              Load return code
         B     OSFXIT2             Abort processing
         END   ,
         LR    SPR,R1              Set stack
         LR    WAR,R1              Ditto
*-
*-       Test for batch mode invocation, (NOT SUPPORTED 5/93)
*-
         TM    @R6,X'80'           Test for batch mode
         IF    ONES,BEGIN          Invoked in batch test mode
*                                  BATCH MODE NO LONGER SUPPORTED
         DC    H'0'                BOMB RIGHT HERE  (5/93)
         END
         ELSE  BEGIN               Attached by monitor
         L     TVTR,@R6            Address of passed TVT
         L     GVTR,TVTGVTP        Address of GVT
         LA    R6,@R6+4            Bump to parameter string pointer
         END   ,

*-
*-       Initialize values in TVT
*-
         SET   TVTFOSFILE          We are OSFILE type subtask
         ST    SPR,TVTSTPTR        Save stack pointer in TVT
         ST    R7,TVTSAVE          Save vs save area address
         SET   TVTSTINIT           Subtask initialization in progress
         MVC   TVTRLAST,=A(-1)     Set for recovery stack overflow
         L     R1,=A(TVTEMODL)     Address of routine values
         MVC   TVTEROUT(4*TVTEVCNT),@R1      Move in addresses
         MVC   TVTPATHN,GVTPATHN   Set default path name
         IF    (TVTWTIME,Z),'MVC TVTWTIME,=A(100*60*TVTDFWTM)'
         OI    TVTOPEN,X'80'       Mark only one DCB
         OI    TVTCLOSE,X'80'      Mark only one DCB
         L     R1,=A(MODSETZM)     Model MODESET for key=zero
         MVC   MODSETZ(4),@R1        Set into tvt
         L     R1,=A(MODSETPM)     Model MODESET for key=zero
         MVC   MODSETP(4),@R1        Set into tvt

         GETMAIN RC,LV=L#OSFWK,    Get a general-purpose work area     X
               BNDRY=PAGE,LOC=(BELOW,ANY)
         IF    (R15,NZ),BEGIN      Insufficient memory for workarea
         LA    R15,12              Load return code
         B     OSFXIT2             Abort processing
         END   ,
         ST    R1,TVTOSFWK         save area pointer

         L     R0,=A(ESTAESZ)      Set stack for 8K bytes
         GETMAIN RC,LV=(0),LOC=(BELOW,ANY)
         ST    R1,TVTESTAK         Reserve for ESTAE stack processing
         LA    R3,TRCNENT#         Number of trace entries
         M     R2,=A(L'TRCENTRY)   Compute total table size
         GETMAIN RC,LV=(3),LOC=(BELOW,ANY)   Trace table storage
         IF    (R15,NZ),BEGIN      Insufficient memory
         MVI   TVTRETCD+3,12       Set return code
         B     OSFXIT              Abort processing
         END   ,

         ST    R1,TVTTRBEG         Save pointer
         ST    R1,TVTTRCUR         Init entry pointer
         LA    R0,0(R1,R3)         Table end address
         ST    R0,TVTTREND         Save address
         LR    R2,R1               Copy address for MVCL
         CLEAR R15                 Clear from length
         MVCL  R2,R14              Clear trace table
         SET   TVTFTRC             Flag tracing active
         SET   TVTNOFWE            no file-write ESTAE     ml960318
         LA    R1,TVTSTOPE         Address of task action ECB
         ST    R1,TVTECBRQ         Save for mother task post
         L     R0,=A(16384)        Our buffer size for SUZAN path
         ST    R0,TVTSBUFL
         MVI   TVTLOGSY,C'*'       Default SYSOUT for log
         MVC   TVTLOGLL,=A(100*1000)  default line limit
         MVC   TVTLOGTL,=H'24'         ...   time limit
         MVC   TVTQWTIM,=A(15)     enq retry wait time, centisec.
         B     *+8                 Skip following
         SET   TVTSENDXMSGS        zap the branch to set this on
         PTRACE Startup            Add first entry
*-
*-       Process any passed over-riding parameters
*-
         TM    @R6,X'80'           Test for exec parameter pointer
         IF    ONES,'LR R1,R6'     Move pointer to exec parameters
         ELSE  'LA R1,@R6+4'       Set pointer to exec parameters
         ACALL SCANPARM            Scan initialization parameters
         SPACE 2
         IF    ~TVTNOEST,BEGIN     Only if we desire ESTAE exits
*-
*-       Define extended STAE recovery environment
*-
*-             Insure that this ESTAE is queued prior to calling
*-             DUMPINIT so that the dumper has a chance before
*-             we release all of the GD control blocks!!
*-
**       QSNAP 'at SETESTAE'
         ACALL SETESTAE            Enable ESTAE exit
         SPACE 2
*-
*-       Initialize dump formatter.
*-
         L     R1,=V(PRTDYN)       Print dynamic allocations
         LA    R0,TVTDYNBF         ...which will need this...
         VCALL DUMPINIT            Initialize dump formatter
**       QSNAP 'after DUMPINIT'
         END   ,
         SPACE 2
*-
*-       Initialize trace table addresses and the symbol table
*-
         XPUSH ,,16,PTR=R2             Get stack space
         ADDSYM ENTRY=(R2),NAME='TVT',LOC=(TVTR),LEN=LH:TVTTLEN
         ADDSYM ENTRY=(R2),NAME='GVT',LOC=(GVTR),LEN=L'GVT
         ADDSYM ENTRY=L:=A(OSFSYM)     Add OSFILE Symbols
         ADDSYM ENTRY=L:=V(SYMUTILS)   Add UTILITY symbols
         ADDSYM ENTRY=L:=V(SYMPATH)    Add PATH symbols
         ADDSYM ENTRY=L:=V(SYMDBSPI)   Add DBESPIE symbols
         ADDSYM ENTRY=L:=V(SYMDUMP)    Add DUMPER symbols
         ADDSYM ENTRY=L:=V(SYMSCANN)   Add SCANNER symbols
         ADDSYM ENTRY=L:=V(SYMMVSUT)   Add MVSUTILS symbols
         ADDSYM ENTRY=L:=V(SYMSHOCT)   Add SHOWCAT symbols
         XPOP  PTR=R2                  Pop stack work area
         SPACE 2
*-
*-       If debugging allowed, set debug ESPIE exit
*-
         IF    TVTFDBUG,BEGIN
         ACALL SETESPIE
         END
         SPACE 2
*-
*-       Create the EVENT table for ECB WAIT/POST
*-
**       QSNAP 'At EVENTS'
         EVENTS ENTRIES=TVTEVCNT   Allocate and create event table
         ST    R1,TVTEVNTS         Save address of event table
         PTRACE EVENTOK            Trace event table creation
         SPACE 2
*-
*-       Allocate dynamic allocation buffer and JES2 output file
*-
         DYNINIT TABLE=TVTDYNBF,LENGTH=L:=A(512)
         IF    (R15,NZ),BEGIN      Insufficient memory
         MVI   TVTRETCD+3,12       Set return code
         B     OSFXIT              Abort processing
         END   ,                   (insufficient memory)
         L     R2,TVTDYNBF         Set address of dynamic buffer
         XPUSH ,,16,PTR=R3         Reserve space
         ADDSYM ENTRY=(R3),NAME='DYNAMBF',LOC=(R2),LEN=512
         XPOP  PTR=R3              Release stack space
         IF    (TVTSEQ,NZ),'L R0,TVTSEQ'
         ELSE  'L R0,TVTNO'        Set TVT id number
         CVD   R0,@SPR             Convert to decimal
         UNPK  TVTLOGDD,@SPR(8)    Convert to zoned
         OI    TVTLOGDD+7,X'F0'    Set valid sign
         MVC   TVTLOGDD(3),=C'OSF' Set complete DDNAME
         DYNADD (DALDDNAM,1,8),TVTLOGDD
         IF    (TVTLOGSY,EQ,'*'),BEGIN   SYSOUT=*
         DYNADD (DALSYSOU,0,0)     SYSOUT, no class
         END   ,                     (SYSOUT=*)
         ELSE  BEGIN               SYSOUT=class
         DYNADD (DALSYSOU,1,1),TVTLOGSY   SYSOUT=class
         END   ,                      (SYSOUT=class)
         DYNADD (DALCLOSE,0,0)               free=close    ml960215
         DYNCALL ,                 Allocate file
         IF    (R15,NZ),BEGIN      Unable to allocate log file
         MVI   TVTRETCD+3,16       Set return code
         QSNAP TVTLOGDD
         QSNAP (R15,R0)
         QSNAP 'LOG SVC99 FAILED'
         DYNCHECK ,
         QSNAP ERRSCB,240
         B     OSFXIT              Abort processing
         END   ,                   (logfile alloc fail)

         MVC   TVTDDNAME,GVTBLANK
*-
*-       Create osfile report file, segment buffers, and open DCB
*-
         GETMAIN RC,LV=OSFSCBBL    Request segment buffer
         IF    (R15,NZ),BEGIN      Insufficient memory
         MVI   TVTRETCD+3,12       Set return code
         B     OSFXIT              Abort processing
         END   ,
         LR    R2,R1               Copy address of segcb
         XPUSH ,,16,PTR=R3         Reserve stack space
         ADDSYM ENTRY=(R3),NAME='OSFSCB',LOC=(R2),LEN=OSFSCBBL
         XPOP  PTR=R3              Release stack space
         LA    R2,@R2+4            Leave room for vbs header
         SEGINIT (R2),OSFSCBBL-4,OSFSCB,RTNTYPE=A,RTN=OSFPSEG
         L     R1,=A(DCBPS)        Address of model DCB
         MVC   OSFDCBPR(DCBPSLEN),@R1        Set model DCB
         LA    R2,OSFDCBPR         Address of print DCB
         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         MVC   DCBDDNAM,TVTLOGDD   Set default ddname
         MVC   DCBLRECL,=AL2(136)  Set default lrecl
         LA    R0,OSFPRXL          ->exit list
         ST3   R0,DCBEXLSA         save in DCB
         OPEN  ((R2),(OUTPUT)),MF=(E,TVTOPEN)
         IF    ~DCBOFLGS.DCBOFOPN,BEGIN
         MVI   TVTRETCD+3,12       Set error return code
         QSNAP 'LOG OPEN FAILED'
         B     OSFXIT              Abort processing
         END   ,
         SET   TVTREPT             Set report file open
         STCK  TVTLOGCK            show open time
         CLEAR TVTLOGCT            line count
         END   ,

*-
*-       Initialize error buildup seg buffer
*-
         LA    R0,ERRBUFL          Length of required error buffer
         VCALL GETLOW              Allocate memory for buffer
         ST    R1,ERRBUFR          Save address of error buffer
         SEGINIT (R1),ERRBUFL,ERRSCB,RTNTYPE=A,RTN=ERRRET
         SPACE 2
*-
*-       Allocate client/server seg buffer for path support
*-
         L     R0,=A(16384)        Acquire 16k buffer
         LR    R5,R0               Copy length
         VCALL GETCORE             Allocate memory
         ST    R1,TVTPATBF         Save buffer address
         LR    R0,R5               Set length of buffer
         VCALL GETCORE             Allocate memory
         ST    R1,TVTPATB2         Set secondary buffer

*-
*-       Report OSFILE initialization
*-
         IF    TVTREPT,BEGIN       Only if logging is still active
         SEGCLR OSFSCB             Clear report segcb
         ACALL LOGTIME             Log time of entry
         SEG   ' OSFILE ('
         SEG   TVTNAME             server name
         SEG   ','
         SEG   TVTLOGDD            DD name       ml960215
         SEG   ') - Startup processing.'
         SEGWR ,                   Write to report file
         END   ,
*-
*-       Allocate client/server data/command path
*-
         ACALL SETPATH             Reset new path and queue to event

*-
*-       Start periodic timer.
*-
         ACALL SETTIMER            Start up periodic timer

*-
*-       Initial queue of ECB's to event table
*-
         LA    R15,TVTSTOPE        Address of task quisce ecb
         EVENTS TABLE=TVTEVNTS,ECB=(R15) Queue to EVENTS table

         LA    R15,TVTTIMRE        Address of timer fire ECB
         EVENTS TABLE=TVTEVNTS,ECB=(R15) Queue to EVENTS table

         LA    R15,TVTPATHE        Address of path post ECB
         EVENTS TABLE=TVTEVNTS,ECB=(R15) Queue to EVENTS table
         TITLE 'Disk I/O support: Main processing loop'
*box
*
*    Main processing loop
*
         SPACE 2
MAINWAIT LOOP  BEGIN               Wait for next event to occur
         PTRACE MainWait           Trace wait
         IF    (TVTFQUISCE,AND,~TPATCMND),OSFXIT  Terminate subtask
         IF    ~TPATCMND,'SET TVTSTWAITING'       Set subtask waiting
         EVENTS TABLE=TVTEVNTS,WAIT=YES           Wait for an event
         PTRACE EVNTWait           Trace R1=completed list, R15=ret
         LR    R2,R1               Save address of completed list
         SET   TVTSTBUSY           Set subtask busy with work
         LA    R3,TVTEVSEC         Address of event copy list
         LOOP  BEGIN               Copy each completed ECB
         LR    R4,R2               Address of current event
         L     R1,@R4              Set address of completed ECB
         L     R0,@R1              Actual ECB
         PTRACE EVNTProc           R0=ECB, R1=ECB address
         MVC   @R3(4),@R4          Save address of completed ECB
         MVC   @R3+4(4),@R1        Save copy of posted ECB
         XC    @R1(4),@R1          Clear posted ECB
         LA    R2,@R2+4            Bump to next completed ECB
         LA    R3,@R3+8            Bump to next copy entry
         TM    0(R4),X'80'         Test for last completed ECB
         UNTIL ONES,END            Continue ECB copy operation

         EVENTS TABLE=TVTEVNTS,LAST=(R4),WAIT=NO

         LR    R14,R4
         PTRACE EVNTlast
         LA    R3,TVTEVSEC         Address of ECB copy list
         LOOP  BEGIN               Call all required routines
         L     R15,@R3             Address of completed ECB
         LA    R15,@R15            Clear extraneous bit/byte
         LA    R14,TVTEVNTS+4      Address of first ECB
         SLR   R15,R14             Create offset into routing table
         L     R15,TVTEROUT(R15)   Point to proper processing rout
         LCALL @R15                Enter processing routine
         L     R15,@R3             Address of processed ECB
         LA    R15,@R15            Clear high bit/byte
         L     R14,@R15            Load actual ECB
         PTRACE EVNTAdd            R14=ECB, R15=ECB address
         EVENTS TABLE=TVTEVNTS,ECB=(R15)     Re-queue ECB to table
         TM    @R3,X'80'           Test for last routine required
         LA    R3,@R3+8            Bump to potential next routine
         UNTIL ONES,END            Process the completed events
         END   ,                   Re-enter wait for next event
         EJECT ,
*box
*
*  Define initial literal pool
*
OSFPRXL  DC    X'85',AL3(OSFPOX)   prind DCB open exit
         SPACE 2
         LTORG ,
         TITLE 'Report DCB OPEN Exit'
*box
*
*        Check BLKSIZE for print DCB.  The exit
*        operates in 24-bit addressing mode.  When the
*        exit is taken the register contents are as follows:
*
*              R0  - No applicable data
*              R1  - Address of DCB
*          R2-R13  - Contents before OPEN macro issued
*
*             R14  - Return address, (must not be altered)
*             R15  - Address of exit routine entry point
*
*  created 1996/01/03 mcl
*
         SPACE 2
OSFPOX   LABEL ,                   Entry point to DCB OPEN exit
         LR    R10,R15             Move exit base register
         USING OSFPOX,R10          Addressability to exit
         LR    R6,R1               Save pointer to DCB
         USING IHADCB,R6           addressability to DCB
         L2    R1,DCBBLKSI         BLKSIZE so far
         IF    (R1,NP),BEGIN       if no blksize
         L     R1,=F'27998'        so use 3390 1/2 trk
         END   ,                      (no blksize)

*  We use RECFM=VB
*  RECFM=V[B], check LRECL/BLKSIZE relationship
         LH    R2,DCBLRECL         LRECL
         LA    R2,4(R2)            LRECL+L'BDW
         CR    R1,R2               BLKSIZE:min. blksi
         IF    L,'LR R1,R2'        if too low, use min.

         STH   R1,DCBBLKSI         Save adjusted BLKSIZE
         BR    R14                 Return to caller
         DROP  R6
         DROP  R10                 Release exit routine addr
         TITLE 'Disk I/O support: Termination control'
*box
*
*   Wings: OSFILE termination process control
*
*        Release acquired resources and terminate task
*
         SPACE 2
OSFCOMMN LABEL ,
OSFXIT   LABEL ,                   Exit processing
         ACALL OSFTERM             Cleanup OSFILE environment

*-
*-       Release ESTAE save stack
*-
         LT    R1,TVTESTAK         Get save stack origin
         IF    NZ,BEGIN
         L     R0,=A(ESTAESZ)      Load save stack size
         FREEMAIN R,A=(1),LV=(0)   Release save stack
         END   ,

*  Release general-purpose workarea

         LT    R1,TVTOSFWK         ->area
         IF    NZ,BEGIN            free it if we have it
         FREEMAIN R,A=(1),LV=L#OSFWK
         CLEAR TVTOSFWK            sho no area
         END   ,                      (have it)

*-
*-       Release save stack
*-
         L     R1,TVTSTPTR         Get save stack origin
         L     R0,=A(STACKSZ)      Load save stack size
         FREEMAIN R,A=(1),LV=(0)   Release save stack
         CLEAR R13                 Insure it's not used again
         CLEAR WAR                 Ditto for stack save pointer

         IF    TVTWEIRD,'LA R6,1'  Set R6 for abend
         ELSE  'CLEAR R6'          Indicate normal terminate

         L     R7,TVTSAVE          Reload passed vs save area addr
         L     R4,TVTRETCD         Load global return code
         LR    R15,R4              Set final return code
*-
*-       Pull the plug for debugging reasons
*-
         IF    (R6,NZ),BEGIN       abend
         ABEND 999,DUMP,STEP       Just pull the plug
         END   ,

OSFXIT2  LABEL ,                   Exit point prior to initialization
*-
*-       Assumes R7 contains the VS save area address and that the
*-       return code has been placed into R15.
*-
         LR    R13,R7              Reset VS save area address
         L     R14,@R13+12         Load return address
         LM    R0,R12,@R13+20        Reload remaining registers
         BR    R14                     Return to caller

         DROP  BR                  Release base addressability
         EJECT ,
*box
*
*   General control block cleanup
*

OSFTWRK  RECORD BEGIN
OSFTENQ  ENQ   (*-*,*-*,S,8,STEP),MF=L
OSFTDEQ  DEQ   (*-*,*-*,8,STEP),MF=L
         END   ,
OSFTERM  PROC  OSFTWRK             ENTER AND OBTAIN WORK AREA
*-
*-       Trace entry to termination of tracing is active
*-
         IF    TVTFTRC,'PTRACE OSFXIT' Trace termination if active
*-
*-       Report termination status if logging is active
*-
         IF    TVTREPT,BEGIN       ONLY IF LOGGING IS STILL ACTIVE
         SEGCLR OSFSCB             CLEAR REPORT SEGCB
         ACALL LOGTIME             LOG TIME OF ENTRY
         SEG   'OSFILE ('
         SEG   TVTNAME             server name
         SEG   ') - Termination in progress.  Flags=X'''
         SEGHX L4:TVTFLAG,8        REPORT STATUS FLAGS
         SEG   ''''                TERMINATE STATUS LINE
         SEGWR ,                   WRITE TO REPORT FILE
         END   ,
*
*        Release internal dataset enqueue if any
*
         CLEAR TVTNQFLG
         CLEAR TVTNQDSN

*-
*-       Cancel ESTAE environment if not entered from RTM
*-
         IF    ~TVTFABND,BEGIN     Only if we are not in ABEND.
         IF    ~TVTNOEST,BEGIN     Release existing ESTAE exits
         IF    TVTREPT,BEGIN       ONLY IF LOGGING IS STILL ACTIVE
         SEGCLR OSFSCB             CLEAR REPORT SEGCB
         ACALL LOGTIME             LOG TIME OF ENTRY
         SEG   'ESTAE exits deactivated.'
         SEGWR ,                   WRITE TO REPORT FILE
         END   ,
         ACALL TRMESTAE            Terminate our ESTAE exit
         ACALL TRMESTAE            Terminate the dumper ESTAE
         END   ,
         END   ,
*-
*-       Release any current paths
*-
         LT    R3,TVTUPATH         Get upath pointer
         IF    NZ,BEGIN            Release path
         IF    TVTREPT,BEGIN       ONLY IF LOGGING IS STILL ACTIVE
         SEGCLR OSFSCB             CLEAR REPORT SEGCB
         ACALL LOGTIME             LOG TIME OF ENTRY
         SEGB  'UPATH buffer released at'
         SEGHX (R3),8              REPORT ADDRESS
         SEGWR ,                   WRITE TO REPORT FILE
         END   ,
         LR    R1,R3               GET UPATH POINTER
         XCALL PATHCLS             Close the path
         END   ,
*-
*-       Release client path buffers
*-
         LT    R2,TVTPATBF         Address of client buffer
         IF    NZ,BEGIN            Release if it exists
         LR    R1,R2               Move buffer pointer
         XCALL FREECORE            Release client buffer
         IF    TVTREPT,BEGIN       Report relase if logging active
         SEGCLR OSFSCB             Clear OSF SEGCB
         ACALL LOGTIME             Log time of release
         SEGB  'Client buffer released at '
         SEGHX (R2),8              Report memory address
         SEGWR ,                   Write line to file
         END   ,
         END   ,
         LT    R2,TVTPATB2         Address of 2nd client buffer
         IF    NZ,BEGIN            Release if it exists
         LR    R1,R2               Move buffer pointer
         XCALL FREECORE            Release client buffer
         IF    TVTREPT,BEGIN       Report relase if logging active
         SEGCLR OSFSCB             Clear OSF SEGCB
         ACALL LOGTIME             Log time of release
         SEGB  'Client buffer released at '
         SEGHX (R2),8              Report memory address
         SEGWR ,                   Write line to file
         END   ,
         END   ,
*-
*-       Release dynamic allocation buffer
*-
         IF    (TVTDYNBF,NZ),BEGIN Release dynamic allocation buffer
         DYNFREE TVTDYNBF          Release the buffer
         END   ,
*-
*-       Release the EVENTS table
*-
         IF    (TVTEVNTS,NZ),BEGIN Release events table is required
         EVENTS ENTRIES=DEL,TABLE=TVTEVNTS
         END   ,
*-
*-       Release WING ACEE pointers if we are last OSFILE module
*-       running.
*-
*-       (or if in batch mode (ie. no monitor just single osfile)
*-
         ACALL CHKLAST             See if we are last OSFILE
         IF    (R15,Z),BEGIN       Release ACEE chain
         XCALL XRACRACE              go do it
         END   ,                    (release acee chain)
*-
*-       Release trace table
*-
         IF    TVTFTRC,BEGIN       Release trace table if active
         L     R1,TVTTRBEG         Starting address of trace table
         L     R0,TVTTREND         Last address in trace table
         SLR   R0,R1               Compute length of trace table
         FREEMAIN R,LV=(0),A=(1)   Release trace table storage
         CLEAR TVTFTRC             Clear tracing active flag
         END   ,
*-
*-       Release symbol table storage
*-
         L     R1,TVTSYMTB         Anchor address of symbol table
         USING SYMENTRY,R1         Addressabilty to table
         WHILE (R1,NZ),BEGIN       Free all entries
         L     R5,SYMNEXT          Point to next entry
         LA    R0,L'SYMENTRY       Length of symbol table entry
         FREEMAIN R,LV=(0),A=(1)   Release symbol table entry
         LR    R1,R5               Move address of next entry
         END   ,
         CLEAR TVTSYMTB            Clear symbol table anchor
         DROP  R1                  Release symbol table
*-
*-       Release error message buffer
*-
         IF    (ERRBUFR,NZ),BEGIN  Release error buffer if exists
         L     R1,ERRBUFR          Address of error buffer
         XCALL FREECORE            Release error buffer
         END   ,
*-
*-       Release report file control blocks
*-
         IF    TVTREPT,BEGIN       Close out report file
         CLEAR TVTREPT             Indicate report file down
         LA    R3,OSFSCB           Address of log segcb
         WITH  (SEGCB,R3),BEGIN    Addressabilty to segcb
         L     R1,SEGCBLOC         Address of seg buffer
         SL    R1,=A(4)            Adjust for vbs header
         LA    R0,OSFSCBBL         Set length of buffer
         FREEMAIN R,LV=(0),A=(1)   Release log buffer
         END   ,
         LA    R2,OSFDCBPR         Address of logging file DCB
         ICM   R15,7,@R2+21        BUFCB
         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN Only close if open
         CLOSE ((R2)),MF=(E,TVTCLOSE)
         FREEPOOL ((R2))           Release buffer pool
         END   ,                      (IF OPEN)
         END   ,                      (WITH IHADCB)
         END   ,                      (REPT)
         PEND  ,
         TITLE 'Command cleanup routine'
*box
*
*  Command cleanup routine (invoked by CMDABORT macro)
*
*  On entry:  R14 has "return" address.  We do not return there but
*  can use it as trace info.  We return to the caller of the last
*  CPROC that was called -- think of CMDABORT as "exit current
*  command proc".  Generally this takes us back to the logic that is
*  scanning the command vector table.
*
*    1.  Return error message across path to client.
*    2.  Re-queue path.
*    3.  Call error recovery routines in reverse order
*
*  CMDABORT should only be invoked within the scope of a CPROC;
*  CPROC entry saves stack frame pointer in TVTCMDAS.
*  mcl 1998/03/19

CMDCLEAN PROC  ,                   Entry for general command cleanup
*-
*-       Log entry to command cleanup routine
*-
**       QSNAP 'CMDCLEAN before SETPATH'
**       QSNAP (R14)
**       QSNAP TVTNQFLG,1

         LR    R2,R14              Save trace register
         LR    R3,R15              Save R15 FWIW (RC maybe)

         IF    (TVTNQFLG,NZ),BEGIN
**       QSNAP TVTNQDSN
         END   ,
         IF    TVTREPT,BEGIN       Write to log if report is active
         LA    R15,OSFSCB          Address of report SEGCB
         ACALL LOGTIME             Log current time of day
         SEG   'Command cleanup TVTPATFL=',,OSFSCB
         HEXSEG TVTPATFL           Report path termination status
**was:   SEGHX LC:TVTPATFL,2       mcl 2002/03/25
         SEGB  '  (from '
         SEGHX (R2),8              dump trace reg
         SEG   ')'
         SEGWR ,                   Write to report log
         END   ,                     (report active)

*-
*-       Send error information to client
*-
         IF    (TERRMSG,AND,~TPATPERR),BEGIN
*                                          msg exists, can be sent

         SEGCLR TVTSCB             Clear any previous data in path
         WINGSHDR SET,HEADER='FILE_ERROR:'
         L     R0,ERRSCBLENF       Set error length

         IF    (R0,GT,8),BEGIN     have a message
         L     R1,ERRSCBLOC        And error message location
         SEG   (R1),(R0)           Add error message
         END   ,                      (have a message)
         ELSE  BEGIN               Error in error handling, no msg
         SEG   'ERRID=ERROR ERRMSG='''  build one now
         SEG   'WINGS error at OSFILE+'
         LA    R2,0(R2)            Clear hi bit
         S     R2,=A(OSFILE)       Get offset
         SEGHX (R2),6              dump trace address
         SEG   ', R15='
         SEGHX (R3),8              Dump RC or whatever
         SEG   ''''                close msg
         END   ,                      (no error msg)

*  Send additional error msgs if any

         IF    (TVTSENDXMSGS,AND,TVTEXMSG),BEGIN  want,got extra msgs
         ACALL SENDEXM             issue them
         END   ,                      (ext msgs present)

         SEGWR ,                   Pass onto path
         END   ,                      (msg can be sent)

*-
*-       Close and re-queue client path
*-
         IF    TPATERR,BEGIN       Close and re-queued client path
         CLEAR TVTPATFL            Clear path flags
         ACALL SETPATH             Close the path and re-open
         END   ,                     (close and re-queue)

*-
*-       Call all recovery routines in recovery stack
*-
**       QSNAP 'CMDCLEAN before RECOVERY'
         ACALL RECOVERY            Process the error recovery stack
*-       just in case we haven't done it, try to deallocate file
         CLI   TVTDDNAME,C' '      Any ddname defined?
         IF    NE,BEGIN            have a ddname, unallocate it
         DYNCLEAR ,                Clear dynamic allocation buffer
         DYNSET S99VRBUN           Set for dynamic unallocation
         DYNADD (DUNDDNAM,1,8),TVTDDNAME
         DYNCALL ,                 De-allocate file
         MVI   TVTDDNAME,C' '      show no allocation
         END   ,                   (unallocate)
*
*        Release internal dataset enqueue if any
*
**       QSNAP 'CMDCLEAN after RECOVERY'
**       QSNAP TVTNQFLG,1
         IF    (TVTNQFLG,NZ),BEGIN
**       QSNAP TVTNQDSN
         END   ,
         CLEAR TVTNQFLG
         CLEAR TVTNQDSN


*  Free error msg buffer area if any

         L     R1,TVTEMBFP         ->buffer area
         IF    (R1,NZ),BEGIN       got a pointer
         L2    R0,TVTEMBFL         L'area
         FREEMAIN R,LV=(0),A=(1)   let it go
         CLEAR TVTEMBFP            show no area
         CLEAR TVTEMBFL
         END   ,                      (got a buffer)
         CLEAR TVTEXMSG            messages flag
*-
*-       Reset command in progress
*-
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear current command name
         CLEAR TVTPATNX            And next command expected
         CLEAR TREADEOF

*-
*-   See if it's time to start a new logfile
*-
         ACALL LOGCHECK

*    PATH LOGIC CHECK:

**?
**?  neat bug here...if we call CMDCLEAN without setting TPATERR,
**?  we have left path open (and possibly left WYLBUR waiting for a
**?  response) but set the status of this server to "waiting".
**?  mcl 1994/11/29
**?
         IF    (TVTPATFL,NZ),BEGIN    path still open      ml950314
         QSNAP 'WINGS logic error, path open at cleanup'
         QSNAP TVT,512             dump part of tvt
         CLEAR TVTPATFL            Clear path flags
         ACALL SETPATH             Close the path and re-open
         END   ,                     (path still open)
*-
*-       Restore stack frame ptr. to value it had on entry to CPROC
*-       Thus, return to caller of the last CPROC called (thus exit
*-       from current CPROC)                               ml980319

         LT    WAR,TVTCMDAS        Reset stack pointer
         FAIL  Z,'Bad CMDCLEAN call.'
*debug   QSNAP @WAR,8
         PEND  ,
         LTORG ,
         TITLE 'Send Extended Error/Info Messages'
SENDEXM  PROC  ,

*-       Send extended error messages to client.
*-       On entry:  Appropriate SEGCB set
*-                  messages pointed to by TVTEMBFP
*-
*-       On exit:  messages seg'd, buffer cleared
*-       SEGWR has NOT been issued.

         SEGDEF TVTSCB
         L     R2,TVTEMBFP         ->buffer area
         IF    (R2,NZ),BEGIN       got a pointer
         WITH  (EMBUFS,R2),BEGIN   address EMBUFS
         LH    R3,TVTEMBFC         msg count
         SEG   ' EXTDATA='''
EML      LABEL ,
         LA    R1,EMBUFT1          ->text
         LH    R0,EMBUFL1          L'text
         S     R0,=F'4'            less length/offset fields
         VCALL RTRIM               keep it short, guys...
         IF    (R0,P),BEGIN        if any msg left
         SEG   (R1),(R0)           put it out...
         SEG   =X'0D'              ending CR
         END   ,                      (any msg left)
         LA    R2,EMBUF2           next
         BCT   R3,EML              do next if any
         SEG   ''''                ending quote
         END   ,                      (with EMBUFS)
         END   ,                      (got a buffer)
         PEND  ,
         TITLE 'Check if last OSFILE subtask'
*box
*
*  CHKLAST - CHECK IF LAST OSFILE SUBTASK
*
*  Routine to check to see if this is last OSFILE task.
*
*  On entry:
*    TVTFSTOPPING and/or TVTFABND flag should be set.
*
*  On exit:
*    R15=ZERO, we are one of last OSFILE modules; clean up
*      global areas.
*    R15=NZ, other OSFILE modules still active
*
*   Note:
*   This routine works on best effort basis.  We try
*   to error on the clean up side.  The algorithm is to
*   go through monitor subtask linked list checking for
*   an active OSFILE subtask that is not stopping or
*   abending.  If two tasks are abendind/stopping at the
*   same time they both may get a R15=0 clean up return.
*
*   Note:
*   Unless caller has set TVTFSTOPPING
*   or TVTFABND, we will always find ourselfs active.
*   and thus we will always get a R15=NZ return.
*
*
CHKLAST  PROC  ,
         CLEAR R15                 CLEAR RETURN
*
*                                  LOOP THRU ALL SUBTASKS
         DROP  TVTR                ML19970730
         L     R3,GVTTVTQH
         WITH  (TVT,R3),BEGIN
         IF    (R3,NZ),'L R3,TVTLINK'  SKIP MONITOR TASK
         WHILE (R3,NZ),BEGIN
         IF    (TVTTCBP,NZ),BEGIN
         IF    TVTFOSFILE,BEGIN
         IF    (~TVTFSTOPPING,AND,~TVTFABND),BEGIN
         LA    R15,4
         END
         END
         END
         L     R3,TVTLINK          GET NEXT SUBTASK
         END   , LOOP THRU TVTS
         END   , WITH R3
*
         PEND
         USING TVT

*box
*
*  Define common routine literal pool


         LTORG ,
         TITLE 'Check for Log Spinoff'
LCWORK   RECORD BEGIN              workarea for log check
LCWCLK   DC    2F'0'               for clock value
         END   ,                      (work area)

LOGCHECK PROC  LCWORK
*  Check the log

         IF    TVTREPT,BEGIN       Logging is in effect
         L     R0,TVTLOGCT         lines written to log
         C     R0,TVTLOGLL         written:limit
         IF    H,LCHEKB            over line limit
         C     R0,=F'1000'         low threshhold: 1k lines
         IF    L,LCHEKD            don't bump even if over time
         STCK  LCWCLK              time
         LM    R0,R1,LCWCLK        in R0/1
         SDL   R0,TVTLOGCK         since log started
         SRDL  R0,12               in microseconds
         D     R0,=A(1000000)      in seconds
         SLR   R0,R0               Clear for 2nd divide
         D     R0,=A(3600)         in hours
*  3600*1000000 is too much for a fullword!
         CH    R1,TVTLOGTL         ET:limit
         IF    L,LCHEKD            under time limit

LCHEKB   LABEL ,
         ACALL BUMPLOG             go restart it

LCHEKD   LABEL ,
         END   ,                      (logging in effect)
         PEND  ,                   LOGCHECK

         TITLE 'Global Keyword Exit Routine'
*box
*
*  Bad option processing
*
         SPACE 2
BADOPT   LABEL ,
         PTRACE BADOPT             Trace bad option
         XPUSH R0,R1               Save pointer to length, address
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=UNREC'       Set error to unrecognized
         SEG   'ERRMSG='''         Build error message
         XPOP  R0,R1               Retrieve parameter pointers
         IF    (R0,P),BEGIN
         SEG   (R1),(R0)           Add bad parameter
         SEG   ': unrecognized option.' add to error message
         END   ,
         SEG   ''''                Add trailing quote
         CMDABORT ,                Cleanup path and re-wait
*box
*
*  Unsupported option processing
*
         SPACE 2
NOTYET   LABEL ,
         PTRACE NOTYET             Trace unsupported option
         XPUSH R0,R1               Save pointer to length, address
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=UNREC'       Set error to unrecognized
         SEG   'ERRMSG='''         Build error message
         XPOP  R0,R1               Retrieve parameter pointers
         IF    (R0,P),BEGIN
         SEG   (R1),(R0)           Add bad parameter
         SEG   ': unsupported option.' add to error message
         END   ,
         SEG   ''''                Add trailing quote
         CMDABORT ,                Cleanup path and re-wait
         EJECT ,
*box
*
*  Missing option processing
*
*  On entry:   R15  Contains address of current SCANCB
*
*  On exit:         Abort branch to the CMDCLEAN routine
*
         SPACE 2
MISSING  LABEL ,
         LR    R2,R15              Save address of scanner CB
         PTRACE MISSING            Trace bad option
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=MISSING'     Set error to unrecognized
         SEG   'ERRMSG='''         Build error message
         WITH  (SCNCB,R2),BEGIN    Addressability to SCANCB
         SEGT  SCNKW               Address of error keyword
         SEGB  ':'                 Add separator
         SEG   'missing option.'   Add to error message
         SEG   ''''                Add trailing quote
         CMDABORT ,                Cleanup path and re-wait
         END   ,
         SPACE 2
*box
*
*  Error recovery stack overflow
*

STCKOVFL LABEL ,
         FAIL  'Error Recovery stack overflow.'

         LTORG
         TITLE 'SCANPARM - Scan initialization parameters'
*box
*
* SCANPARM-- Routine to process parameters.
*
*   On entry:  R1 Contains pointer to EXEC parameters
*
*   On exit:      TVT fields have been initialized
*
*   On error parameters an exit is made to OSFXIT with a return
*   code of 24.
*

SCANPARM PROC  ,
         L     R2,@R1              Point to exec parameter pointer
         LH    R0,@R2                load length of parameters
         LA    R1,@R2+2                point to start of parameters
         SCINIT (R1),(R0),TVTSCNCB       initialize scanner
         SCAN  PARMPRT,TVTSCNCB            scan exec parameters
         IF    NZ,BEGIN            Abort on invalid exec parameter
         MVI   TVTRETCD+3,24       Set error return code
         B     OSFXIT              And abort sub-task initialization
         END   ,
         PEND  ,

*-
*- Parm file scan table.
*-
* options P=PARM, A=ABBREVIATE, I=INTEGER, PI=POS. INTEGER

PARMPRT  SCKW  PATH,SCEPATH,(A,P)
         SCKW  SCRVOL,SCESVOL,(A,P)
         SCKW  SCRMCLAS,SCESMCL,(A,P)
         SCKW  SCRSCLAS,SCESSCL,(A,P)
         SCKW  LCLASS,SCELGCL,(A,P)
         SCKW  LLINELIM,SCELGLL,(A,P,PI)
         SCKW  LTIMELIM,SCELGTL,(A,P,PI)
         SCKW  TIMER,SCETMR,(A,P,PI)
         SCKW  NOESTAE,SCENEST,A
         SCKW  DEBUG,SCDEBUG,A
         SCKW  PDEBUG,SCPDBUG,A
         SCKW  PTIMEOUT,SCEPTIMO,(A,P,PI)
         SCKW  PPAUSE,SCEPWTTM,(A,P,PI)
         SCKW  ORVYL,SCEORVYL,(A,P)
         SCKW  WEIRD,SCEWEIRD,A
         SCKW  ,SCANERR
         SPACE 2
*-
*- Invalid keyword encountered in scan
*-
SCANERR  PROC  ,
         MVI   TVTRETCD+3,24       Set error return code
         QSNAP 'SCAN ERROR'
         QSNAP @R1,(R0)
         PEND  ,

*-
*- Set weird processing mode
*-
SCEWEIRD PROC  ,
         SET   TVTWEIRD            Enable weird processing mode
         PEND  ,
*-
*- Set alternate path name of sub-task
*-
SCEPATH  PROC  ,                   Set new path name
         IF    ((R0,P),AND,(R0,LE,8)),BEGIN
         LR    R2,R0               Copy length of path name
         DEX   R2,'MVC TVTPATHN(0),@R1'      Move in path name
         OC    TVTPATHN,GVTBLANK   Force blanks and upper case
         END   ELSE,'ACALL SCANERR'
         PEND  ,

*-
*- Set name of scratch volume
*-
SCESVOL  PROC  ,                   Set scratch volume name
         LR    R5,R15              Save SCANCB ptr
         IF    (R0,LT,6),BEGIN
         ACALL SCANERR             invalid, name too short
         END   ,                      (too short)

         ELSEIF (R0,EQ,6),BEGIN    One volume
         LA    R0,TVTTMVOL0        ->vol list first entry
         ACALL ADDTVOL             put this vol in list
         MVC   TVTTMVOL#,=H'1'     no. entries
         END   ,                      (one vol)

         ELSE  BEGIN               more than one
         IF    (R0,GT,36),SVAERR   more than five
         CLI   @R1,C'('            then must be (vol,vol)
         IF    NE,SVAERR           Nope, not a good list
         LA    R3,1(,R1)           ->first vol
         LR    R2,R0               token length
         SR    R4,R4               volcount
SVALOOP  LABEL ,                   loop to do each vol:
         LR    R1,R3               ->volser
         LR    R15,R4              volcount
         MH    R15,=H'12'          l'volentry
         LA    R0,TVTTMVOL0(R15)   ->vol list entry this vol.
         ACALL ADDTVOL             add it to list
         LA    R4,1(,R4)           Count vol
         LA    R3,7(R3)            ->next in given list
         S     R2,=F'7'            length remaining in given list
         IF    NP,SVAERR           not a good list, ended wrong
         IF    (R2,GE,7),SVALOOP   more vols, do it
         IF    (R2,GT,1),SVAERR    should be exactly 1 left: )
*  fell thru, done with list
         STH   R4,TVTTMVOL#        save vol count
         END   ,                      (more than one)
         LR    R15,R5              restore
         EXIT  ,
SVAERR   ACALL SCANERR             bad list
         LR    R15,R5              restore
         PEND  ,

         TITLE 'Check for Scratch Volume'

*  R1->a volser
*
*  Scan list of "scratch" volumes
*
*  On exit:  R15=0 if scratch vol, 4 otherwise

CHKTVOL  PROC  ,
         LH    R6,TVTTMVOL#        number of entries
         IF    (R6,Z),BEGIN        if no entries
         CLEAR R15                 RC so far
         CLC   =C'SCR',@R1         SCRxxx
         IF    NE,'LA R15,4'       if not
         END   ,                      (no entries)

         ELSE  BEGIN               Some entries, check them
         LA    R3,TVTTMVOL0        ->first entry
         WITH  (VOLENTRY,R3)
CHKTLOOP CLC   VOLVOLSR,@R1        entry:given
         IF    EQ,BEGIN            found it
         CLEAR R15
         EXIT  CHKTVOL             done
         END   ,                      (found it)
         LA    R3,12(R3)           ->next
         BCT   R6,CHKTLOOP         try again
         LA    R15,4               fell thru, no match
         END   ,                      (with R3)
         PEND  ,

ADDTVOL  PROC  ,                   Add vol to temp vol lisi

*  R0  -> target vol list entry
*  R1  -> volser
         LR    R3,R0               ->vol list entry
         WITH  (VOLENTRY,R3)
         MVC   VOLVOLSR,@R1
         OC    VOLVOLSR,GVTBLANK   force upper case
         XCALL FINDUCB             get UCB for this vol
         WITH  (UCBOB,R1)
         MVC   VOLUCBTP,UCBTYP     UCBTYPE field in vollist
*? maybe we should check RC from FINDUCB?
         PEND  ,

*-
*- Set management class for temp datasets
*-
SCESMCL  PROC  ,                   Set MGMTCLAS
         IF    ((R0,P),AND,(R0,LE,8)),BEGIN
         LR    R2,R0               Copy length of class name
         DEX   R2,'MVC TVTTMMGC(0),@R1'      Move in class name
         OC    TVTTMMGC,GVTBLANK   Force blanks and upper case
         END   ELSE,'ACALL SCANERR'
         PEND  ,

*-
*- Set storage class for temp datasets
*-
SCESSCL  PROC  ,                   Set STORCLAS
         IF    ((R0,P),AND,(R0,LE,8)),BEGIN
         LR    R2,R0               Copy length of class name
         DEX   R2,'MVC TVTTMSTC(0),@R1'      Move in class name
         OC    TVTTMSTC,GVTBLANK   Force blanks and upper case
         END   ELSE,'ACALL SCANERR'
         PEND  ,

*-
*- Enable ORVYL testing
*-
SCEORVYL PROC  ,                   ORVYL=acct
         CLEAR TVTORVYL            Tentative "none"
         CLEAR TVTORVAC
         IF    ((R0,EQ,6),AND,(@R1+2,EQ,'.')),BEGIN  got gg.uuu
         LR    R2,R0
         DEX   R2,'MVC TVTORVAC(0),@R1'  move in acct
         SET   TVTORVYL            show kluge is in use
         END   ,                   (got gg.uuu)
* anything but gg.uuu just turns feature off
         PEND  ,

*-
*- Set SYSOUT class for log datasets
*-
SCELGCL  PROC  ,                   Set SYSOUT
         IF    (R0,EQ,1),BEGIN     Must be 1 char.
         MVC   TVTLOGSY,@R1        move in class name
         OI    TVTLOGSY,C' '       Force upper case
         END   ELSE,'ACALL SCANERR'
         PEND  ,

*-
*-  Set log line limit value (in thousands) for spinoff
*-
SCELGLL  PROC  ,                   LLINELIM=nnn (thousands)
         L     R0,@R15             value from command
         MH    R0,=H'1000'            is in thousands
         ST    R0,TVTLOGLL              but we use ones
         PEND  ,                   Return to scanner

*-
*-  Set log time limit value (in hours) for spinoff
*-
SCELGTL  PROC  ,                   LTIMELIM=nn (hours)
         L     R0,@R15             value from command
         STH   R0,TVTLOGTL         in hours
         PEND  ,                   Return to scanner

*-
*- Disable general ESTAE processing
*-
SCENEST  PROC  ,
         SET   TVTNOEST            Disable ESTAE processing
         PEND  ,

*-
*- DEBUG - ALLOW INTERACTIVE DEBUGGING
*-
SCDEBUG  PROC  ,
         SET   TVTFDBUG            Enable Debugging, set ESPIE exit
         PEND  ,

*-
*- PDEBUG - ENABLE PATH TRAFFIC DEBUGGING
*-
SCPDBUG  PROC  ,
         SET   TVTXDBUG            Debugging, trace path traffic
         PEND  ,

*-
*-  Set periodic timer fire value (In seconds)
*-
SCETMR   PROC  ,                   Set default timer fire value
         PEND  ,

*-
*-  Set Path buffer-full timeout value (In Milli-seconds)
*-
SCEPTIMO PROC  ,                   Path buffer-full timeout
         MVC   TVTBFTIM,@R15       SET PATH BUFFER-BUFF TIMEOUT
         PEND  ,                   Return to scanner

*-
*- Set Path buffer emptied pause time (In Milli-seconds)
*-
SCEPWTTM PROC  ,                   Path buffer-empty wait time
         MVC   TVTBETIM,@R15       SET PATH BUFFER-EMPTY PAUSE TIME
         PEND  ,                   Return to scanner
         EJECT ,
         LTORG ,
         TITLE 'Enable ESTAE exit'
*box
*
*  SETESTAE - Enable OSFILE ESTAE exit
*

SETESTL  RECORD BEGIN
TVTESTPL ESTAE *-*,PURGE=NONE,ASYNCH=YES,TERM=YES,MF=L
         END   ,

SETESTAE PROC  SETESTL
         CLEAR SETESTL
         L     R0,=A(OSFESTAE)
         ESTAE (0),PURGE=NONE,ASYNCH=YES,TERM=YES,                     X
               PARAM=(TVTR),MF=(E,TVTESTPL)
         IF    (R15,NZ),BEGIN      Can't set STAE exit...
         WTO   'Note: ESTAE exit can not be set.'
         END
         SET   TVTESTAE            Set ESTAE environment active
         PTRACE ESTAEOK            Trace ESTAE successful
         PEND  ,
         TITLE 'Terminate last queued ESTAE routine'
*box
*
*  TRMESTAE - Terminate last queued ESTAE routine
*
*  On entry:   No applicable parameters
*
*  On exit:    Last ESTAE queued is deleted
*

TRMESWRK RECORD BEGIN
         ESTAE *-*,MF=L            Generate estae parameter list
         END   ,

TRMESTAE PROC  TRMESWRK            Enter and allocate stack space
         CLEAR TRMESWRK            Clear ESTAE parameter list
         ESTAE 0,MF=(E,TRMESWRK)   Terminate last estae routine
         PEND  ,                   Return to caller
*
         QLTORG
         TITLE 'ESPIE code, DEBUG interface.'
*box
*
*
*  SET ESPIE -
*
*  ALL WORK DONE IN DBESPIE MODULE.
*  WE JUST CALL XDBESPIE.
*  THE DBESPIE MODULE CONTAINS ROUTINE TO SET
*  ESPIE EXIT.  IT ALSO CONTAINS THE ESPIE EXIT
*  ROUTINE.  THAT IS ALL IT CONTAINS.
*
*  CAUTION:
*  DO not set exit for program exception 15.
*  This can cause an infinit loop if a program
*  exception 15 happens.
*
*  CAUTION:
*  The SYMBOL table should exist prior to this call.
*  (as we set the symbol table pointer up at this time)
*
*
SETESPIE PROC
         VCALL  XDBESPIE
         PEND
*
         TITLE 'PROCPATH - Process path activity'
*box
*
*  PROCPATH - PROCESS PATH ACTIVITY
*
*        1.  Handle path open requests.
*        2.  Handle path close request.
*        3.  Handle new information post codes.
*
         SPACE 2
PROCPATH PROC  ,
         L     R2,TVTUPATH         Address of upath control
         WITH  (UPATH,R2)          Addressability to UPATH
         L2    R0,UPATSPST         Load Suzan post flags
         PTRACE Upatspst           Trace post flags
         IF    UPATSPST.UPATFCLS,BEGIN opened path has closed
         PTRACE PCLOSED            Trace path closed
         IF    TPATCMND,BEGIN      Check for command cleanup req
         ACALL RECOVERY            Process the recovery stack
*  added 1995/03/17 mcl:  prevent path seq err after aborting
*  read of small file (small=hit eof before running out of suzan
*  buffers)
***debug: temporarily disable this  2002/03/22
*** 2002/06/11:  put it back.  disabling did indeed cause path seq
*** errors.  no longer remember why this case causes them but it does.
***-     B     NOTREOF             RESTORED 2002/06/11
         IF    TREADEOF,BEGIN      we were almost done with READ
         CLEAR TVTPATCM            so forget we were doing it, we
*                                  already closed and deallocated
         CLEAR TREADEOF
         END   ,                   (were almost done)
***debug
NOTREOF  EQU   *
         CLEAR TPATCMND            no longer doing a cmnd  ml960606
         END   ,                   (command cleanup req'd)
**debug  QSNAP 'PROCPATH calling SETPATH'
         ACALL SETPATH             Restart a fresh path
         EXIT  PROCPATH            Return to main wait loop
         END   ,                   (opened path has closed)

         IF    UPATSPST.UPATFOPN,BEGIN fresh path open
         PTRACE POPENED            Trace path opened
         SET   (TPATOPEN,EQ)       Reset path flags
         CLEAR TVTORVSS            Not ORVYL yet
         INCR  R1,TVTCNTPOPENS     Tally a path open
         CLEAR UPATSPST.UPATFOPN,MODE=LOCKED,REF=UPATH
         L     R0,=A(16384)        Our buffer size for SUZAN path
         ST    R0,TVTSBUFL         set default, open parm may change
         LR    R1,R2               Set address of upath control
         VCALL PATHINFO            Request path information
         IF    TVTXDBUG,BEGIN      path debug requested
         QSNAP 'Path Opened, UPATBUFL='
         QSNAP UPATBUFL
         END   ,                      (path debug)
         L     R0,UPATBUFL         user's buffer length    ml950602
         IF    (R0,P),'ST R0,TVTSBUFL'  use it if we got it
* copied from pathopen code mcl 2002/01/30
         LA    R3,TVTSCB           Address of segment control bufr
         L     R4,TVTPATBF         Get address of segment buffer
         LA    R4,@R4+16           Skip past WINGS header
         L     R5,TVTSBUFL         SUZAN buffer length for sends
         S     R5,=F'16'           minus our header length
         WITH  (SEGCB,R3),BEGIN    Seg buffer addressability
         SEGINIT (R4),(R5),(R3),RTNTYPE=V,RTN=PATHSEG,ERR=PATHERR
         L     R2,TVTUPATH         Address of upath control block
         ST    R2,TVTSCBUSR        Save upath pointer to upath
         END   ,                      (with SEGCB)
* end copied code 2002/01/30
* appears we were using TVTSBUFL from *previous* path open???

* check for call from ORVYL, kluge it up if so
         IF    TVTORVYL,BEGIN      Allow ORVYL kluge?
         CLC   =C'GS.ORV',UPATPACT acct GS.ORV
         IF    EQ,BEGIN             caller under GS.ORV
         CLC   UPATPJOB,=C'ORVYL   '
         IF    EQ,BEGIN            it's really an ORVYL call
         SET   TVTORVSS            show actually ORVYL call
**-      SET   UPATFAUTH           and he's OK...
         MVC   UPATPACT,TVTORVAC   fake another acct
         MVC   UPATPNAM,=C'ORVYL/WINGS testing  '
         END   ,                   (job ORVYL)
         END   ,                   (GS.ORV)
         END   ,                   (allow ORVYL kluge)
         MVC   TVTUSER,UPATPACT+3  Requestor's userid (uuu)
         MVC   TVTGROUP,UPATPACT   Requestor's group code (gg)
         MVC   TVTLINE,UPATPLNO    Requestor's line number ml940330
         STCK  TVTLRCLK            Save time stamp         ML940315
         L     R0,TVTLRCLK         time, left part
         L     R3,CVTPTR
         WITH  (CVT,R3),'AL R0,CVTTZ'  Time zone adjustment
         ST    R0,TVTLRCLK         save adjusted (local) time
         MVC   TVTLACLK,TVTLRCLK   Copy time stamp         ml940330
         IF    UPATFAUTH,'SET TPATAUTH'
         IF    UPATFSPR,'SET TPATSPR'  Indicate SYS priv'd
         IF    UPATFOPR,'SET TPATOPR'  Indicate OPR priv'd
         END   ,                      (fresh path open)

         IF    UPATSPST.UPATFNI,BEGIN  New information processing
*// DEBUG 1 LINE ,,, FIX PATH INFO BUG
         L     R5,TVTCNTPCLOSE     Get current number of closes
         PTRACE PNEWINFO           Trace new information post
         STCK  TVTLACLK            timestamp new info rec'd
         L     R0,TVTLACLK         time, left part
         L     R3,CVTPTR
         WITH  (CVT,R3),'AL R0,CVTTZ'  Time zone adjustment
         ST    R0,TVTLACLK         save adjusted (local) time
         CLEAR UPATSPST.UPATFNI,MODE=LOCKED,REF=UPATH
         LR    R1,R2               Set upath pointer
         VCALL PATHREAD            Read buffer from partner
         PTRACE AFTPATHR           R0=Length, R1=Address, R15=return

         WHILE (R15,Z),BEGIN       Process ALL data in buffer
         LR    R2,R0               Save length
         L     R3,TVTPATB2         Set to address
         LR    R15,R0                Save length
         LR    R14,R1                  Save address of data
         LR    R0,R3                     Set move to address
         LR    R1,R2                       Set move to length
         MVCL  R0,R14                        Move to secondary buffer

*  Look for a command

         SEGCLR ERRSCB             no leftovers from previous cmd
         LA    R15,CMDVECT         Address of command vector table
         LOOP  BEGIN               Scan possible major commands
         L     R14,@R15+16         Load processing command address
         CLC   @R15(16),@R3        Compare against passed request
         IF    EQ,BEGIN            Found command processing routine
         LA    R1,@R3              Start of message
         LA    R1,@R3+16           Skip past prefix
         LR    R0,R2
         SH    R0,=H'16'           Adjust length
         BALR  R14,R14             Don't change addressing mode
         CLEAR R14                 Terminate loop
         END   ELSE,BEGIN
         IF    (R14,Z),BEGIN
         WINGSHDR SET,HEADER='FILE_ERROR:'
         SEGCLR TVTSCB             Clear client segcb
         SEGB  'ERRID=BADCMD'      Set error identifier
         SEG   'ERRMSG='''         Set error message keyword
         SEGT  @R3,16              Set bad command
         SEG   ': Invalid wings command'
         SEG   ''''                Terminate response
         SEGWR ,                   Send to client
         QSNAP 'BADCMD path abort'
         ACALL SETPATH             Set path re-queue
         EXIT  PROCPATH            Abort command
         END   ,
         LA    R15,@R15+20         Bump to next major command
         END   ,
         UNTIL (R14,Z),END         Loop back for next command
*  DEBUG 3 LINES ,,, FIX PATH INFO BUG
         IF    (R5,NE,TVTCNTPCLOSE),BEGIN  IF PATH CLOSED,
**?      QSNAP 'PATH INFO KLUGE ACTIVATED'
         EXIT  PROCPATH                      OUT OF HERE
         END
         L     R1,TVTUPATH         Address of upath control
         VCALL PATHREAD            Read next transaction if any
         PTRACE AFTPATHR
         END   ,
         END   ,
         PEND  ,
         TITLE 'Major command vector table'
*box
*
*   WINGS - Major command vector table:
*
         SPACE 2
CMDVECT  DC    0A(0)               Command vector table
         CMDVECT COMMAND='FILE_CATLG:   ',ROUT=CMDCTLG
         CMDVECT COMMAND='FILE_OPEN:    ',ROUT=CMDOPEN
         CMDVECT COMMAND='FILE_EOF:     ',ROUT=CMDEOF
         CMDVECT COMMAND='FILE_WRITE:   ',ROUT=CMDWRITE
         CMDVECT COMMAND='FILE_CLOSE:   ',ROUT=CMDCLOSE
         CMDVECT COMMAND='FILE_RENAME:  ',ROUT=CMDFREN
         CMDVECT COMMAND='FILE_LSPACE:  ',ROUT=CMDLSPCE
         CMDVECT COMMAND='FILE_SCRATCH: ',ROUT=CMDFSCR
         CMDVECT COMMAND='FILE_ALLOCATE:',ROUT=CMDALLOC
         CMDVECT COMMAND='SHOW_VERSION: ',ROUT=CMDSVER
         CMDVECT COMMAND='SHOW_DIR:     ',ROUT=CMDSDIR
         CMDVECT COMMAND='SHOW_CAT:     ',ROUT=CMDFSHOW
         CMDVECT COMMAND='FILE_SHOW:    ',ROUT=CMDFSHOW
         CMDVECT COMMAND='VTOC_SHOW:    ',ROUT=CMDFSHOW
         CMDVECT COMMAND='UNIT_INFO:    ',ROUT=CMDUNIF
         CMDVECT COMMAND='SHOW_ACEE:    ',ROUT=CMDSACEE
         CMDVECT COMMAND='OSFILE_STATUS:',ROUT=CMDSTAT
         CMDVECT COMMAND='RELEASE_LOG:  ',ROUT=CMDRLOG
         CMDVECT COMMAND='RACF_REFRESH: ',ROUT=CMDRREFR
         CMDVECT COMMAND='TEST_FUNC:    ',ROUT=CMDFTEST
         CMDVECT ,                 Terminate command vector list
         TITLE 'Process post of monitor ECB'
*box
*
*   Process monitor post action required
*
*     Process monitor request based on the setting of TVT flags.
*
*
         SPACE 2
MONPOST  PROC  ,
         L     R15,TVTSTOPE        LOAD ECB CONTENTS
         PTRACE MonPost
         IF    TVTFSTOP,BEGIN      Process stop request from monitor
         SET   TVTFQUISCE+TVTFSTOPPING,MODE=LOCKED,REF=TVT
         CLEAR TVTFSTOP,MODE=LOCKED,REF=TVT
         END   ,                      (stop request)
         IF    TVTFSPINLOG,BEGIN   LOGREL command (spin off log)
         ACALL BUMPLOG
         END   ,                      (logrel)
         POST  TVTECBCM,0          Post monitor request processed
         ACALL CHKLAST             Are we last live OSFILE subtask
         CLEAR R15
         PEND  ,
         TITLE 'Startup periodic timer'
*box
*
*   (re)start periodic timer
*
*      The purpose of the timer is to wake-up occasionally to
*      avoid 522 wait abend conditions.  Also on each timer
*      fire some global tables are processed to released older
*      entries.
*
*      We arrive here when the timer has fired.
*
         SPACE 2
SETTIMER PROC  ,

         IF    TPATCMND,BEGIN      Command in progress
*   OK, gotta check to see if we're waiting for Godot...
*   mcl 1998/01/12

         STCK  TVTSTCK             Save current time
         L     R0,TVTSTCK          Current date/time (to ~1sec.)
         SL    R0,TVTLACLK         how long since last action?
         SLL   R0,10               ...in milliseconds?
         C     R0,TVTBFTIM         same as buffer-full-wait timout
*                                  (which is in milliseconds)
**-  deleted following 1998/04/20 ml: cmdabort not cleaning up right
**-      IF    H,BEGIN             Waiting but busy!  Doing what?
**-
**-      IF    TREADEOF,BEGIN      we were almost done with READ
**-      QSNAP 'Timed out waiting for client EOF'
**-      PTRACE TimeoutR           Trace timeout
**-      SEGCLR ERRSCB             Clear error seg control block
**-      SEGB  'ERRID=TIMEOUT'
**-      SEG   'ERRMSG=''Timed out waiting for client EOF'''
**-      CMDABORT ,                Cleanup path and re-wait
**-      END   ,                      (were almost done)
**-
**-      ELSEIF TVTORVSS,BEGIN        ORVYL connection
**-for now, no timeout of orvyl
**-      END   ,                      (ORVYL)
**-
**-      ELSE BEGIN                busy, not EOF, not ORVYL
**-      QSNAP 'Timed out waiting for client.  Doing '
**-      QSNAP TVTPATCM
**-      QSNAP 'waiting for'
**-      QSNAP TVTPATNX
**-      PTRACE TimeoutX           Trace timeout
**-      SEGCLR ERRSCB             error seg control block
**-      SEGB  'ERRID=TIMEOUT'
**-      SEG   'ERRMSG=''Timed out doing '
**-      SEG   TVTPATCM            current command
**-      SEG   ', expecting '
**-      SEG   TVTPATNX            expected next cmd
**-      SEG   ''''                Close msg
**-      CMDABORT ,
**-      END   ,                      (busy, not done with READ)
**-
**-      END   ,                      (waiting but busy)
         END   ,                      (Command in progress)

         ACALL LOGCHECK            see if it's time to spin log
*box
*
*  Reset the timer for another interval
*
*

         XPUSH ,,L'STIMERL,PTR=R2  Stack space of stimer parameters
         L     R1,=A(STIMERL)        address of stimerm parameter list
         MVC   0(L'STIMERL,R2),0(R1)   set parameter list
         XPUSH R11,,PTR=R3               set user parameter
         L     R15,=A(TIMREXIT)            address of exit routine
         STIMERM SET,BINTVL=TVTWTIME,EXIT=TIMREXIT,PARM=(R3),          X
               WAIT=NO,ID=TVTSTMID,MF=(E,(R2))
         IF    (R15,NZ),'FAIL "Bad STIMERM call"'
         XPOP  PTR=R2              Release stack space
         PEND  ,
         SPACE 3
*box
*
*   STIMERM exit routine (Called from OS and runs as an IRB).
*     Post main task and return.
*

TIMREXIT WITH  (TIMREXIT,R15),BEGIN
         L     R11,@R1+4           Retreive address of TVT table
         IF    (~TVTFSTOPPING,AND,~TVTFABENDING),BEGIN       ML940217
         POST  TVTTIMRE,0          Post timer ECB
         END                       ,                       ML940217
         BR    R14                 Return to OS
         END
         TITLE 'OSFILE - Privileged operation check'
*box
*
*  PRIVOP - Check client identification for privileged operation
*           request.  May I see your license, registration, and
*           proof of insurance?
*
*  On entry:   Not applicable
*
*  On exit:    Normal return if partner is authorized, else
*              error abort to CMDCLEAN routine is taken.
*
         SPACE 2
PRIVOP   PROC  ,
         IF    ~TPATAUTH,BEGIN     Partner is not authorized...
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTAUTH'     Indicate privileged operation
         SEG   'ERRMSG=''Privileged WINGS operation'''
         CMDABORT ,                Abort current command
         END   ,
         CLEAR R15                 Zero return code
         PEND  ,
         TITLE 'Set control routine for error messages'
*box
*
*  Seg control routine for error messages
*
*    The error segment buffer is only used for error message
*    buildup.  If the TERRMULT flag is set we take the write request
*    and prefix ERRMSG='<text>' and add it to the
*    TVTSCB client buffer.
*
         SPACE 2
ERRRET   PROC  ,TRACE=NO           No trace routine
         LR    R2,R15              Save segcb address
         CLEAR R15                 Zero return code
         WITH  (SEGCB,R2),BEGIN    Addressability to SEGCB
         IF    SEGCBOVF,BEGIN      Error buffer overflow
         FAIL  'Error SEGCB overflow condition'
         END   ,
         IF    SEGCBWR,BEGIN       Indicate write request
         LR    R3,R1               Save address of message
         LR    R4,R0               Save length of message
         IF    TERRMULT,BEGIN      Enclose text with errmsg=
         SEG   'ERRMSG=''',,TVTSCB Pass on to client buffer
         SEG   (R3),(R4)           Add passed error message
         SEGB  ''''                Terminate quoted errmsg
         END   ,
         END   ,
         END   ,
         PEND
         TITLE 'Seg control routine for batch report'
*box
*
*  WINGS: OSFILE seg control routine
*
*
         SPACE 2
OSFPSEG  PROC  ,TRACE=NO
         LR    R2,R15              Save segcb address
         WITH  (SEGCB,R2),BEGIN    Addressability to SEGCB
         IF    SEGCBWR,BEGIN       Seg write request
         LR    R2,R0               Save length
         LR    R3,R1               Save address
         S     R3,=A(4)            Decrement for vbs header
         XC    @R3(4),@R3          Clear VBS header
         A     R0,=A(4)            Adjust for VBS header
         STH   R0,@R3              Plug VBS length
         PUT   OSFDCBPR,(R3)       Write to report file
         L     R4,TVTLOGCT         linecount
         A     R4,=F'1'            count this one
         ST    R4,TVTLOGCT         ...
         LCR   R0,R2               Complement bytes written
         PRETURN (R0)              Return bytes written
         END   ,
         END   ,
         PEND  ,
         QLTORG
         TITLE 'SETPATH - Requeue path control'
*box
*
*  SETPATH - REQUEUE PATH CONTROL
*
*        1.    Close previous path control block in any
*        2.    Allocate a new path control block
*        3.    Open path for processing
*        4.    Initialize SEG control buffer
*        5.    Queue path ECB to events table
*
SETPDATA RECORD BEGIN              debug area mcl2002/03/19
SETPDECB DS    CL4                 ECB for tracing
SETPDPFL DS    CL1                 path flag for tracing
SETPDSFL DS    CL2                 SUZAN flags for tracing
         END   ,                   SETPDATA
         SPACE 2
SETPATH  PROC  SETPDATA
         CLEAR SETPDATA
         MVC   SETPDECB,TVTPATHE   Save path ECB for tracing
         L     R0,TVTUPATH         Load address of upath block
         IF    (R0,NZ),BEGIN       Release old upath control block
         DELSYM NAME='UPATH',LOC=(R0)  Delete symbol from table
         L     R1,TVTUPATH         Set UPATH pointer
         WITH  (UPATH,R1),BEGIN
         MVC   SETPDPFL,UPATFLAG   Save flags
         MVC   SETPDSFL,UPATSPST      for tracing
         END   ,                      (with UPATH)
         CLEAR TVTUPATH            DEBUG  1 LINE
         VCALL PATHCLS             Close path
         INCR  R1,TVTCNTPCLOSE     COUNT PATH CLOSE
         IF    TVTREPT,BEGIN       Log path close
         LA    R15,OSFSCB          Addres of report segcb
         ACALL LOGTIME             Log time of path close
         SEG   'Path closed.  ',,OSFSCB
         HEXSEG SETPDPFL           **debug** mcl2002/03/19
         SEGBLANK 1
         HEXSEG SETPDECB           SUZAN path ECB (TVTPATHE)
         SEGBLANK 1
         HEXSEG SETPDSFL           SUZAN path post flags
         SEGWR ,                   Write path closed message
         SEGWR ,                   Blank line for neatness
         END   ,                     (log path close)
         END   ,                     (release old path)

         VCALL PATHALLO            Allocate new path control block
         ST    R1,TVTUPATH         Save path pointer
         LR    R2,R1               Copy address of path pointer
         XPUSH ,,16,PTR=R3             Get stack space
         ADDSYM ENTRY=(R3),NAME='UPATH',LOC=(R2),LEN=256
         XPOP  PTR=R3                  Pop stack work area
         WITH  (UPATH,R2),BEGIN    Addressability to UPATH
         LA    R1,TVTPATHE         Switch default path ecb
         ST    R1,UPATECB          Save pointer in path block
         ST    R1,TVTBWECL+4       ...and in fill/timer list
         LA    R1,TVTBTECB         ->timeout ECB
         ST    R1,TVTBWECL         ...in fill/timer list
         OI    TVTBWECL+4,X'80'    this is the last entry
         MVC   UPATMY,TVTPATHN     Initialize path name
         LR    R1,R2               Move pointer to upath
         VCALL PATHOPEN            Open path
         SET   UPATFWHDR           Indicate WINGS header required
         END   ,                     (with UPATH)
         LA    R3,TVTSCB           Address of segment control bufr
         L     R4,TVTPATBF         Get address of segment buffer
         LA    R4,@R4+16           Skip past WINGS header
         L     R5,TVTSBUFL         SUZAN buffer length for sends
         S     R5,=F'16'           minus our header length
         WITH  (SEGCB,R3),BEGIN    Seg buffer addressability
         SEGINIT (R4),(R5),(R3),RTNTYPE=V,RTN=PATHSEG,ERR=PATHERR
         L     R2,TVTUPATH         Address of upath control block
         ST    R2,TVTSCBUSR        Save upath pointer to upath
         END   ,                     (with SEGCB)
         PEND  ,
         TITLE 'FILE_OPEN Options Scanning'
*box
*
*  FILOSCAN -- Routine to scan the FILE_OPEN options and save
*    the information in the TVT.
*  This routine is also used by FILE_SCRATCH.
*
*    On entry:
*      R15   - FILPB ptr
*      R1,R0 - file options loc, len
*
*    On exit:
*      FILPB is updated with the options specified
*
FILOSWA  RECORD BEGIN
         SCANCB PFX=FILOSCN
         END
*-
FILOSCAN PROC  FILOSWA
         LR    R7,R15              FILPB ptr
         WITH  (FILPB,R7)
*-
*-       Initialize scanner to parameters passed to us.
*-
         SCINIT (R1),(R0),FILOSCNCB  Initialize scanner
*-
*-       Scan FILE_OPEN options.
*-
         LA    R1,3                SET SCAN-TYPE TO 3
         XCALL SCTYPE              SET NEW SCAN-TYPE
         SCAN  FILOPRT,FILOSCNCB   Scan file_open parameters
         IF    NZ,BEGIN            Some kind of error occurred
         SEGCLR ERRSCB
         SEG   'ERRID=CMDERR ERRMSG=''Syntax error in OPEN options'''
         CMDABORT ,                ABORT COMMAND
*EDIT
         END
         PEND
*-
*-       FILE_OPEN Options Routine Table
*-
         SPACE 3
FILOPRT  SCKW  NAME,FILONAME       see special SCNDSN code
         SCKW  CNAME,FILOCNAME
         SCKW  USER,FILOUSER,P
         SCKW  GROUP,FILOGROUP,P
         SCKW  ACCOUNT,FILOACCOUNT,P
         SCKW  REQTYPE,FILOREQTYPE,P
         SCKW  PATHBUFL,FILOBUFL,(A,P,PI)
         SCKW  LRECL,FILOLRECL,(P,I)
         SCKW  PRIQTY,FILOPRIQTY,(P,I)
         SCKW  SECQTY,FILOSECQTY,(P,I)
         SCKW  ALOCUNIT,FILOALUN,P
         SCKW  DIRQTY,FILODIRBLK,(P,I)
         SCKW  DIRBLKS,FILODIRBLK,(P,I)
         SCKW  DIRMEMS,FILODIRMEM,(P,I)
         SCKW  NTYPE,FILONTYPE,P
         SCKW  RECFM,FILORECFM,P
         SCKW  BLOCKSZ,FILOBLKSIZE,(P,PI)
         SCKW  BLKSIZE,FILOBLKSIZE,(P,PI)
         SCKW  VOL,FILOVOL,P
         SCKW  VOLUME,FILOVOL,P
         SCKW  DATACLAS,FILODCLS,P
         SCKW  MGMTCLAS,FILOMCLS,P
         SCKW  STORCLAS,FILOSCLS,P
         SCKW  BYTEGUESS,FILOBYTEGUESS,(P,I,A)
         SCKW  BYTECOUNT,FILOBYTEGUESS,(P,I,A)
         SCKW  BYTECNT,FILOBYTEGUESS,(P,I,A)
         SCKW  LINECOUNT,FILOLINECOUNT,(P,I,A)
         SCKW  LINECNT,FILOLINECOUNT,(P,I,A)
         SCKW  SETUSER,FILOSETUSER,P
         SCKW  SETGROUP,FILOSETGROUP,P
         SCKW  TITLE,FILOTITLE,(A,P)
         SCKW  SETLIB,FILOSETLIB,P
         SCKW  PASSCHK,FILOPSCHK,P
         SCKW  WHOLEPDS,FILOPWPDS,P
         SCKW  VTYPE,FILOVTYPE,P
         SCKW  SHARE,FILOPENQU,P
         SCKW  EXPAND,FILOPEXPA,P
         SCKW  CHANGFMT,FILOPCFMT,P
         SCKW  CATLG,FILOPCAT,(P,A)
         SCKW  TEMP,FILOPVTMP,P
         SCKW  RACF,FILORACF,P
         SCKW  ,FILOSKIP           Ignore unknown "KEYWORD=VALUE"
         QLTORG ,
         EJECT
*box
*
*  NAME=<DATA SET NAME>
*
FILONAME PROC
         WITH  (FILPB,R7)
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBNAME,GVTBLANK  Blank data set name
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'FILPBNAME      Not too long
         MOVE  R2,FILPBNAME,@R1    Move in data set name
         LR    R15,R6
         PEND
*box
*
*  CNAME=<DATA SET NAME>
*
FILOCNAME PROC
         WITH  (FILPB,R7)
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBCNAME,GVTBLANK Blank current data set name
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'FILPBCNAME     Not too long
         MOVE  R2,FILPBCNAME,@R1   Move in data set name
         LR    R15,R6
         PEND
*-
*-  Set Path buffer length value (in bytes)
*-
FILOBUFL PROC  ,                   Path buffer-full timeout
         MVC   TVTSBUFL,@R15       Set path buffer length (def.16384)
         PEND  ,                   Return to scanner

*box
*
*  TITLE=<Libary member title string>
*
FILOTITLE PROC ,
         WITH  (FILPB,R7)
         LR    R3,R15              Save address of scancb
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         IF    ((@R1,EQ,'"'),OR,(@R1,EQ,'''')),BEGIN
         XCALL DQSCAN              Dequote passed string
         END   ,
         IF    (R0,NEG),BADOPT     Bad keyword value
         ST    R0,FILPBTITLEN      Save original title string length
         CEIL  R0,=A(42)           Only move a total of 42 bytes
         MVC   FILPBTITLE,GVTBLANK Blank pad title area
         LR    R2,R0               Copy length of title string
         IF    (R2,POS),BEGIN
         DEX   R2,'MVC FILPBTITLE(0),@R1'    Move in title string
         END
         LR    R15,R3              Reset scancb address
         PEND  ,                   Return to scanner

*box
*
*  USER=user
*
FILOUSER PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (@R1,EQ,'&&'),BEGIN  Allow "&" or "&user"...
         LA    R1,@R1+1
         DECR  R0
         IF    (R0,Z),'SETMSG TVTUSER'  Requestor's user code
         END
*
         IF    (R0,NE,L'FILPBUSER),BADOPT  Wrong length
         MVC   FILPBUSER,@R1       Save option
         PEND
         EJECT ,
*box
*
*  GROUP=group
*
FILOGROUP PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (@R1,EQ,'@'),BEGIN  Allow "@" or "@group"...
         LA    R1,@R1+1
         DECR  R0
         IF    (R0,Z),'SETMSG TVTGROUP'  Requestor's group code
         END
*
         IF    (R0,NE,L'FILPBGROUP),BADOPT  Wrong length
         MVC   FILPBGROUP,@R1      Save option
         PEND
*box
*
*  TEMP={YES | NO}
*
FILOPVTMP PROC ,
         WITH  (FILPB,R7)          ADDRESSABILITY TO FILEPB
         IF    (R0,Z),MISSING      REQUIRED PARAMETER MISSING
         IF    (R0,NEG),BADOPT     INVALID LENGTH
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOVOLTEMP'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOVOLTEMP'
         ELSE  'B BADOPT'          INVALID PARAMETER ERROR
         PEND  ,
*box
*
*  RACF={YES | NO}
*
FILORACF PROC ,
         WITH  (FILPB,R7)          ADDRESSABILITY TO FILEPB
         IF    (R0,Z),MISSING      REQUIRED PARAMETER MISSING
         IF    (R0,NEG),BADOPT     INVALID LENGTH
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),'SET TVTPBFONRACF'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),'CLEAR TVTPBFONRACF'
         ELSE  'B BADOPT'          INVALID PARAMETER ERROR
         XPUSH R15                 Save address of scanner cb
         ACALL PRIVOP              Privileged operation check
         XPOP  R15                 Retrieve scanner cb addr
         PEND  ,
*box
*
*  PASSCHK={YES | NO}
*
FILOPSCHK PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing option
         IF    (R0,NEG),BADOPT     Invalid string passed
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOPASSCHK'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOPASSCHK'
         ELSE  'B BADOPT'          Neither YES or NO passed
         XPUSH R15                 Save address of scanner cb
         ACALL PRIVOP              Privileged operation check
         XPOP  R15                 Retrieve scanner cb addr
         PEND  ,
*box
*
*  WHOLEPDS={YES | NO}  (option on SCRATCH)
*
FILOPWPDS PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing option
         IF    (R0,NEG),BADOPT     Invalid string passed
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOWHOLPDS'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOWHOLPDS'
         ELSE  'B BADOPT'          Neither YES or NO passed
         PEND  ,
*
*  VTYPE={READ|WRITE}   (option on VERIFY)
*
FILOVTYPE PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing option
         IF    (R0,NEG),BADOPT     Invalid string passed
         IF    ((R0,EQ,4),AND,(@R1,EQ,'READ')),'CLEAR TVTPBFOCKWRITE'
         ELSEIF ((R0,EQ,5),AND,(@R1,EQ,'WRITE')),'SET TVTPBFOCKWRITE'
         ELSE  'B BADOPT'          unrecognized option
         PEND  ,
*box
*
*  SHARE={YES | NO}
*
FILOPENQU PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing option
         IF    (R0,NEG),BADOPT     Invalid string passed
         IF    ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOSHARE'
         ELSEIF ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOSHARE'
         ELSE  'B BADOPT'          Neither YES or NO passed
         PEND  ,
*box
*
*  EXPAND={YES | NO}
*
FILOPEXPA PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing option
         IF    (R0,NEG),BADOPT     Invalid string passed
         IF    ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOEXPND'
         ELSEIF ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOEXPND'
         ELSE  'B BADOPT'          Neither YES or NO passed
         PEND  ,
*box
*
*  CHANGFMT={YES | NO}
*
FILOPCFMT PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing option
         IF    (R0,NEG),BADOPT     Invalid string passed
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOCHNGFMT'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOCHNGFMT'
         ELSE  'B BADOPT'          Neither YES or NO passed
         PEND  ,
*box
*
*  CATLG={CAT | UNCAT | RECAT }
*        {YES | NO            }
*
FILOPCAT PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING
         IF    (R0,NEG),BADOPT
         CLEAR TVTPBCATFLG
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),'SET TVTPBFNOCAT'
         ELSEIF ((R0,EQ,5),AND,(@R1,EQ,'UNCAT')),'SET TVTPBFNOCAT'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFCAT'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'CAT')),'SET TVTPBFCAT'
         ELSEIF ((R0,EQ,5),AND,(@R1,EQ,'RECAT')),'SET TVTPBFRECAT'
         ELSE  'B BADOPT'
         PEND  ,
*box
*
*  ACCOUNT=account
*
FILOACCOUNT PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (R0,NE,L'FILPBACCOUNT),BADOPT  Wrong length
         MVC   FILPBACCOUNT,@R1    Save option
         PEND
*box
*
*  SETUSER=USER
*
FILOSETUSER PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (R0,NE,3),BADOPT    Invalid length for user
         MVC   FILPBSETUSER,@R1    Move in set user
         PEND
*box
*
*  SETGROUP=GROUP
*
FILOSETGROUP PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (R0,NE,2),BADOPT    Invalid length for group
         MVC   FILPBSETGROUP,@R1   Move in set group
         PEND
*box
*
*  SETLIB=<default lib>
*
FILOSETLIB PROC
         WITH  (FILPB,R7)
         LR    R3,R15              Save address of scancb
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBSETLIB,GVTBLANK Blank current data set name
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'FILPBSETLIB    Not too long
         MOVE  R2,FILPBSETLIB,@R1  Move in data set name
         SETMSG FILPBSETLIB
         VCALL TOUPPER
         LR    R15,R3              Reset scancb address
         PEND
         EJECT ,
*box
*
*  VOLUME=VOLSER
*  VOL=VOLSER
*
FILOVOL  PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (R0,GT,6),BADOPT    Invalid length of volume
         MVC   FILPBVOL,GVTBLANK   Pre-blank
         STH   R0,FILPB#VOL        Save length
         LR    R2,R0               Copy length of volume parameter
         MOVE  R2,FILPBVOL,@R1     Save volume
         PEND
*box
*
*  DATACLAS=<CLASS>
*
FILODCLS PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBDATACLAS,GVTBLANK  Blank data class
         LR    R2,R0               Copy length of value
         CEIL  R2,L'FILPBDATACLAS  Not too long
         MOVE  R2,FILPBDATACLAS,@R1    Move in DATACLASS
         OC    FILPBDATACLAS,GVTBLANK  smash case
         PEND
*box
*
*  STORCLAS=<CLASS>
*
FILOSCLS PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBSTORCLAS,GVTBLANK  Blank storage class
         LR    R2,R0               Copy length of value
         CEIL  R2,L'FILPBSTORCLAS  Not too long
         MOVE  R2,FILPBSTORCLAS,@R1    Move in STORCLASS
         OC    FILPBSTORCLAS,GVTBLANK  smash case
         PEND
*box
*
*  MGMTCLAS=<CLASS>
*
FILOMCLS PROC
         WITH  (FILPB,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBMGMTCLAS,GVTBLANK  Blank mgmt class
         LR    R2,R0               Copy length of value
         CEIL  R2,L'FILPBMGMTCLAS  Not too long
         MOVE  R2,FILPBMGMTCLAS,@R1    Move in MGMTCLASS
         OC    FILPBMGMTCLAS,GVTBLANK  smash case
         PEND
*box
*
*  LRECL=<VALUE>
*
FILOLRECL PROC  ,                  Processing for LRECL=<nn>
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         MVC   FILPBLRECL,SCNVAL   Move in logical record length
         PEND
*box
*
*  BLKSIZE=<VALUE>
*
FILOBLKSIZE PROC  ,                Processing for BLKSIZE=n
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         MVC   FILPBBLKSIZE,SCNVAL  Move in blksize
         PEND
*box
*
*  PRIQTY=<VALUE>
*
FILOPRIQTY PROC  ,                Processing for PRIQTY=n
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         MVC   FILPBALLOCPRI,SCNVAL  Move in quantity
         PEND
*box
*
*  SECQTY=<VALUE>
*
FILOSECQTY PROC  ,                Processing for SECQTY=n
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         MVC   FILPBALLOCSEC,SCNVAL  Move in quantity
         PEND
*box
*
*  ALOCUNIT={TRK|CYL|KB|MB}
*
FILOALUN PROC  ,                Allounit= processing
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         CLEAR FILPBALTYPKB        got a value, clear default
         IF    (SCNKW,EQ,'TRK '),'SET FILPBALTYPTR'          TRK
         ELSEIF (SCNKW,EQ,'CYL  '),'SET FILPBALTYPCY '       CYL
         ELSEIF (SCNKW,EQ,'KB '),'SET FILPBALTYPKB '         KB
         ELSEIF (SCNKW,EQ,'MB '),'SET FILPBALTYPMB '         MB
         ELSE  'B BADOPT'          Error
         PEND
*box
*
*  DIRBLKS=<VALUE>
*
FILODIRBLK PROC  ,                Processing for DIRBLKS=n
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         MVC   FILPBALLOCDIR,SCNVAL  Move in quantity
         PEND
*box
*
*  DIRMEMS=<VALUE>        Directory value in MEMBERS
*
FILODIRMEM PROC  ,                 Processing for DIRMEMS=n
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         L     R3,SCNVAL           quantity
         LA    R3,2(R3)              +2
         SR    R2,R2               clear for divide
         D     R2,=F'3'            ((mems+2)/3) 3 per blk, round up
         ST    R3,FILPBALLOCDIR    Save value as blocks
         PEND
*box
*
*  BYTEGUESS=byte count
*
FILOBYTEGUESS PROC
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   TVTBYTEGUESS,SCNVAL Save byte count
         PEND
*box
*
*  LINECOUNT=LINE COUNT
*
FILOLINECOUNT PROC
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   TVTLINEGUESS,SCNVAL Save byte count
         PEND
*box
*
*  RECFM={FIXED,EDIT,VARIABLE}
*
FILORECFM PROC  ,                  RECFM= Processing
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (SCNKW,EQ,'EDIT '),'SET FILPBFRECEDIT'  Edit

* 2001/05/03 MCL:  support B and M suffixes, FIXED, VARIABLE

         ELSEIF ((SCNKW,EQ,'F '),OR,(SCNKW,EQ,'FB '),OR,               *
               (SCNKW,EQ,'FIXED ')),BEGIN        F or FB
         SET FILPBFRECFIX          F(B)
         END   ,                                 (F/FB)

         ELSEIF ((SCNKW,EQ,'FA '),OR,(SCNKW,EQ,'FBA ')),BEGIN
         SET   FILPBFRECFIX        F(B)
         SET   FILPBFRECCA         ..A
         END   ,                                 (FA/FBA)

         ELSEIF ((SCNKW,EQ,'FM '),OR,(SCNKW,EQ,'FBM ')),BEGIN
         SET   FILPBFRECFIX        F(B)
         SET   FILPBFRECCM         ..M
         END   ,                                 (FM/FBM)

         ELSEIF ((SCNKW,EQ,'V '),OR,(SCNKW,EQ,'VB '),OR,               *
               (SCNKW,EQ,'VARIABLE ')),BEGIN          V or VB
         SET   FILPBFRECVAR        V/VB
         END   ,                   (V/VB)

         ELSEIF ((SCNKW,EQ,'VA '),OR,(SCNKW,EQ,'VBA ')),BEGIN   VA/VBA
         SET   FILPBFRECVAR        V(B)
         SET   FILPBFRECCA         ...A
         END   ,                   (VA/VBA)

         ELSEIF ((SCNKW,EQ,'VM '),OR,(SCNKW,EQ,'VBM ')),BEGIN   VM/VBM
         SET   FILPBFRECVAR        V(B)
         SET   FILPBFRECCM         ...M
         END   ,                   (VM/VBM)

         ELSE  'B BADOPT'          Error
         PEND
         QLTORG ,
*box
*
*  NTYPE={WYLBUR,TSO,BOTH,EXACT}
*
FILONTYPE PROC  ,                  Ntype= processing
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         CLEAR FILPBFTYPWYL+FILPBFTYPTSO+FILPBFTYPEXACT  clr flgs
         IF    (SCNKW,EQ,'WYLBUR '),'SET FILPBFTYPWYL'    Wylbur
         ELSEIF (SCNKW,EQ,'TSO '),'SET FILPBFTYPTSO'      TSO
         ELSEIF (SCNKW,EQ,'BOTH '),BEGIN         BOTH Wylbur and TSO
         SET   FILPBFTYPWYL                      (only valid for
         SET   FILPBFTYPTSO                       SHOW commands)
         END   ,                      (BOTH)
         ELSEIF (SCNKW,EQ,'EXACT '),'SET FILPBFTYPEXACT'  Exact
         ELSE  'B BADOPT'          Error
         MVC   TVTFNTYP,FILPBDTYPE   copy ntype flags      ml970121
         PEND
*box
*
*  REQTYPE=VALUE
*
FILOREQTYPE PROC  ,                Reqtype= processing
         WITH  (FILPB,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         IF    (SCNKW,EQ,'READ '),'SET FILPBFREQREAD'        Read
         ELSEIF (SCNKW,EQ,'WRITE '),'SET FILPBFREQWRITE'     Write
         ELSEIF (SCNKW,EQ,'APPEND '),'SET FILPBFREQAPPEND'   Append
         ELSEIF (SCNKW,EQ,'REPLACE '),'SET FILPBFREQREPLACE' Replace
         ELSEIF (SCNKW,EQ,'VERIFY '),'SET FILPBFREQVERIFY'   Verify
         ELSE  'B BADOPT'          Error
         IF    FILPBFREQAPPEND,NOTYET
         PEND
*box
*
*  <Ignored keyword>=<Ignored value>
*  REWRITTEN, mcl, 1997/09/15
FILOSKIP PROC
         LR    R5,R15
         WITH  (SCNCB,R5)
         LR    R4,R0               L'keyword
         LA    R1,0(R4,R1)         ->past keyword
         L     R2,SCNLEN           Length remaining
         IF    (R2,Z),SKIPDONE     if no token

* OK, now      R1-> just past "ignored keyword" (should point to =)
*              R2=  length remaining to scan

         CLI   @R1,C'='            we use key=value
         IF    NE,SKIPDONE         so if no = sign, done ignoring
         LA    R3,1(,R1)           ->value to ignore
         L     R1,SCNLOC           ->string left to parse
         AR    R1,R2               ->past end of that string
         S     R2,=F'1'            length remaining
         BNP   SKIPDONE            if nothing to skip
         LR    R0,R1               save end pointer
         L     R4,=A(NBTRT)        translate table: find a blank
         DEX   R2,'TRT 0(0,R3),@R4'  find a blank
         LR    R2,R1               ->delimiting blank, or end
         SR    R0,R1               length remaining
         ST    R2,SCNLOC           reset
         ST    R0,SCNLEN             scancb...
SKIPDONE LABEL ,
**-         IF    (R0,Z),MISSING      Missing keyword value
**-         IF    (R0,NEG),BADOPT     Bad keyword value
**-*
**-         L     R4,SCNRA            Preserve original return addr
**-         L     R3,SCNPRT           Preserve scan table ptr
**-*
**-         SCTYPE 3,(R5)             MPD's magic
**-         LR    R6,R1               Save old type
**-         SCAN  ,(R5)               Skip value
**-         SCTYPE (R6),(R5)          restore scantype
**-*
**-         ST    R3,SCNPRT           Restore scan table ptr
**-         ST    R4,SCNRA            Restore return addr
**-         LA    R15,SCNCB
         PEND
         TITLE 'Scan Dataset Name'
*
*  Scan Dataset Name.  Special syntax rules apply.
*  rev. 1997/07/31 mcl:  handle quoted name w/embedded blank
*
*  GET POINTERS FROM SCAN CONTROL BLOCK
*  UPDATE SCAN CONTROL BLOCK.
*
*  ON ENTRY:
*     R6 - SCANCB
*
*  ON EXIT:
*    R1,R0 - DATA SET NAME LOCATION, LENGTH
*
*
SCNDSN   PROC  ,
*
         SCTELL LA:@R6
*
*                                  SCIP BLANKS AND '='
         WHILE ((R0,POS),AND,(@R1,EQ,' ')),BEGIN
         INCR  R1
         DECR  R0
         END   ,                      (scan blank)
         IF    ((R0,POS),AND,(@R1,EQ,'=')),BEGIN
         INCR  R1
         DECR  R0
         END   ,                      (scan =)
         WHILE ((R0,POS),AND,(@R1,EQ,' ')),BEGIN
         INCR  R1
         DECR  R0
         END   ,                      (scan blank)

         LR    R2,R1               R2 - START OF NAME

         IF    ((@R2,NE,''''),AND,(@R2,NE,'"')),BEGIN  no quotes
*  LOOK FOR END OF NAME
         WHILE ((R0,POS),AND,(@R1,GT,' ')),BEGIN  ML950131
         INCR  R1
         DECR  R0
         END   ,                      (scan blank ending name)
         END   ,                      (no quotes)
         ELSE  BEGIN               Quoted name
         INCR  R1                  skip leading
         DECR  R0                              quote
         WHILE ((R0,POS),AND,(@R1(1),NE,@R2)),BEGIN scan same kind
         INCR  R1                                   of quote
         DECR  R0
         END   ,                      (scan quote ending name)
         INCR  R1                  skip closing
         DECR  R0                               quote
         END   ,                      (quoted name)

*  REINIT SCAN LOC LEN
         SCINIT (R1),(R0),LA:@R6
*
*                                  RETURN R1,R0 - LOC LEN
         LR    R0,R1
         SR    R0,R2
         LR    R1,R2
*
         PRETURN (R0,R1)
         PEND
*
         QLTORG
         TITLE 'Process FILE_OPEN Options'
*box
*
*  FILOFIN -- Post process all the FILE_OPEN options and set
*    appropriate defaults or generate an error if inconsistent
*    options were specified.
*
*    On entry:
*      R15 - FILPB ptr
*
FFINWA   RECORD BEGIN
FFINESG  SEGCB ,                   Error SEGCB
FFINEBUF DS    CL128               Error message buffer
         END
*-
FILOFIN  PROC  FFINWA
         CLEAR FFINWA
         LR    R7,R15
         WITH  (FILPB,R7)
*
         SEGINIT FFINEBUF,,FFINESG  Init our error SEGCB
*-
*-       If no NTYPE, assume WYLBUR              ml19970730
*-
         IF    (TVTPBFTYPWYL+TVTPBFTYPTSO+TVTPBFTYPEXACT,Z),BEGIN
         SET   TVTPBFTYPWYL        Assume Wylbur format
         END
*-
*-       Build the complete OS file name.
*-
         LA    R1,FILPB            File parameters
         LA    R15,FFINESG         Error SEGCB ptr
         ACALL BUILDDSN            Build completed OS file name
         IF    NZ,BEGIN            Error...
         XPUSH R0,R1
         SEGCLR ERRSCB             Path error SEGCB ptr
         SEG   'ERRID=BADDSN ERRMSG='''
         XPOP  R0,R1
         SEG   (R1),(R0)           Error message
         SEG   ''''
*
         CMDABORT ,                Abort current command
         END
*-
*-       Check for valid OS file name.
*-
         LA    R1,FILPB            File parameters
         LA    R15,FFINESG         Error SEGCB ptr
         ACALL CHECKDSN            Check dsname syntax
         IF    NZ,BEGIN            Error...
         XPUSH R0,R1
         SEGCLR ERRSCB             Path error SEGCB ptr
         SEG   'ERRID=BADOSDSN ERRMSG='''
         XPOP  R0,R1
         SEG   (R1),(R0)           Error message
         SEG   ''''
*
         CMDABORT ,                Abort current command
         END
*
         PEND
*
         SEGDEF DUMMY              (Neatness)
         TITLE 'Build Dataset Name'
*box
*
*  BUILDDSN -- Routine to build the OS file name given the name
*    and all the other pieces.
*
*    On entry:
*       R1  - FILPB ptr
*       R15 - Error message SEGCB ptr
*
*    On exit, R15 (and cc):
*       0 = ok; DSNAME and MEMBER filled in:
*             FILPBDSNAME - 44 character OS file name
*             FILPBDSMEM  - 8 character member name
*                             (binary zero if none)
*             FILPBDSACCT - account (uuugg) of dsname owner
*                             (binary zero if non-standard ds)
*
*       nz= error, R1,R0 = error message loc, len
*
BDSNWA   RECORD BEGIN
BDSNESGP DS    A                   Error SEGCB ptr
BDSNSG   SEGCB ,                   Filname expansion SEGCB
BDSNBUF  DS    CL128               Full filename area
BDSNFLAG FLAG  ,                   added 19970613 ml
         FLAG  BDSN$$$$            $name specified
         END   BDSNWA
*-
BUILDDSN PROC  BDSNWA
         LR    R3,R1
         WITH  (FILPB,R3)
*
         CLEAR BDSNWA
         ST    R15,BDSNESGP        Save error SEGCB ptr
         SEGCLR .(R15)             Reset error SEGCB
*
         CLEAR FILPBDSNAME         No dsname yet
         CLEAR FILPBDSMEM          No member speified
         CLEAR FILPBDSACCT         No account for this dsname yet
*
         SEGINIT BDSNBUF,,BDSNSG
         MVC   BDSNBUF,GVTBLANK    Pre-blank filename area
*
*  Check if name supplied
*
         IF    (FILPBNAME,Z),BEGIN no name
         SEG   'No file name supplied.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (no name)
*-
*-       Check for too many levels of recursion (this could
*-         happen, for example, if the current filename
*-         was "*").
*-
         INCR  R15,FILPBLEVEL      Count nest level
         IF    (R15,GT,3),BEGIN    Nested too deep...
         SEGT  FILPBNAME,,.L:BDSNESGP
         SEG   ': file name can not be resolved.',,.L:BDSNESGP
         B     BDSNERR
         END
*-
*-       Process USER/GROUP/ACCOUNT overrides.
*-
         IF    ((FILPBACCOUNT,NZ),AND,                                 *
               ((FILPBUSER,NZ),OR,(FILPBGROUP,NZ))),BEGIN
         CLEAR R0
*
         IF    (FILPBUSER,NZ),BEGIN
         SEG   (R1),(R0),.L:BDSNESGP
         SEG   'USER=',,.L:BDSNESGP
         SEGT  FILPBUSER,,.L:BDSNESGP
         SETMSG ' and '
         END
*
         IF    (FILPBGROUP,NZ),BEGIN
         SEG   (R1),(R0),.L:BDSNESGP
         SEG   'GROUP=',,.L:BDSNESGP
         SEGT  FILPBGROUP,,.L:BDSNESGP
         SETMSG ' and '
         END
*
         IF    (FILPBACCOUNT,NZ),BEGIN
         SEG   (R1),(R0),.L:BDSNESGP
         SEG   'ACCOUNT=',,.L:BDSNESGP
         SEGT  FILPBACCOUNT,,.L:BDSNESGP
         END
*
         SEG   ' are mutually exclusive options.',,.L:BDSNESGP
         B     BDSNERR
         END
*-
*-       Check out ACCOUNT option and convert it to USER and GROUP.
*-
         IF    (FILPBACCOUNT,NZ),BEGIN  Validate account option...
         SETMSG FILPBACCOUNT       Account
         VCALL RTRIM
         IF    ((R0,EQ,6),AND,(@R1+3,EQ,'$')),BEGIN  uuu$gg...
         MVC   @R13(6),FILPBACCOUNT  Save "uuu$gg"
         MVC   FILPBACCOUNT(2),@R13+4  Convert...
         MVI   FILPBACCOUNT+2,C'.'       to...
         MVC   FILPBACCOUNT+3(3),@R13      gg.uuu
         END
*
         IF    ((R0,NE,6),OR,                                          *
               ((@R1+2,NE,'.'),AND,(@R1+2,NE,'$'))),BEGIN  Bad...
         SEG   'ACCOUNT=',,.L:BDSNESGP
         SEGT  FILPBACCOUNT,,.L:BDSNESGP
         SEG   ' is incorrectly specified.',,.L:BDSNESGP
         B     BDSNERR
         END
*
         MVC   FILPBGROUP,FILPBACCOUNT  Save group
         MVC   FILPBUSER,FILPBACCOUNT+3  Save user
         CLEAR FILPBACCOUNT        Reset account
         END
*-
*-       Isolate file name and member name.
*-
         SETMSG FILPBNAME          Filename
         VCALL LRTRIM              Strip blanks
         VCALL TOUPPER             Upper case
         LR    R6,R1
         LR    R5,R0               R6,R5 = file name loc, len
*-
*-       Allow quoted names
*-
         IF    ((@R1,EQ,''''),OR,(@R1,EQ,'"')),BEGIN  quoted
         SET   FILPBFQUOTED        remember the quote
         INCR  R1
         DECR  R0
         DECR  R0
         VCALL LRTRIM              strip blanks inside the quotes
         IF    (R0,EQ,0),BEGIN     If no name, error       ml970729
         SEG   'No file name supplied.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (no name)
         LR    R6,R1               new position
         LR    R5,R0               new length
         END   ,                      (quoted)
*-
*-       Check for library, case 1A:  filename(member) or GDG
*-
         LR    R4,R5               save length             ml970801
         LR    R2,R6               ->name
         AR    R2,R5               L'name
         DECR  R2                  R2 = last char of dsname

         IF    (@R2,EQ,')'),BEGIN  It's file(member)...
         DECR  R5                  Account for ")"
         DECR  R2                  Back up ptr
         CLEAR R15                 Init member length

         LOOP  BEGIN               Backscan for "("...
         IF    (R5,NP),BEGIN       Bad dsn:  no left paren
         SEGT  FILPBNAME,,.L:BDSNESGP
         SEG   ': mismatched parenthesis.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (bad dsn: no left paren)
         IF    (@R2,EQ,'('),EXIT   Found start of member, scram
         DECR  R2                  Back up ptr
         DECR  R5                  Reduce length
         LA    R15,@R15+1          One more character
         END   ,                      (backscan)
*
         DECR  R5                  Account for "("

*  rev. 1997/08/01 mcl:  strip blanks so dsn(  mem  ) is ok

         MVC   FILPBDSMEM,GVTBLANK  Pre-blank
         LA    R1,@R2+1            ->member name
         LR    R0,R15              L'name
         VCALL LRTRIM              Strip blanks inside parens

         IF    (R0,GT,8),BEGIN    Member name too long...
         SEGT  FILPBNAME,,.L:BDSNESGP
         SEG   ': member name is too long.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (too long)

         LR    R15,R0              Length
         MOVE  R15,FILPBDSMEM,@R1  Save member name
*-
*-       Check for a GDG name, case 1B:  filename(gdg #).
*-

         LA    R2,FILPBDSMEM

         IF    ((@R2,EQ,C'+'),OR,(@R2,EQ,C'-'),OR,                     X
               (@R2,EQ,'0 ')),BEGIN   gdg
         LR    R5,R4               If GDG, restore orig len
         CLEAR FILPBDSMEM
         END   ,                      (gdg)
         END   ,                      (filename(member) or GDG)
*-
*-       Check for library, case 2:  filename#member.
*-
         ELSE  BEGIN               Might be "file#member"...
         SETMSG (R6),(R5)          Complete filename
*
         IF    FILPBFQUOTED,EXIT   ignore # within quotes  ml970729

         WHILE (R0,POS),BEGIN      Look for "#"...
         IF    (@R1,EQ,'#'),EXIT   Start of member name, scram
         LA    R1,@R1+1
         DECR  R0
         END   ,                      (look for #)
*
         IF    (R0,POS),BEGIN      Found a member name...
         LR    R5,R1
         SR    R5,R6               Calculate length before "#"
*
         LA    R1,@R1+1            Skip past "#"
         DECR  R0                  Adjust remaining length
*
         IF    (R0,GT,8),BEGIN     Member name too long...
         SEGT  FILPBNAME,,.L:BDSNESGP
         SEG   ': member name is too long.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (name too long)
*
         MVC   FILPBDSMEM,GVTBLANK  Pre-blank
         LR    R15,R0
         MOVE  R15,FILPBDSMEM,@R1  Save member name
         END   ,                      (found member name)
         END   ,                      (might be name#mem)

*  If quoted name, don't check $, @gg, &uuu      ml19970729

         IF    FILPBFQUOTED,STARCHEK
*-
*-       Handle "$filename" fully qualified dsnames.
*-
         IF    (@R6,EQ,'$'),BEGIN  $-style...
         IF    ((FILPBUSER,NZ),OR,(FILPBGROUP,NZ)),BEGIN
         SEG   'ACCOUNT/USER/GROUP override not ',,.L:BDSNESGP
         SEG   'allowed with $ file names.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (user/group override)
*
         LA    R6,@R6+1
         DECR  R5
         SEG   (R6),(R5)           Full dsname
         SET   BDSN$$$$            remember the $
**-ml    B     BDSNCHK             1997-06-11: this caused
*                                  $dsn#* to save member "*"
         B     STARCHEK            got dsn, now check member
         END   ,                      ($-style)
*-
*-       Process "&uuu." and "@gg." prefixes (in any order).
*-
         WHILE ((R5,POS),AND,((@R6,EQ,'&&'),OR,(@R6,EQ,'@'))),BEGIN
*-
*-       Handle "&.filename" or "&uuu.filename".
*-
         IF    (@R6,EQ,'&&'),BEGIN  Starts with ampersand...
         IF    ((R5,GE,2),AND,(@R6+1,EQ,'.')),BEGIN  &.file...
         MVC   FILPBUSER,TVTUSER   Use requestor's user code
         LA    R6,@R6+2
         SH    R5,=H'2'
         END   ,                      (&.file)
*
         ELSEIF ((R5,GE,5),AND,(@R6+4,EQ,'.')),BEGIN  &uuu.file...
         MVC   FILPBUSER,@R6+1     Save userid
         LA    R6,@R6+5            Skip past "&uuu"
         SH    R5,=H'5'            Adjust length
         END   ,                      (&uuu.file)
*
         ELSEIF (R5,EQ,1),BEGIN    &...
         MVC   FILPBUSER,TVTUSER   Use requestor's user code
         LA    R6,@R6+1            Skip past "&"
         DECR  R5                  Adjust length
         END   ,                      (&...)
*
         ELSEIF (R5,EQ,4),BEGIN    &uuu...
         MVC   FILPBUSER,@R6+1     Save userid
         LA    R6,@R6+4            Skip past "&uuu"
         SH    R5,=H'4'            Adjust length
         END   ,                      (&uuu...)
*
         ELSE  BEGIN               Bad format file name...
         SEG   (R6),(R5),.L:BDSNESGP
         SEG   ': bad format for && in file name.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (bad format)
         END   ,                      (starts with &)
*-
*-       Handle "@.filename" or "@gg.filename".
*-
         ELSEIF (@R6,EQ,'@'),BEGIN  Starts with at-sign...
         IF    ((R5,GE,2),AND,(@R6+1,EQ,'.')),BEGIN  @.file...
         MVC   FILPBGROUP,TVTGROUP  Use requestor's group code
         LA    R6,@R6+2
         SH    R5,=H'2'
         END   ,                      (@.file)
*
         ELSEIF ((R5,GE,2),AND,(@R6+3,EQ,'.')),BEGIN  @gg.file...
         MVC   FILPBGROUP,@R6+1    Save group
         LA    R6,@R6+4            Skip past "@gg"
         SH    R5,=H'4'            Adjust length
         END   ,                      (@gg.file)
*
         ELSEIF (R5,EQ,1),BEGIN    @...
         MVC   FILPBGROUP,TVTGROUP  Use requestor's group
         LA    R6,@R6+1            Skip past "@"
         DECR  R5                  Adjust length
         END   ,                      (@...)
*
         ELSEIF (R5,EQ,3),BEGIN    @gg...
         MVC   FILPBGROUP,@R6+1    Save group
         LA    R6,@R6+3            Skip past "@gg"
         SH    R5,=H'3'            Adjust length
         END   ,                      (@gg...)
*
         ELSE  BEGIN               Bad format file name...
         SEG   (R6),(R5),.L:BDSNESGP
         SEG   ': bad format for @ in file name.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (bad format)
         END   ,                      (starts with @)
         END   ,                      (WHILE... scan for @&)
*-
*-       Handle resolving "*" member name specification.
*-         This is done by expanding CNAME (a recursive call
*-         to BUILDDSN) and then saving the member name.
*-
STARCHEK IF    (FILPBDSMEM,EQ,'* '),BEGIN  Expand * member...
         CLEAR FILPBDSMEM          Reset member name
*
         IF    (FILPBCNAME,NZ),BEGIN  We have a current name...
         XPUSH ,,L'XFILPB,PTR=R4   Make a new FILPB
         WITH  (XFILPB,R4),BEGIN
         MOVEL XFILPB,FILPB,L'FILPB  Initialize it with our FILPB
         MVC   XFILPBNAME,FILPBCNAME  Set name to resolve
         CLEAR XFILPBFTYPWYL+XFILPBFTYPTSO     CNAME is
         SET   XFILPBFTYPEXACT              fully qual'd ML940726
         LA    R1,XFILPB           File parameters
         L     R15,BDSNESGP        Pass our error SEGCB ptr
         ACALL BUILDDSN            Expand current dsname
         BNZ   BDSNEXIT            Nested error, scram
         MVC   FILPBDSMEM,XFILPBDSMEM  Save current member name
         END   ,                      (with XFILPB)
         XPOP  ,,L'XFILPB
         END   ,                      (have current name)
*
         IF    (FILPBDSMEM,Z),BEGIN  No member name...
         SEGT  FILPBNAME,,.L:BDSNESGP
         SEG   ': illegal, no current member name.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (no member name)
         END   ,                      (expand *)

         IF    BDSN$$$$,BDSNCHK       if $dsn, no further processing
*                                     ml 19970613, 19970729
*-
*-       Add default library if member specified with no file name.
*-
         IF    ((R5,Z),AND,(FILPBDSMEM,NZ)),BEGIN  Mem w/no lib...
         XPUSH ,,L'XFILPB,PTR=R4   Make a new FILPB
         WITH  (XFILPB,R4),BEGIN
         MOVEL XFILPB,FILPB,L'FILPB  Initialize with our FILPB
         MVC   XFILPBNAME,FILPBSETLIB  Set name to resolve
         IF    (XFILPBNAME,Z),BEGIN If no default lib
         MVC   XFILPBNAME,GVTBLANK  Default lib to LIB
         MVC   XFILPBNAME(3),=CL3'LIB'
         END   ,                      (no default lib)
         LA    R1,XFILPB           File parameters
         L     R15,BDSNESGP        Pass our error SEGCB ptr
         ACALL BUILDDSN            Expand library prefix
         BNZ   BDSNEXIT            Nested error, scram
         MVC   FILPBDSNAME,XFILPBDSNAME  Save full library name
         MVC   FILPBDSACCT,XFILPBDSACCT  Copy ownership account too
         MVC   FILPBDTYPE,XFILPBDTYPE    ...and name type
         END   ,                      (with XFILPB)
         XPOP  ,,L'XFILPB
*
         CLEAR R15                 All done
         IF    (FILPBDSMEM,EQ,GVTBLANK),'CLEAR FILPBDSMEM' ml940516
         B     BDSNEXIT            Scram
         END   ,                      (mem w/no lib)
*-
*-       Handle resolving "*" file name.
*-         We expand CNAME with a recursive call to BUILDDSN
*-         and then exit.
*-
         IF    ((R5,EQ,1),AND,(@R6,EQ,'*')),BEGIN  * file name...
         IF    (FILPBCNAME,Z),BEGIN  No current filename...
         SEGT  FILPBNAME,,.L:BDSNESGP
         SEG   ': illegal, no current file name.',,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (no current filename)
*
         XPUSH ,,L'XFILPB,PTR=R4   Make a new FILPB
         WITH  (XFILPB,R4),BEGIN
         MOVEL XFILPB,FILPB,L'FILPB  Initialize it with our FILPB
         MVC   XFILPBNAME,FILPBCNAME  Set name to resolve
         CLEAR XFILPBFTYPWYL+XFILPBFTYPTSO    CNAME is
         SET   XFILPBFTYPEXACT              fully qual'd ML940726
         LA    R1,XFILPB           File parameters
         L     R15,BDSNESGP        Pass our error SEGCB ptr
         ACALL BUILDDSN            Expand library prefix
         BNZ   BDSNEXIT            Nested error, scram
*
         MVC   FILPBDSNAME,XFILPBDSNAME  Save expanded dsname
         MVC   FILPBDSACCT,XFILPBDSACCT  Save ownership account too
         MVC   FILPBDTYPE,XFILPBDTYPE    ...and name type
         IF    (FILPBDSMEM,EQ,GVTBLANK),'CLEAR FILPBDSMEM' ml940516
         IF    (FILPBDSMEM,Z),BEGIN      If not *#member
         MVC   FILPBDSMEM,XFILPBDSMEM    Save current member name
         END   ,                      (Not *#member)
         END   ,                      (with XFILPB)
         XPOP  ,,L'XFILPB
*
         CLEAR R15                 All done
         B     BDSNEXIT            Scram
         END   ,                      (* file name)
*-
*-       Check for "WYL.gg.uuu.<anything>" filenames.
*-
         IF    ((R5,GT,11),AND,(@R6,EQ,'WYL.')),BEGIN
         IF    (@R6+3,NE,'.'),EXIT
         IF    (@R6+6,NE,'.'),EXIT
         IF    (@R6+10,NE,'.'),EXIT
*                                  Specified user/grp override
         IF    (FILPBGROUP,NZ),'MVC @R6+4(2),FILPBGROUP'
         IF    (FILPBUSER,NZ),'MVC @R6+7(3),FILPBUSER'
         SEG   (R6),(R5)           Full dsname
         B     BDSNCHK
         END   ,                      (WYL.)
*-
*-       Check for "gg$uuu.<anything>" filenames.
*-
         IF    ((R5,GT,7),AND,(@R6+2,EQ,'$')),BEGIN
         IF    (@R6+6,NE,'.'),EXIT
*                                  Specified user/grp override
         IF    (FILPBGROUP,NZ),'MVC @R6(2),FILPBGROUP'
         IF    (FILPBUSER,NZ),'MVC @R6+3(3),FILPBUSER'
         SEG   (R6),(R5)           Full dsname
         B     BDSNCHK
         END   ,                      (gg$uuu)
*-
*-       Check for "SYSn.<anything>" filenames.
*-
         IF    ((R5,GT,5),AND,(@R6,EQ,'SYS')),BEGIN
         IF    ((@R6+3,LT,'0'),OR,(@R6+3,GT,'9')),EXIT
         IF    (@R6+4,NE,'.'),EXIT
         SEG   (R6),(R5)           Full dsname
         B     BDSNCHK
         END   ,                    (SYSn)
*-
*-       If Type=Wylbur means "WYL.gg.uuu.filename".
*-
         IF    FILPBFTYPWYL,BEGIN  Wylbur format...
         SEG   'WYL.'
*
         SETMSG FILPBGROUP         Group override
         IF    (FILPBGROUP,Z),BEGIN
         SETMSG FILPBSETGROUP      Default group
         IF    (FILPBSETGROUP,Z),'SETMSG TVTGROUP'
         END   ,                      (group)
         SEG   (R1),(R0)
         SEG   '.'
*
         SETMSG FILPBUSER          User override
         IF    (FILPBUSER,Z),BEGIN
         SETMSG FILPBSETUSER       Default user
         IF    (FILPBSETUSER,Z),'SETMSG TVTUSER'
         END   ,                      (user default)
         SEG   (R1),(R0)
         SEG   '.'
*
         SEG   (R6),(R5)
         B     BDSNCHK
         END   ,                      (WYL)
*-
*-       If Type=TSO means "gg$uuu.filename".
*-
         IF    FILPBFTYPTSO,BEGIN  TSO format...
         SETMSG FILPBGROUP         Group override
         IF    (FILPBGROUP,Z),BEGIN
         SETMSG FILPBSETGROUP      Default group
         IF    (FILPBSETGROUP,Z),'SETMSG TVTGROUP'
         END   ,                      (dflt group)
         SEG   (R1),(R0)
         SEG   '$'
         SETMSG FILPBUSER          User override
         IF    (FILPBUSER,Z),BEGIN
         SETMSG FILPBSETUSER       Default user
         IF    (FILPBSETUSER,Z),'SETMSG TVTUSER'
         END   ,                     (dflt user)
         SEG   (R1),(R0)
         SEG   '.'
*
         SEG   (R6),(R5)
         B     BDSNCHK
         END   ,                      (TSO format)
*-
*-       If Type=EXACT then don't change it at all.
*-
         IF    FILPBFTYPEXACT,BEGIN  Exact format...
         SEG   (R6),(R5)
         B     BDSNOK
         END   ,                      (exact)
*-
*-       Unknown file type.
*-
         SETMSG 'Unknown file type (expecting TYPE=WYLBUR).'
         B     BDSNERR
*-
*-       Do final data set name cleanup and checking.
*-
BDSNCHK  IF    (FILPBDSMEM,EQ,GVTBLANK),'CLEAR FILPBDSMEM'
*
         SETMSG BDSNBUF            Dsname
         VCALL RTRIM               Trim trailing blanks
         VCALL TOUPPER             Convert to upper case
         L     R2,BDSNSGLENF
         SH    R2,=AL2(L'FILPBDSNAME)  Too long?
         IF    POS,BEGIN           Yes...
         SEG   ': file name is ',,.L:BDSNESGP
         SEGDC (R2),,.L:BDSNESGP
         SEG   ' characters too long:',,.L:BDSNESGP
         SEGT  FILPBNAME,,.L:BDSNESGP
         B     BDSNERR
         END   ,                      (too long)
         B     BDSNOK              All done
*-
*-       Error return.
*-
BDSNERR  L     R5,BDSNESGP
         WITH  (SEGCB,R5),BEGIN
         IF    (SEGCBLENF,Z),BEGIN  Generic error message...
         SEGT  FILPBNAME,,.SEGCB
         SEG   ': illegal file name.',,.SEGCB
         END   ,                      (generic error)
*
         SETMSG L:SEGCBLOC,L:SEGCBLENF  Error message
         END   ,                      (with SEGCB)
*
         PRETURN (R0,R1)
         LA    R15,4
         B     BDSNEXIT
*-
*-       Normal return.
*-
BDSNOK   MVC   FILPBDSNAME,BDSNBUF  Return full dsname
         CLEAR FILPBFTYPWYL+FILPBFTYPTSO
         SET   FILPBFTYPEXACT       until proven otherwise...
*-
*-       Save owner's account for this file name.
*-         This means picking the "uuugg" out of a
*-         file name of the forms:
*-            . WYL.gg.uuu.FILENAME
*-            . gg$uuu.FILENAME
*-
         IF    ((FILPBDSNAME,EQ,'WYL.'),AND,                           *
               (FILPBDSNAME+3,EQ,'.'),AND,                             *
               (FILPBDSNAME+10,EQ,'.')),BEGIN     got WYL-style
         MVC   FILPBDSACCT(3),FILPBDSNAME+7  uuu
         MVC   FILPBDSACCT+3(2),FILPBDSNAME+4  gg
**-ml960930 IF    (FILPBDSACCT,EQ,TVTACCT),'SET FILPBFTYPWYL' if ours
         CLEAR FILPBFTYPTSO+FILPBFTYPEXACT  flags
         SET   FILPBFTYPWYL        ...WYL type
         END   ,                                 (got WYL-style)
*
         ELSEIF ((FILPBDSNAME+2,EQ,'$'),AND,                           *
               (FILPBDSNAME+6,EQ,'.')),BEGIN   got TSO-style name
         MVC   FILPBDSACCT(3),FILPBDSNAME+3  uuu
         MVC   FILPBDSACCT+3(2),FILPBDSNAME  gg
         CLEAR FILPBFTYPWYL+FILPBFTYPEXACT
         SET   FILPBFTYPTSO         Show TSO-style
         END   ,                               (got TSO-style)
*
         CLEAR R15                 A-ok
BDSNEXIT PEND
*
         SEGDEF DUMMY              (Neatness)
*
         QLTORG
         TITLE 'Check Dataset Name Syntax'
*box
*
*  CHECKDSN -- Routine to check that the file name conforms
*    to the OS data set name conventions.
*
*  Revised 1997/07/25 mcl:  Better conformance to OS DSNAME rules
*  (allow dash and x'C0').
*
*      On entry:
*        R1  - FILPB ptr
*        R15 - Error message SEGCB ptr
*
*      On exit, R15 (and CC):
*        0 = ok
*        nz= error, R1,R0 = error message loc, len
*
CDSNWA   RECORD BEGIN
CDSNESGP DS    A                   Error SEGCB ptr
CDSNTYPE DS    F                   Max TRT value for valid dsn chars
CDSNTYP2 DS    F                   Max TRT value for 2nd or later chr
         END
*-
CHECKDSN PROC  CDSNWA
         LR    R3,R1
         WITH  (FILPB,R3)
*
         ST    R15,CDSNESGP        Error SEGCB ptr
         SEGCLR .(R15)             Reset error SEGCB
*
         SETMSG FILPBDSNAME        File name
         VCALL RTRIM               Trim trailing blanks
*-
*-       Check for null file name.
*-
         LR    R6,R1
         LTR   R5,R0
         IF    NP,BEGIN            Null filename...
         SEG   'Null file name is not allowed.',,.L:CDSNESGP
         B     CDSNERR
         END
*-
*-       See if further checking is warranted.
*-

         IF    FILPBFSYNCHK,BEGIN  suppress syntax check
         CLEAR R15                 in case we quit here
** ml970613 we were suppressing only if quoted.  but wylbur strips
**-the quotes so we don't see them.  Now we'll try suppressing the
** check if the "no check" flag is set, period.  We set the flag
** for dsn of scratch oldname of rename.  Maybe should set it for
** USE too?  (anything but create?)
         EXIT  CHECKDSN            no furthr questions, Your Honor

**-      IF    FILPBFQUOTED,'EXIT CHECKDSN'  found quote above...
**-      CLI   FILPBNAME,C''''     given name as NAME='name'
**-      IF    EQ,'EXIT CHECKDSN'  so never mind
**-      CLI   FILPBNAME,C'"'      or double quote
**-      IF    EQ,'EXIT CHECKDSN'
         END   ,                      (suppress syntax)
*-
*-       Check file name character by character.
*-
         LA    R4,8                Max no. of chars per level
         MVC   CDSNTYPE,=A(1)      Allow dot, alpha, or national
         MVC   CDSNTYP2,=A(3)      2nd char above + numeric, dash
         WHILE (R5,POS),BEGIN
         LC    R2,@R6              Get char
         LC    R0,DSNCHR(R2)       Get char type
*
*                                  IF '.'
         IF    (@R6,EQ,'.'),BEGIN  dot
         IF    (R4,GE,8),BEGIN     Another dot...
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         SEG   ': illegal file name',,.L:CDSNESGP
         SEG   ' (file name has two dots together).',,.L:CDSNESGP
         B     CDSNERR
         END   ,                      (another dot)
         IF    (~TVTPBFREQSHOWDSN,AND,(R5,EQ,1)),BEGIN  Ends with dot
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         SEG   ': illegal file name',,.L:CDSNESGP
         SEG   ' (file name ends with a dot).',,.L:CDSNESGP
         B     CDSNERR
         END   ,                      (ends with dot)
         LA    R4,8                Allow eight more chars
         MVC   CDSNTYPE,=A(1)      Allow dot, alpha, or national
         END   ,                      (dot)
*
*                                  IF '('
         ELSEIF (@R6,EQ,'('),BEGIN    Lib member or GDG
         LA    R2,0(R6,R5)
         DECR  R2                  ->last char
         IF    (@R2,NE,')'),BEGIN    ...isn't closing )
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         SEG   ': illegal file name.',,.L:CDSNESGP
         SEG   'Mismatched parenthesis.',,.L:CDSNESGP
         B     CDSNERR
         END   ,                      (no closing paren)
         LC    R2,1(R6)            char. after (
         LC    R0,DSNCHR(R2)       type of char after (

*  Checking member name or GDG (relative generation reference)
*  R2 = the first character  R6 -> opening paren  R5 = remaining length

         IF    ((R5,EQ,3),AND,(@R6,EQ,'(0)')),CDSNOK   base(0) GDG ref

         IF    ((R2,NE,C'+'),AND,(R2,NE,C'-')),BEGIN  Not a GDG ref.

*  Member of PDS
*  NOTE:  BUILDDSN code normally strips out membername (but not GDG
*  ref), so the folowing code is bypassed.       ml19970819

         DECR  R5                  ignore ')'
         LA    R4,8                max. member name length
         MVC   CDSNTYPE,=A(1)      to check 1st char of member
         MVC   CDSNTYP2,=A(2)      to check 2nd etc. chars
         END   ,                       (not a GDG)

         ELSE  BEGIN               Otherwise, check as GDG
         INCR  R6                  ->char. after (
         DECR  R5                  length
         DECR  R5  ignore ')'

         IF    ((R2,EQ,C'+'),OR,(R2,EQ,C'-')),BEGIN  +nn or -nn GDG
         INCR  R6                  skip +
         DECR  R5                    or -

*  Have dsn(+nnnn) or dsn(-nnnn).  Check the nnnn part     ml970725
*  R6->nnnn   R5=length of nnnn part

         IF    ((R5,NP),OR,(R5,GT,4)),BEGIN  unary +- or too long.
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         SEG   ': illegal file name:  ',,.L:CDSNESGP
         SEG   'Invalid relative generation ',,.L:CDSNESGP
         S     R6,=A(2)            back up to (
         A     R5,=A(3)            restore (+   )
         SEG   @R6,(R5),.L:CDSNESGP  the (junk)
         B     CDSNERR
         END   ,                      (unary +-/bad char)

         DEX   R5,'TRT @R6,NUMCHR'  check for non-numeric
         IF    Z,CDSNOK            all OK, done

*   Invalid (non-numeric) character found

         SEG   @R1,1,.L:CDSNESGP   the bad char (set by TRT)
       SEG ': illegal character in relative generation ',,.L:CDSNESGP
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         B     CDSNERR

         END   ,                      (+nn or -nn)

         END   ,                      (check as GDG)
         END   ,                      (member or GDG)
*
*                                  OTHER CHARACTERS
         ELSE  BEGIN               All other chars
         IF    (R0,GT,CDSNTYPE),BEGIN Illegal character ...
         IF    (@R6,NE,C' '),BEGIN other than blank
         SEG   @R6,1,.L:CDSNESGP
         SEG   ': illegal character in file name ',,.L:CDSNESGP
         END   ,                      (other than blank)
         ELSE  BEGIN               bad char is a blank
         SEG   'blank illegal in file name ',,.L:CDSNESGP
         END   ,                      (blank in dsname)
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         B     CDSNERR
         END   ,                      (illegal char)
         DECR  R4
         IF    (R4,NEG),BEGIN      Over 8 chars w/o a dot...
         SEGT  FILPBDSNAME,,.L:CDSNESGP
         SEG   ': illegal file name',,.L:CDSNESGP
         SEG   ' (over 8 characters without a dot).',,.L:CDSNESGP
         B     CDSNERR
         END   ,                      (over 8)
         MVC   CDSNTYPE,CDSNTYP2   Allow numbers too now ml970725
         END   ,                      (all other chars)
*
         LA    R6,@R6+1
         DECR  R5
         END   ,                      (loop)
*
         B     CDSNOK              All done
*-
*-       Error return.
*-
CDSNERR  L     R15,CDSNESGP
         WITH  (SEGCB,R15),'SETMSG L:SEGCBLOC,L:SEGCBLENF'  Err msg
         PRETURN (R0,R1)
         LA    R15,4
         B     CDSNEXIT
*-
*-       Normal return.
*-
CDSNOK   CLEAR R15                 A-ok
CDSNEXIT PEND
*
         SEGDEF DUMMY              (Neatness)
*
         QLTORG
*-
*-       OS file name character type table. rev. 1997/07/25 mcl
*-
*-         0 - Dot (.)
*-         1 - Alphabetic or National ($,@,#)
*-         2 - Numeric (including X'C0')
*-         3 - dash
*-       255 - Everything else
*-
DSNCHR   DC    256X'FF'
         ORG   DSNCHR+C'.'
         DC    X'00'
         ORG   DSNCHR+X'C0'
         DC    X'02'               "+0" like numeric       ml970725
         DC    X'010101010101010101' C1-C9 (A-I)
         ORG   DSNCHR+C'J'
         DC    X'010101010101010101'
         ORG   DSNCHR+C'S'
         DC    X'0101010101010101'
         ORG   DSNCHR+C'$'
         DC    X'01'
         ORG   DSNCHR+C'@'
         DC    X'01'
         ORG   DSNCHR+C'#'
         DC    X'01'
         ORG   DSNCHR+C'0'
         DC    X'02020202020202020202'
         ORG   DSNCHR+C'-'
         DC    X'03'
         ORG   ,
NUMCHR   DC    256X'FF'            Check for numeric
         ORG   NUMCHR+C'0'
         DC    10X'00'             0-9
         ORG   ,
         TITLE 'Check Return Code from Last Dynamic Allocation'
*box
*
*  DYNCHECK - Process return code from last dynamic allocation
*             call.
*
*  On entry:   R15 contains the address of a fullword which points
*                  to the DYNTABLE control block
*
*  On exit:    R15=0 The dynamic allocation request was successful.
*                 =4 The dynamic allocation request was successful
*                    but a warning message is present due to the
*                    information reason code left the SVC99 request
*                    block.  The error message is in ERRSCB.
*                 =8 The dynmaic allocation request was failed.
*                    The ERRSCB control block contains a formatted
*                    message.
*

DYNCHWK  RECORD BEGIN
DYNCHRGD DC    C'(0000-0000)+'''   info/reason code area, quote
         ORG   DYNCHRGD
         DC    C'('
DYNCHRG1 DC    C'0000',C'-'        first digits
DYNCHRG2 DC    C'0000',C')'        second digits
DYNCHRGM DC    C'+'                "+" for more info
         ORG   ,
         DC    0F'0'
##EMLINK LINK  EP=IEFDB476,SF=L    area for link parm list
#EMLINK  EQU   *-##EMLINK          length
EMLINK   EQU   ##EMLINK,#EMLINK    define area
EMLINK@  DC    A(0)                parmlist pointer
         END   ,                   (DYNCHWK)

DYNCHECK PROC  DYNCHWK
         L     R2,@R15             Load address of dyntable control
         WITH  (DYNTABLE,R2)       Addressability to dynamic buffer
         IF    (DYNTID,NE,C'DYNB'),BEGIN     Validity check CB
         FAIL  'Bad DYNTABLE address passed' Fail with message
         END   ,                      (FAIL)

         SEGCLR ERRSCB             Clear error buffer

*  Get return codes

         L     R3,DYNTRETC         R3 - RETURN CODE
         L     R4,DYN99CBP         ->parmlist
         WITH  (S99RB,R4)          S99RB area

*  Prepare dump of error/info codes

         MVC   DYNCHRGD,=C'(0000-0000) '''       prime it
         BTX   DYNCHRG1,4,L2:S99ERROR    error code
         BTX   DYNCHRG2,4,L2:S99INFO     info code

* format error/info messages

         L     R5,S99S99X          ->RB extension
         WITH  (S99RBX,R5)
         CLI   S99ENMSG,0          any messages?
         IF    NZ,BEGIN            yes, format them
         MVI   DYNCHRGM,C'+'       sho more msgs available

         CLEAR TVTEMBFA
         LA    R3,TVTEMBFA         ->EMBUF area
         WITH  (EMPARMS,R3),BEGIN  address it
         MVI   EMFUNCT,EMRETURN    return formatted msgs to us
         MVI   EMIDNUM,EMSVC99     we are caller with SVC99 err
         MVC   EMNMSGBK,S99ENMSG   number of msgs
         ST    R4,EMS99RBP         ->parmlist
         CLEAR R0
         IC    R0,EMNMSGBK         #msgs
         STH   R0,TVTEMBFC         save count
         SLL   R0,8                *256 per msg
         STH   R0,TVTEMBFL         save length
         GETMAIN R,LV=(0)          storage for buffers
         ST    R1,TVTEMBFP         save pointer
         ST    R1,EMBUFP           ...and in parmlist
         SET   TVTEXMSG            Show messages exist
         MVC   EMRETCOD,DYNTRETC   RETURN CODE from SVC99
         MVC   EMLINK,EMLINK#      (pgm) parmlist for link
         ST    R3,EMLINK@          (data) parmlist for link

         LINK  SF=(E,EMLINK),MF=(E,EMLINK@)   call IEFDB476
         PTRACE IEFDB476
         END   ,                   (with EMPARMS)
*? CHECK RC?
         END   ,                      (format msgs)

*                                  INVALID PARM LIST FOR SVC99
         L     R3,DYNTRETC         R3 - RETURN CODE
         IF    (R3,EQ,12),BEGIN    Invalid parameter list
         SEGB  'ERRID=SVC99ERR'    Indicate svc99 allocation error
         SEG   'ERRMSG=''SVC99 invalid parameter list'
         SEG   DYNCHRGD            reason/info and close quote
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (invalid parm list)
*
*
         ELSEIF (R3,EQ,8),BEGIN    Installation failed request
         SEGB  'ERRID=SVC99ERR'    Indicate allocation error
         SEG   'ERRMSG=''Installation verification routine '
         SEG   'has failed the SVC99 request.'
         SEG   DYNCHRGD
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (installation failed req)


         ELSEIF (R3,EQ,4),BEGIN    Environmental error

         IF    (S99ERROR,EQ,X'210'),BEGIN    dataset in use
         SEG   'ERRID=INUSE ERRMSG='''
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' data set is in use.  '
         SEG   DYNCHRGD            reason, info, quote
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (0210)

         IF    (S99ERROR,EQ,X'0218'),BEGIN  volume not mounted
         SEG   'ERRID=NOTMNTD ERRMSG='''
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' volume '
* Get volser
         IF    (TVTPBVOL,NZ),BEGIN  specific volume was given
         SEG   TVTPBVOL             so report it
         END   ,                    (specific)
         ELSE  BEGIN               no vol given, must be catlgd
         SEG   TVTCATVOL           so use catlg vol
** see EFSETUP for volume choice logic
         END   ,                    (no vol given)
         SEG   ' is not mounted.  '
         SEG   DYNCHRGD            reason, info, quote
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (0210)
*
         IF    (S99ERROR,EQ,X'4714'),BEGIN  4714:  no space
         SEG   'ERRID=NOSPACE ERRMSG='''
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' cannot find sufficient disk space.  '
         SEG   DYNCHRGD            reason, info, close quote
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (4714)


         IF    (S99ERROR,EQ,X'4704'),BEGIN   duplicate name on vol

         IF    (~TVTPBFREQREPLACE),BEGIN   user didn't say REPLACE
         SEG   'ERRID=EXISTS ERRMSG='''
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' already exists.  '
         SEG   DYNCHRGD            code dump
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (4704/noreplace)

*box
*
*  OK, we got 4704 (dup name) but REPLACE was set and in theory we
*  already looked for the original (in catlg and/or specified vol)
*  and didn't find it...
*

         IF    (TVTPBFOVOLTEMP),BEGIN   SAVE ... TEMP REPLACE

*  If user did SAVE ... TEMP REPLACE, we're not using SMS for TEMP,
*  and a duplicate uncatlg'd file is on our temp volume...we get 4704.
*  We didn't find it in the catalog, and we did nonspecific vol req to
*  UNIT=SYSDA, and there was a dupe on e.g. SCR002.

         IF    (TVTTMVOL#,NZ),BEGIN  TEMP VOL defined
         MVI   TVTUCFLG,1          Show no uncatlg on scratch
         LA    R0,TVTPBDSNAME      dsn
         LA    R1,TVTTMVOL         volume list
         ACALL SCRPS               Do scratch
*  Ignore RC, may have tried on several vols, succeeding on one is OK
         IF    (~TVTFDYNRTX),BEGIN  have not already retried
         SET   TVTFDYNRT0          try it again, sam
         END   ,                     (haven't already)
         LA    R15,8               RC
         B     DCKDONE
         END   ,                      (tempvol defined)

         ELSE  BEGIN               no tempvol defined
         B     DAIRFAIL            we lose, no way to recover
         END   ,                      (no tempvol)
         END   ,                      (TEMP REPL)

* if we got here, then it was SAVE ... REPLACE, not TEMP
         B     DAIRFAIL            abandon all hope

         END   ,                      (4704)

*
*  Check for 57xx errors                         ML950612

         LH    R0,S99ERROR
         SRL   R0,8                57xx becomes 0057
         IF    (R0,EQ,X'0057'),BEGIN             57xx:  catalog error
         IF    (S99ERROR,EQ,X'5708'),BEGIN can't catlg
         SEG   'ERRID=EXISTS ERRMSG=''' assume it's duplicate name
         LA    R15,ERRSCB
         ACALL FMTDSN              DSN to msg
         SEG   ' is already cataloged.  '
         SEG   DYNCHRGD            reason, info, close quote
         LA    R15,8               RC
         B     DCKDONE
         END   ,                      (5708)

         IF    (S99ERROR,EQ,X'5718'),BEGIN             GDG catlg err
         SEG   'ERRID=CATERR ERRMSG='''
         LA    R15,ERRSCB
         ACALL FMTDSN
         SEG   ' cannot be cataloged, invalid GDG reference.  '
         SEG   DYNCHRGD            reason, info, close quote
         LA    R15,8
         B     DCKDONE
         END   ,                      (5718)

*  Other 57xx, unusual error

         SEG   'ERRID=CATERR ERRMSG='''
         LA    R15,ERRSCB
         ACALL FMTDSN
         SEG   ' cannot be cataloged, catalog error code '
         SEG   DYNCHRGD            reason, info, close quote
         LA    R15,8               RC
         B     DCKDONE

         END   ,                      (57xx)

*                                  OTHER ERRORS, GET GENERIC MESSAGE
DAIRFAIL LABEL ,
         SEG   'ERRID=SVC99ERR ERRMSG=''' dynamic allocation error
         SEG   'Dynamic allocate failed, RC('
         SEGHX (R3),4              Report svc99 return code
         SEG   ')  err/inf '
         SEG   DYNCHRGD            reason/info codes
         LA    R15,8               Set return code
         B     DCKDONE
         END   ,                      (environmental error/RC=4)

         IF    (R3,Z),BEGIN        No error
         CLEAR R15
         IF    (S99ENMSG,NZ),BEGIN but had messages
         MVI   DYNCHRGM,C'+'       sho more msgs available
         SEG   'INFOMSG='''        Indicate info messages present
         SEG   DYNCHRGD            reason/info and close quote
         LA    R15,4               Show "OK but have msgs"
         END   ,                      (but had msgs)
         END   ,                      (no error)

DCKDONE  LABEL ,

         PEND  ,

EMLINK#  LINK  EP=IEFDB476,SF=L
         TITLE 'DELCAT - Delete System Catalog Entry'
*box
*
*  DELCAT  --  Delete catalog entry from system catatlog'
*
*    On entry:
*        R0    Contains address of 44-byte left justified DSN.
*
*    On Exit:
*        R15   Contains zero for successful completion
*        R15   Non-zero ERRSCB contains error information
*
         SPACE 2
DELCAT   PROC  ,
         LR    R2,R0               Save address of data set name
         L     R15,=A(CAMCATDL)
         MVC   OSFCAMCT(12),@R15       move in model camlst
         ST    R2,OSFCAMCT+4           set address of data set name
         CATALOG OSFCAMCT              uncatalog data set
         IF    (R15,NZ),BEGIN
*-
*-       Place delete catalog error message in ERRSCB
*-
         LR    R2,R15              Save catalog return code
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CATERR ERRMSG=''Delete catalog error, return='
         SEGDC (R2),0              Report return code
         LA    R15,4               Set error return code
         SEG   ''''                Terminate error message
         END   ,
         PEND  ,
         TITLE 'CATALOG: Catalog Passed Dataset Name'
*box
*
*  CATALOG  --  Catalog passed data set in system catalog
*
*    On entry:
*        R0    Contains address of 44-byte left justified dsn
*        R1    Contains address of volume list
*              Volume list:
*              +0  2  Binary volume count
*              +2  4  Device type
*              +6  6  Volume serial
*              +12 2  Data set sequence number
*
*    On Exit:
*        R15   Contains zero for successful catalog operation.
*              Contains non-zero for catalog error
         SPACE 2
CATALOG  PROC  ,
         LR    R2,R0               Save data set name pointer
         LR    R3,R1               Save pointer to volume list
         L     R15,=A(CAMCATCT)
         MVC   OSFCAMCT(20),@R15       Move in model camlst
         ST    R2,OSFCAMCT+4           Set address of data set name
         ST    R3,OSFCAMCT+12          Set address of volume list
         CATALOG OSFCAMCT              Catalog data set
         IF    (R15,NZ),BEGIN
*-
*-       REPORT CATALOG ERROR
*-
         LR    R2,R15              Save catalog return code
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=CATERR ERRMSG=''catalog error,return='
         SEGDC (R2),0              Report return code
         SEG   ''''
         LA    R15,4               Set error return code
         END   ,
         PEND  ,
         TITLE 'CATLOC - Locate Dataset in Catalog'
*box
*
*  CATLOC  --  Locate data set in system catalog
*
*    On entry:
*        R1    Contains address of 44-byte left justified dsn
*        R0    Contains address of 10 byte return area, filled in
*              with first volume serial information for return zero
*              If R0=0, no info is returned
*
*    On exit:
*        CC=Z
*               R1     Contains address of complete volume list
*                      The list is saved in OSFCATWK.
*        CC=NZ
*              (R0,R1) Contains length, location of error message
*              ...also in ERRSCB
*              R15     Contains catalog return code
*
         SPACE 2
CATLOC   PROC  ,
         LR    R2,R0               Address of return area
         LR    R3,R1               Address of data set name
         L     R15,=A(CAMCATMD)
         MVC   OSFCAMCT(16),@R15       Move in model camlst
         ST    R3,OSFCAMCT+4           Save pointer to data set name
         LA    R0,OSFCATWK             Address of catalog work area
         ST    R0,OSFCAMCT+12          Save pointer to work area
         LOCATE OSFCAMCT               Locate data set via catalog
         PTRACE CATLOCRT               Trace locate return code
         LR    R4,R15              Save locate return code

         IF    (R15,Z),BEGIN       R15=0:  found it
         CLC   OSFCATWK(12),=XL12'0'   If zero cat volume, treat as
         IF    EQ,BEGIN            if not found at all...May happen
         LA    R4,8                with future GDG reference.
         B     CATNOTLOC
         END   ,                      (zero cat vol)
         IF    (R2,NZ),BEGIN       if return wanted
         MVC   @R2(10),OSFCATVL    Return first located volume
         END   ,                      (return wanted)
         LA    R1,OSFCATWK         Address of volume list
         PRETURN (R1)              Return address of complete list
         EXIT  CATLOC              Exit command procedure
         END   ,                      (R15=0)

         IF    (R15,EQ,8),BEGIN    Not located in system catalog
CATNOTLOC LABEL ,
         SEGCLR ERRSCB             Clear segment buffer
         SEGLD ERRSCB              Set error segment buffer
         SEG   'ERRID=NOTFOUND ERRMSG='''
         L     R1,OSFCAMCT+4       Address of data set name
         LA    R0,44               Set maximum length of name
         VCALL RTRIM               Trim trailing blanks
         SEGB  (R1),(R0)           Add to message
         SEG   'not found.'''
         LR    R15,R4              RESET RETURN CODE
         END   ,                      (not located)

         ELSE  BEGIN               unusual error
         XPUSH R15,R0              Save R15 and R0 for message
         SEGCLR ERRSCB             Clear error message
         SEG   'ERRID=CATERR ERRMSG='''
         XPOP  R2,R3               Retrieve r15 and r0
         SEG   'Catalog error R15='
         SEGDC (R3)                Report R15 value
         SEG   ', R0='
         SEGDC (R2)                Report R0 value
         SEG   ''''
         END   ,                      (unusual error)

         LR    R15,R4              Reset locate return code
         LH    R0,ERRSCBLENF       Load current length
         L     R1,ERRSCBLOC        Load message address
         PRETURN (R0,R1)
         PEND  ,
         LTORG ,
         TITLE 'Obtain FMT3 DSCB'
*box
*
*  OBTFMT3 - Obtain format 3 DSCB.
*
*  On entry:   R0 - Contains the address of the desired CCHHR
*              R1 - Contains the address of the volume serial
*
*  On exit:         The OSFFMT3 data area contains the FMT3 DSCB
*

OBTFMT3  PROC  ,
         L     R15,=A(CAMOBSK)     Address of model camlst
         MVC   OSFCAMCT(16),@R15   Move in model camlist
         ST    R0,OSFCAMCT+4       Address of cchhr required
         ST    R1,OSFCAMCT+8       Address of required volume serial
         LA    R0,OSFFMT3          Address of fmt3 area return
         ST    R0,OSFCAMCT+12      Address to recieve fmt3
         OBTAIN OSFCAMCT           Read in fmt3 dscb
         PTRACE OBTFMT3RT
         PEND  ,
         TITLE 'Obtain FMT1 DSCB'
*box
*
*  OBTFMT1 - Obtain format 1 DSCB for passed data set name.
*
*  On entry:   TVTPBDSNAME contains the fully qualified data set name
*              and the TVTVOLSER field must contain the volume
*              serial number for the DASD device.
*
*  On exit:    For R15=0 the TVT field OSFFMT1 contains the 96
*              byte portion of the requested FMT1 DSCB.
*
*              For R15=NZ an error message has been seg'd.
*

OBTFMT1  PROC  ,
         L     R15,=A(CAMOBT)
         MVC   OSFCAMCT(16),@R15   Move in model camlist control
         LA    R1,TVTPBDSNAME      Address of fully qual dsn
         ST    R1,OSFCAMCT+4       Save address in camlist
         LA    R1,TVTVOLSER        Address of volume serial
         ST    R1,OSFCAMCT+8       Save address in camlist
         LA    R1,OSFDSCWK         Address of work area
         ST    R1,OSFCAMCT+12      Save address in camlist
         OBTAIN OSFCAMCT           Read in fmt1 dscb
         PTRACE obfmt1RT           Trace return code
         LTR   R2,R15              Save and test obtain return code
         IF    Z,BEGIN             Successful obtain has been done
         MVC   OSFFMT1(44),TVTPBDSNAME Set data set name into FMT1
         MVC   OSFFMT1+44(96),OSFDSCWK Move in fmt1 dscb
         END   ,                      (successful)

         ELSEIF (R15,EQ,4),BEGIN   Volume not mounted error return
         SEGCLR ERRSCB             Clear error buffer
         SEGB  'ERRID=NOTMNTD'     Volume not mounted
         SEG   'ERRMSG='''         Report volume
         SEGB  'Volume'            Report volume serial number
         L     R1,OSFCAMCT+8       Address of volume serial
         SEGT  (R1),6              Set volume serial into message
         SEG   ' is not mounted.'''
         END   ,                      (not mounted)

         ELSEIF (R15,EQ,8),BEGIN   Data set not on volume
         SEGCLR ERRSCB             Clear error seg buffer
         SEGB  'ERRID=NOTONVOL'    Data set not found
         SEG   'ERRMSG='''
         LA    R15,ERRSCB          Address of error scb
         ACALL FMTDSN              Format data set name into message
         SEGB  ' is not on'        Report not on volume
         L     R1,OSFCAMCT+8       Address of volume serial
         SEGT  (R1),6              Add volume serial to message
         SEG   ''''                Add last quote
         END   ,                      (not on vol)

         ELSE  BEGIN               Process unkown return codes
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=VTOCERR'     Specify unknown error type
         SEG   'ERRMSG=''Obtain error, R15='
         SEGDC (R2)                Add to message
         SEG   ''''                Close quote
         END   ,                      (unknown rc)

         LR    R15,R2              Set error return code
         PEND  ,
         TITLE 'Process Error Recovery Stack'
*BOX
*
*  RECOVERY - PROCESS THE ERROR RECOVERY STACK
*

RECOVERY PROC  ,
         IF    (TVTRLAST,NE,-1),BEGIN
         FAIL  'RECOVERY STACK OVERFLOW!'
         END   ,
         L     R2,TVTRCYST         Load index to recovery stack
         CLEAR R3                  Zero work register to stack clear
         WHILE (R2,NZ),BEGIN       Call each recovery routine
         L     RAR,TVTRCYST(R2)    Load address of recovery routine
         ST    R3,TVTRCYST(R2)     Clear recovery routine address
         BALR  RAR,RAR             Enter recovery routine (AMODE!)
         S     R2,=A(4)            Decrement stack index
         END   ,
         CLEAR TVTRCYST            Clear recovery stack index
         PEND  ,
         TITLE 'PRTCMD - Print Passed Command to Log File'
*box
*
*  Print passed command to logging file
*
*  On entry:   R0 contains the total length of the command.
*              R1 contains the address of the command.
*              R15 contians the address of a valid SEGCB.
*
*  On exit:    The command is printed.
*
         SPACE 2
PRTCMDWA RECORD BEGIN
PRTCMLRL DS    F                   LRECL of printfile
PRTCMMIN DS    F                   minimum length to keep when
*                                  breaking lines
         END   ,                      (PRTCMDWA)
         SPACE
PRTCMD   PROC  PRTCMDWA
         IF    TVTREPT,BEGIN
         LR    R7,R15              Move passed SEGCB pointer
         LR    R2,R0               Save passed length
         LR    R3,R1               Save address of command
         SEGLD (R7)                Set logging segment buffer
         LR    R15,R7              Move address of segcb pointer
         ACALL LOGTIME             Set current time into message
         IF    (R2,GE,16),BEGIN    Output command header
         SEG  @R3,16               Seg buffer prefix
         LA    R3,@R3+16           Update buffer address
         SL    R2,=A(16)           Decrement length
         SEG   'Line='             report line no.         ml960215
         LH    R0,TVTLINE          partner's line-number   ml960215
         SEGDC (R0),4              into msg                ml960215
         SEG   ' Account='         Report path owner
         SEG   TVTGROUP            Report group code of path owner
         SEG   '.'                 Set '.' for separator
         SEG   TVTUSER             Report use code of path owner
         IF    TPATAUTH,'SEG " (Auth)"'  Authorized caller
         IF    TPATSPR,'SEG " (Sys)"'  User has sys privs
         L     R6,TVTUPATH         Address of path control block
         WITH  (UPATH,R6),BEGIN    Addressability to upath
         IF    (UPATPJOB,NZ),BEGIN Report subsystem or jobname
         SEG   ' Subsystem='       Set title for subsystem
         SEGT  UPATPJOB            Report sybsystem name
         END   ,
         END   ,
         SEGWR ,                   Output command header
         END   ,

         LA    R4,OSFDCBPR         Address of print DCB
         WITH  (IHADCB,R4),BEGIN   Addressability to DCB
         LH    R0,DCBLRECL         LRECL of printfile
         END   ,                      (with DCB)
         S     R0,=F'4'            It's VB format...
         S     R0,=A(PRTCMIN)      less indent value
         ST    R0,PRTCMLRL         ...the available data length
         SRL   R0,1                /2
         ST    R0,PRTCMMIN         is most to cut when breaking
         WHILE (R2,GE,PRTCMLRL),BEGIN    Must break it up

*  Try to break it at a blank                              ml960102
*  R3->data   R2=length

         L     R4,PRTCMMIN         most we can waste
         L     R5,PRTCMLRL         max we can print
         LA    R5,0(R5,R3)         ->past last we could print
PRTCLOOP CLI   @R5,C' '            blank there?
         BE    PRTBRK              OK
*  try again
         BCTR  R5,0                back up one
         BCT   R4,PRTCLOOP         and look again
*  fell thru, use max length
         L     R5,PRTCMLRL         the max.
         B     PRTBRKM
*  found it.  R5-> just past breakpoint
PRTBRK   SR    R5,R3               Get length to use here
PRTBRKM  SEG   PRTCMID             Provide indentation
         SEG   (R3),(R5)           Set into segment buffer
         SEGWR ,
         LA    R3,0(R3,R5)         Bump to next line
         SR    R2,R5               Decrement length
         CLI   @R3,C' '            we broke at blank?
         IF    EQ,BEGIN            skip
         LA    R3,1(R3)                 the
         BCTR  R2,0                         blank
         END   ,                      (skip blank)
         END   ,                      (break up record)

         IF    (R2,NZ),BEGIN       Check for any residual data
         SEG   PRTCMID             Provide indentation
         SEG   (R3),(R2)           Report final line
         SEGWR ,                   Write final line
         END   ,
         SEGCLR ,                  Clean out any extraneous stuff
         END   ,
         PEND  ,                   Return to procedure caller
PRTCMID  DC    C'   -> '           Provide indentation
PRTCMIN  EQU   L'PRTCMID           the indent value
         TITLE 'Add Timestamp to Message'
*box
*
*  Set current time of day (local time) into passed segcb file
*
*  On entry:   R15 contains the address of a valid SEGCB.
*
*  On exit:    The current time of day has been added
*

LOGTIME  PROC  ,
         LR    R2,R15              MOVE SEGCB POINTER
         XPUSH ,,12,PTR=R4         Get stack space
         STCK  TVTSTCK             Current time of day
         LM    R0,R1,TVTSTCK       Set into parameter registers
         L     R5,CVTPTR
         WITH  (CVT,R5),'AL R0,CVTTZ'  Time zone adjustment
         ST    R0,TVTSTCK          save adjusted (local) time
         LR    R15,R4              Move address of work area
         XCALL FMTNDATE            Convert date            ml960102
         LA    R1,5(R1)            skip year
         S     R0,=F'5'             ...
         SEGB  (R1),(R0),(R2)      Set mm/dd into message
         LM    R0,R1,TVTSTCK       Set into parameter registers
         LR    R15,R4              Move address of work area
         XCALL FMTTIME             Convert time
         SEGB  (R1),(R0),(R2)      Set time into message
         XPOP  ,,PTR=R4            Restore stack pointer
         PEND  ,
         LTORG ,
         TITLE 'XPRTCMD - External entry to log errors.'
*BOX
*
*  XPRTCMD - External entry to log errors
*
*  On entry:   R0 contains the total length of the message
*              R1 contains the address of the message
*
*  On exit:    Passed command has been written to the log file
*

XPRTCMD  XPROC ,
         LA    R15,OSFSCB          Address of logging seg buffer
         ACALL PRTCMD              Log the command
         CLEAR R15                 Zero return code
         PEND  ,
         TITLE 'PATHERR: Cleanup after SCOM error in PATH'
*box
*
*  PATHERR - Process buffer full condition from path write
*
*        This routine is entered from the PATH routines when an
*        error return code is encountered on the SCOM path write
*        request.  The only error processed currently is a SUZAN
*        client buffer full condition.
*
*  On Entry:   R15 contains the address of the SEGCB
*              R1  contains the SCOM return code
*              TVT addressable, we hope                    ML940222
*
*  On Exit:    R15=0 - Recovery successful, attempt to resend
**   not yet-> R15=NZ - Abort, timed out                   ML940218
*              on error not timeout, just branch to CMDCLEAN
         SPACE 2
PATHERWA RECORD BEGIN
UTIMERL  STIMERM SET,MF=L
#UTIMERL EQU   *-UTIMERL           L'list
         END   ,
PATHERR  PROC  PATHERWA
         L     R9,=A(OSFCOMMN)
         LR    R2,R15              Move segcb address
         WITH  (SEGCB,R2)          Addressability to segcb
         L     R3,SEGCBUSR         Address of upath control block
         WITH  (UPATH,R3)          Addressability to upath cb
*-
*-       Process client buffer full condition
*-
         IF    (R1,EQ,UPATRBAF),BEGIN Client buffer is full
         L     R4,UPATECB          Load address of ECB
**-ml    XC    @R4(4),@R4          Clear ecb for wait
         CLEAR R15                 RC if this works
         TM    @R4,X'40'           posted already?
         IF    NO,BEGIN notpost0   not posted yet:
         L     R0,@R4              ECB contents
         CLEAR R14                 alternate ECB: cleared
         CS    R0,R14,@R4          look again, clear if not posted
         IF    Z,BEGIN  notpost1   hasn't been posted, wait for it
         LA    R1,UTIMERL            address of stimerm parameter list
         MVC   0(#UTIMERL,R1),UTIMERL0 set parameter list
*  hope we got TVT addressability below...                 ml940218
         SET   UPATTWAIT           show we're waiting      ml940222
         CLEAR TVTBTECB            timer ecb
         STIMERM SET,BINTVL=TVTBFTIM,EXIT=UPTOEXIT,PARM=TVTBWECL,      X
               WAIT=NO,ID=UPATTOID,MF=(E,UTIMERL)
         IF    (R15,NZ),'FAIL "Bad STIMERM call"'
         PTRACE UTIMEROK            Trace timer set
**WAIT ON BOTH ECBS
         WAIT  1,ECBLIST=TVTBWECL  Wait for buffer to empty
**CANCEL TIMER
         TM    @R4,X'40'           SUZAN posted complete
         IF    O,BEGIN  success    Yes, a success
         STIMERM CANCEL,ID=UPATTOID,MF=(E,UTIMERL) quit waiting
         CLEAR UPATTWAIT           forget we were waiting
         CLEAR R15                 RC maybe
*notyet  IF    ~UPATSPST.UPATFFQE,BEGIN  posted for wrong reason
*notyet  IC    R15,UPATSPST        Use flags as the bad RC
*notyet  END   ,
         END   ,        success
** we timed out waiting for the buffer to empty.
         ELSE  BEGIN    stoodup    Client has stood us up
         SEGCLR OSFSCB             Clear report segcb
         ACALL LOGTIME             time stamp it
         SEG   'Timed out waiting on path buffer.  User='
         SEG   TVTGROUP            gg                      ML940222
         SEG   '.'                 .                       ML940222
         SEG   TVTUSER             uuu                     ML940222
         SEGWR ,
         SET   TPATERR+TPATPERR    Indicate path re-queue
         QSNAP 'Timed out waiting on path buffer'
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=TIMEOUT'     Indicate path timeout
         SEGB  'ERRMSG=''Timed out waiting for WYLBUR'
         SEGB  ''''                Terminate message
** should set RC here and return
**       LA    R15,8               Indicate error
         CMDABORT MSG=NO           Abort current command
         END   ,        stoodup
         END   ,        notpost1
         END   ,        notpost0
         ELSE BEGIN  ,  wasposted
         QSNAP 'recovered from path post error'
         END   ,        wasposted
         END   ,        cbuffull
*-
*-       Process client has prematurely died
*-
         ELSEIF (R1,EQ,UPATRNOP),BEGIN Client has gone away
         SEGCLR OSFSCB             Clear report segcb
         ACALL LOGTIME             time stamp it           ML940118
         SEG   'Path closed unexpectedly by '              ML940222
         SEG   TVTGROUP            gg                      ML940222
         SEG   '.'                 .                       ML940222
         SEG   TVTUSER             uuu                     ML940222
         SEGWR ,
         SET   TPATERR+TPATPERR    Indicate path re-queue
         IF    UPATTWAIT,BEGIN     If we started a timer...
         STIMERM CANCEL,ID=UPATTOID,MF=(E,UTIMERL) quit waiting
         CLEAR UPATTWAIT           forget we were waiting
         END   ,
         LA    R15,8               error RC
         CMDABORT MSG=NO           Abort current command
         END   ,
*-
*-       Unexpected SCOM code encountered
*-
         ELSE  BEGIN               unexpected RC
         QSNAP 'Unexpected SCOM return code'
         QSNAP (R1)
         QSNAP TVTSCB,60
         LR    R4,R1               Save return code
         IF    ~TPATPERR,BEGIN      don't seg again if path error
         SEG   'Unexpected SCOM send return code ('
         SEGDC (R4)                Report return code
         SEG   ')'                 Terminate message
         SEGWR ,                   Write to report file
         SET   TPATERR+TPATPERR    Set for path re-queue, no sends
         END   ,                     (not path error)
         SEGCLR OSFSCB             Clear report SEGCB
         ACALL LOGTIME             Log time of entry
         SEG   'Unexpected SCOM send return code ('
         SEGDC (R4)                Report return code
         SEG   ')'                 Terminate message
         SEGWR ,                   WRITE TO REPORT FILE
         LA    R15,8               Indicate error
         CMDABORT MSG=NO           Abort current command in progress
         END   ,                     (unexpected RC)
         PEND  ,

UTIMERL0 STIMERM SET,MF=L          Dummy list
         LTORG ,
         TITLE 'Timer Exit for Buffer Wait'
*box
*
*   STIMERM exit routine (Called from OS and runs as an IRB).
*   Essentially the same as TIMREXIT; this one fires when a
*   "waiting for buffer to empty" times out.
*   MCL 940217
*

UPTOEXIT WITH  (UPTOEXIT,R15),BEGIN
         L     R1,@R1+4            ->secondary ECB (parm to timer)
         POST  (R1),0              Post timer ECB
*  we do this indirect posting because STIMERM doesn't let us
*  give it an ECB to post...
         BR    R14                 Return to OS
         END
         TITLE 'Log command'
*box
*
*  LOGCMND - Log command to logging file
*
*  On entry:   R0 contains command length
*              R1 contains command address
*
*  On exit:    Command is logged if logging is active
*

LOGCMND  PROC  ,
*-
*-       Write out debugging info if reporting is on.
*-
         IF    TVTREPT,BEGIN       Reporting is active...
         SL    R1,=A(16)           Include command type
         AL    R0,=A(16)           Adjust length
         LA    R15,OSFSCB          Address of logging segcb
         ACALL PRTCMD              Print passed options
         END
         PEND  ,
         TITLE 'DISLINE - Display line number'
*box
*
*  DISLINE - Display line number
*
*  On Entry:   R0  Contains the binary line number
*              R15 Contains address of a seg control block
*
*  On Exit:    Message seg'd into seg control block
*
         SPACE 2
DISLWRK  RECORD BEGIN
DISEDIT  DC    X'402020202020202020202021204B202020'
         END   ,

DISLINE  PROC  DISLWRK             Enter and stack work area
         CVD   R0,TVTSTCK          line number as packed
         MVC   DISEDIT,=X'402020202020202020202021204B202020'
         ED    DISEDIT,TVTSTCK     Edit line number
         LA    R1,DISEDIT          Address of converted number
         LA    R0,L'DISEDIT        Length of number
         LOOP  BEGIN               Scan to first non-blank char
         IF    (@R1,NE,' '),EXIT   Terminate loop
         LA    R1,@R1+1            Bump to next character
         S     R0,=A(1)            Decrement length
         END   ,
         LR    R2,R1               Copy string starting address
         AR    R2,R0               Last address + 1
         S     R2,=A(1)            Decrement to last character
         LOOP  BEGIN               Trim trailing 0's
         IF    (@R2,NE,'0'),EXIT   Exit loop
         S     R2,=A(1)            Decrement address
         S     R0,=A(1)            Decrement length
         END   ,
         SEG   (R1),(R0)
         PEND  ,
         TITLE 'FMTDSN - Seg data set name'
*box
*
*  FMTDSN - Seg data set name
*
*  On entry:   R15 contains the address of a valid SEGCB
*
*  On exit:    The TVTPBDSNAME is SEG'd
*

FMTDSN   PROC  ,
         LA    R1,TVTPBDSNAME      Default dsn address start
         LA    R0,44               Default dsn maximum length
         IF    ~TVTPBFTYPEXACT,BEGIN   DSN is either type WYL or TSO
         IF    TVTPBFTYPTSO,BEGIN
*-
*-       Adjust name for TSO format
*-
         IF    (TVTPBDSACCT,EQ,TVTACCT),BEGIN  acct match
         LA    R1,TVTPBDSNAME+7    Eliminate header
         LA    R0,44-7             Set maximum length
         END   ,                      (acct match)
         END   ,                      (FTYPTSO)
         IF    TVTPBFTYPWYL,BEGIN  WYL-type
*-
*-       Adjust name for WYLBUR format
*-
         IF    (TVTPBDSACCT,EQ,TVTACCT),BEGIN acct match
         LA    R1,TVTPBDSNAME+11   Eliminate header
         LA    R0,44-11            Set maximum length
         END   ,                      (acct match)
         END   ,                      (WYL-type)
         END   ,                      (~exact)

         SEGLD (R15)               Set segcb address
         SEGT  (R1),(R0)           Seg to passed buffer
         PEND  ,
         TITLE 'OSFILE_STATUS: Display status counters'
*box
*
*  OSFILE_STATUS: Display status counters
*
*
         SPACE 2
CMDSTAT  CPROC ,                   Display status counters
         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
*-
*-  Send off counters
*-
         WINGSHDR SET,HEADER='DATA:'   set wings header string
         SEGCLR TVTSCB             Clear client segcb
         SEGCOL 19                 Center title at 68 columns
         SEGWR 'Wings: OSFILE - Status counters'
         SEGWR ,                   Set blank line
*-
*-             Send Path counters
*-
         SEGCOL 29                 Tab out to column ten
         SEGWR 'Path Counters'     Title for Path Counter section
         SEGCOL 25                 Title for path opens
         SEG   'Opens'             Set open title
         SEGCOL 45                 Title for path closes
         SEG   'Closes'            Set close title
         SEGWR ,                   Send title line to client
         SEGCOL 20                 Prepare to send total opens
         SEGDC TVTCNTPOPENS        Convert opens into status
         SEGCOL 40                 Prepare to send total closes
         SEGDC TVTCNTPCLOSE        Convert path closes into status
         SEGWR ,                   Write status line to client
*-
*-             Send Transactions received data
*-
         SEGCOL 25                 Title for transactions received
         SEG   'Transactions received'       set title
         SEGWR ,                   Write status line to client
         SEGCOL 10                 Tab to count column
         SEG   'Count'             Set title
         SEGCOL 20                 Tab to bytes column
         SEG   'Total Bytes'       Set title
         SEGCOL 40                 Tab to bytes/trans
         SEG   'Bytes/Transaction' Set title
         SEGWR ,
         SEGCOL 10                 Set for count of transaction read
         SEGDC TVTCNTRECVD         Convert transactions read
         SEGCOL 20                 Tab to next field
         XPUSH ,,20,PTR=R2
         LM    R0,R1,TVTCNTBRECVD  LOAD BYTES RECEIVED VALUE
         LR    R15,R2              SET RECEIVE ADDRESS
         XCALL DINTCONV            CONVERT DOUBLE WORD INTEGER
         SEG   (R1),(R0)           Convert bytes read
         XPOP  PTR=R2              RESET STACK SPACE
         SEGWR ,                   Write status to client
*-
*-             Send Transactions sent
*-
         SEGCOL 28                 Title for transactions received
         SEG   'Transactions sent'           Set title
         SEGWR ,                   Write status line to client
         SEGCOL 10                 Tab to count column
         SEG   'Count'             Set title
         SEGCOL 20                 Tab to bytes column
         SEG   'Total Bytes'       Set title
         SEGCOL 40                 Tab to bytes/trans
         SEG   'Bytes/Transaction' Set title
         SEGWR ,
         SEGCOL 10                 Set for count of transaction sent
         XPUSH ,,20,PTR=R2
         CLEAR R0                  CLEAR HIGH ORDER PORTION
         L     R1,TVTCNTSENT       SET TRANSACTIONS SENT
         LR    R15,R2              SET WORK AREA
         XCALL DINTCONV            CONVERT TO STRING
         XPUSH R0,R1               PUSH LENGTH AND LOCATION
         LA    R1,16               SET COLUMN MID-POINT
         SRL   R0,2                DIVIDE LENGTH BY TWO
         SLR   R1,R0               COMPUTE COLUMN NUMBER
         SEGCOL (R1)               TAB TO COMPUTED COLUMN
         XPOP  R0,R1               RETREIVE LOCATION AND LENGTH
         SEG   (R1),(R0)           SET INTO MESSAGE
         SEGCOL 20                 Tab to next field
         LM    R0,R1,TVTCNTBSENT   LOAD BYTES RECEIVED VALUE
         LR    R15,R2              SET RECEIVE ADDRESS
         XCALL DINTCONV            CONVERT DOUBLE WORD INTEGER
         SEG   (R1),(R0)           Convert bytes read
         XPOP  PTR=R2              RESET STACK SPACE
         SEGWR ,                   Write status to client
*-
*-       Send end of data indication
*-
         WINGSHDR SET,HEADER='EOF:'    indicate no more data
         SEGWR ,
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL SETPATH             Close and requeue client path
         PEND  ,                   Return to mainwait loop
         TITLE 'RELEASE_LOG: Release Current Log'
*box
*
*  RELEASE_LOG - Close and release current log file
*
*
         SPACE 2
CMDRLOG  CPROC ,
         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         WINGSHDR SET,HEADER='RELEASE_LOG:'
         IF    TVTREPT,BEGIN       Release if log is active
         ACALL BUMPLOG             close and reallocate
         SEGCLR TVTSCB
         SEG   'MSG=''Log has been released'''
         SEGWR ,
         END   ELSE,BEGIN          log file not open
         SEGCLR TVTSCB             Clear response area
         SEG   'MSG=''Log is not currently active'''
         SEGWR ,
         END   ,                      (log not open)

         ACALL RECOVERY            Process recovery stack
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL SETPATH             Close and requeue client path
         PEND  ,
         EJECT
*box
*
*  BUMPLOG - subroutine to actually close and reallocate logfile
*  called by RELEASE_LOG command and also by time/line check routine
*
*

BUMPLOG  PROC  ,                   close and reallocate logfile
*-
*-       Write trailer record at end of old log
*-
         SEGCLR OSFSCB             Clear report segcb
         ACALL LOGTIME             Log time of entry
         SEG   ' OSFILE ('
         SEG   TVTNAME             server name
         SEG   ','
         SEG   TVTLOGDD            DD name
         SEG   ') - Log File Closing.'
         SEGWR ,                   Write to report file
         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         LA    R2,OSFDCBPR         Address of print DCB
         CLOSE ((R2)),MF=(E,TVTOPEN)   Close report file
         FREEPOOL ((R2))               Release buffer pool
         CLEAR TVTFSPINLOG         clear spin request flag
* reallocate log file with existing ddname
         DYNCLEAR ,                Clean dynamic allocation buffer
         DYNADD (DALDDNAM,1,8),TVTLOGDD
         IF    (TVTLOGSY,EQ,'*'),BEGIN   SYSOUT=*
         DYNADD (DALSYSOU,0,0)     SYSOUT, no class
         END   ,                     (SYSOUT=*)
         ELSE  BEGIN               SYSOUT=class
         DYNADD (DALSYSOU,1,1),TVTLOGSY   SYSOUT=class
         END   ,                      (SYSOUT=class)
         DYNADD (DALCLOSE,0,0)               free=close
         DYNCALL ,                 Allocate file
         MVC   DCBDDNAM,TVTLOGDD   Set default ddname
         MVC   DCBLRECL,=AL2(137)  Set default lrecl
         OPEN  ((R2),(OUTPUT)),MF=(E,TVTOPEN)
         IF    ~DCBOFLGS.DCBOFOPN,BEGIN  open failed
         MVI   TVTRETCD+3,12       Set error return code
         B     OSFXIT              Abort processing
         END   ,                      (open failed)
         END   ,                      (with IHADCB)
*-
*-       Report logfile reopen (header for new sysout file)
*-
         STCK  TVTLOGCK            show open time
         CLEAR TVTLOGCT            line count
         SEGCLR OSFSCB             Clear report segcb
         ACALL LOGTIME             Log time of entry
         SEG   ' OSFILE ('
         SEG   TVTNAME             server name
         SEG   ','
         SEG   TVTLOGDD            DD name
         SEG   ') - Log File reopened.'
         SEGWR ,                   Write to report file
         PEND  ,

         LTORG ,
         TITLE 'RACF_REFRESH: Refresh RACF profiles.'
*box
*
*  RACF_REFRESH - Refresh the passed account's RACF profiles.
*
*        The user's ACEE RACF control block is removed and then
*        re-created.  This allows future RACHECK calls to use
*        updated profiles, not the ones buffered in CSA.,
*
*        Currently no parameters are accepted and only the
*        logged on account can reset his RACF protection.
*
*        Wings racf acee chain resource must be enq/dequeued.
*
*
         SPACE 2
CMDRREFR CPROC ,                   Enter RACF profile refresh
         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         SPACE
         VCALL XRACREFR            invoke refresh routine
* returns ACEE ptr in R2
         WITH  (WINGACEE,R2)       Addressability to wingacee
         WINGSHDR SET,HEADER='RACF_REFRESH:'
         SEGLD TVTSCB              Set for client path
         SEG   'MSG=''RACF profiles have been reset for '
         LC    R0,WACEEACT         Load length of account
         LA    R1,WACEEACT+1       Point to user id
         SEG   (R1),(R0)           Report user id
         SEG   ''''                Terminate message
         SEGWR ,                   Send response back to the client

         ACALL RECOVERY            PROCESS RECOVERY STACK
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL SETPATH             Close and requeue client path
         PEND  ,                   Return to command loop
         LTORG ,
         TITLE 'CMDSVER - Return OSFILE Version Number'
*box
*
*  SHOW_VERSION - Return OSFILE version number
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (SHOW_VERSION:)
*
*              Currently there are no parameters for SHOW_VERSION
*
*  On exit:    The WINGS OSFILE current version number is returned
*              to the client.
*
         SPACE 2
CMDSVER  CPROC ,
         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request

         WINGSHDR SET,HEADER='SHOW_VERSION:'
         SEGLD TVTSCB              Set for client path
         SEG   'MSG='''            Return version number
         L     R1,=V(VERSION)      Address of version text
         LA    R0,235              Set maximum length of version
         SEGT  (R1),(R0)           Return version
         SEG   ''''                Terminate message
         SEGWR ,                   Return to client

         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL SETPATH             RE-QUEUE CLIENT PATH
         PEND  ,                   Return to the command processor
         LTORG ,
         TITLE 'CMDFTEST - Test interface'
*box
*
*  TEST_FUNC - Test interface
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name
*
*
*
*  On exit:
*
*
         SPACE 2
CMDFTEST CPROC ,
         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request

         WINGSHDR SET,HEADER='DATA:'   Set WINGS header
         SEGCLR TVTSCB
         SEGWR 'TESTING DINTCONV ROUTINE'
         XPUSH ,,20,PTR=R2
         CLEAR R4
         L     R5,=A(X'7FFFFFFD')
         LA    R3,10
         WHILE (R3,NZ),BEGIN
         SEGHX (R4),8
         SEG   ' '
         SEGHX (R5),8
         SEG   '  '
         LR    R0,R4
         LR    R1,R5
         LR    R15,R2
         XCALL DINTCONV            CONVERT DOUBLE-WORD INTEGER
         SEGB  (R1),(R0)
         SEGWR ,
         ADL   R4,=A(0,1)          BUMP BY ONE
         S     R3,=A(1)
         END   ,
         SEGWR ,
         SEGWR ,
         CLEAR R4
         L     R5,=A(X'FFFFFFFE')
         LA    R3,10
         WHILE (R3,NZ),BEGIN
         SEGHX (R4),8
         SEG   ' '
         SEGHX (R5),8
         SEG   '  '
         LR    R0,R4
         LR    R1,R5
         LR    R15,R2
         XCALL DINTCONV            CONVERT DOUBLE-WORD INTEGER
         SEGB  (R1),(R0)
         SEGWR ,
         ADL   R4,=A(0,1)          BUMP BY ONE
         S     R3,=A(1)
         END   ,
         XPOP  PTR=R2
         SEGWR ,                   Return to client

         WINGSHDR SET,HEADER='EOF:'    Set WINGS header
         SEGWR ,                   Return to client
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL SETPATH             RE-QUEUE CLIENT PATH
         PEND  ,                   Return to the command processor
         LTORG ,
         TITLE 'FILE_SCRATCH: Scratch data set'
*box
*
*
*  FILE_SCRATCH - Scratch passed data set.
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (FILE_SCRATCH:)
*
*  On exit:    The data set is scratched.
*
*        Revised ml 1994/10/06
*        Revised/completed by mcl, 1994/05/07
*
         SPACE 2
SCRWA    RECORD BEGIN
SCRPLOC  DS    A                   Parameter location
SCRPLEN  DS    A                   Parameter length
         SPACE
         SCANCB PFX=FSCRSCN
         SPACE
         END
*-
         COPY  VOLENTRY
         SPACE
CMDFSCR  CPROC SCRWA
         CLEAR SCRWA               Clear stack work area
         ST    R1,SCRPLOC          Save parameter address
         ST    R0,SCRPLEN          Save parameter length
*
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         WINGSHDR SET,HEADER='FILE_SCRATCH:'
*-
*-       Scan FILE_OPEN options used by SCRATCH
*-
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general fields
         CLEAR TVTBLK              Clear blocking control
         SET   TVTPBFREQSCRATCH    show SCRATCH command
         SETMSG L:SCRPLOC,L:SCRPLEN FILE_OPEN options
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
*-       Scan FILE_SCRATCH special options
*-
         L     R0,SCRPLEN          Restore cmd length
         L     R1,SCRPLOC          Restore cmd pointer
         SCINIT (R1),(R0),FSCRSCNCB  Initialize scanner
         LA    R1,3                SET SCAN-TYPE TO 3
         XCALL SCTYPE              SET NEW SCAN-TYPE
         SCAN  FSCRPRT,FSCRSCNCB   Scan scratch parameters
         IF    NZ,BEGIN            Some kind of error occurred
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=CMDERR'
         CMDABORT ,                Abort command
         END   ,                      (some kind of error)
*-
*-       Now build the completed OS file name and member name.
*-
         LA    R15,TVTFILPB        FILPB ptr
         SET   TVTPBFSYNCHK        do not syntax-check
         ACALL FILOFIN             Build finished dsname, etc.

         IF    (TVTPBDSMEM,NZ),'SET TVTUPMEM'   if member scratch

*  Enqueue within this WINGS job (MVS will protect us if another
*  WINGS has it)

         L     R0,=A(TDNQSHR)      preliminary enq shared, keep it
*                                  from getting moved on us
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

*-
*-  OK, where we go from here depends...scratch of member, or of an
*-  entire dataset?  We haven't verified DSORG yet so base this choice
*-  on whether a member name was specified.  After doing OBTAIN we
*-  will check member yes/no, WHOLEPDS, and PDS/not for consistency.
*-

         IF    TVTUPMEM,BEGIN      Scratch of member requested
         ACALL EFSETUP             set up for member update:
*                                  vol check, allocate, obtain
         ACALL CKEXPDT
*-
*-       Determine file data set organization for scratch.
*-
         IF    (~TVTDSORG.DS1DSGPO),BEGIN  error:  member of sequential
         SEGCLR ERRSCB
         SEGB  'ERRID=NOTPDS'      Set error ID:  not a PDS
         SEGB  'ERRMSG=''Member specified, but file '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Add file name
         SEG   ' is not a partitioned data set.'''   terminate msg
         CMDABORT  ,               Abort current command
         END   ,                   (error: mem of sequential)

*  To scratch a member, exclusive enq unless SHARE=YES (we already
*  have shared enqueue)

         SET   TVTFISPDS           show PDS
         IF    ~TVTPBFOSHARE,BEGIN SHARE=NO
         L     R0,=A(TDNQEXC)      exclusive...
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)
         END   ,                      (SHARE=NO)

         ACALL SCRPO               scratch specified member
         END   ,                       (PDS member scr)

*-
*-  Scratch an entire dataset (any DSORG)
*-

         ELSE  BEGIN               No member, do whole dataset

         ACALL SRSETUP             check vol, obtain (no allocate)

         IF    (R15,EQ,4),'CMDABORT'  if not mounted

         IF    (R15,EQ,8),BEGIN    DSCB not on volume
         IF    (TVTUCFLG,Z),BEGIN  but it is cataloged
         SEGCLR ERRSCB             forget the error msg
         LA    R0,TVTPBDSNAME
         ACALL DELCAT              so uncatalog it
         SEGLD TVTSCB              Set for client path
         SEGB  'MSG=''File'        Report file scratched
         LA    R15,TVTSCB          Address of client SEGCB
         ACALL FMTDSN              Add data set to message
         SEG   ' not on '
         SEG   OSFCATVV            volume serial from list
         SEG   ' but was uncataloged.'''
         SR    R15,R15             looks like good scratch
         B     SCRDONE
         END   ,                      (was in catlg)
         ELSE  BEGIN               wasn't cataloged, user gave vol
         CMDABORT  ,               Abort scratch command
         END   ,                      (wasn't cataloged)
         END   ,                      (DSCB not on vol)

         IF    (TVTDSORG.DS1DSGPO,AND,~TVTPBFOWHOLPDS),BEGIN   ERROR:
*                                  PDS, no member, not WHOLEPDS opt
         SEGCLR ERRSCB             Clear error SEGCB
         SEGB  'ERRID=NOMEMBER'    Set error ID
         SEGB  'ERRMSG=''Member not specified in library'
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Add file name
         SEG   ''''                Terminate message
         CMDABORT ,                Abort current command
         END   ,                   (no member specified)

*-
*-       check for expiration date
*-
         IF    (~TVTPBFOOVRD),'ACALL CKEXPDT'

         PTRACE BEFSCR
         IF    (OSFFMT1+(DS1SMSFG-DS1DSNAM).DS1SMSDS),'OI TVTUCFLG,2'
*                                                  SMS, no uncatlg

*  To scratch entire dataset, we now need exclusive enqueue

         L     R0,=A(TDNQEXC)      exclusive...
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

         LA    R0,TVTPBDSNAME      Address of data set name
         LA    R1,OSFCATWK         Address of volume list

         ACALL SCRPS               Scratch sequential file
         IF    (R15,NZ),'CMDABORT'  if we failed          ml970513

SCRDONE  IF    ((R15,Z),AND,~TVTPBFORETAIN),BEGIN
         VCALL RACGREM             Remove profile for scratched ds
         END   ,                     (remove profile)
         SEGWR ,,TVTSCB            Return message to client
         END   ,                      (sequential or whole PDS)
*
         SET   TPATERR             force path close
         B     CMDCLEAN            Go clean up (normal cmd end)
         PEND  ,
         EJECT ,
*  Options table for FILE_SCRATCH special options
         SPACE
FSCRPRT  SCKW  RETAIN,FSCRRETN,P
         SCKW  OVRD,FSCROVRD,P
         SCKW  ERASE,FSCRERAS,P
         SCKW  ,FILOSKIP           Ignore unknown "KEYWORD=VALUE"
         SPACE 2
*
*  OVRD={YES|NO}
*
FSCROVRD PROC ,
         IF    (R0,Z),MISSING
         IF    (R0,NEG),BADOPT
         IF    ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOOVRD'
         ELSEIF ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOOVRD'
         ELSE  'B BADOPT'
         PEND  ,
*
*  ERASE={YES|NO}
*
FSCRERAS PROC ,
         IF    (R0,Z),MISSING
         IF    (R0,NEG),BADOPT
         IF    ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFOERAS'
         ELSEIF ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFOERAS'
         ELSE  'B BADOPT'
         PEND  ,
*
*  RETAIN={YES|NO}
*
FSCRRETN PROC ,
         IF    (R0,Z),MISSING
         IF    (R0,NEG),BADOPT
         IF    ((R0,EQ,3),AND,(@R1,EQ,'YES')),'SET TVTPBFORETAIN'
         ELSEIF ((R0,EQ,2),AND,(@R1,EQ,'NO')),'CLEAR TVTPBFORETAIN'
         ELSE  'B BADOPT'
         PEND  ,
         TITLE 'WINGS: SCRPS - Scratch DSORG=PS file.'
*box
*
*  SCRPS - SCRATCH DSORG=PS FILE
*
*  On entry:   R0  Contains address of data set name
*              R1  Contains address of volume list
*
*  On exit:    File is scratched
*              Message is seg'd but not written
*              RC is that from SCRATCH SVC.
*

SCRPSWK  RECORD BEGIN
SCRPSRC  DS    F                   Return code
SCRPSRS  DS    F                   reason codes
         END   ,
SCRPS    PROC  SCRPSWK
         CLEAR SCRPSRC             OK so far...
         L     R15,=A(CAMSCR)      Address of model scratch list
         MVC   OSFCAMCT(16),@R15   Prime camlst model area
         ST    R0,OSFCAMCT+4       Address of data set name
         ST    R1,OSFCAMCT+12      Address of volume list
         IF    (TVTPBFOOVRD),'OI OSFCAMF2,CAMSCOVR'  override expdt
         IF    (TVTPBFOERAS),'OI OSFCAMF2,CAMSCERA'  erase tracks
         CLEAR R0                  Zero UCB address
         LR    R4,R1               Save volume list pointer
         SCRATCH OSFCAMCT          Issue scratch SVC
         ST    R15,SCRPSRC
         PTRACE SCRRET             Trace return code
         SPACE
*  Following code lifted from CATSCR.
         SPACE
         IF    (R15,NZ),BEGIN        Had error(s)
*  We had trouble on at least one volume.  Find out what.  R4->volist
         ST    R0,SCRPSRS          Save reason codes
         LH    R3,0(R4)             Volume count
         LA    R4,2(R4)             ->volume list
         USING VOLENTRY,R4
*  STATUS CODES IN VOLUME LIST:
*
*        0     Good news
*        1     DSCB not found
*        2     Access not permitted, or VSAM dataset
*        3     OVRD not specified, or EXPDT not passed
*        4     I/O error, bad DSCB, or unexpected CVAF return code
*        5     Volume not mounted
*        6     Oper could not mount vol
*        7     Data set in use
*        8     Access not permitted: RACF
*        9     Defined to RACF but couldn't be deleted
*
         SEGCLR ERRSCB             Clear error seg block
         SEG   'ERRID='
         L     R6,ERRSCBLOC        ->seg buffer
         L     R1,ERRSCBLENF       length used
         LA    R6,0(R6,R1)         save pointer to ERRID
         SEGB  'VTOCERR '          tentative error code
         SEGB  'ERRMSG=''File'     Report file scratched
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Add data set to message
ERRLOOP  SR    R5,R5               Clear
         IF    (VOLSCRCD,NZ),BEGIN  had a problem this vol.
         SEG   ' not scratched on '
         SEGB  VOLVOLSR
         SEG   ': ('
         IC    R5,VOLSCRCD         Scratch status code
         SEGDC (R5),2              into msg
         SEG   ') '
         IF    (R5,GT,MAXCD),'L R5,MAXCD'  use max if out of table
         MH    R5,=AL2(#CFTABNT)   Size of table entry
         LA    R2,CFTABLE(R5)      -->table entry
         WITH  (CFTAB,R2),BEGIN
         OC    TVTUCFLG,CFTUCFLG   Uncat/nouncat flag
         SEGT  CFTERTXT            Msg text
         SEG   '; '
         MVC   @R6(L'CFTERRID),CFTERRID ERRID back in start of buffer
         END   ,                     (with cftab)
         END   ,                     (had problem this vol)
         ELSE  BEGIN               this vol was OK
*                                  (but others weren't)
         SEG   ' scratched on '
         SEG   VOLVOLSR
         SEG   '; '
         END   ,                     (this vol OK)
ERRLOOPX LA    R4,12(R4)           ->next list entry
         BCT   R3,ERRLOOP          Check next volume
         IF    (TVTUCFLG,Z),BEGIN  OK to uncatlg
         ACALL DELCAT              REMOVE CATALOG ENTRY
         SEG   'was uncataloged.'
         END   ,                     (ok to uncat)
         SEG   '  ('
         SEGHX SCRPSRC,2           RC hex
         SEG   '-'
         SEGHX SCRPSRS,8           reason codes
         SEG   ')'''                end of msg
         END   ,                     (had error(s) somewhere)
         DROP  R4
         ELSE  BEGIN  ,            Scratch was OK
         SEGLD TVTSCB              Set for client path
         SEGB  'MSG=''File'        Report file scratched
         LA    R15,TVTSCB          Address of client SEGCB
         ACALL FMTDSN              Add data set to message
         SEG   ' scratched '
         END   ,                     (scratch OK)
         LA    R0,TVTPBDSNAME      ADDRESS OF DATA SET NAME
         IF    (TVTUCFLG,Z),BEGIN  OK to uncatlg
         ACALL DELCAT              REMOVE CATALOG ENTRY
         SEG   'and uncataloged'
         END   ,                     (ok to uncat)
         ELSE  BEGIN               not OK to uncatalog
         TM    TVTUCFLG,2          SMS
         IF    Z,BEGIN             Not SMS and don't uncat
         SEG   'but not uncataloged'
         END   ,                     (not SMS)
         END   ,                     (not ok to uncat)
         SEG   ''''                complete msg
* We seg but don't write error msg...in some cases it is discarded.
* Caller must do CMDABORT to flush out error msg if wanted, based on
* return code
         L     R15,SCRPSRC         rcode
         PEND  ,
         TITLE 'WINGS: SCRPO - Scratch member from PDS'
*box
*
*  SCRPO - SCRATCH MEMBER FROM PDS LIBRARY
*
*  On entry:  PDS has been SVC99 allocated, DSORG checked.
*  On exit:   Member has been scratched, message seg'd to client.
*  Errors exit directly to CMDCLEAN
*

SCRPO    PROC  CMDEOFD
         SEGCLR TVTSCB

*-
*-       Open file for BPAM update processing
*-
         L     R1,TVTRBINF         ->RBINFO
         ACALL UPDOPEN             Open file for output processing
         IF    NZ,BEGIN            Test for good open
         CMDABORT ,                Abort file_scratch command
         END   ,
*-
*-       File is now allocated and open
*-
*-
         LA    R3,OSFPDS           Address of BLDL return area
         WITH  (PDSDIR,R3)         Addressability to BLDL return
         CLEAR PDSDIR              Clear BLDL return area to zero
         MVC   PDSFF,=AL2(1)       Set for one entry
         MVC   PDSLL,=AL2(76)      Length of entry
         MVC   PDSNAME,TVTPBDSMEM  Set member name
         LA    R15,STOW_DEL        Set stow for "delete"
         ACALL PDSSTOW             Update pds directory

         IF    NZ,BEGIN            error from STOW
         PTRACE BADStow            R15=stow return code
         CMDABORT ,                Abort save command
         END   ,                      (error from STOW)
         DROP  R3
*-
*-       Close output file and deallocate it
*-
         LA    R2,OSFBSAM          Address of BSAM/BPAM DCB
         ST    R2,CMDEOFCL           Save in close parameter list
         OI    CMDEOFCL,X'80'          Mark as only one DCB

         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN       Close if file is open
         CLOSE ,MF=(E,CMDEOFCL)    Close file
         END   ,
         ACALL WFILFREE            release allocation      ml940816
         END   ,
*-
*-       Send FILE_SCRATCH response to client
*-
         WINGSHDR SET,HEADER='FILE_SCRATCH:'
         SEGCLR TVTSCB             Clear extraneous data
         SEG   'MSG='''            Return message to client
         SEGTB TVTPBDSMEM          Report member name scratched
         LA    R2,OSFPDS           Address of directory information
         WITH  (PDSDIR,R2),BEGIN   Addressability to PDS
         SEG   'scratched in '
         END   ,
         LA    R15,TVTSCB          Address of cleint SEGCB
         ACALL FMTDSN              Report formatted data set name
         SEG   ''''                TERMINATE MESSAGE
         SEGWR ,                   RETURN FILE_SCRATCH TO CLIENT
         SPACE 2
         CLEAR R15                 ZERO RETURN CODE
         PEND  ,
         SPACE 2
*  Reason code/return code table for SCRATCH
         SPACE
CFTABLE  DC    CL8' ',AL1(0),CL31'Scratched on volume'               00
CFTAB    RECORD BEGIN  ,           scratch return code table entry
CFTERRID DS    CL8                 Error ID
CFTUCFLG DS    AL1                 OK to uncatalog flag
CFTERTXT DS    CL31                Error message text
         END   ,                     (scratch rc table entry)
#CFTABNT EQU   *-CFTABLE           Entry length
CFTABLE0 DC    CL8'NOTONVOL',AL1(0),CL31'Not on volume'              01
         DC    CL8'DSNEXPDT',AL1(1),CL31'Protected by expire date'   02
*  above code not documented as EXPDT but it's what you get w/SMS
         DC    CL8'DSNEXPDT',AL1(1),CL31'Protected by expire date'   03
*                                        ....v....1....v....2....v....
         DC    CL8'VTOCERR ',AL1(1),CL31'VTOC I/O error or CVAF error'
         DC    CL8'NOTONVOL',AL1(1),CL31'Volume not mounted'         05
         DC    CL8'NOTONVOL',AL1(1),CL31'Volume not mounted'         06
         DC    CL8'INUSE   ',AL1(1),CL31'Data set in use'            07
         DC    CL8'NOACCESS',AL1(1),CL31'Access not permitted'       08
         DC    CL8'NOACCESS',AL1(1),CL31'Access not permitted'       09
         DC    CL8'VTOCERR ',AL1(1),CL31'Unknown SCRATCH status code' A
#CFTABLE EQU   (*-CFTABLE0)/#CFTABNT last entry number
MAXCD    DC    A(#CFTABLE)
         LTORG ,
         TITLE 'SHOW_DIR: Show PDS directory'
*box
*
*
*  SHOW_DIR - Show directory in a partitioned data set.
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (SHOW_DIR:)
*
*  On exit:    PDS(E) directory list is returned to the client.
*
SDIROPTS RECORD BEGIN              SHOW DIR options area
SDIRFROM DS    CL8                 FROM
SDIRLIKE DS    CL8                 LIKE
SDIRTO   DS    CL8                 TO
SDIR#LIK DS    H                   Length of LIKE string
SDIRFLGS FLAG  ,
         FLAG  SDIRFALL            ALL option
         FLAG  SDIRFHEX            HEX option
         FLAG  SDIRFTER            TERSE option
         FLAG  SDIRFOLD            OLD option
* if none of above, MEMBER [ONLY] option
         FLAG  SDIRLAST            Last member found
*  work areas
         SCANCB PFX=SDIRSCN
         SPACE
SDIRWK   DS    2D                  for FMTTIME etc.
         ORG   SDIRWK
SDIRP#   DS    D
SDIRFW   DS    F
         ORG   ,
SDIRXW   DS    CL10                For date formatting
         DS    2F                  (insurance)
SDIREPTR DS    A                   ->error msg from SYNAD
         END   ,                      (SDIROPTS)
         SPACE 2
*-
CMDSDIR  CPROC SDIROPTS            SHOW DIRECTORY cmd
         LR    R2,R0               Save command length
         LR    R3,R1               Save command address
         CLEAR SDIROPTS
         MVC   SDIRTO,=8XL1'FF'    default upper bound
         SET   SDIRFALL            FORMAT=ALL default
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command to report file
         INCR  R0,TVTCNTREQ        Count OSFILE command request
*-
*-       Scan SHOW_DIR OPTIONS.
*-
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general fields
         CLEAR TVTBLK              Clear blocking control
         SET   TVTPBFREQREAD       show we're reading
         SETMSG (R3),(R2)          SHOW_DIR options
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
*-       Scan SHOW_DIR options.
*-
         LR    R0,R2               Restore cmd length
         LR    R1,R3               Restore cmd pointer
         SCINIT (R1),(R0),SDIRSCNCB  Initialize scanner
         LA    R1,3                SET SCAN-TYPE TO 3
         XCALL SCTYPE              SET NEW SCAN-TYPE
         LA    R7,SDIROPTS         ->work area
         SCAN  SDIRPRT,SDIRSCNCB   Scan show_dir parameters
         IF    NZ,BEGIN            Some kind of error occurred
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR'
         CMDABORT ,                Abort command
         END   ,                      (some kind of error)
         IF    (SDIRFROM,GT,SDIRTO),BEGIN  from>to
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR ERRMSG=''Inconsistent FROM/TO options'''
         CMDABORT ,                Abort command
         END   ,                      (from>to)
         LH    R1,SDIR#LIK         L'LIKE string
         IF    (R1,GT,0),BEGIN     Check LIKE
         CMPR  R1,SDIRLIKE,SDIRFROM
         IF    LT,BEGIN            LIKE<FROM
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=CMDERR'
         SEG   'ERRMSG=''LIKE option inconsistent with FROM option'''
         CMDABORT ,                Abort command
         END   ,                      (bad LIKE/FROM)
         LH    R1,SDIR#LIK
         CMPR  R1,SDIRLIKE,SDIRTO  LIKE:TO
         IF    GT,BEGIN            LIKE>TO
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=CMDERR'
         SEG   'ERRMSG=''LIKE option inconsistent with TO option'''
         CMDABORT ,                Abort command
         END   ,                      (bad LIKE/TO)
         END   ,                      (check LIKE)
*-
*-       Now build the completed OS file name and member name.
*-
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOFIN             Build finished dsname, etc.

*  Enqueue within this WINGS job (MVS will protect us if another
*  WINGS has it)

         L     R0,=A(TDNQSHR)      shared...
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

*-
*-       Find and allocate the data set
*-
         ACALL EFSETUP             errors exit directly

*  On return:  File allocated, DSCB found

*-
*-       Insure specified file is a PDS(e)
*-
         LA    R2,OSFFMT1          Address of FMT1 DSCB area
         WITH  (DS1DSNAM,R2),BEGIN Addressability to fmt1 dscb
         IF    ~TVTDSORG.DS1DSGPO,BEGIN      Not a PDS(e)
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTPDS'      Report error:  not a PDS
         SEGB  'ERRMSG=''File'     Set error message
         LA    R15,ERRSCB          Error segcb address
         ACALL FMTDSN              Report file name
         SEG   ' is not a partitioned data set.'''
         CMDABORT  ,               Abort show directory command
         END   ,                      (not a pds)
* MCL 2001/10/12 check for HFS
         IF    DS1SMSFG.DS1PDSEX,BEGIN      actually HFS dataset
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTPDS'      Report error:  not a PDS
         SEGB  'ERRMSG=''File'     Set error message
         LA    R15,ERRSCB          Error segcb address
         ACALL FMTDSN              Report file name
         SEG   ' is HFS, not a partitioned data set.'''
         CMDABORT  ,               Abort show directory command
         END   ,                      (actually HFS)
         IF    (DS1SMSFG.DS1PDSE),'SET TVTFISPE'   show PDS/E
         END   ,                      (with DSCB1)

*-
*-       Open directory for input
*-
         ACALL PDOPEN              Open directory for input
         IF    (R15,NZ),BEGIN      Process error conditions
         CMDABORT ,                Abort current command
         END   ,

         ACALL INITRB              Get an RBINFO block
*-
*-       Return directory information to client
*-
         WINGSHDR SET,HEADER='DATA:'   Indicate data line return
         SEGCLR TVTSCB                 Clear client segcb
         IF    (SDIRFTER,OR,SDIRFALL,OR,SDIRFHEX),BEGIN header
         SEG   'Member    '
         IF    SDIRFHEX,BEGIN      HEX
         SEG   'TTR-C    User Data'
         END   ,                      (hex)
         ELSE  BEGIN               not HEX
         IF    SDIRFALL,BEGIN      ALL option
         SEG   ' Created    Last Updated    UserID   '
         END   ,                      (ALL)
         SEG   '  Title'
         END   ,                      (not HEX)
         SEGWR ,
         END   ,                      (header)
*-
*-       Read directory of PDS(e)
*-
         L     R5,TVTRBINF         Address of RBINFO control
         WITH  (RBINFO,R5)         Addressability to RBINFO
         LA    R7,SDIROPTS         ->work area
         SET   RBFFIX               Set fixed format
         MVC   RBLRECL,=A(256)     Set data set logical record
         MVC   RBBLKSI,=A(256)     Set data set block size value
         L     R0,TVTBUFP          Address of the input buffer
         ST    R0,RBSTART            Save in RBINFO
*                                  Loop reading records
         CLEAR R2                  Clear directory block count
         CLEAR R3                  Clear used directory block count
         GET   OSFQSAM             Get first block
         WHILE ~TVTFEOF,BEGIN
         INCR  R2                  Count directory block
         IF    ~SDIRLAST,BEGIN     still finding members
         INCR  R3                  Count used directory block
         ACALL PRNTDENT            Return information to client
         END   ,                     (data in block)
         GET   OSFQSAM             Get next record
         END   ,                   Loop
DIREOF   LABEL ,                   end-of-file reading directory
         SET   TVTFEOF             Set end of file flag
         SPACE 2
*-
*-       Send response
*-
         WINGSHDR SET,HEADER='DATA:'
         SEGCLR TVTSCB             Clear client SEGCB
         SEGDC (R3),0              Report count of used blocks
         SEG   ' directory blocks in use out of '
         SEGDC (R2),0              Report total directory blocks
         SEG   ' allocated.'
         IF    TVTFISPE,BEGIN      PDS/E
         SEG   '  (PDS/E)'
         END   ,                     (PDS/E)
         SEGWR ,
         WINGSHDR SET,HEADER='EOF:'
         SEGWR ,                   Write final response
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL RECOVERY            Process recovery stack
         ACALL SETPATH             Re-queue path
         EXIT  CMDSDIR             done here
         TITLE 'Directory I/O Error Routine'
** invoked asynchronously by QSAM when GET triggers an error
DIRSYNAD SYNADAF ACSMETH=QSAM,PARM1=(1),PARM2=(0)
         LR    R4,R1               Save msg area ptr       ml991104
         LA    R0,L'IOERRREC       Length needed           ml991104
         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)              ml 20020416
         LR    R2,R1               ->area                  ml991104
         WITH  (IOERRREC,R2)       Addressability to work area
         XC    IOERMSG2(4),IOERMSG2    Zero poetential PDSE info ret
         MVC   IOERMSG1(128),@R4   Move in first 128 bytes of msg
         CLI   SYNM2FLG,C'S'       Test for any PDSE information
         IF    EQ,'MVC IOERMSG2,@R4+136'     Move in PDSE section
         SYNADRLS ,                Release SYNADAF work areas
         VCALL AMODE31             Re-enter 31 bit mode addressing
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=DIRIOERR'    Indicate I/O error
         SEGB  'ERRMSG=''I/O Error reading directory of'
         LA    R15,ERRSCB          ADDRESS OF ERROR SEGCB
         ACALL FMTDSN              REPORT DATA SET NAME
         LA    R3,OSFQSAM          Load data control block address
         SEG   '.  Error is: '
         SEG   SYNERRM             The nature of the problem
         SEG   ', block length is '                        ML940118
         SEGDC L2:SYNBLKL,5        Report bytes read
         SEG   ', block address is '                       ML940118
         SEG   SYNCCHHR            (already formatted)     ML940118
         SEG   ''''                Terminate error message
         LR    R1,R2               work area             ml20020416
         LA    R0,L'IOERRREC
         FREEMAIN R,LV=(0),A=(1)   free work space       ml20020416
         CMDABORT ,                give up...
         PEND  ,
         LTORG ,
         EJECT ,
*  Options table for SHOW DIRECTORY options
         SPACE
SDIRPRT  SCKW  FROM,PSDRFROM,P
         SCKW  LIKE,PSDRLIKE,P
         SCKW  TO,PSDRTO,P
         SCKW  FORMAT,PSDRFRMT,P
         SCKW  ,FILOSKIP           Ignore unknown "KEYWORD=VALUE"
         EJECT ,
*
*  FROM=<Member Name>
*
PSDRFROM PROC
         WITH  (SDIROPTS,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         CLEAR SDIRFROM            Zero for padding
         LR    R2,R0               Copy length of name
         CEIL  R2,L'SDIRFROM       Not too long
         MOVE  R2,SDIRFROM,@R1     Move in member name
         PEND
*
*  TO  =<Member Name>
*
PSDRTO   PROC
         WITH  (SDIROPTS,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   SDIRTO,=8XL1'FF'    Ones for padding
         LR    R2,R0               Copy length of name
         CEIL  R2,L'SDIRTO         Not too long
         MOVE  R2,SDIRTO,@R1       Move in member name
         PEND
*
*  LIKE=<Member Name>
*
*  Note:  Similar to FROM/TO code, but here we save length.
*         We will compare only for length of the LIKE string.
*
PSDRLIKE PROC
         WITH  (SDIROPTS,R7)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   SDIRLIKE,GVTBLANK   Blank current member name
         LR    R2,R0               Copy length of name
         CEIL  R2,L'SDIRLIKE       Not too long
         STH   R2,SDIR#LIK         Save length
         MOVE  R2,SDIRLIKE,@R1     Move in member name
         PEND
*
*  FORMAT={MEMBER|TERSE|HEX|ALL|OLD}
*
PSDRFRMT PROC ,
         WITH  (SDIROPTS,R7)
         IF    (R0,Z),MISSING
         IF    (R0,NEG),BADOPT
         CLEAR SDIRFLGS
         IF    ((R0,EQ,3),AND,(@R1,EQ,'HEX')),'SET SDIRFHEX'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'ALL')),'SET SDIRFALL'
         ELSEIF ((R0,GE,3),AND,(@R1,EQ,'TER')),'SET SDIRFTER'
         ELSEIF ((R0,GE,3),AND,(@R1,EQ,'OLD')),'SET SDIRFOLD'
         ELSEIF ((R0,GE,3),AND,(@R1,EQ,'MEM')),BEGIN
         END   ,                   (MEM)
         ELSE  'B BADOPT'          other values invalid
         PEND  ,
*BOX
*
*  PRNTDENT: Decode directory block
*
*  On entry:  R1 contains the address of the directory block
*             R7 contains the address of SDIROPTS work area
*
*
WYLDATA  RECORD BEGIN              WYLBUR PDS directory entry
WYLMEMN  DS    CL8                 Member name
WYLTTRC  DS    XL4                 TTRC
WYLCCCC  EQU   WYLTTRC+3,1            C alone
* Following map the 'user data" field:
WYLUDATA DS    0CL62               User Data, generally
WYLCRDT  DS    XL4                 create date/time 32bit STCK
WYLOOFLG EQU   WYLCRDT,2,C'X'      old old flag: x'0000'
WYLOODAT EQU   WYLCRDT+2,2,C'X'    old old crdat: yddd
WYLHDR   DS    C'WYL0'             ID
WYLUPDT  DS    XL4                 last update date/time
WYLACT   DS    CL8                 GG.UUUbb
WYLTITL  DS    CL42                Title
#WYLT    EQU   WYLTITL-WYLDATA     Length of other than title
#WYLU    EQU   WYLTITL-WYLCRDT     User data length less title
         END   ,

         COPY  SPFDATA

PRNTDENT PROC  ,
         WITH  (SDIROPTS,R7)
         LR    R6,R1               Save address of block start
         SEGCLR TVTSCB             Clear and setup SEGCB
         L2    R3,@R6              True count of data in block
         LA    R6,@R6+2            Bump to start of block
         WITH  (WYLDATA,R6),BEGIN
         IF    (R3,GE,14),BEGIN    Only if members exist in block
         S     R3,=A(2)            Adjust for two-byte header
         WHILE (R3,P),BEGIN        Loop formatting member names
         CLC   WYLMEMN,=8XL1'FF'   Test for last member
         IF    EQ,BEGIN            Last member
         SET   SDIRLAST            show last member found
         EXIT  PRNTDENT            get out...
         END   ,                      (last member)
         ELSE  BEGIN               Got an actual membername
         LC    R4,WYLCCCC          Retrieve "C" entry
         N     R4,=A(X'1F')        Remove extraneous information
         SLL   R4,1                Convert to true byte count
*  see if we want this member.
         IF    ((WYLMEMN,GE,SDIRFROM),AND,(WYLMEMN,LE,SDIRTO)),BEGIN
         LH    R5,SDIR#LIK         LIKE= string length
         IF    (R5,Z),DOMEM        no string
         BCTR  R5,0                -1 for EX-CLC
         EX    R5,LOOKLIKE         apply LIKE test
         IF    NE,SKIPMEM          not like this
         B     DOMEM
LOOKLIKE CLC   WYLMEMN(0),SDIRLIKE  (executed)
DOMEM    SEG   WYLMEMN             Return member name
         IF    SDIRFHEX,BEGIN      HEX option
         SEG   '  '
         UNPK  SDIRWK(9),WYLTTRC(5)    TTR-C
         TR    SDIRWK,GVT$HEX         as hex
         SEG   SDIRWK,8              ...into msg
         SEG   ' '
         LC    R5,WYLCCCC          "C" byte
         N     R5,=A(X'1F')        clear alias, n'ttrn bits
         IF    (R5,NZ),BEGIN       Got user data
         SRL   R5,1                Had halfwords, now got fullwords
         LA    R2,WYLUDATA         ->udata
         IF    (R5,NZ),BEGIN       Got fullword worth
UDATLOOP UNPK  SDIRWK(9),@R2(5)    First word of udata
         TR    SDIRWK(8),GVT$HEX         as hex
         SEG   SDIRWK,8              ...into msg
         SEG   ' '
         LA    R2,@R2+4            ->next
         BCT   R5,UDATLOOP         Loop back for next
         END   ,                      (got fullwords)
         TM    WYLCCCC,1           L'UDATA, lo bit, in halfwords
         IF    O,BEGIN             got an odd halfword
         UNPK  SDIRWK(5),@R2(3)    last halfword of udata
         TR    SDIRWK(4),GVT$HEX         as hex
         SEG   SDIRWK,4              ...into msg
         END   ,                      (odd halfword)
         END   ,                      (got udata)
         END   ,                      (HEX)
         ELSE  BEGIN               not HEX
         IF    (SDIRFALL,OR,SDIRFOLD),BEGIN     ALL-old
         IF    (R4,EQ,4),BEGIN     might be old old fmt
         CLC   WYLOOFLG,=X'0000'   0000yddd
         IF    EQ,BEGIN            OK, could be old old
         L2    R1,WYLOODAT         yddd
         LR    R0,R1               yddd
         SRL   R0,12               000y
         N     R1,=X'00000FFF'     0ddd
         IF    ((R0,LE,9),AND,(R1,LE,X'0366')),BEGIN  plausible
         IF    (R0,LE,2),BEGIN     1980-1982
         A     R0,=X'00000080'     get yy
         END   ,                      (80-82)
         ELSE  BEGIN               1973-1979
         A     R0,=X'00000070'     yy
         END   ,                      (73-79)
* OK, now R0=yy and R1=ddd
         SLL   R1,20               ddd00000
         SLDL  R0,16               00yyddd0
         O     R0,=X'0000000C'     00yyddds
         LA    R1,SDIRWK           ->work area
         XCALL DATE                Format date
         LR    R5,R1               save ->fmtd date
         IF    ~SDIRFOLD,BEGIN     not OLD display format
         SEG   '    ----    19'    no crdat, ladat 20th cent.
         SEG   @R5+6,2             yy low part of 19yy
         SEG   '/'
         SEG   @R5,5               mm/dd
         END   ,                      (not OLD display)
         ELSE BEGIN                OLD display
         SEG   '        '          no time
         SEG   @R5,8               crdate
         END   ,                      (OLD display)
         END   ,                      (plausible old old)
         END   ,                      (could be old old)
         END   ,                      (might be old old)
         END   ,                      (ALL-old)
         SPACE
         IF    (R4,GE,20),BEGIN    Long enough to be WYLBUR
         CLC   WYLHDR,=C'WYL0'     Magic token
         IF    EQ,BEGIN            Yes, it's ours
         SEG   ' '
         IF    (SDIRFALL,OR,SDIRFOLD),BEGIN  ALL or OLD
         IF    SDIRFALL,BEGIN      do ALL info
         CLI   WYLCRDT,X'80'       plausible hi byte of STCK
         IF    H,BEGIN             hi wd>x'80000000'
         L     R0,WYLCRDT          Create date/time stamp
         SR    R1,R1               Low half
         LA    R15,SDIRWK          ->work area
         XCALL FMTNDATE
         SEG   (R1),(R0)           date yyyy/mm/dd
         SEG   ' '
         END   ,                      (got crdate)
         ELSE  BEGIN               no crdate
         SEG   '   ----    '       ,
         END   ,                      (no crdate)
         L     R0,WYLUPDT          Date/time stamp
         SR    R1,R1               Low half
         LA    R15,SDIRWK          ->work area
         XCALL FMTNDATE
         SEG   (R1),(R0)           date yyyy/mm/dd
         SEG   ' '
         L     R0,WYLUPDT
         SR    R1,R1
         LA    R15,SDIRWK          do the same for time
         XCALL FMTTIME             get hh:mm:ss.hh
         SEG   (R1),5              ...but only use hh:mm
         SEG   '  '
         SEG   WYLACT              User ID
         END   ,                      (ALL [new])
         ELSE  BEGIN               [all]OLD
         SEG   ' '
         L     R0,WYLUPDT          Last update timestamp
         SR    R1,R1               no low half
         LA    R15,SDIRWK          ->workarea
         XCALL FMTTIME             get hh:mm:ss
         SEG   (R1),5              but only use hh:mm
         SEG   ' '
         L     R0,WYLUPDT          last update timestamp
         SR    R1,R1               no low half
         LA    R15,SDIRWK          ->workarea
         XCALL FMTDATE             date mm/dd/yy style
         SEG   (R1),(R0)
         SEG   '  '
         SEGB  WYLACT              User ID
         END   ,                      ([all]OLD)
         END   ,                      (ALL)
         IF    (SDIRFTER,OR,SDIRFALL,OR,SDIRFOLD),BEGIN  do title
         LR    R5,R4               user data bytes
         S     R5,=A(#WYLU)        title length bytes
         IF    P,BEGIN             have a title
         SEG   ' '
         SEG   WYLTITL,(R5)        Pass title to user
         END   ,                      (have title)
         END   ,                      (do title)
         END   ,                      (eq WYL0)
         ELSEIF (SDIRFTER,OR,SDIRFALL),BEGIN  Not WYLBUR,see if ISPF
*  following lifted from IOPROGM with mods       ml 940707
         WITH  (SPFDATA,R6)          address directory entry
*  R4 has user data count, *bytes*
ISPFCHEK IF    (R4,GE,30),BEGIN    Data length (halfwords) for ISPF
         CLEAR R2
         TRT   SPFCRDAT,$CKPACKD   Create date should be packed
         IF    Z,'EXIT ISPFCHEK'   Unsigned is invalid
         C     R2,=F'1'            Function byte for (digit/sign)
         IF    NE,'EXIT ISPFCHEK'  Bad
         LA    R15,SPFCRDAT+L'SPFCRDAT-1    ->last byte
         CR    R15,R1               TRT should have pointed there
         IF    NE,'EXIT ISPFCHEK'  We lose
         TRT   SPFLUDAT,$CKPACKD   Do
         IF    Z,'EXIT ISPFCHEK'     the
         C     R2,=F'1'                 same
         IF    NE,'EXIT ISPFCHEK'            test
         LA    R15,SPFLUDAT+L'SPFLUDAT-1          on
         CR    R15,R1                               "last
         IF    NE,'EXIT ISPFCHEK'                        update"
         TRT   SPFLUTIM,$CKPACKD   Last update time
         IF    NZ,'EXIT ISPFCHEK'  should be unsigned packed.
*  ISPF format.
         SEG   ' '
         IF    SDIRFALL,BEGIN      ALL option
         L     R0,SPFCRDAT         Create date
         LA    R1,SDIRXW           Work area
         VCALL NDATE               Convert
         SEG   SDIRXW,10           Date in msg
         SEG   ' '
         L     R0,SPFLUDAT         Update date
         LA    R1,SDIRXW           ->work area for formatting
         VCALL NDATE               Convert date
         SEG   SDIRXW,10           date in msg
         SEG   ' '
         MVO   SDIRP#,SPFLUTIM     time of last update (u.s. packed)
         UNPK  SDIRFW,SDIRP#       unpacked time as hhmm
         SEG   SDIRFW,2            HH
         SEG   ':'                 :
         OI    SDIRFW+3,C'0'       fix sign field
         SEG   SDIRFW+2,2          MM
         SEG   '  '
         SEG   SPFUSER             User ID
         END   ,                      (ALL option)
         SEG   ' '
         LC    R15,SPFVER          Version (1 byte binary)
         BTD   SDIRXW,2,(R15)      get 2-digit decimal
         OI    SDIRXW,C'0'         leading zero, not blank
         MVI   SDIRXW+2,C'.'       VV.
         LC    R15,SPFMOD          Mod level (1 byte)
         BTD   SDIRXW+3,2,(R15)
         OI    SDIRXW+3,C'0'       VV.MM, leading 0 in each
         SEG   SDIRXW,5
         SEG   ' Size='
         SEGDC L2:SPFSIZE,5
         SEG   '  Init='
         SEGDC L2:SPFINIT,5
         SEG   '  Mods='
         SEGDC L2:SPFNMOD,5
         END   ,                      (udata ge 30)
         END   ,                      (not WYLBUR fmt)
         END   ,                      (udata ge 20)
         END   ,                      (not HEX)
         SEGWR ,                   Return to client
SKIPMEM  LABEL ,
         END   ,                      (passed FROM/TO test)
         LA    R4,@R4+12           Adjust for member+TTRC value
         SLR   R3,R4               Decrement length remaining
         LA    R6,WYLDATA(R4)      Bump to next member
         END   ,                      (got membername)
         END   ,                      (WHILE R3>0, data in block)
         END   ,                      (block has data)
         ELSE  BEGIN               No members in block
         SET   SDIRLAST            show last member found
         END   ,                      (last member)
         END   ,                      (WITH R6)
         PEND  ,
         SPACE 3
         LTORG ,
         COPY  $CKPACKD
         TITLE 'FILE_SHOW - Display data sets'
*box
*
*  FILE_SHOW - Display data sets via catalog or on volume
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (FILE_SHOW:)
*
*  On exit:    Data sets have been returned to the client.
*

*
         COPY  FSHOAREA
         SPACE 2
CMDFSHOW CPROC FSHOAREA
         LR    R2,R0               Save command length
         LR    R3,R1               Save command address
         MVC   TVTPATCM,@R15       Set current command
         CLC   =C'VTOC',@R15       VTOC_SHOW?
         IF    EQ,'SET TVTPBFREQSHOWVTOC' if VTOC_SHOW entry
         ELSE  'SET TVTPBFREQSHOWDSN'    if FILE_SHOW entry
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
**-?0596 WINGSHDR SET,HEADER='FILE_SHOW:'
*-
*-       Scan generic options (same as FILE_OPEN)
*-
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general fields
         CLEAR TVTBLK              Clear blocking control
         SET   TVTPBFREQSHOWDSN    Show "show" command
         SET   TVTPBFTYPTSO+TVTPBFTYPWYL  NTYPE=BOTH default
         SETMSG (R3),(R2)          options
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
         CLEAR FSHOAREA
         IF    TVTPBFREQSHOWVTOC,BEGIN  this is SHOW VTOC
         SET   FSHOVTOC            flag in FSHOAREA
         END   ,                      (is SHOW VTOC)
         MVC   TVTOPTLIKE,GVTBLANK
         IF    (TVTPBNAME,NZ),BEGIN    user gave NAME
         MVC   TVTOPTLIKE,TVTPBNAME  NAME same as LIKE
         END   ,                       (gave NAME)
         MVC   TVTOPTTO,GVTBLANK
         MVC   TVTOPTFROM,GVTBLANK
         SET   FSHOTYPD+FSHOTYPT+FSHOTYPG  default is all catlg.

*-
*-       Scan FILE_SHOW options.
*-
         LR    R0,R2               Restore cmd length
         LR    R1,R3               Restore cmd pointer
         SCINIT (R1),(R0),FSHOSCNCB  Initialize scanner
         LA    R1,3                SET SCAN-TYPE TO 3
         XCALL SCTYPE              SET NEW SCAN-TYPE
         LA    R7,FSHOAREA         ->work area
         SCAN  FSHOPRT,FSHOSCNCB   Scan FILE_SHOW parameters
         IF    NZ,BEGIN            Some kind of error occurred
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR ERRMSG=''WYLBUR error, invalid parms to FI*
               LESHOW'''
         CMDABORT ,                Abort command
         END   ,                      (some kind of error)
*
*  VOL=volume
*
         IF    (TVTPBVOL,NZ),BEGIN user said ON VOL
         LA    R1,TVTPBVOL         ->volume name or stem
         LH    R0,TVTPB#VOL        L'volname
         IF    ~FSHOVTOC,BEGIN     if catalog search
         SET   FSHOWVOL            so we gotta get vol lists
         SET   FSHOTYPD+FSHOTYPT   could be either disk or tape
         CLEAR FSHOTYPG            Forget GDG
         SET   FSHOONVL            sho vol check
         END   ,                      (catalog search)
         ELSE  BEGIN               VTOC search
         IF    (R0,NE,6),BADOPT    gotta have actual volser
         END   ,                      (VTOC search)
         END   ,                      (ON VOL)
*
*  ONLY
*
         IF    FSHOONLY,'SET FSHOWVOL+FSHOWDSC'
         SPACE
*
*  TEMP
*
         IF    TVTPBFOVOLTEMP,BEGIN  If TEMP was specified
         SET   FSHOTEMP+FSHOTYPD   Show TEMP, DISK options
         CLEAR FSHOTYPG+FSHOTYPT   no tape, gdg
         SET   FSHOWVOL            will need vol info to do this
         END   ,                      (TEMP)

*  FROM/TO/LIKE consistency check

         CLI   TVTOPTTO,C' '         any TO option?
         IF    LE,BEGIN            No TO option:
         MVI   FSHOTO,X'FF'        so set to high
         MVI   TVTOPTTO,X'FF'
         END   ,                     (no TO)

         IF    ~FSHOONLY,BEGIN     not ONLY option, check from/to
         IF    (TVTOPTFROM,GT,TVTOPTTO),BEGIN  from>to
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR ERRMSG='''
         SEG   ' Inconsistent FROM/TO options'''
         CMDABORT ,                Abort command
         END   ,                      (from>to)

         LH    R1,TVTOPT#LIK         L'LIKE string
         IF    (R1,GT,0),BEGIN     Check LIKE
         CMPR  R1,TVTOPTLIKE,TVTOPTFROM
         IF    LT,BEGIN            LIKE<FROM
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR ERRMSG='''
         SEG   'LIKE option inconsistent with FROM option'''
         CMDABORT ,                Abort command
         END   ,                      (bad LIKE/FROM)

         LH    R1,TVTOPT#LIK
         CMPR  R1,TVTOPTLIKE,TVTOPTTO  LIKE:TO
         IF    GT,BEGIN            LIKE>TO
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR ERRMSG='''
         SEG   'LIKE option inconsistent with TO option'''
         CMDABORT ,                Abort command
         END   ,                      (bad LIKE/TO)
         END   ,                      (check LIKE)
         END   ,                      (not ONLY)

*  LIKE

         CLI   TVTOPTLIKE,C' '       no LIKE yet
         IF    NH,BEGIN            no LIKE
         LA    R0,L'TVTOPTFROM
         LA    R1,TVTOPTFROM
         VCALL RTRIM               How long is it
         LR    R2,R0               Save length
         LA    R0,L'TVTOPTTO
         LA    R1,TVTOPTTO
         VCALL RTRIM
         CR    R0,R2               L'to<->L'from
         IF    L,'LR R2,R0'        shorter length
         IF    (R2,GT,1),BEGIN     have something to compare
         LA    R3,TVTOPTFROM
         LA    R4,TVTOPTTO
         SR    R15,R15
FTL      CLC   0(1,R3),0(R4)       from:to
         IF    NE,FTX              found not-match
         LA    R15,1(R15)          count char.
         LA    R3,1(R3)            bump ptr1
         LA    R4,1(R4)            bump ptr2
         IF    (R15,LT,R2),FTL     loop back
FTX      STH   R15,TVTOPT#LIK        save length and
         MOVE  R15,TVTOPTLIKE,TVTOPTTO copy common part
         END   ,                      (have from/to)
         END   ,                      (no LIKE)

*  from/exclude

         IF    FSHOEXCL,BEGIN      actually said EXCLUDE not FROM
         LA    R1,FSHOFROM         ->name
         LA    R0,L'FSHOFROM       (max) len
         VCALL RTRIM               adjust
         AR    R1,R0               ->trailing blank
         MVI   @R1,X'FF'           becomes trailing "high" byte
         END   ,                     (EXCLUDE)

*  to/through

         IF    FSHOTHRU,BEGIN      actually said THROUGH not TO
         LA    R1,FSHOTO           ->name
         LA    R0,L'FSHOTO         (max) len
         VCALL RTRIM               adjust
         AR    R1,R0               ->trailing blank
         MVI   @R1,X'FF'           becomes trailing "high" byte
         END   ,                     (THROUGH)
*
*  LIKE, FROM, TO are dsname options.  Qualify if necessary
*
         IF    (TVTPBFTYPWYL,AND,TVTPBFTYPTSO),BEGIN       NTYPE=BOTH
         CLEAR TVTPBFTYPTSO        first pass will by TYPE=WYL
         SET   FSHOBOTH            remember to also do TYPE=TSO
         END   ,                      (BOTH)

         IF    TVTPBFTYPEXACT,BEGIN    Fully-qualified names
         MVC   FSHOFROM,TVTOPTFROM     copy  the
         MVC   FSHOTO,TVTOPTTO              already
         MVC   FSHOLIKE,TVTOPTLIKE             qualified
         MVC   FSHO#LIK,TVTOPT#LIK                 names
         OC    FSHOFROM,GVTBLANK        but smash case     ml970930
         OC    FSHOTO,GVTBLANK            of names since
         OC    FSHOLIKE,GVTBLANK            we don't call builddsn
         END   ,                       (fully-qualified)

         ELSE  BEGIN               qualify names

FSHO_QUALIFY  LABEL ,

*  FROM
         CLI   TVTOPTFROM,C' '       any FROM option?
         IF    NE,BEGIN            qualify FROM option
         MVC   TVTPBNAME,GVTBLANK
         MVC   TVTPBNAME(44),TVTOPTFROM  name qualifier is like dsn
         LA    R1,TVTFILPB         ->FILPB
         LA    R15,ERRSCB          error segcb
         ACALL BUILDDSN
         IF    NZ,BEGIN            Error...
         XPUSH R0,R1
         SEGCLR ERRSCB             Path error SEGCB ptr
         SEG   'ERRID=BADDSN ERRMSG='''
         XPOP  R0,R1
         SEG   (R1),(R0)           Error message
         SEG   ''''
         CMDABORT ,                Abort current command
         END   ,                     (error)
         MVC   FSHOFROM,TVTPBDSNAME   processed dsn is qualified
         END   ,                   (qualify FROM)

*  TO
         CLI   TVTOPTTO,X'FF'      any TO option?
         IF    NE,BEGIN            have TO option
         MVC   TVTPBNAME,GVTBLANK
         MVC   TVTPBNAME(44),TVTOPTTO    TO option
         LA    R1,TVTFILPB         ->FILPB
         LA    R15,ERRSCB          error segcb
         ACALL BUILDDSN
         IF    NZ,BEGIN            Error...
         XPUSH R0,R1
         SEGCLR ERRSCB             Path error SEGCB ptr
         SEG   'ERRID=BADDSN ERRMSG='''
         XPOP  R0,R1
         SEG   (R1),(R0)           Error message
         SEG   ''''
         CMDABORT ,                Abort current command
         END   ,                     (error)

         MVC   FSHOTO,TVTPBDSNAME   processed dsn is qualified
         END   ,                     (have TO option)

*  LIKE option.

         LA    R1,TVTFILPB         ->FILPB
         LA    R15,ERRSCB          error segcb
         MVC   TVTPBNAME,GVTBLANK
         MVC   TVTPBNAME(44),TVTOPTLIKE  name qualifier is like dsn
         ACALL BUILDDSN
         IF    NZ,BEGIN            Error...
         XPUSH R0,R1
         SEGCLR ERRSCB             Path error SEGCB ptr
         SEG   'ERRID=BADDSN ERRMSG='''
         XPOP  R0,R1
         SEG   (R1),(R0)           Error message
         SEG   ''''
         CMDABORT ,                Abort current command
         END   ,                     (error from BUILDDSN)
         IF    (FSHOLIKE,EQ,TVTPBDSNAME),FSHODONE   Quit now,
*                                  doing 2nd of NTYPE=BOTH and
*              ml971117            got same name as 1st time
         MVC   FSHOLIKE,TVTPBDSNAME   LIKE string qualified
         LA    R1,FSHOLIKE         ->qualified name
         LA    R0,44               max length
         VCALL RTRIM               Get actual length
         STH   R0,FSHO#LIK         L'LIKE string

         END   ,                      (Qualify names)

         IF    ~FSHOVTOC,BEGIN     looking at catalog, check length
         LH    R0,FSHO#LIK         L'LIKE
         IF    (R0,LT,5),BEGIN     5 chars is enough
         CLC   FSHOLIKE(3),=C'WYL' 3-4 OK if not WYL or WYL.
         IF    (EQ,OR,(R0,LT,3)),BEGIN   qualifier too short
         XPUSH R0,R1
         SEGCLR ERRSCB
         SEG   'ERRID=BADDSN ERRMSG=''LIKE=$'
         XPOP  R0,R1
         IF    (R0,NZ),'SEG FSHOLIKE,(R0)'  include the short name
         SEG   ':  invalid, result is too large.'''
         CMDABORT ,                Abort current command
         END   ,                     (error, qualifier too short)
         END   ,                     (length < 5)
         END   ,                     (catalog, check length)

         LA    R1,FSHOLIKE         LIKE/ONLY qualifier
         LA    R0,44               Name length
         VCALL RTRIM               get actual length
         STH   R0,FSHO#LIK         Save length
*-
*-       Send response
*-
         WINGSHDR SET,HEADER='DATA:'
         SEGCLR TVTSCB             CLEAR CLIENT SEGCB
         SEGLD TVTSCB              ->SEGCB
         LA    R1,FSHOAREA         ->options area
         IF    FSHOVTOC,BEGIN      SHOW VTOC
         SET   TVTPBFREQSHOWVTOC   Show "show" command
         XCALL SHOWVTOC            look at VTOC
         END   ,                      (SHOW VTOC)
         ELSE  'XCALL SHOWCAT'              or catlg as case may be
         LR    R2,R15              RC
         IF    (R2,Z),BEGIN        normal return
         IF    FSHOBOTH,BEGIN      NTYPE=BOTH
         CLEAR TVTPBFTYPWYL        already did the WYL part
         SET   TVTPBFTYPTSO        so now do TSO
         CLEAR FSHOBOTH            but don't do it again
         B     FSHO_QUALIFY        requalify names, search again
         END   ,                      (NTYPE=BOTH)
FSHODONE LABEL ,
         WINGSHDR SET,HEADER='EOF:                 '
         SEGWR ,                   Write final response
         SET   TPATERR             cause path clear
         B     CMDCLEAN            and go home...
         END   ,                      (normal return)

         ELSE  BEGIN               Error return
         CMDABORT ,                Abort current command
         END   ,                      (error return)

         PEND  ,
         LTORG ,
         EJECT
*box
*
*        FILE_SHOW Options.
*
         USING FSHOAREA,R7
FSHOPRT  SCKW  FROM,CATFROM
         SCKW  LIKE,CATLIKE
         SCKW  TO,CATOTO
         SCKW  THROUGH,CATTHRU
         SCKW  EXCLUDE,CATEXCL
         SCKW  CATREPT,CATREPT,P
         SCKW  REPORT,CATREPT,P
         SCKW  CATTYPE,CATTYPE,P
         SCKW  ONLY,DSNNONLY,P  only=yes|no
         SCKW  MAXNAMES,CATMAXN,(P,PI)
         SCKW  ,FILOSKIP           ignore unknown "keyword=value"
         SPACE
*box
*
*  CATTYPE={DISK|TAPE|DATA|GDG|ALL|VTOC}
*
CATTYPE  PROC ,
         IF    (R0,Z),MISSING      REQUIRED PARAMETER MISSING
         IF    (R0,NEG),BADOPT     INVALID LENGTH
         IF    ((R0,EQ,4),AND,(@R1,EQ,'DISK')),BEGIN   TYPE=DISK
         CLEAR FSHOTYPT+FSHOTYPG   not tape, gdg
         SET   FSHOTYPD            but only disk
         END   ,                                 (type=disk)
         ELSEIF ((R0,EQ,4),AND,(@R1,EQ,'TAPE')),BEGIN  TYPE=TAPE
         CLEAR FSHOTYPD+FSHOTYPG   not disk, gdg
         SET   FSHOTYPT            but only tape
         END   ,                                 (type=tape)
         ELSEIF ((R0,EQ,4),AND,(@R1,EQ,'DATA')),BEGIN  TYPE=DATA
         CLEAR FSHOTYPG            not gdg
         SET   FSHOTYPD+FSHOTYPT   but only disk, tape
         END   ,                                 (type=data)
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'GDG')),BEGIN  TYPE=GDG
         SET   FSHOTYPG            gdg
         CLEAR FSHOTYPD+FSHOTYPT   but not disk, tape
         END   ,                                 (type=GDG)
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'ALL')),BEGIN  TYPE=ALL
         SET   FSHOTYPG+FSHOTYPD+FSHOTYPT     ALL options
         END   ,                                 (type=ALL)
         ELSEIF ((R0,EQ,4),AND,(@R1,EQ,'VTOC')),BEGIN  TYPE=VTOC
         SET   FSHOVTOC            VTOC, not CATALOG
         END   ,                                 (TYPE=VTOC)
         ELSE  'B BADOPT'          INVALID PARAMETER ERROR
         PEND  ,                   (CATTYPE)
*box
*
*  REPORT ={DSN|VOL|DSCB}
*  CATREPT={DSN|VOL|DSCB}
*
CATREPT  PROC ,
         IF    (R0,Z),MISSING      REQUIRED PARAMETER MISSING
         IF    (R0,NEG),BADOPT     INVALID LENGTH
         IF    ((R0,EQ,3),AND,(@R1,EQ,'DSN')),BEGIN rept DSN only
         CLEAR FSHOWVOL+FSHOWDSC   report only dsns
         END   ,                                 (rept=dsn)
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'VOL')),BEGIN  unit/vol
         SET   FSHOWVOL            report volser and unit
         CLEAR FSHOWDSC            ...only
         END   ,                                 (rept=vol)
         ELSEIF ((R0,EQ,4),AND,(@R1,EQ,'DSCB')),BEGIN  dscb info
         SET   FSHOWDSC+FSHOWVOL   report DSCB info
         END   ,                                 (rept=dscb)
         ELSE  'B BADOPT'          INVALID PARAMETER ERROR
         PEND  ,
*box
*
*  LIKE=<DATA SET NAME>
*
CATLIKE  PROC
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   TVTOPTLIKE,GVTBLANK   clean up field
         LR    R2,R0
         CEIL  R2,L'TVTOPTLIKE       Not too long
         STH   R2,TVTOPT#LIK         save length
         IF    (R2,NZ),BEGIN       don't move if null
         MOVE  R2,TVTOPTLIKE,@R1     Move in data set name
         END   ,                     (not null)
         LR    R15,R6
         PEND
         SPACE
*box
*
*  TO=<DATA SET NAME>
*
CATOTO   PROC
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'TVTOPTTO         Not too long
         MOVE  R2,TVTOPTTO,@R1       Move in data set name
         LR    R15,R6
         PEND
         SPACE
*box
*
*  THROUGH=<DATA SET NAME>
*
CATTHRU  PROC
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'TVTOPTTO         Not too long
         MOVE  R2,TVTOPTTO,@R1       Move in data set name
         SET   FSHOTHRU            show THROUGH not TO
         LR    R15,R6
         PEND
         SPACE
*box
*
*  FROM=<DATA SET NAME>
*
CATFROM  PROC
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'TVTOPTFROM       Not too long
         MOVE  R2,TVTOPTFROM,@R1     Move in data set name
         LR    R15,R6
         PEND
         SPACE
*box
*
*  EXCLUDE=<DATA SET NAME>
*
CATEXCL  PROC
         LR    R6,R15              save, set scancb ptr
         ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'TVTOPTFROM       Not too long
         MOVE  R2,TVTOPTFROM,@R1     Move in data set name
         SET   FSHOEXCL            show EXCLUDE not FROM
         LR    R15,R6
         PEND
         SPACE
*
*box
*
*  ONLY={YES | NO}
*
DSNNONLY PROC ,
         IF    (R0,Z),MISSING      REQUIRED PARAMETER MISSING
         IF    (R0,NEG),BADOPT     INVALID LENGTH
         IF    ((R0,EQ,2),AND,(@R1,EQ,'NO')),BEGIN   ONLY=NO
         CLEAR FSHOONLY
         END   ,                                 (only=no)
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'YES')),BEGIN  only=yes
         SET   FSHOONLY
         END   ,                                 (only=yes)
         ELSE  'B BADOPT'          INVALID PARAMETER ERROR
         PEND  ,
*
*  MAXNAMES=<VALUE>
*
CATMAXN  PROC  ,                   Processing for MAXNAMES=n
         WITH  (SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         MVC   FSHOMAXN,SCNVAL     copy in value
         PEND
         SPACE 2
*box
         QLTORG
         DROP  R7
         TITLE 'FILE_RENAME: Rename a data set or member'
*box
*
*
*  FILE_RENAME: - Rename a data set or member
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (FILE_RENAME:)
*
*  On exit:    The data set is renamed
*
         SPACE 2
RENWA    RECORD BEGIN
RENPLOC  DS    A                   Parameter location
RENPLEN  DS    A                   Parameter length
RENRETC  DS    F
RFILPB   FILPB PFX=RFILPB          FILPB for newname
         SPACE
         SCANCB PFX=FRENSCN
         SPACE
RENVOLS  DC    H'0'                Number of returned volumes
RENVOLIS DS    (20*12)X            Reserve space for volume list
         END
         SPACE
CMDFREN  CPROC RENWA
         CLEAR RENWA               Clear stack work area
         ST    R1,RENPLOC          Save parameter address
         ST    R0,RENPLEN          Save parameter length
*
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         WINGSHDR SET,HEADER='FILE_RENAME:'
*-
*-       Scan FILE_OPEN options used by RENAME
*-
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general fields
         CLEAR TVTBLK              Clear blocking control
         SET   TVTPBFREQRENAME     show RENAME command
         SETMSG L:RENPLOC,L:RENPLEN FILE_OPEN options
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
*-       Now build the completed OS file name (oldname)
*-
         LA    R15,TVTFILPB        FILPB ptr for oldname
         SET   TVTPBFSYNCHK        don't syntax-check old name
         ACALL FILOFIN             Build finished dsname, etc.

*-
*-       Scan FILE_RENAME special options
*-
         MOVEL RFILPB,TVTFILPB,L'FILPB  Initialize
         MVC   RFILPBDSMEM,GVTBLANK   init memname
         MVC   RFILPBDTYPE,TVTFNTYP  original NTYPE value  ml970121
*  dsn build of oldname may have changed NTYPE, this is original value
         L     R0,RENPLEN          Restore cmd length
         L     R1,RENPLOC          Restore cmd pointer
         SCINIT (R1),(R0),FRENSCNCB  Initialize scanner
         LA    R1,3                SET SCAN-TYPE TO 3
         XCALL SCTYPE              SET NEW SCAN-TYPE
         LA    R7,RFILPB           RFILPB pointer
         SCAN  FRENPRT,FRENSCNCB   Scan RENAME parameters
         IF    NZ,BEGIN            Some kind of error occurred
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=CMDERR'
         SEG   'ERRMSG=''WYLBUR error, bad parm to RENAME'''
         CMDABORT ,                Abort command
         END   ,                      (some kind of error)
*-
*-
*-       Build the complete OS file name (newname)
*-
         LA    R15,RFILPB          File parameters for newname
         ACALL FILOFIN             Build completed OS file name
         CLI   RFILPBDSMEM,C' '    member still blank?
         IF    EQ,'CLEAR RFILPBDSMEM'   other code wants 00

*  Enqueue within this WINGS job

         L     R0,=A(TDNQSHR)      preliminary enq shared, keep it
*                                  from getting moved on us
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

*  we will enq exclusive later, unless renaming member with SHARE

*-
*-  OK, where we go from here depends...rename of member, or an
*-  entire dataset.  We haven't verified DSORG yet so base this choice
*-  on whether a member name was specified.  After doing OBTAIN we
*-  will check for consistency among PS/PO, member name specifications.
*-
*-  This logic was revised 11/96; previously we did volume lookup and
*-  OBTAIN first.
*-
         IF    ((TVTPBDSMEM,NZ),OR,(RFILPBDSMEM,NZ)),BEGIN member
*                                                (new or old) given
         SET   TVTUPMEM            show member update
         IF    (RFILPBDSMEM,Z),BEGIN   error:  old mem but no new
         SEGCLR ERRSCB
         SEGB  'ERRID=NOMEMBER'
         SEG 'ERRMSG=''Old member name but no new member name given.'''
         CMDABORT ,                abort cmd
         END   ,                      (error: old but no new mem)

         ELSEIF (TVTPBDSMEM,Z),BEGIN  error:  new mem but no old
         SEGCLR ERRSCB
         SEGB  'ERRID=RENNEWMB'
         SEG 'ERRMSG=''New member name but no old member name given.'''
         CMDABORT ,                abort cmd
         END   ,                      (error: new but no old mem)

         ACALL EFSETUP             set up for member update:
*                                  vol check, allocate, obtain, RACF
         ACALL CKEXPDT             can't do it if EXPDT protected
*-
*-       Verify file data set organization for member rename
*-
         IF    (~TVTDSORG.DS1DSGPO),BEGIN  error:  member of sequential
         SEGCLR ERRSCB
         SEGB  'ERRID=NOTPDS'      Set error ID:  not a PDS
         SEGB  'ERRMSG=''Members specified, but file '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Add file name
         SEG   ' is not a partitioned data set.'''   terminate msg
         CMDABORT  ,               Abort current command
         END   ,                   (error: mem of sequential)

*  To rename a member, exclusive enq unless SHARE=YES (we already
*  have shared enqueue)

         SET   TVTFISPDS           show PDS
         IF    ~TVTPBFOSHARE,BEGIN SHARE=NO
         L     R0,=A(TDNQEXC)      exclusive...
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)
         END   ,                      (SHARE=NO)

         LA    R1,RFILPB           ->newname area
         ACALL RENPO               rename the member
         END   ,                       (PDS member rename)

         ELSE  BEGIN               Rename of an entire dataset

         ACALL SRSETUP             check vol, obtain (no allocate)

         IF    (R15,NZ),'CMDABORT'  if not found/mounted/obtained



*  To rename entire dataset, we now need exclusive enqueue (oldname)

         IF    ~TVTPBFOSHARE,BEGIN   SHARE=NO (normal enqueue)
         L     R0,=A(TDNQEXC)      exclusive...
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)
         END   ,                   (exclusive)

         LA    R1,RFILPB           ->FILPB for newname
         MVI   RFILPBRACFLG,RACF_ALTER   access needed
         VCALL CHKRACFA            Check for ALTER access (newname)
         IF    (R15,NZ),'CMDABORT'  error, msg already seg'd

         IF    (OSFFMT1+(DS1SMSFG-DS1DSNAM).DS1SMSDS),'OI TVTUCFLG,2'
*                                                  SMS, don't recatlg

         IF    (TVTUCFLG,NE,1),BEGIN    need to recatalog
*  UCFLG:  0=cataloged, recat newname  1=not catlg'd,
*          2=SMS, we won't recatlg but SMS will

*  Check newname for catalog conflict

         LA    R1,RFILPBDSNAME     ->newname
         LA    R0,RENVOLS          ->area for vol list we don't want
         L     R15,=A(CAMCATMD)    ->model CAMLIST
         MVC   OSFCAMCT(16),@R15   Move in model camlst
         ST    R1,OSFCAMCT+4       Save pointer to data set name
         ST    R0,OSFCAMCT+12      Save pointer to work area
         LOCATE OSFCAMCT           Look for newname, hope not found

         IF    (R15,Z),BEGIN       Success is failure, newname is
*                                  already cataloged
         SEGCLR ERRSCB
         SEGB  'ERRID=EXISTS'
         SEG   'ERRMSG=''New dataset name is already cataloged on '
         SEG   RENVOLIS+4,6          the volume
         SEG   '.'''
         CMDABORT ,                abort cmd
         END   ,                      (error: newname already catlgd)

         END   ,                      (need to recatlg)

         L     R15,=A(CAMREN)      Address of model rename list
         MVC   OSFCAMCT(16),@R15   Prime camlst model area
         LA    R0,TVTPBDSNAME      Address of data set name
         LA    R1,OSFCATWK         Address of volume list
         ST    R0,OSFCAMCT+4       Address of data set name
         ST    R1,OSFCAMCT+12      Address of volume list
         LA    R0,RFILPBDSNAME     address of newname
         ST    R0,OSFCAMCT+8       in list
         CLEAR R0                  Zero UCB address
         IF    (TVTUCFLG,EQ,1),BEGIN   not renaming catlg'd ds
         OI    OSFCAMCT+2,X'10'    show OK to rename dupe uncat'd
*                                  mcl 2001/10/15 (MVS 2.10)
         END   ,                      (not renaming catlg'd)
         LR    R4,R1               Save volume list pointer
         RENAME OSFCAMCT           Issue rename SVC
         ST    R15,RENRETC
         PTRACE RENRET             Trace return code
         SPACE

         IF    (R15,NZ),BEGIN        Had error(s)
*  We had trouble on at least one volume.  Find out what.  R4->volist
         LH    R3,0(R4)             Volume count
         LA    R4,2(R4)             ->volume list
         USING VOLENTRY,R4
*  STATUS CODES IN VOLUME LIST:
*
*        0     Good news
*        1     DSCB not found
*        2     Access not permitted, or VSAM dataset
*        3     OVRD not specified, or EXPDT not passed
*        4     I/O error, bad DSCB, or unexpected CVAF return code
*        5     Volume not mounted
*        6     Oper could not mount vol
*        7     Data set in use
*        8     Access not permitted: RACF
*        9     Defined to RACF but couldn't be deleted
*
         SEGLD TVTSCB              Set for client path
         SEG   'ERRID='
         L     R6,TVTSCBLOC        ->seg buffer
         L     R1,TVTSCBLENF       length used
         LA    R6,0(R6,R1)         ->next byte
         SEGB  'RENFAIL '          tentative error code
         SEGB  'MSG=''File'        Report file renamed
         LA    R15,TVTSCB          Address of client SEGCB
         ACALL FMTDSN              Add data set to message
RRRLOOP  SR    R5,R5               Clear
         IF    (VOLSCRCD,NZ),BEGIN  had a problem this vol.
         SEG   ' not renamed on '
         SEG   VOLVOLSR
         SEG   ': '
         IC    R5,VOLSCRCD         rename status code
         IF    (R5,GT,MAXRD),'L R5,MAXRD'  use max if out of table
         MH    R5,=AL2(#RFTABNT)   Size of table entry
         LA    R1,RFTABLE(R5)      -->table entry
         WITH  (RFTAB,R1),BEGIN
         OC    TVTUCFLG,RFTUCFLG   Uncat/nouncat flag
         MVC   @R6(L'RFTERRID),RFTERRID  ERRID back in start of buffer
         SEGT  RFTERTXT            Msg text
         SEG   '; '
         END   ,                     (with rftab)
         END   ,                     (had problem this vol)

         ELSE  BEGIN               this vol was OK
*                                  (but others weren't)
         SEG   ' renamed on '
         SEG   VOLVOLSR
         SEG   '; '
         END   ,                     (this vol OK)

RRRLOOPX LA    R4,12(R4)           ->next list entry
         BCT   R3,RRRLOOP          Check next volume
         SEG   ''''                end of msg
         SEGWR ,                   return msg to client
         END   ,                     (had error(s) somewhere)
         DROP  R4

         ELSE  BEGIN  ,            Rename was OK
         SEGLD TVTSCB              Set for client path
         SEGB  'MSG=''File'        Report file renameed
         LA    R15,TVTSCB          Address of client SEGCB
         ACALL FMTDSN              Add data set to message
         SEG   ' renamed to '
         SEGT  RFILPBNAME          new name
         END   ,                     (rename OK)

         LA    R0,TVTPBDSNAME      ->old dsname
         IF    (TVTUCFLG,Z),BEGIN  OK to uncatlg
         ACALL DELCAT              Remove old name from catlg
         LA    R0,RFILPBDSNAME     ->newname
         LA    R1,OSFCATWK         ->volume list
         ACALL CATALOG             cat newname with old vol list

         IF    (R15,Z),BEGIN       cataloged OK
         SEG   ' and recataloged'
         END   ,                     (recat ok)

         ELSE  BEGIN                 (recat fail)
         SEG   ' but not recataloged'
         END   ,                      (recat fail)
         END   ,                     (ok to uncat)

         ELSE  BEGIN               not OK to uncatalog
         TM    TVTUCFLG,2          SMS
         IF    Z,BEGIN             non-SMS non-recat
         SEG   ' but not recataloged'
         END   ,                     (non-SMS non-recat)
         END   ,                     (not ok to uncat)

         SEG   ''''                complete msg
         L     R15,RENRETC         rcode
         IF    ((R15,Z),AND,~TVTPBFORETAIN),BEGIN
         VCALL RACGREM             Remove profile for renamed ds
         END   ,                     (remove profile)
         SEGWR ,,TVTSCB            Return message to client
         END   ,                      (sequential or whole PDS)

         SET   TPATERR             cause path clear
         B     CMDCLEAN            and go home...
         PEND  ,
         EJECT ,
*  Options table for FILE_RENAME special options
         SPACE
FRENPRT  SCKW  NEWNAME,FRENNEWN,P
         SCKW  ,FILOSKIP           Ignore unknown "KEYWORD=VALUE"
         EJECT ,
*box
*
*  NEWNAME=<DATA SET NAME>
*
FRENNEWN PROC
         WITH  (FILPB,R7)          RFILPB pointer
         LR    R6,R15              save, set scancb ptr
         LA    R15,ERRSCB          Error segcb ptr
**??     ACALL SCNDSN
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   FILPBNAME,GVTBLANK  Blank data set name
         LR    R2,R0               Copy length of dsn
         CEIL  R2,L'FILPBNAME      Not too long
         MOVE  R2,FILPBNAME,@R1    Move in data set name
         LR    R15,R6
         PEND
*box
*
*  <Ignored keyword>=<Ignored value>
*
FRENSKIP PROC
         LR    R5,R15
         WITH  (SCNCB,R5)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         L     R4,SCNRA            Preserve original return addr
         L     R3,SCNPRT           Preserve scan table ptr
*
         SCAN  ,(R5)               Skip value
*
         ST    R3,SCNPRT           Restore scan table ptr
         ST    R4,SCNRA            Restore return addr
         LA    R15,SCNCB
         PEND
         SPACE 2
         SPACE 2
*  Reason code/return code table for RENAME - similar to CFTABLE
         SPACE
RFTABLE  DC    CL8' ',AL1(0),CL31'Renamed on volume'                 00
RFTAB    RECORD BEGIN  ,           rename return code table entry
RFTERRID DS    CL8                 Error ID
RFTUCFLG DS    AL1                 OK to uncatalog flag
RFTERTXT DS    CL31                Error message text
         END   ,                     (rename rc table entry)
#RFTABNT EQU   *-RFTABLE           Entry length
RFTABLE0 DC    CL8'NOTONVOL',AL1(0),CL31'Not on volume'              01
         DC    CL8'NOACCESS',AL1(1),CL31'Access not permitted'       02
         DC    CL8'EXISTS  ',AL1(1),CL31'New name already on volume' 03
*                                        ....v....1....v....2....v....
         DC    CL8'VTOCERR ',AL1(1),CL31'VTOC I/O error or CVAF error'
         DC    CL8'NOTMNTD ',AL1(0),CL31'Volume not mounted'         05
         DC    CL8'NOTMNTD ',AL1(0),CL31'Volume not mounted'         06
         DC    CL8'INUSE   ',AL1(1),CL31'Data set in use'            07
         DC    CL8'NOACCESS',AL1(1),CL31'Access not permitted by RACF'
         DC    CL8'VTOCERR ',AL1(1),CL31'Unknown RENAME status code'  ?
#RFTABLE EQU   (*-RFTABLE0)/#RFTABNT last entry number
MAXRD    DC    A(#RFTABLE)
         LTORG ,
         TITLE 'WINGS: RENPO - Rename Member in PDS'
*box
*
*  RENPO - Rename member in PDS
*
*  On entry:  TVT has dsname and old membername
*             R1->RFILPB with new membername
*             SVC99 allocate has been done
*
*  On exit:   Member has been renamed, message sent to client.
*  Errors exit directly to CMDCLEAN
*

RENPO    PROC  CMDEOFD
         LR    R7,R1               Save FILPB ptr
         WITH  (FILPB,R7)
         SEGCLR TVTSCB
*
*-
*-       Open file for BPAM processing
*-
         L     R1,TVTRBINF         ->RBINFO
         ACALL UPDOPEN             Open file for output processing
         IF    NZ,BEGIN            Test for good open
         CMDABORT ,                Abort file_rename command
         END   ,
*-
*-       File is now allocated and open
*-
*-
         LA    R3,OSFPDS           Address of BLDL return area
         WITH  (PDSDIR,R3)         Addressability to BLDL return
         CLEAR PDSDIR              Clear BLDL return area to zero
         MVC   PDSFF,=AL2(1)       Set for one entry
         MVC   PDSLL,=AL2(76)      Length of entry
         MVC   PDSNAME,TVTPBDSMEM  Set member name
         LA    R15,STOW_CNG        Set stow for "change"
         MVC   PDSNEWNM,FILPBDSMEM  new membername from RFILPB
         ACALL PDSSTOW             Update pds directory

         IF    NZ,BEGIN            STOW error
         PTRACE BADStow            R15=stow return code
         CMDABORT  ,               Abort save command
         END   ,                      (STOW error)
         DROP  R3
*-
*-       Close output file and deallocate it
*-
         LA    R2,OSFBSAM          Address of BSAM/BPAM DCB
         ST    R2,CMDEOFCL           Save in close parameter list
         OI    CMDEOFCL,X'80'          Mark as only one DCB

         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN       Close if file is open
         CLOSE ,MF=(E,CMDEOFCL)    Close file
         END   ,
         ACALL WFILFREE            release allocation
         END   ,
*-
*-       Send FILE_RENAME response to client
*-
         WINGSHDR SET,HEADER='FILE_RENAME:'
         SEGCLR TVTSCB             Clear extraneous data
         SEG   'MSG='''            Return message to client
         SEGTB TVTPBDSMEM          Report old member name
         SEGB  'renamed to'
         SEGTB FILPBDSMEM          report newname
         LA    R2,OSFPDS           Address of directory information
         WITH  (PDSDIR,R2),BEGIN   Addressability to PDS
         SEG   'in '
         END   ,
         LA    R15,TVTSCB          Address of cleint SEGCB
         ACALL FMTDSN              Report formatted data set name
         SEG   ''''                TERMINATE MESSAGE
         SEGWR ,                   RETURN FILE_RENAME TO CLIENT
         SPACE 2
         CLEAR R15                 ZERO RETURN CODE
         PEND  ,
         TITLE 'SHOW_ACEE: Display Wings ACEE chain'
*box
*
*  SHOW_ACEE - Display Wings ACEE chain
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (SHOW_ACEE:)
*
*  On exit:    The ACEE chain is returned.
*
         SPACE 2
CMDSACEE CPROC ,                   Command entry point
         LR    R2,R0               Save parameter length
         LR    R3,R1               Save parameter address
*
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         VCALL XRACSACE            Call show-acee routine
*-
*-       RETURN END OF DATA TO CLIENT
*-
         WINGSHDR SET,HEADER='EOF:'    SET END OF DATA HEADER
         SEGWR ,                       RETURN TO CLIENT
*-
*-       Release ENQ on WINGS ACEE chain
*-
         L     R1,=A(DEQMODL)      Address of ENQ model parameter
         MVC   OSFENQL(L'DEQMODL),@R1  Initialize parameter list
         L     R2,=A(RACENQ)       Address of minor name
         DEQ   (GVTJOBNM,(R2),L'RACENQ,STEP),MF=(E,OSFENQL)
*-
*-       COMMAND CLEANUP AND RETURN
*-
         ACALL RECOVERY            PROCESS RECOVERY STACK
         CLEAR TPATCMND            Clear command in progress
         CLEAR TVTPATCM            Clear command name
         CLEAR TVTPATNX            Clear next command name
         ACALL SETPATH             Close and re-queue client path
         PEND  ,                   Return to caller
RACENQ   DC    C'ACEE-CHAIN'       Minor queue name for enq
         LTORG ,
         TITLE 'FILE_LSPACE: Display available space on vol'
*box
*
*
*  FILE_LSPACE - Display available space on volume
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (FILE_LSAPCE:)
*
*  On exit:    The available space data on the passed DASD volume
*              is returned to the client.
*
         SPACE 2
CMDLSPCE CPROC ,
         LR    R2,R0               Save command length
         LR    R3,R1               Save command address
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         CLEAR TVTGEN              Zero current volume serial
         WINGSHDR SET,HEADER='DATA:'         Set header for error ret
         SCINIT (R3),(R2),TVTSCNCB Initialize scanner
         SCAN  LSPCKWRT,TVTSCNCB   Scan off parameters
         IF    (TVTVOLSER,Z),BEGIN Error if no volumehas been passed
         SEGCLR ERRSCB                       Clear error SEGCB
         SEGB  'ERRID=NOVOL'                 Set error identification
         SEG   'ERRMSG=''No volume specified'''
         CMDABORT ,                          Abort LSPACE command
         END   ,

         IF    (TVTLSPFL,Z),'SET TVTLSPEXT'  Set default request
         LA    R1,TVTVOLSER        Address of volume serial
         XCALL FINDUCB             Locate unit control block address
         IF    NZ,BEGIN            Unable to locate ucb address
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTMNTD'     No volume located
         SEGB  'ERRMSG=''Volume'
         SEGTB TVTVOLSER           Add volume serial to message
         SEG   'is not mounted.'''
         CMDABORT ,                Abort show space command
         END   ,

         LR    R2,R1               Save UCB address
         ACALL LSPACE              Return available space
         IF    NZ,BEGIN            Process return codes
         LR    R2,R15              Save return code
         SEGCLR ERRSCB             Clear error SEGCB
         SEGB  'ERRID=LSPACE'      Add error identification
         SEG   'ERRMSG=''BAD RETURN CODE FROM LSPACE ('
         SEGDC (R2)
         SEG   ')'''
         CMDABORT ,
         END   ,
         XPUSH ,,L'DEVCAPCT,PTR=R3
         WITH  (DEVCAPCT,R3)
         CLEAR DEVCAPCT            CLEAR DEVCAP CONTROL
         ST    R2,DCUCBPTR         SAVE UCB POINTER
         LR    R1,R3               MOVE ADDRESS OF DEVCAPCT
         ACALL DEVCAP              DETERMINE DEVICE CAPACITIES
         SEGLD TVTSCB              Set for client path
         L     R2,TVTOSFWK         Address of lspace return
         WITH  (LSPDRETN,R2)
*-
*-       Return space information for volume
*-
         SEG   'MSG='''            Begin message data
         SEGTB TVTVOLSER           REPORT VOLUME SERIAL
         SEG   '- '                CONTINUE BUILDING MESSAGE DATA
*-
*-       Return formatted extent information
*-
         IF    TVTLSPEXT,BEGIN
         SET   TVTLSPSENT          Mark first line sent
         L     R1,LSPDTCYL         Set number of free cylinders
         M     R0,DCTRKCYL           compute number of tracks
         A     R1,LSPDTTRK             add number of tracks
         SEGDC (R1)                      report number of tracks
         SEG   ' tracks available, '
         SEGDC LSPDNEXT
         SEG   ' extents, '
         L     R1,LSPDLCYL         Largest free cylinder extent
         M     R0,DCTRKCYL           compute number of tracks
         A     R1,LSPDLTRK             add residual tracks to extent
         SEGDC (R1)                      add to report line
         SEG   ' track largest extent'
         SEG   ''''
         SEGWR ,
         END   ,
*-
*-       RETURN COMPLETE EXTENT INFORMATION IS REQUESTED
*-
         IF    TVTLSPFULL,BEGIN
         SEG   'MSG='''                begin message buildup
         IF    TVTLSPSENT,'SEGBLANK 9' add blank for subsequent write
         SET   TVTLSPSENT              set <cr> already sent
         SEG   'EXTENTS='          Report number of extents
         SEGDC LSPDNEXT            Convert free extents
         SEG   ' FREE_CYLS='       Report number of free cylinders
         SEGDC LSPDTCYL            Convert free cylinders
         SEG   ' FREE_TRKS='       Report additional free tracks
         SEGDC LSPDTTRK            Convert free tracks
         SEG   ' LARGEST_CYL='     Report largest cylinder extent
         SEGDC LSPDLCYL            Convert largest cylinder extent
         SEG   ' LARGEST_TRK='     Report largest track group
         SEGDC LSPDLTRK            Report largest tracks
         SEGWR ,                   Ship to client
         END   ,
*-
*-       RETURN AVAILALBE FMT-0 DSCB COUNT IF REQUESTED
*-
         IF    TVTLSPAVAIL,BEGIN
         IF    TVTLSPSENT,BEGIN
         SEG   'MSG='''                BEGIN MESSAGE BUILDUP
         SEGBLANK 9                     TAB OVER
         END   ,
         SET   TVTLSPSENT              INDICATE PREVIOUS LINE OUT
         SEG   'There are '            START MESSAGE
         SEGDC LSPDF0S                 REPORT FREE FMT-0 DSCBS
         SEG   ' available format=0 DSCB''S'''
         SEGWR ,                       SHIP TO CLIENT
         END   ,
*-
*-       RETURN VTOC INDEX STATUS IF REQUESTED
*-
         IF    TVTLSPINDEX,BEGIN
         IF    TVTLSPSENT,BEGIN
         SEG   'MSG='''                BEGIN MESSAGE BUILDUP
         SEGBLANK 9                     TAB OVER
         END   ,
         SET   TVTLSPSENT              INDICATE <CR> HAS BEEN SENT
         IF    (LSPDSTAT.LSPDIXDS+LSPDIXAC,Z),BEGIN
         SEG   'The volume has no VTOC index defined'''
         END   ELSE,BEGIN
         IF    (LSPDSTAT.LSPDIXAC),BEGIN    index info
         SEG   'The VTOC index is active, '
         SEGDC LSPDVIRS
         SEG   ' free VIRs'
         END   ,                       (index info)
         ELSE  'SEG "The VTOC index is disabled"'
         END   ,
         SEGWR ,                   RETURN MESSAGE TO CLIENT BUFFER
         END   ,
*-
*-       RETURN THE VOLUME FRAGMENTATION INDEX IF REQUESTED
*-
         IF    TVTLSPFRAG,BEGIN
         IF    TVTLSPSENT,BEGIN
         SEG   'MSG='''                BEGIN MESSAGE BUILDUP
         SEGBLANK 9                     TAB OVER
         END   ,
         SET   TVTLSPSENT
         SEG   'The fragmentation index is '
         SEGDC LSPDFRAG
         SEG   ''''                Terminate message
         SEGWR ,                   Return message to client
         END   ,

*-
*-       SEND END OF FUNCTION TO CLIENT
*-
         WINGSHDR SET,HEADER='EOF:                 '
         SEGWR ,                   Write final response
         XPOP  ,,PTR=R3            Release stack space
         DROP  R3                  Release devcap control
         SET   TPATERR             cause path clear
         B     CMDCLEAN            and go home...
         PEND  ,
         SPACE 2
LSPCKWRT SCKW  VOLUME,LSVOLUME,(A,P)
         SCKW  OPTIONS,LSOPT,(A,P)
         SCKW  ,
         SPACE 2
LSOPT    PROC  ,
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         IF     ((R0,EQ,3),AND,(@R1,EQ,'ALL')),BEGIN
         SET   TVTLSPFULL+TVTLSPAVAIL+TVTLSPINDEX+TVTLSPEXT
         SET   TVTLSPFRAG
         END   ,
         ELSEIF ((R0,EQ,4),AND,(@R1,EQ,'FULL')),'SET TVTLSPFULL'
         ELSEIF ((R0,EQ,5),AND,(@R1,EQ,'AVAIL')),'SET TVTLSPAVAIL'
         ELSEIF ((R0,EQ,5),AND,(@R1,EQ,'INDEX')),'SET TVTLSPINDEX'
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'EXT')),'SET TVTLSPEXT'
         ELSEIF ((R0,EQ,4),AND,(@R1,EQ,'FRAG')),'SET TVTLSPFRAG'
         ELSE  'B BADOPT'
         PEND  ,

LSVOLUME PROC  ,
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   TVTVOLSER,GVTBLANK  PRE-BLANK VOLUME SERIAL FIELD
         LR    R2,R0               COPY LENGTH OF PARM
         DEX   R2,'MVC TVTVOLSER(0),@R1'     MOVE IN VOLUME SERIAL
         OC    TVTVOLSER,GVTBLANK  UPPER CASE VOLUME SERIAL
         PEND  ,
         SPACE 2
         LTORG ,
         TITLE 'UNIT_INFO: Display UCB information for disk vol'
*box
*
*  UNIT_INFO - Display UCB information for given volser or unit
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (UNIT_INFO:)
*
*  On exit:    UCB info passed to client
*
*  1996/04/24  mcl  initial implementation
*
CMDUNIF  CPROC ,
         LR    R2,R0               Save command length
         LR    R3,R1               Save command address
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         CLEAR TVTGEN              Zero current volume serial
         CLEAR TVTUIFL             clear flags
         SET   TVTUIFMT            set default
         SCINIT (R3),(R2),TVTSCNCB Initialize scanner
         SCAN  UNIFKWRT,TVTSCNCB   Scan off parameters
         IF    (TVTVOLSER,Z),BEGIN Error if no volumehas been passed
         WINGSHDR SET,HEADER='FILE_ERROR:'   Set header for error ret
         SEGCLR ERRSCB                       Clear error SEGCB
         SEGB  'ERRID=NOVOL'                 Set error identification
         SEG   'ERRMSG=''No volume specified'''
         CMDABORT ,                          Abort UNITINFO command
         END   ,

         LA    R1,TVTVOLSER        Address of volume serial
         XCALL FINDUCB             Locate unit control block address
*-ml9804 IF    NZ,BEGIN            Unable to locate ucb address
*-ml9804 SR    R1,R1               Show no UCB
*-ml9804 END   ,

         LR    R2,R1               Save UCB address
         LR    R3,R0               save extension address  ml980420

         WINGSHDR SET,HEADER='DATA:'  Set WINGS header
         SEGLD TVTSCB              Set for client path
         IF    (R2,NZ),BEGIN       got UCB
         LR    R1,R2               ->UCB                   ml980420
         LA    R15,OSFCATWK        ->a nice work area      ml980420
         LR    R0,R3               ->common extension      ml980420
         XCALL UCBFMT              format UCB info
*-
*-       Return UCB information for volume
*-
         L     R0,OSFCATWK         Length of returned data
         IF    (R0,NZ),BEGIN       got some
         LA    R1,OSFCATWK+4       ->the data part
         SEG   (R1),(R0)           do it
         END   ,                      (got some)
         END   ,                      (got UCB)
         ELSE BEGIN                no UCB
         SEG   GVTBLANK,4          null response
         END   ,                      (no UCB)
         SEGWR ,
*-
*-       SEND END OF FUNCTION TO CLIENT
*-
         WINGSHDR SET,HEADER='EOF:'
         SEGWR ,                   Send termination message
         SET   TPATERR             cause path clear
         B     CMDCLEAN            and go home...
         PEND  ,
         SPACE 2
UNIFKWRT SCKW  VOLUME,UIVOLUME,(A,P)
         SCKW  UNIT,UIUNIT,(A,P)
         SCKW  FORMAT,UIFMT,(A,P)
         SCKW  ,
         SPACE 2
UIFMT    PROC  ,                   FORMAT option
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         IF     ((R0,EQ,3),AND,(@R1,EQ,'RAW')),BEGIN
         CLEAR TVTUIFL
         SET   TVTUIRAW
         END   ,                      (RAW)
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'HEX')),BEGIN
         CLEAR TVTUIFL
         SET   TVTUIHEX
         END   ,
         ELSEIF ((R0,EQ,3),AND,(@R1,EQ,'STD')),BEGIN
         CLEAR TVTUIFL
         SET   TVTUIFMT
         END   ,
         ELSE  'B BADOPT'
         PEND  ,

UIVOLUME PROC  ,
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         MVC   TVTVOLSER,GVTBLANK  PRE-BLANK VOLUME SERIAL FIELD
         LR    R2,R0               COPY LENGTH OF PARM
         DEX   R2,'MVC TVTVOLSER(0),@R1'     MOVE IN VOLUME SERIAL
         OC    TVTVOLSER,GVTBLANK  UPPER CASE VOLUME SERIAL
         PEND  ,
UIUNIT   PROC  ,
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
         IF    ((R0,LT,3),OR,(R0,GT,4)),BADOPT  invalid length
         MVC   TVTVOLSER,GVTBLANK  PRE-BLANK VOLUME SERIAL FIELD
         LR    R2,R0               COPY LENGTH OF PARM
         IF    (R2,EQ,3),BEGIN     3-digit unit address
         MVC   TVTVOLSER+3(3),@R1  copy unit address
         MVI   TVTVOLSER+2,C'0'    leading zero
         END   ,                     (3 digit)
         ELSE  BEGIN               4-digit
         MVC   TVTVOLSER+2(4),@R1  Copy unit address
         END   ,                     (4 digit)
         OC    TVTVOLSER,GVTBLANK  upcase unit address
         PEND  ,
         SPACE 2
         LTORG ,
         TITLE 'FILE_CATLG:   Processing routine'
*box
*
*  FILE_CATLG:
*
*  On entry:   R0  contains length of optional parameters
*              R1  contains address of optional parameters
*              R15 points to command name (FILE_CATLG:)
*
*  On exit:    The passed data set is cataloged on the requested
*              volume.
*

CATWA    RECORD BEGIN
CATPLOC  DS    A                   Parameter location
CATPLEN  DS    A                   Parameter length
CATWUNIT DS    CL8                 Unit Name
CATWXFSQ DS    F                   file seq temp save for errmsg

*  Volume List for catalog operations:

CATWVOLST DS  0H
CATWVOLCT DS  H                    Volume count
CATWUCBTP DS   XL4                 UCBTYPE info for catalog
CATWUCBDV EQU  CATWUCBTP+2,1,C'X'  device-class byte
CATWVOLSR DS   CL6                 Volser
CATWFLSQ DS    H                   File Sequence Number

*  End of volume list

         SCANCB PFX=FCATSCN

SMSINFOR SMSINFOR
         END   CATWA

CMDCTLG  CPROC CATWA               FILE_CATLG: entry point
         CLEAR TVTPATNX            Clear next command name
         CLEAR CATWA               Clear stack work area
         MVC   TVTPATCM,@R15       Set current command
         SET   TPATCMND            Set command in progress
         ST    R1,CATPLOC          Save parameter address
         ST    R0,CATPLEN          Save parameter length
         ACALL LOGCMND             Log command on entry
         INCR  R0,TVTCNTREQ        Count OSFILE command request
         WINGSHDR SET,HEADER='FILE_CATLG:'
         CLEAR CATWUCBTP
         CLEAR CATWVOLSR
         CLEAR CATWFLSQ
         MVC   CATWVOLCT,=H'1'     volume count
         CLEAR CATWUNIT
*
*-
*-       Scan FILE_OPEN options used by CATALOG
*-
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general fields
         CLEAR TVTBLK              Clear blocking control
         SET   TVTPBFREQCATALOG    show CATALOG command
         SET   TVTPBFCAT           assume CATALOG request
*  CATALOG cmd does cat/uncat/recat...assume CAT unless option
*  specified (CATLG={CAT|UNCAT|RECAT}
         SETMSG L:CATPLOC,L:CATPLEN FILE_OPEN options
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
*-       Scan FILE_CATALOG special options
*-
         L     R0,CATPLEN          Restore cmd length
         L     R1,CATPLOC          Restore cmd pointer
         SCINIT (R1),(R0),FCATSCNCB  Initialize scanner
         LA    R1,3                SET SCAN-TYPE TO 3
         XCALL SCTYPE              SET NEW SCAN-TYPE
         LA    R7,CATWA
         SCAN  FCATPRT,FCATSCNCB   Scan catalog parameters
         IF    NZ,BEGIN            Some kind of error occurred
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=CMDERR' ',,TVTSCB
         CMDABORT ,                Abort command
         END   ,                      (some kind of error)
*-
*-       Now build the completed OS file name and member name.
*-
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOFIN             Build finished dsname, etc.


*  Enqueue within this WINGS job (MVS will protect us if another
*  WINGS has it)

         L     R0,=A(TDNQEXC)      exclusive enqueue
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

*-
*-       Check RACF access for cat/uncat, (alter or read with
*-       password).
*-
         LA    R1,TVTFILPB         ->FILPB
         MVI   TVTPBRACFLG,RACF_ALTER
         VCALL CHKRACFA            Check for RACF ALTER access
         IF    (R15,NZ),'CMDABORT'  error, msg already seg'd

*-
*-  UNCATALOG or RECATALOG
*-


*-
*-  CATALOG
*-

         IF    TVTPBFRECAT,CATCOM  Recatalog

*********************************************************************
*                                                                   *
*  For RECATALOG:  First setup for CATALOG; then do UNCAT, then     *
*  do a CATALOG.  We don't do CAMLST RECAT because it can mess up   *
*  an SMS dataset.  We set up CATALOG first, so we don't UNCAT      *
*  until we're pretty sure we can CAT.                              *
*                                                                   *
*********************************************************************

         IF    TVTPBFCAT,BEGIN     CATALOG request

*  Check to see if already cataloged, error if so

         ACALL GTCATVOL            Get cataloged vol, if any
* If RC=0, R1 has ->vollist

         IF    (R15,Z),BEGIN       RC=0 is bad news here
         SEGCLR ERRSCB
         SEG   'ERRID=EXISTS ERRMSG=''' duplicate name
         LA    R15,ERRSCB
         ACALL FMTDSN              DSN to msg
         SEG   ' is already cataloged on '
         SEG   TVTCATVOL           the volume
         SEG   '.'''               close msg
         B     CATFAIL
         END   ,                      (bad news, already catlgd)

CATCOM   LABEL ,       Common to CATALOG, RECATALOG

*-
*-       Determine volume serial of data set
*-

         IF    (TVTPBVOL,Z),BEGIN  no volume specified
         SEGCLR ERRSCB
         SEG   'ERRID=NOVOL ERRMSG=''No volume specified for CATALOG re*
               quest.'''
         B     CATFAIL
         END   ,                      (no vol)

         MVC   CATWVOLSR,TVTPBVOL  Copy volume-serial

*  Volume specified, see if it's mounted

         LA    R1,CATWVOLSR        -> volume serial
         XCALL FINDUCB             Locate unit control block

         IF    NZ,BEGIN            Unable to locate ucb address
         CLEAR CATWUCBTP           Clear UCB info

         IF    (CATWUNIT,Z),BEGIN  no unit
         SEGCLR ERRSCB
         SEG   'ERRID=NOUNIT ERRMSG=''No UNIT information, and volume i*
               s not online.'''
         B     CATFAIL
         END   ,                      (no unit)
         END   ,                      (no UCB)

         ELSE  BEGIN               found UCB
         WITH  (UCBOB,R1)           ## addressability to UCB
         MVC   CATWUCBTP,UCBTYP     UCBTYPE info into volume list
         END   ,                      (found UCB)

         IF    (CATWUCBTP,Z),BEGIN   no unit info yet

*  Process UNIT value

      IF ((CATWUNIT,EQ,'DISK    '),OR,(CATWUNIT,EQ,'SYSALLDA')),BEGIN
*                                               UNIT=DISK
         MVC   CATWUCBTP,UCBT3390  assume 3390
         END   ,                               (UNIT=DISK)
         ELSEIF (CATWUNIT,EQ,'3390'),BEGIN       UNIT=3390
         MVC   CATWUCBTP,UCBT3390
         END   ,                      (3390)

         ELSEIF (CATWUNIT,EQ,'3380'),BEGIN       UNIT=3380
         MVC   CATWUCBTP,UCBT3380
         END   ,                      (3380)

        ELSEIF ((CATWUNIT,EQ,'TAPE    '),OR,(CATWUNIT,EQ,'T3480   '),OR*
               ,(CATWUNIT,EQ,'3480')),BEGIN      TAPE/3480
         MVC   CATWUCBTP,UCBT3480
         END   ,                      (TAPE/3480)
         ELSEIF ((CATWUNIT,EQ,'T3490   '),OR,(CATWUNIT,EQ,'3490    ')),*
               BEGIN                             3490
         MVC   CATWUCBTP,UCBT3490
         END   ,                          (3490)

         ELSEIF ((CATWUNIT,EQ,'T3490E  '),OR,(CATWUNIT,EQ,'3490E   ')),*
               BEGIN                             3490E
         MVC   CATWUCBTP,UCBT349E
         END   ,

        ELSEIF ((CATWUNIT,EQ,'T6250   '),OR,(CATWUNIT,EQ,'T3420   '),OR*
               ,(CATWUNIT,EQ,'3420')),BEGIN      TAPE/3420
         MVC   CATWUCBTP,UCBT3420
         END   ,                      (TAPE/3420)

         ELSE  BEGIN               bad unit
         SEGCLR ERRSCB
         SEG   'ERRID=BADUNIT ERRMSG='''
         SEG   CATWUCBTP
         SEG   ':  Unrecognized unit name.'''
         B     CATFAIL
         END   ,                      (bad unit)

         END   ,                      (no unit info)

*  No fileseq for disk

         TM    CATWUCBDV,DEVCLDA   Disk?
         IF    ONES,'CLEAR CATWFLSQ'   then no fileseq

         IF    TVTPBFRECAT,UNCAT   for RECAT, first
*                                    do UNCAT, then CAT

*  Let's go catalog

DOCAT    LA    R0,TVTPBDSNAME      ->DSN
         LA    R1,CATWVOLST        ->volume list
         ACALL CATALOG

         IF    (R15,NZ),CATFAIL    error msg built by CATALOG

         SEGLD TVTSCB              Set for client path
         SEGB  'MSG=''File'        Report file scratched
         LA    R15,TVTSCB          Address of client SEGCB
         ACALL FMTDSN              Add data set to message
         IF    TVTPBFRECAT,BEGIN   recat
         SEG   ' recataloged on '
         END   ,                     (recat)
         ELSE  BEGIN               cat
         SEG   ' cataloged on '
         END   ,                     (cat)
         SEG   CATWVOLSR           volume serial from list
         SEG   '.'''
         B     CATDONE
         END   ,                      (CATALOG)


         ELSE  BEGIN               UNCATALOG command

*  Here for UNCATALOG command, or doing a RECAT

UNCAT    SR    R0,R0               no extra returns
         LA    R1,TVTPBDSNAME      ->name
         ACALL CATLOC              catalog lookup
         IF    (R15,NZ),BEGIN      lookup failed
         IF    TVTPBFRECAT,DOCAT   OK if we are recataloging
         CMDABORT                  for UNCAT, not in catlg or other
*                                  error (msg seg'd)
         END   ,                      (lookup failed)
         CLC   OSFCATVL,=C'MIGRAT' HSM got it?
         IF    EQ,BEGIN            it's migrated, can't uncatlg
         SEGCLR ERRSCB
         SEG   'ERRID=MIGRATED ERRMSG=''File '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' is migrated and cannot be '
         IF    TVTPBFRECAT,BEGIN   RE-cat
         SEG   'recataloged.'''
         END   ,                      (recat)
         ELSE  BEGIN               uncat
         SEG   'uncataloged.'''
         END   ,                      (uncat)
         CMDABORT
         END   ,                      (migrated)

         LA    R1,TVTPBDSNAME      ->dsn
         LA    R0,SMSINFOR         ->sms result area
         XCALL SMSINFO             see if system-mangled
*  RC:  0 if cataloged, sms info in smsinfor area; nz if not cat
*  (unlikely here, we just looked it up above)
         IF    (R15,Z),BEGIN       found
         IF    (SMSISTCL,NE,GVTBLANK),BEGIN   SMS

         SEGCLR ERRSCB
         SEG   'ERRID=SMS ERRMSG=''File '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' is system-managed and cannot be '
         IF    TVTPBFRECAT,BEGIN   RE-cat
         SEG   'recataloged.'''
         END   ,                      (recat)
         ELSE  BEGIN               uncat
         SEG   'uncataloged.'''
         END   ,                      (uncat)
         CMDABORT
         END   ,                      (SMS)
         END   ,                      (FOUND)
         LA    R0,TVTPBDSNAME      ->dsname
         ACALL DELCAT
         IF    (R15,NZ),CATFAIL    unsuccessful, msg already seg'd

         IF    TVTPBFRECAT,DOCAT    doing recat, no msg for uncat part

         SEGLD TVTSCB              Set for client path
         SEGB  'MSG=''File'        Report file scratched
         LA    R15,TVTSCB          Address of client SEGCB
         ACALL FMTDSN              Add data set to message
         SEG   ' uncataloged.'''
         B     CATDONE
         END   ,                   (uncatalog)

CATDONE  LABEL ,
         SEGWR ,,TVTSCB            Return message to client
         SET   TPATERR             force path close
         B     CMDCLEAN            Go clean up

CATFAIL  CMDABORT ,                Abort scratch command

         PEND  ,
         EJECT ,
*  Options table for FILE_CATALOG special options
         SPACE
FCATPRT  SCKW  UNIT,FCATUNIT,P
         SCKW  FILESEQ,FCATFLSQ,(P,PI)
         SCKW  ,FILOSKIP           Ignore unknown "KEYWORD=VALUE"
         SPACE 2
*
*  UNIT={unitname}
*
FCATUNIT PROC ,
         WITH  (CATWA,R7)
         IF    (R0,Z),MISSING
         IF    (R0,NEG),BADOPT
         MVC   CATWUNIT,GVTBLANK   Unit name
         LR    R2,R0               Copy length of unitname
         CEIL  R2,L'CATWUNIT       Not too long
         MOVE  R2,CATWUNIT,@R1     Move in unit name
         PEND  ,

*box
*
*  FILESEQ=<VALUE>
*
FCATFLSQ PROC  ,                Processing for FILESEQ=n
         WITH  (CATWA,R7),(SCNCB,R15)
         IF    (R0,Z),MISSING      Missing keyword value
         IF    (R0,NEG),BADOPT     Bad keyword value
*
         L     R0,SCNVAL           value
         STH   R0,CATWFLSQ         file sequence number in vollist
         IF    (R0,GT,9999),BEGIN  fileseq out of range
         ST    R0,CATWXFSQ         save bad value (fullwd)
         SEGCLR ERRSCB
         SEG   'ERRID=BADFSEQ ERRMSG='''
         SEGDC CATWXFSQ
         SEG   ':  Invalid file sequence number, maximum is 9999'''
         CMDABORT ,                go home
         END   ,                      (bad fileseq)
         PEND

*  UCBDEVTYPE info for unit names

UCBT3390 DC    X'3030200F'         3390 disk
UCBT3380 DC    X'3050200E'         3380 disk
UCBT349E DC    X'78048081'         3490E tape
UCBT3490 DC    X'78048081'         same as 3490E?
UCBT3480 DC    X'78048080'         3480 tape
UCBT3420 DC    X'32008003'         3420 tape
UCBTSPAR DC    X'00000000'         zappable spare

DEVCLDA  EQU   X'20'               Direct access
         LTORG ,
         TITLE ' FILE_OPEN Command Processor'
*box
*
*  FILE_OPEN Command Processor
*
*    On entry:
*      R15      16 char id (FILE_OPEN)
*      R1,R0    File open options (text after "FILE_OPEN:")
*
*  On exit:    The file has been sent to the client (REQTYPE=READ)
*              or the file has been written to DASD (REQTYPE=WRITE).
*
*  NOTE:
*  per JDN the path clobber problem described below was fixed, and the
*  auth kluge is no longer necessary, so it was removed 1994/11/15 by
*  mcl.
*========================deleted====================================
* -all uses and save must be authorized connections. see below. this
* -is not because they must really be authorized. but for now there
* -is some kind of core clobber bug that happens when we see
* -non authorized paths.  we note that all paths are authorized,
* -thus a non authorized path is a core clobber.  at first suzan
* -path support was suspected.  but now i think it is a wings bug
* -and I will look for it.  but this fix should protect us for now.
* -The wylbur side of the path will reopen if it sees 'NOTAUTH' so
* -that this error/fix kludge is not seen by the users.
*
         SPACE 2
CMDOPEN  CPROC
**-      ACALL PRIVOP              use/saves privd **mcl 1994/11/15**
         LR    R2,R0               Save command length
         LR    R3,R1               Save command address
*  1995/03/14 mcl:  check for path sequence error:
         IF    (TVTPATCM,NZ),BEGIN should be no command in progress
         QSNAP 'FILE_OPEN path sequence error, old cmd was '
         QSNAP TVTPATCM,16
*  2002/06/11 mcl:  report path seq errs on wings log
         IF    TVTREPT,BEGIN       logging active
         SEGCLR OSFSCB
         SEG   'Path sequence error: OPEN when current command is:'
         SEG   TVTPATCM            this cmd
         SEG   ' expecting '
         SEG   TVTPATNX            expected next cmd
         SEGWR ,                   report it
         END   ,                   (logging active)
         ACALL RECOVERY            ** 2002/06/11: this was below
*                                     and was always being done***
         END   ,                   (path seq error)

         CLI   TVTDDNAME,C' '      shouldn't be a ddname yet
         IF    H,BEGIN             leftover dd card?
         QSNAP 'FILE_OPEN path sequence error, dd still allocated:'
         QSNAP TVTDDNAME,8
         IF    TVTREPT,BEGIN       logging active
         SEGCLR OSFSCB
         SEG   'Path sequence error:  DDname '
         SEGB  TVTDDNAME
         SEG   ' still allocated, DSN='
         SEG   TVTNQDSN
         SEGWR ,                   log it
         END   ,                   (logging active)
* 2002/06/11 mcl:  this code was below with separate test.
         DYNCLEAR ,                Clear dynamic allocation buffer
         DYNSET S99VRBUN           Set for dynamic unallocation
         DYNADD (DUNDDNAM,1,8),TVTDDNAME
         DYNCALL ,                 De-allocate file
         MVI   TVTDDNAME,C' '      show no allocation
         CLEAR TVTNQFLG            Show no enq
         CLEAR TVTNQDSN
         END   ,                   (levtover dd error)

         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         CLEAR TREADEOF
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
*
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general information
         CLEAR TVTBLK              Clear blocking control area
         ZOT   OSFCBST,OSFCBLEN    Clear OSF control blocks
         SET   TVTPBFCAT           default is CATALOG for new file
*-
*-       Scan FILE_OPEN options.
*-
         SETMSG (R3),(R2)          FILE_OPEN options
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
*-       Now build the completed OS file name and member name.
*-
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOFIN             Build finished dsname, etc.
*-
*-       Check for inconsistent options.
*-
         IF    (TVTPBREQTYPE,Z),BEGIN
         SEGCLR ERRSCB             Path error SEGCB ptr
         SEG   'ERRID=CMDERR '     Set no type error
         SEG   'ERRMSG=''No REQTYPE specified'''
         CMDABORT ,                Abort current command
         END
*-
*-       Do file read.
*-
         IF    (TVTPBFREQREAD,OR,TVTPBFREQVERIFY),BEGIN  read/verify
         ACALL FILEREAD            Read file
         END
*-
*-       Do file write.
*-
         ELSEIF (TVTPBFREQWRITE,OR,          Request type=WRITE        X
               TVTPBFREQAPPEND,OR,           Request type=APPEND       X
               TVTPBFREQREPLACE),BEGIN       Request type=REPLACE
         ACALL FILEWRIT            Write file
         END   ,
*-
*-       Unknown request type.
*-
         ELSE  BEGIN               Unknown request type...
         SEGCLR TVTSCB             Clear any messages in path buffer
         SEGCLR ERRSCB             Set path segcb
         WINGSHDR SET,HEADER='FILE_ERROR:'
         SEGB  'ERRID=CMDERR'      Indicate error for save command
         SEG   'ERRMSG='''         Set error message
         SEG   'Unknown file request operation'''
         CMDABORT  ,               Abort current command
         END   ,                   (unknown req type)
         PEND
         LTORG ,
         TITLE ' FILE_ALLOC Command Processor'
*box
*
*  FILE_ALLOC Command Processor
*
*    On entry:
*      R15      16 char id (FILE_ALLOC)
*      R1,R0    File open options (text after "FILE_ALLOC:")
*
*  On exit:    The file has been allocated.
*
*  NOTE:
*  Implemented 1994/05/31 by mcl; this is a rework of FILE_OPEN.
*
         SPACE 2
FILALOCD RECORD BEGIN              ALOC PROCESSING WORKING STORAGE
FILALOCL CLOSE (*-*),MF=L          GENERATE CLOSE PARAMETER LIST
         END   ,
         SPACE 2
CMDALLOC CPROC FILALOCD
         LR    R2,R0               Save command length
         LR    R3,R1               Save command address
         MVC   TVTPATCM,@R15       Set current command
         CLEAR TVTPATNX            Clear next command name
         SET   TPATCMND            Set command in progress
         ACALL LOGCMND             Log command
         INCR  R0,TVTCNTREQ        Count OSFILE command request
*
         CLEAR TVTFILPB            Initialize FILPB
         CLEAR TVTGEN              Clear general information
         CLEAR TVTBLK              Clear blocking control area
         ZOT   OSFCBST,OSFCBLEN    Clear OSF control blocks
         SET   TVTPBALTYPKB        default is KB
         SET   TVTPBFCAT           default is CATALOG

*-
*-       Scan FILE_OPEN options (also used for ALLOCATE)
*-
         SETMSG (R3),(R2)          FILE_OPEN options
         LA    R15,TVTFILPB        FILPB ptr
         MVC   TVTPBALLOCSEC,=F'-1'  we want to see if SECQTY=0
         ACALL FILOSCAN            Scan FILE_OPEN options
*-
*-       Now build the completed OS file name
*-
         LA    R15,TVTFILPB        FILPB ptr
         ACALL FILOFIN             Build finished dsname, etc.

         L     R0,TVTPBALLOCSEC    SECQTY
         LTR   R0,R0               we set -1 before option scan
         IF    M,BEGIN             no SECQTY supplied
         IF    (TVTPBALLOCDIR,NZ),'CLEAR TVTPBALLOCSEC' =0 for PDS
         ELSE  BEGIN               Sequential, supply a default
         L     R0,TVTPBALLOCPRI    PRIQTY
         SRA   R0,3                1/8 PRIQTY
         IF    Z,'LA R0,1'         but at least one
         ST    R0,TVTPBALLOCSEC    Save default secondary
         END   ,                      (sequential)
         END   ,                      (no SECQTY)
*-
*-       Do file allocate.
*-
         SET   TVTPBFREQALLOCATE   show "allocate"
         LA    R1,TVTFILPB         ->FILPB
         MVI   TVTPBRACFLG,RACF_ALTER    ALTER access
         VCALL CHKRACFA            Same check as for WRITE
         IF    (R15,NZ),'CMDABORT'  no access

*  Preliminary checks for "does file exist" -- similar to those
*  in FILE_WRITE but here "exists" is fatal error.

         ACALL GTCATVOL               GET CATALOGED VOL, IF ANY

         IF    ((R15,Z),AND,~TVTPBFNOCAT),BEGIN Found in catalog,
*              mcl 1999/07/13                 fatal unless NOCAT
         MVC   TVTVOLSER,TVTCATVOL vol for msg
         B     AFAILX              quit with msg
         END   ,                      (found, fatal)

         IF    (TVTPBVOL,NZ),BEGIN User-specified volume
         MVC   TVTVOLSER,TVTPBVOL
         ACALL OBTFMT1                DO FORMAT1 OBTAIN,
*  RC=0 if found DSCB (on given vol if any, else cat vol)
         IF    (R15,Z),BEGIN       Already exists: error
AFAILX   LABEL ,
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=EXISTS'      Report data set already exists
         SEG   'ERRMSG='''
         LA    R15,ERRSCB          Address of error seg control
         ACALL FMTDSN              Convert file name into message
         SEGB  ' already exists'
         IF    (TVTPBVOL,NZ),BEGIN Found on user specified volume
         SEG   ' on '                  continue building message
         SEGT  TVTVOLSER               report volume serial
         END   ,                       (found on user-spec vol)
         ELSEIF (TVTCATVOL,EQ,'MIGRAT'),BEGIN if migrated
         SEG   ' (migrated).'
         END   ,                       (migrated)
         SEG   ''''                Terminate message
         CMDABORT ,                Abort save operation
         END   ,                      (already exists)
         END   ,                      (user-specified vol)

         SET   TVTFISNEW           Show status=new
         SET   TVTFISPS            Tentative "sequential"
         IF    (TVTPBALLOCDIR,NZ),BEGIN   dir qty nonzero: pds
         SET   TVTFISPDS           Show "partitioned"
         END   ,                     (dir nonzero)

         ACALL FILEALLO            Allocate file
*-
*-   If sequential, open and close to clean out junk data
*-
         L     R5,TVTRBINF         Set parameter address
         WITH  (RBINFO,R5),BEGIN
         LA    R7,RBSPACE
         WITH  (SPACALC,R7),BEGIN
         L     R0,SPACPRIM         Primary allocation value
         END   ,                      (with R7)
         END   ,                      (with R5)
*  Only open if sequential, have space, have recfm/lrecl
         IF    ((R0,P),AND,(TVTPBRECFM,NZ),AND,TVTFISPS),BEGIN
         IF    (TVTPBFRECEDIT,OR,(TVTPBLRECL,NZ)),BEGIN
         LR    R1,R5               ->RBINFO
         ACALL WRTOPEN             Open file for output processing
         IF    NZ,BEGIN            Test for good open
         CMDABORT ,                Abort file_write command
         END   ,                      (bad open)
*
*-       OK, now we can close it
*-
         LA    R2,OSFBSAM          Address of BSAM DCB
         ST    R2,FILALOCL           Save in close parameter list
         OI    FILALOCL,X'80'          Mark as only one DCB

         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN       Close if file is open
         CLOSE ,MF=(E,FILALOCL)    Close file
         END   ,                   (DCB is open)
         END   ,                   (with IHADCB)
         END   ,                   (edit or have lrecl)
         END   ,                   (seq, have space, recfm)

         ACALL WFILFREE            un-allocate it          ml940816
*
*-
*-       File is now allocated send msg to client
*-
         WINGSHDR SET,HEADER='FILE_ALLOCATED:'
         SEGCLR TVTSCB             Clear any extraneous data
*notyet  IF    (TVTVOLSER,NZ),BEGIN volume is known
*notyet  SEG   'VOLUME='
*notyet  SEGB  TVTVOLSER
*notyet  END   ,                      (volume is known)
*notyet  IF    ~TVTPBFNOCAT,BEGIN  didn't say no catalog
*notyet  SEGB  'CATALOG'           so we must have...
*notyet  END   ,                      (cataloged)

         SEG   'MSG=''File '       Return fully qualified dsn
         SEGT  TVTPBDSNAME,44      Trim the name
         SEG   ' allocated'
         IF    (TVTPBVOL,NZ),BEGIN    user specified a volume
         SEG   ' on '
         SEG   TVTVOLSER
         IF    (TVTPBVOL,NE,TVTVOLSER),BEGIN   and we got another
         SEG   ' (unable to allocate on requested volume '
         SEG   TVTPBVOL
         SEG   ')'
         END   ,                      (got another vol)
         END   ,                      (user specified vol)
         IF    (TVTSENDXMSGS,AND,TVTEXMSG),BEGIN  want,got extra msgs
         SEG   '+'''               sho we have 'em
         ACALL SENDEXM             and go seg 'em
         END   ,                      (got extra msgs)
         ELSE  BEGIN               no got extra
         SEG   ''''                closing quote
         END   ,                      (no got extra)
         SEGWR ,                   Return FILE_ALLOCATED: to client

         CLEAR TVTPATNX            no next command expected
         SET   TPATERR             close the path
         B     CMDCLEAN            and clean up
         PEND
         TITLE 'FILE_EOF Command processor'
*box
*
*  Wings - FILE_EOF Command processor
*
*        FILE_EOF is expected after the FILE_OPEN command or
*        after a series of FILE_WRITE commands from the client.
*
*        Check for REQTYPE={WRITE | APPEND} to validate the
*        FILE_EOF command.
*

CMDEOFD  RECORD BEGIN              EOF PROCESSING WORKING STORAGE
CMDEOFCL CLOSE (*-*),MF=L          GENERATE CLOSE PARAMETER LIST
         END   ,
         SPACE 2
CMDEOF   CPROC CMDEOFD
         IF    (TVTPATNX,NE,=CL16'FILE_EOF:'),BEGIN
         IF    (TVTPATNX,EQ,=CL16'FILE_WRITE:'),EXIT
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=SYNCERR'     Report path sync error
         SEG   'ERRMSG=''Path synchronization error'''
         CMDABORT ,                Abort current command
         END   ,
         SPACE 2
*-
*-       Check for type of command processing was in effect.
*-         For read type opertions close the input file and report
*-         FILE_CLOSE:
*-         For write type operations close the output file and
*-         report FILE_CLOSE:
*-
         IF    ~TVTPBFREQREAD,BEGIN    not read, must be write
         L     R15,TVTRBINF        Address of rbinfo control
         ACALL PUTDONE             Write final block
         IF    TVTFISPDS,BEGIN     PDS stow processing
         LA    R2,OSFPDS           Address of directory information
         WITH  (PDSDIR,R2),BEGIN   Addressability to PDS
         IF    (PDSTTR,Z),BEGIN    We were writting a new member
         LA    R15,STOW_ADD        Set stow for "add"
         END   ELSE,BEGIN          (new mem)  not new mem
         LA    R15,STOW_REP        Set stow for "replace"
         END   ,                   (not new mem)
         ACALL PDSSTOW             Update pds directory
         IF    NZ,BEGIN            stow fail
         PTRACE BADStow            R15=stow return code
         CMDABORT ,                Abort save command
         END   ,                   (stow fail)
         END   ,                   (with pdsdir)
         END   ,                   (pds stow processing)
*-
*-       Close output file and release allocation
*-
         LA    R2,OSFBSAM          Address of BSAM/BPAM DCB
         ST    R2,CMDEOFCL           Save in close parameter list
         OI    CMDEOFCL,X'80'          Mark as only one DCB

         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN       Close if file is open
         CLOSE ,MF=(E,CMDEOFCL)    Close file
         END   ,                   (DCB is open)
         END   ,                   (with IHADCB)
         ACALL WFILFREE            un-allocate it          ml940816
*-
*-       Send FILE_EOF: response to client
*-
         WINGSHDR SET,HEADER='FILE_EOF:'
         SEGCLR TVTSCB             Clear extraneous data
         SEG   'MSG='''            Return message to client
         IF    TVTFISPDS,BEGIN     PDS message information return
         IF    (TVTPBTITLEN,NZ),BEGIN  PDS TITLE WAS STOWED
         IF    (TVTPBTITLEN,GT,42),BEGIN   title was too long
         LA    R1,TVTPBTITLE       ADDRESS OF TITLE STRING
         LA    R0,42               SET MAXIMUM LENGTH
         XCALL RTRIM               TRIM TRAILING BLANKS
         L     R2,TVTPBTITLEN      SET ORIGINAL TITLE LENGTH
         SR    R2,R0               EXTRA CHARACTERS DISCARDED
         SEGB  'Title is too long, the last'
         SEGDC (R2)
         SEG   ' characters have been ignored.'''
         SEG   'MSG='''
         END   ,                   (title too long)
         END   ,                   (title was stowed)
         SEGTB TVTPBDSMEM          Report member name saved
         LA    R2,OSFPDS           Address of directory information
         WITH  (PDSDIR,R2),BEGIN   Addressability to PDS
         IF    (PDSTTR,Z),BEGIN    We were writting a new member
         SEG   'saved in '
         END   ELSE,BEGIN          (new) not new
         SEG   'replaced in '      Set stow for "replace"
         END   ,                   (not new)
         END   ,                   (with PDSDIR)
         LA    R15,TVTSCB          Address of cleint SEGCB
         ACALL FMTDSN              Report formatted data set name
         END   ,                   (PDS)
         ELSE  BEGIN               Messages for sequential files
         LA    R15,TVTSCB          Address of client segcb
         ACALL FMTDSN              Format data set name
         IF    (TVTPBFREQWRITE,OR,TVTPBFREQREPLACE),BEGIN wrt/rep
         IF    TVTFISNEW,'SEG " saved"'
         IF    TVTFISOLD,'SEG " replaced"'
         END   ,                   (wrt/rep)
         ELSEIF TVTPBFREQAPPEND,BEGIN     append
         IF    TVTFISNEW,'SEG " saved"'
         IF    TVTFISOLD,'SEG " appended"'
         END   ,                          (append)
         ELSE  'SEG " processed"'
         END   ,                   (sequential)
         IF    (TVTPBVOL,NZ),BEGIN  IF VOLUME,   ml951114
         SEG   ' on '
         SEGT  TVTVOLSER           REPORT VOLUME
         IF    ((TVTPBVOL,NZ),AND,(TVTPBVOL,NE,TVTVOLSER)),BEGIN
         SEG   ' (unable to save on requested volume)'
         END   ,                   (vol changed)
         END   ,                   (vol known)
         SEG   ''''                TERMINATE MESSAGE
         SEGWR ,                   RETURN FILE_EOF TO CLIENT
         END   ,                   (not a read op.)
         SPACE 2
*-
*-       Mark next command expected from client
*-
         MVC   TVTPATNX,=CL16'FILE_CLOSE:'
         PEND  ,
         TITLE 'WINGS: FILE_WRITE COMMAND PROCESSOR'
*box
*
*  WINGS - FILE_WRITE COMMAND PROCESSOR
*
*  On entry:   (R0,R1) contains the length and address of the
*              FILE_WRITE buffer, less the sixteen byte header
*
*  On exit:    The passed client buffer has been blocked and
*              written to the open file.
*
*  Recovery:   The lower level routines set error recovery
*              routines into the recovery stack for CMDCLEAN
*              processing.
*

CMDWRITE CPROC ,
         IF    (TVTPATNX,NE,=CL16'FILE_WRITE:'),BEGIN
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=SYNCERR'     Report path sync error
         SEG   'ERRMSG=''Path synchronization error'''
         CMDABORT ,                Abort current command
         END   ,
         ACALL WRTFILE             Deblock and write records to file
         IF    (R15,NZ),BEGIN      Error                   ML940201
         CMDABORT ,
         END   ,
         PEND  ,                   Return to caller
         TITLE 'WINGS: FILE_CLOSE COMMAND PROCESSOR'
*box
*
*  WINGS - FILE_CLOSE COMMAND PROCESSOR
*
*  On entry:   Not applicable
*
*  On exit:    The passed client buffer has been blocked and
*              written to the open file.
*
*  Recovery:   The lower level routines set error recovery
*              routines into the recovery stack for CMDCLEAN
*              processing.

CMDCLOSE CPROC ,
         IF    (TVTPATNX,NE,=CL16'FILE_CLOSE:'),BEGIN
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=SYNCERR'     Report path sync error
         SEG   'ERRMSG=''Path synchronization error'''
         CMDABORT ,                Abort current command
         END   ,
         IF    TVTREPT,BEGIN
         SEGCLR OSFSCB
         LA    R15,OSFSCB          ADDRES OF REPORT SEGCB
         ACALL LOGTIME             LOG CURRENT TIME
         SEG   'File_close sent'
         SEGWR ,
         END   ,
         WINGSHDR SET,HEADER='FILE_CLOSE:'
         SEGCLR TVTSCB             Clear any previous data
         SEGWR ,                   Indicate closed file
*2002/04/01 mcl:  debugging wylbur path closed error
         STIMER WAIT,BINTVL=CMDCWAIT  slow things down before close
*end debug code
         SET   TPATERR             INDICATE RE-QUEUE OF PATH
         B     CMDCLEAN            RETURN VIA CLEANUP
         PEND  ,
*2002/04/01 degug code: one line
CMDCWAIT DC    F'1'                wait time in centiseconds
         TITLE 'PDSBLDL - Return directory information'
*box
*
*  PDSBLDL - Return directory information
*
*  On entry:   TVTOSFIL fields OSFBPAM and OSFPDS data
*              areas.
*
* On exit:     The directory is searched for the TVTPBDSMEM
*              member and the directory information is returned in
*              the OSFPDS data area in the TVTOSFIL extension.
*
*              R15 = 0 Directory information has been returned
*                  = 4 Member not found
*                  = 8 Unexpected or I/O error
*

PDSBLDL  PROC  ,
         LA    R2,OSFBPAM          Address of open BPAM DCB
         LA    R3,OSFPDS           Address of BLDL return area
         WITH  (PDSDIR,R3)         Addressability to BLDL return
         CLEAR PDSDIR              Clear BLDL return area to zero
         MVC   PDSFF,=AL2(1)       Set for one entry
         MVC   PDSLL,=AL2(76)      Length of entry
         MVC   PDSNAME,TVTPBDSMEM  Set member name
         BLDL  (R2),(R3)           Return directory information
         PTRACE BLDLret            Trace BLDL return code
         LR    R4,R15              Save BLDL return code

         IF    (R15,NZ),BEGIN      Process return codes

         IF    (R15,EQ,4),BEGIN    Process member not found
         SEGCLR ERRSCB             Clear error scb
         SEG   'ERRID=NOTINPDS ERRMSG='''
         SEGT  TVTPBDSMEM          Report member name
         SEG   ' not in '          Continue to build message
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Report file name
         SEG   ''''                Terminate error message
         END   ,                      (member not found)

         ELSE  BEGIN               Process I/O error return
         SEGCLR ERRSCB             Clear error segcb
      SEG 'ERRID=DIRIOERR ERRMSG=''Unexpected return code from BLDL='
         SEGDC (R4)                Report the code
         SEG   ''''                Terminate message
         CMDABORT ,                Error abort
         END   ,                      (I/O error)

         END   ,                      (nonzero RC)

         LR    R15,R4              Reset original BLDL return code
         PEND  ,
         TITLE 'PDSFIND - Find BPAM member for read'
*box
*
*  PDSFIND - Locate start of BPAM member for read
*
*  on Entry:   OSFPBAM and OSFPDS fields in TVTOSFIL
*
*  On exit:    The next read request will start at the specified
*              member.
*

PDSFIND  PROC  ,
         LA    R2,OSFBPAM          Address of bpam DCB
         LA    R3,OSFPDS           Address of bldl directory entry
         WITH  (PDSDIR,R3),BEGIN   Addressability to directory
         XCALL AMODE24             Enter 24-bit mode for find
         FIND  (R2),PDSTTR,C       Utilize in core BLDL list for find
         XCALL AMODE31             Enter 31-bit mode after find
         END   ,
         PEND  ,
         TITLE 'NOTEDSN - Retrieve TTR pointer for BSAM file'
*box
*
*  NOTEDSN - Retrieve current TTR from data set
*
*  On entry:   Either the OSFBSAM or OSFBPAM data control block
*              in the TVTOSFIL extension in a valid OPEN state.
*
*  On exit:    No errors are returned from the NOTEDSN routine
*              R0  (Write) contains the track balance in bytes
*                  (Read)  contains the track capacity in bytes
*              R1          Contains the current TTRZ value
*

NOTEDSN  PROC  ,
         XCALL AMODE24             Enter 24-bit addressing mode
         NOTE  OSFBSAM,TYPE=REL    Retrieve current TTR pointer
         XCALL AMODE31             Enter 31-bit addressing mode
         PRETURN (R0,R1)           Return note values
         PEND  ,
         TITLE 'PDSSTOW - Update directory after write'
*box
*
*  PDSSTOW - Update PDS directory
*
*  On entry:   OSFBPAM and OSFPDS fields in the TVTOSFIL
*
*              R15= 0  STOW_ADD Add operation
*                 = 1  STOW_REP Replace operation
*                 = 2  STOW_DEL Delete operation
*                 = 3  STOW_CNG Change operation
*
*              The DCB is open for OUTPUT or UPDATE of the PDS.
*
*  On exit:    The directory of the output PDS is updated with
*              current member data.
*
*              R15 =  0 Successful STOW
*                  =  4 Member already exists for type "A"
*                  =  8 Member does not exist for type "C", "R", "D"
*                  = 12 Insufficient room in directory
*                  = 16 Bad news!
*
*              For non zero return codes a formatted message is
*              placed in the ERRSCB seg control block
*
*  NOTE:
*  ch fixed long title bug on 08/17/92.  We now always clear bits
*  1,2 in the C byte of the TTRC.  These bits are the relocation
*  bits used in loadmodules to signify that some TTR need to be
*  relocated.  Wylbur cannot save load modules, so we must clear
*  these bits.                                         Leaving
*  these bits on can cause condense to fail trashing lib members.
*  The long title bug turned on these bits in error, so now we
*  always turn them off (we know we don't have any TTRn fields in
*  the directory).
*
         SPACE 2
PDSSTOWK RECORD BEGIN
PDSSDW   DS    2F
PDSSFLAG FLAG
         END   ,
         SPACE
PDSSTOW  PROC  PDSSTOWK
         LR    R2,R15              Save STOW option [A,R,D,C]
         IF    (R2,NZ),BEGIN       Check STOW options
         IF    ((R2,NP),OR,(R2,GT,3)),BEGIN  out of range
         FAIL  'BAD STOW OPTION PARAMETER'
         END   ,                        (option out of range)
         END   ,                      (check STOW options
         STC   R2,PDSSFLAG
         LA    R3,OSFPDS           Get address of directory
         WITH  (PDSDIR,R3)         Addressability to pds directory
         TM    PDSSFLAG,STOW_DEL   bit on = del or cng
         IF    Z,BEGIN             add or rep, i.e.not del/cng
*                                  see comments below above LCR stuff
*-
*-       Update directory information
*-
*                                  R4 usage: dir user data len
         LC    R4,PDSC             Load count of user halfwords
         N     R4,=A(X'1F')        Eliminate flags and ttr count
         SLA   R4,1                R4 - dir user data length (bytes)
         FLOOR R4,20               Minimum user data len
         STCK  PDSSDW              date/time from CPU clock
         L     R0,PDSSDW           hi word of clock
         L     R5,CVTPTR
         WITH  (CVT,R5),'AL R0,CVTTZ'  Time zone adjustment
         IF    (PDSSFLAG,EQ,0),BEGIN   new member
         STCM  R0,15,PDSCSTCK      save create date/time stamp
         END   ,                      (new member)
         MVC   PDSWYLCK,=C'WYL0'   Set wylbur identifier
         STCM  R0,15,PDSSTCK       Save time of last save
         CLEAR PDSACCT             Zero account
         MVC   PDSACCT(2),TVTGROUP     Set group code
         MVI   PDSACCT+2,C'.'          Set '.' separator
         MVC   PDSACCT+3(3),TVTUSER    Set user code
         MVC   PDSACCT+6(2),=CL2'  '   Blank remaining two bytes
         IF    (TVTPBTITLE,NZ),BEGIN   Update title information
         CLEAR PDSTITLE                Zero current title string
         LA    R0,42                   Maximum length of title
         LA    R1,TVTPBTITLE           Address of title string
         XCALL RTRIM                   Trim trailing blanks
         LR    R5,R0                   Move trimmed length
         LA    R5,@R5+1                Round up to even number
         N     R5,=A(X'FE')            For half-word length
         LR    R4,R5                   New title len
         DEX   R5,'MVC PDSTITLE(0),TVTPBTITLE'   Set updated title
         LA    R4,@R4+20               Total new user dir data len
         END   ,                       (update title)
         LC    R5,PDSC             Get C value
         N     R5,=X'00000080'     AND off all but alias bit
*                ,                 (get rid of bits 1/2 especially)
         SRL   R4,1                R4 - user data len (halfwords)
         N     R4,=X'0000001F'     Max title length insurance
         OR    R4,R5               New C value is alias bit and len
         STC   R4,PDSC             Replace in directory entry
*-       Preserve the K and Z fields in the BLDL list area
         XPUSH ,,PDSSTOWL,PTR=R5   Obtain stack space
         MVC   @R5(PDSSTOWL),PDSNAME          Save "K" and "Z" fields
         MVC   PDSNAME+2(PDSSTOWL-2),@R5      Set list for STOW
*-       Set register values to indicate type of stow
*-
         LA    R1,OSFBPAM          Address of BPAM DCB
         LA    R0,PDSNAME+2        Point to stow data
*  OK, gonna get cute here.  Operation is indicated by comp'ing
*  R0 or R1 or both.  Add (opt 0): no comp.  Rep (opt 1) comp R1.
*  Del (opt 2): comp R0.  Cng (opt 3):  comp R0 and R1.  So,
         SPACE
         IF    (PDSSFLAG.STOW_REP),'LCR R1,R1'  replace
         STOW  (1),(0)             Options have been set
         PTRACE STOWRET            Trace stow return codes
         LR    R4,R15              Save stow return code
         LR    R6,R0               Save stow reason code   ML940216
         MVC   PDSNAME(PDSSTOWL),@R5   Return "K" and "Z" fields
         XPOP  PTR=R5                  Restore stack
         END   ,                      (A or R)
         SPACE
         ELSE  BEGIN               D or C
*-       Set register values to indicate type of stow
*-
         LA    R1,OSFBPAM          Address of BPAM DCB
         LA    R0,PDSNAME          Point to stow data
         LCR   R0,R0               del or cng
         IF    (PDSSFLAG.STOW_REP),'LCR R1,R1'  change
* see comment above re: LCR instructions
         STOW  (1),(0)             Options have been set
         PTRACE STOWRET            Trace stow return codes
         LR    R4,R15              Save stow return code
         LR    R6,R0               Save stow reason code   ML940216
         END   ,                      (D or C)
*-       Common to all options:

         IF    (R4,NZ),BEGIN       some kind of error
         SEGCLR ERRSCB             Clear error segcb buffer

         IF    (R4,EQ,4),BEGIN     Member already exists
         TM    PDSSFLAG,STOW_CNG   change? (=rename)
         IF    NO,BEGIN            no, the dupename is here
         SEG   'ERRID=EXISTS ERRMSG='''
         SEGTB PDSNAME
         END   ,                      (not change)
         ELSE  BEGIN               yes, it's newname that's bad
         SEG   'ERRID=RENEXIST ERRMSG='''
         SEGTB PDSNEWNM
         END   ,                      (newname is bad)
         SEGB  'already exists in file'
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Report data set name
         SEG   ''''                Terminate message
         END   ,                      (already exists)

         ELSEIF (R4,EQ,8),BEGIN    Member not found
         SEG   'ERRID=NOTINPDS ERRMSG='''
         SEGTB PDSNAME             Report member name
         SEGB  'is not in library' Continue error message buildup
         LA    R15,ERRSCB          Address of error seg control block
         ACALL FMTDSN              Convert file name into message
         SEG   ''''                Terminate message
         END   ,                      (member not found)

         ELSEIF (R4,EQ,12),BEGIN   PDS directory is full
         SEG   'ERRID=DIRNOSPC ERRMSG=''Directory is full in file '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Report data set name
         SEG   ''''                Terminate message
         END   ,                      (directory full)

*                             REASON=X'B37' OR X'D37' OR X'E37'
         ELSEIF ((R4,EQ,16),AND,(R6,GE,2871),AND,(R6,LE,3639)),BEGIN
         SEGB  'ERRID=LIBFULL ERRMSG=''Not enough space in'
         LA    R15,ERRSCB          ADDRESS OF ERROR SEGCB
         ACALL FMTDSN              FORMAT NAME INTO MESSAGE
         SEG   ''''                Terminate message
         END   ,                      (x37)

         ELSE  BEGIN               Unusual error
         SEGB  'ERRID=DIRIOERR ERRMSG=''STOW error.  RC='
         SEGDC (R4)
         SEG   ', reason code='
         SEGHX (R6)
         SEG   ', DSN='
         LA    R15,ERRSCB          ADDRESS OF ERROR SEGCB
         ACALL FMTDSN              FORMAT NAME INTO MESSAGE
         SEG   ''''                Terminate message
         END   ,                      (unusual error)
         END   ,                      (some kind of error)
         LR    R15,R4              Reset original STOW return code
         PEND  ,
         SPACE
         LTORG ,
         TITLE 'LSPACE - Determine available space on volume'
*box
*
*  LSPACE - Determine available space on dasd volume
*
*  On entry:   R1  Contains the UCB address for the desired volume
*
*  On exit:    R15=0  Available space data returned in r1
*                 =NZ Return code from the LSPACE SVC call.  In
*                     addition the ERRSCB contains an error message
*

LSPACE   PROC  ,
         LR    R2,R1               Copy unit control boock address
         L     R1,=A(LSPLST)       Address of model paramter list
         L     R3,TVTOSFWK         ->work area
         MVC   OSFLSPC(LSPLSTL),@R1    initialize parameter list
         LSPACE UCB=(R2),DATA=(R3),F4DSCB=OSFFMT4,                     *
               SMF=NONE,MF=(E,OSFLSPC)
         PTRACE LSPACERT           Trace return code
         PEND  ,
         TITLE 'DEVCAP - return device capacities'
*box
*
*  DEVCAP - Return device capacities
*
*  On entry:   R1 Contains the address of the DEVCAPCT control block
*                 The DCUCBPTR field must contain a valid UCB pointer
*
*  On exit:    R15 = 0  R1 contains tracks/cylinder
*

DEVCAP   PROC  ,
         LR    R5,R1               SAVE ADDRESS OF PARAMETER LIST
         WITH  (DEVCAPCT,R5)       Addressability to rbinfo
         L     R3,CVTPTR           Set cvt pointer
         L     R3,CVTZDTAB-CVT(,R3)    set device characteristics
         L     R4,DCUCBPTR         Set UCB address
         WITH  (UCBOB,R4)           ## addressability to DCB
         LC    R1,UCBTBYT4         Get device type from ucb
         IC    R1,@R3(R1)          Get index into dct table
         ALR   R3,R1               Set start of device entry
         WITH  (DVCT,R3),BEGIN     ## address dct table
         L2    R0,DVCTRK           Get tracks per cylinder
         ST    R0,DCTRKCYL         Save tracks per cylinder
         L2    R0,DVCTRKLN         Set track length
         ST    R0,DCTRKLEN         Save track length
* following added 1995/01/18 mcl:
         LC    R1,UCBTBYT4         Get device type from ucb
         MH    R1,=AL2(##LDEVTB)   index our device table
         L     R15,=A(DEVTABLE)    ->table
         LA    R15,0(R1,R15)       ->entry for this disk type
         L     R0,@R15+8           get our blksize
         ST    R0,DCOPTBLK         save optimum blksize in dct
         END   ,                   That's enough for now
         CLEAR R15                 ZERO RETURN CODE
         ST    R15,DCRETCD         SAVE IN CONTROL BLOCK
         PEND  ,
         TITLE 'SETDEVCH - Set device characteristics'
*box
*
*  SETDEVCH - Set device characteristics
*
*  On entry:   R1 Contains the address of the RBINFO control block
*
*  On exit:    RBINFO fields have been updated
*

SETDEVCH PROC  ,
         LR    R2,R1               Move address of rbinfo control
         WITH  (RBINFO,R2)         Addressability to rbinfo
         LA    R15,4               RC if no volser
         CLC   TVTVOLSER,=C'      '  is volser defined?
         IF    H,BEGIN             got a volser...
         XPUSH ,,L'DEVCAPCT,PTR=R3 Reserve stack space
         WITH  (DEVCAPCT,R3),BEGIN
         CLEAR DEVCAPCT            Clear capacity control block
         LA    R1,TVTVOLSER        Address of data set volume serial
         XCALL FINDUCB             Locate data set's UCB pointer
*  1996/07/29 mcl:  just exit w/RC if no UCB (was: CMDCLEAN/INTFAIL)
         IF    (R15,NZ),BEGIN      Unable to locate required UCB
*        XPOP  PTR=R3              release stack space
         EXIT  SETDEVCH            ...and quit (with RC)
         END   ,                      (unable to locate UCB)

         ST    R1,RBUCBAD          Save UCB address
         ST    R1,DCUCBPTR         Save UCB pointer for devcap
         LR    R1,R3               Address of devcapct
         ACALL DEVCAP              Update device capacities
         MVC   RBTRKCYL,DCTRKCYL   Set tracks/cylinder value
         MVC   RBTRKLEN,DCTRKLEN   Set maximum track length
         MVC   RBOPTBLK,DCOPTBLK   optimum block size      ml950118
         END   ,                      (with R3)
         XPOP  PTR=R3              Release stack space
         SET   RBDEVSET            Indicate characteristics set
         IF    TVTREPT,BEGIN       report
         SEGCLR OSFSCB             Log value
         SEG   '      UCB=',,OSFSCB
         SEGHX RBUCBAD,8
         SEG   ', VOL='
         SEG   TVTVOLSER
         SEG   ', TRKS/CYL='
         SEGDC RBTRKCYL
         SEG   ', TRKLEN='
         SEGDC RBTRKLEN
         SEGWR ,
         END   ,                      (report)
         CLEAR R15                 RC
         END   ,                      (got a volser)
         PEND  ,
         LTORG ,
         TITLE 'Find and Allocate Existing File'
*box
*
*  EFSETUP - Find existing file, allocate, obtain DSCB
*
*            Used by FILEREAD and SHOWDIR (always)
*            Used by SCRATCH and RENAME (for PDS member)
*
*  On entry:  Command options parsed, TVTFILPB set up,
*             internal enqueue done.
*
*  On exit:  TVTVOLSER set, SVC99 allocate of file done, DSCB found.
*            DSORG retrieved, verified PS or PO; RECFM retrieved,
*            verified "defined".
*
*  This code formerly was in FILEREAD and SHOWDIR, moved 1996/11/07
*  We used to do the SVC99 after doing an OBTAIN, now do SVC99 first;
*  this eliminates a "window" where d.s. could be moved/recatlg'd
*  between OBTAIN and SVC99.  Also new logic works with HSM, as the
*  SVC99 forces recall of a migrated dataset.

EFWORK   RECORD BEGIN
EFFLAGS  FLAG  ,
         FLAG  EXFDISPOLD          want DISP=OLD
         END   EFWORK

EFSETUP  PROC  EFWORK
         CLEAR EXFDISPOLD
*-
*-       Find the data set
*-
         ACALL GTCATVOL            Get cataloged vol, if any
* If RC=0, R1 has ->vollist

         IF    (R15,NZ),BEGIN      Not in catalog
         IF    (TVTPBVOL,Z),BEGIN  and no volume specified
         SEGCLR ERRSCB             Clear segment buffer
         SEG   'ERRID=NOTFOUND ERRMSG='''
         LA    R15,ERRSCB          Address of error scb
         ACALL FMTDSN              Format data set name into message
         SEG   ' not found.'''
         CMDABORT ,                Cleanup path and re-wait
         END   ,                      (no vol)

         MVC   TVTVOLSER,TVTPBVOL  use specified vol-ser
         END   ,                      (not in catlg)

*  OK, now we either have (1) a volume in TVTPBVOL (which may override
*  catlg), or (2) a successful catalog lookup.  If (2), we DON'T use
*  vol from lookup for alloc -- we alloc w/o unit/vol and let alloc do
*  its own lookup.  This handles migrate recovery and multivol cases
*  cleanly.                                      ml 961111

*
*        Check access
*
         LA    R1,TVTFILPB         ->FILPB
         IF    ((TVTPBFREQVERIFY,AND,TVTPBFOCKWRITE),    verify-alter  *
               OR,TVTPBFREQWRITE,OR,TVTPBFREQAPPEND,OR,TVTPBFREQREPLACE*
               ,OR,TVTPBFREQSCRATCH,OR,TVTPBFREQRENAME),BEGIN
*                                  save, scratch, rename
         MVI   TVTPBRACFLG,RACF_ALTER  So check write access
         SET   EXFDISPOLD          ...and will need DISP=OLD
*  If only updating PDS member, UPDATE will do   1997/08/14 mcl
         IF    TVTUPMEM,'MVI TVTPBRACFLG,RACF_UPDATE'
         END   ,                      (need write access)

         ELSE  'MVI TVTPBRACFLG,RACF_READ'  read or normal verify
         VCALL CHKRACFA            go check (whatever) access

*  If no access, errmsg seg'd, error flags set

         IF    (R15,NZ),'CMDABORT'    if no access

         IF    TVTPBFOSHARE,'CLEAR EXFDISPOLD' want shared access
*                                              even though for output

         DYNCLEAR ,                Clean dynamic allocation buffer

         DYNADD (DALDSNAM,1,44),TVTPBDSNAME  Specify data set name
         IF    EXFDISPOLD,BEGIN              want exclusive use
         DYNADD (DALSTATS,1,1),=X'01'        disp=old
         END   ,                             (exclusive)
         ELSE  BEGIN                         non-exclusive
         DYNADD (DALSTATS,1,1),=X'08'        disp=shr
         END   ,                             (non-exclusive)

         IF    (TVTPBVOL,NZ),BEGIN           volume serial given
         DYNADD (DALVLSER,1,6),TVTPBVOL      set volume serial
         DYNADD (DALUNIT,1,8),=CL8'SYSALLDA' Add unit specification
         END   ,                             (volume serial given)

         DYNADD (DALRTDDN,1,8),GVTBLANK      return ddname
         XPUSH R1                            save address of ddname
         DYNADD (DALRTVOL,1,6),GVTBLANK      return volume serial
         XPUSH R1                            save address of volser

         DYNCALL ,                           allocate file
         PTRACE Xdyncall           Trace return from dyncall

         DYNCHECK ,                Process any return codes
         IF    (R15,GT,4),BEGIN    trouble...
         CMDABORT ,                Cleanup path and re-enter wait
         END   ,                      (trouble)

*-
*-       Retrieve dynamic allocation returned values for
*-       VOL=SER=, and DDNAME=
*-

         XPOP  R2                  Retrieve address of volser ret
         LH    R1,@R2+4            Load length of returned volser
         DEX   R1,'MVC TVTVOLSER(0),@R2+6'

         XPOP  R2                  Retrieve address of ddname ret
         MVC   TVTDDNAME,GVTBLANK  Blank out ddname
         LH    R1,@R2+4            Load length of returned ddname
         DEX   R1,'MVC TVTDDNAME(0),@R2+6'   move in ddname

         RECVRY ROUT=WFILFREE      Recovery reoutine to de-allocate

         ACALL OBTFMT1             get format-1 DSCB

*  OBTAIN done from TVTVOLSER
*  RC from OBTAIN:
*  0 = got the DSCB
*  4 = volume not mounted          error msg seg'd
*  8 = DSCB not in the VTOC        error msg seg'd
* 12 = unusual error               error msg seg'd
*  4 should be impossible here after successful svc99

         IF    (R15,NZ),BEGIN      error

*  RC nonzero, error message already seg'd by OBTAIN routine

         CMDABORT ,                Abort file read
         END   ,                      (error)

*-
*-       Determine data set organization
*-
         LA    R2,OSFFMT1          Address of format-1 DSCB
         WITH  (DS1DSNAM,R2),BEGIN                  FMT1-DSCB
         MVC   TVTDSORG,DS1DSORG   copy DSORG
         MVC   TVTRECFM,DS1RECFM   ...and record format
         END   ,                      (FMT1-DSCB)
         IF    (TVTDSORG.DS1DSGPS+DS1DSGPO,Z),BEGIN  invalid DSORG
         SEGCLR ERRSCB             Clear error segcb
         CLC   TVTDSORG(2),=X'0000'  undefined?
         IF    EQ,BEGIN            all zeros, undefined
         SEGB  'ERRID=DSEMPTY'     Data set empty (no DSORG)
         SEG   'ERRMSG=''Data set is empty (DSORG undefined)'''
         END   ,                      (DSORG all zeros)
         ELSE  BEGIN               invalid, but not zeros
         SEGB  'ERRID=BADDSORG'    Report error id
         SEG   'ERRMSG=''Invalid data set organization'
         SEG   ', DSORG='
         IF     (TVTDSORG,EQ,=X'0004'),'SEG "(TCAM)"'
         ELSEIF (TVTDSORG,EQ,=X'0008'),'SEG "(VSAM)"'
         ELSEIF (TVTDSORG,EQ,=X'2000'),'SEG "(DA)"'
         ELSEIF (TVTDSORG,EQ,=X'8000'),'SEG "(ISAM)"'
         ELSE   BEGIN              unknown nonzero
         SEG   'X'''''             Report actual dsorg
         L2    R1,TVTDSORG         Set data set organization
         SEGHX (R1),4              Report invalid dsorg valie
         SEG   ''''''
         END   ,                     (unknown nonzero)
         SEG   ''''                Complete errmsg= value
         END   ,                      (invalid, not zeros)
         CMDABORT ,                Abort current command
         END   ,                            (invalid DSORG)

         PEND  ,
         LTORG ,
         TITLE 'Find (Don''t Allocate) Existing File'
*box
*
*  SRSETUP - Find existing file, for scratch/rename
*
*            Used by SCRATCH and RENAME of whole dataset (not
*            for PDS member)
*
*  On entry:  Command options parsed, TVTFILPB set up,
*             internal enqueue done.
*
*  On exit:  TVTVOLSER set,  If RC=0, DSCB found.
*            If necessary, recalled
*            from migration.  DSORG retrieved.
*            Volume list (from catlg or user-given vol) is in
*            OSFCATWK.
*            If RC=4, volume not mounted, error message seg'd.
*            If RC=8, DSCB not found, error message seg'd.
*
*  This code formerly was in WSELVOL and partly in SCRATCH and RENAME.

SRSETUP  PROC  ,
*-
*-       Find the data set
*-
         MVI   TVTUCFLG,0          "OK to uncatlg" flag
         ACALL GTCATVOL            Get cataloged vol, if any

* If RC=0, R1 has ->vollist (saved in OSFCATWK)

         MVC   TVTVOLSER,TVTCATVOL catalog volume is it, unless..

         IF    (TVTPBVOL,NZ),BEGIN User specified a volume
         MVC   TVTVOLSER,TVTPBVOL  so use it
         IF    (R15,Z),BEGIN       and also is cataloged
         IF    (TVTPBVOL,NE,TVTCATVOL),'OI TVTUCFLG,1'  override
         END   ,                      (also catlgd)
         ELSE  'OI TVTUCFLG,1'     if not catlg'd
         END   ,                      (user volume)

         ELSEIF (R15,NZ),BEGIN     No vol, and not in catalog
         SEGCLR ERRSCB             Clear segment buffer
         SEG   'ERRID=NOTFOUND ERRMSG='''
         LA    R15,ERRSCB          Address of error scb
         ACALL FMTDSN              Format data set name into message
         SEG   ' not found.'''
         CMDABORT ,                Cleanup path and re-wait
         END   ,                      (no vol)

*  OK, now we either have a volume in TVTVOLSER to use, either user
*  specified or from the catalog.  If cataloged and user gave a
*  different vol, we have set TVTUCFLG to indicate "don't change catlg"

         IF    (TVTUCFLG.1),BEGIN  catlg override/not catlgd
         MVC   OSFCATCT,=H'1'      Build volume list: volcount
         MVC   OSFCATVV,TVTPBVOL    ...volser
         LA    R1,TVTPBVOL         Address of volume serial
         XCALL FINDUCB             Locate unit control block address
         IF    NZ,BEGIN            Unable to locate UCB
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTMNTD'     No volume located
         SEGB  'ERRMSG=''Volume'
         SEGTB TVTVOLSER           Add volume serial to message
         SEG   'is not mounted.'''
         CMDABORT ,                Abort rename command
         END   ,                      (no UCB)

         WITH  (UCBOB,R1)           ## addressability to UCB
         MVC   OSFCATVU,UCBTYP     UCBTYPE info into volume list
         END   ,                      (catlg override/not cat)
*
*        Check access
*
         LA    R1,TVTFILPB         ->FILPB
         MVI   TVTPBRACFLG,RACF_ALTER       scratch/rename needs
         IF    TVTUPMEM,'MVI TVTPBRACFLG,RACF_UPDATE' if pds mem
         VCALL CHKRACFA                         ALTER access

*  If no access, errmsg seg'd, error flags set

         IF    (R15,NZ),'CMDABORT'    if no access

         IF    (TVTPBMIGRATED),BEGIN   HSM got it
         LA    R1,TVTPBDSNAME      ->dsn
         XCALL TICKLEDS            go get it back
         ACALL GTCATVOL            find where it went
         MVC   TVTVOLSER,TVTCATVOL
         END   ,                      (HSM got it)

         ACALL OBTFMT1             get format-1 DSCB

*  OBTAIN done from TVTVOLSER
*  RC from OBTAIN:
*  0 = got the DSCB
*  4 = volume not mounted          error msg seg'd
*  8 = DSCB not in the VTOC        error msg seg'd
* 12 = unusual error               error msg seg'd

         IF    (R15,GT,8),'CMDABORT'    error

*  RC nonzero, error message already seg'd by OBTAIN routine

         IF    (R15,Z),BEGIN       OK, got a DSCB
         LA    R2,OSFFMT1          Address of format-1 DSCB
         WITH  (DS1DSNAM,R2),BEGIN                  FMT1-DSCB
         MVC   TVTDSORG,DS1DSORG   copy DSORG
         MVC   TVTRECFM,DS1RECFM   ...and record format
         END   ,                      (FMT1-DSCB)
         END   ,                      (got a format-1)

         ELSE  BEGIN               no volume and/or dscb
         CLEAR TVTDSORG
         CLEAR TVTRECFM
         END   ,                      (no vol/dscb)
*  R15 left with Rc from OBTAIN...

         PEND  ,
         LTORG ,
         TITLE 'File Read Routine'
*box
*
*  FILEREAD - File read routine, also does file verify
*
*  On Entry:   Data set name and optional volume location
*              information has been set into the TVT.
*
*  On Exit:    READ -
*              Data set has been passed to the client.  Next command
*              expected from the client will be a FILE_EOF:.
*
*              VERIFY - FILE_OK has been passed to client, unless an
*              error message was passed during OPEN
*
*  Flow:       1. RDOPEN - Open file for BSAM input.
*              2. RDFILE - Process input file.
*                 2a.  GETRECD - Return record
*                      3.  NEXTBLK - Return next sequential block
*                      4.  READBLK - Low level BSAM read
*
         SPACE 2
FILEREAD PROC  ,
*-
*-       Count USE command
*-
         IF    TVTPBFREQREAD,'INCR  R0,TVTCNTUSE'  Tally USE command

*  Enqueue within this WINGS job

         L     R0,=A(TDNQSHR)      shared...
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

         ACALL EFSETUP             find dataset, allocate, get DSCB
*                                  was inline here, made proc 961107

         IF    TVTDSORG.DS1DSGPO,BEGIN       Mark as a library
         SET   TVTFISPDS                     set as a pds
         IF    (~TVTPBFREQVERIFY,AND,(TVTPBDSMEM,Z)),BEGIN No member
         PTRACE NoMemSp                      Trace error
         SEGCLR ERRSCB                       Clear error SEGCB
         SEGB  'ERRID=NOMEMBER'              Set error id
         SEGB  'ERRMSG=''Member not specified in library'
         LA    R15,ERRSCB                    Address of error segcb
         ACALL FMTDSN                        Add file name
         SEG   ''''                          Terminate message
         CMDABORT ,                          Abort current command
         END   ,                            (no member specified)
         END   ,                            (library)
         ELSE  BEGIN                         sequential data set
         SET   TVTFISPS                      set as sequential
         IF    (TVTPBDSMEM,NZ),BEGIN         member of sequential
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTPDS'      Report error:  not a PDS
         SEG   'ERRMSG='''
         SEGT  TVTPBDSNAME
       SEG ' is not a partitioned data set.  Member does not exist.'''
         CMDABORT ,                Abort current command
         END   ,                            (member of sequential)
         END   ,                      (sequential)
*
*  check for valid RECFM
*  ml 1994/11/30
         IF    ((TVTRECFM,Z),AND,(TVTPBRECFM,Z)),BEGIN  NO RECFM
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=DSEMPTY'     Report error ID
         SEG   'ERRMSG=''Data set empty (RECFM not defined)'''
         CMDABORT ,                Abort current command
         END   ,                      (no RECFM)

*  check last-address-written (see if empty)
*  ml 1997/07/07  deleted 1997/09/02...LSTAR may be zero even
**-               though a filemark was written.
**-      LA    R2,OSFFMT1          Address of FMT1 DSCB area
**-      WITH  (DS1DSNAM,R2),BEGIN Addressability to fmt1 dscb
**-      IF    (DS1LSTAR,Z),BEGIN  empty file (LSTAR not set)
**-      SEGCLR ERRSCB             Clear error segcb
**-      SEGB  'ERRID=DSEMPTY'     Report error ID
**-      SEG   'ERRMSG=''Data set empty (never written)'''
**-      CMDABORT ,                Abort current command
**-      END   ,                      (no LSTAR)
**-      END   ,                      (with DSCB)

         ACALL RDOPEN              Open file for input processing
         IF    NZ,BEGIN            Error in file open
         CMDABORT ,                Abort current command
         END   ,
         ACALL INITRB              Build an RBINFO block
         WITH  (RBINFO,R1),BEGIN   Addressability to rbinfo block
         L     R0,TVTBUFP          Address of the input buffer
         ST    R0,RBSTART            save in rbinfo
         END   ,

*-
*-  Tell client that file is open and ready
*-
         SEGLD TVTSCB              Set path seg control block
         IF    TVTPBFREQVERIFY,BEGIN
         WINGSHDR SET,HEADER='FILE_VERIFY:'
         END   ,                   (verify)
         ELSE  BEGIN               read
         WINGSHDR SET,HEADER='FILE_OPEN:'
         END   ,                   (read)
         SEG   'NAME='             Return completed data set name
         LA    R1,TVTPBDSNAME      Address of complete data set name
         LA    R0,44               Set maximum length of name
         XCALL RTRIM               Trim trailing blanks
         SEG   (R1),(R0)           Return data set name
         IF    (TVTPBDSMEM,NZ),BEGIN Return member if present
         SEG   '('                 OPEN MEMBER SPECIFICATION
         SEGT  TVTPBDSMEM            TRIM TRAILING BLANKS
         SEG   ')'                 CLOSE MEMBER SPCIFICATION
         END   ,                      (member present)
         IF    TVTPBFREQVERIFY,BEGIN   verify
         SEG   ' FILE_OK'
         END   ,                      (verify)
         SEGWR ,                   Complete message

         IF    TVTPBFREQREAD,BEGIN READ request, get some data
         ACALL RDFILE              Read sequential file
         IF    NZ,BEGIN            Error in file read
         CMDABORT ,                Abort current command
         END   ,                      (error in file read)
*-
*-       File has been processed and sent across the client path.
*-       Close files and send FILE_EOF:
*-
**       QSNAP 'FILE_EOF SENT'
         WINGSHDR SET,HEADER='FILE_EOF:'
         SEGCLR TVTSCB             Clear any residual data
         SEGWR ,,TVTSCB            Write end of file message
         MVC   TVTPATNX,=CL16'FILE_EOF:'

*-
*-       Call all recovery routines to perform housekeeping and
*-       close files.
*-
         ACALL RECOVERY            Process recovery stack
         SET   TREADEOF            show we're pretty much done
**       QSNAP 'After RECOVERY after READFILE'
**       QSNAP TVTNQFLG,1
         IF    (TVTNQFLG,NZ),BEGIN
**       QSNAP TVTNQDSN
         END   ,
         END   ,                      (READ request)
         SPACE
         ELSE  BEGIN               not READ
         SET   TPATERR             we will close path now
         CLEAR TVTPATNX
         B     CMDCLEAN            normal return via cleanup
         END   ,                      (not READ)
         PEND  ,
         LTORG ,
         EJECT ,
*box
*
*  Buffer cleanup error recovery routine
*
*  1995/05/31 mcl

BUFREC   PROC  ,
         LT    R1,TVTBUFP          Check for allocated buffer
         IF    NZ,BEGIN            Release data buffer if present
         VCALL FREECORE            Release buffer
         CLEAR TVTBUFP             clear pointer
         CLEAR TVTBUFSZ
         END   ,                      (had buffer)
         PEND  ,
         TITLE 'RDOPEN - Open BSAM/BPAM DCB for Input'
*box
*
*  RDOPEN - Open file for BSAM/BPAM sequential input processing
*
*  On Entry:   The file has been successfully allocated and the
*              TVTDDNAME field in the tvt has been initialized to
*              the allocated DDNAME.
*
*  On Exit:
*     R15=0   File successfully opened for input processing.  If
*             PDS, requested member has been found.
*
*     R15=NZ  ERRSCB contains error message.
*
         SPACE 2
RDOPEN   PROC  ,
         RECVRY ROUT=RDOPRCY       Stack rdopen recovery routine
*                                  Set prototype bsam DCB
         IF    TVTFISPDS,BEGIN     Processing for bpam library read
         LA    R0,OSFBSAM          Address of bsam DCB
         LA    R1,DCBBPAML           length of bsam DCB
         L     R14,=A(DCBBPAM)         address of prototype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB
         END   ELSE,BEGIN
         LA    R0,OSFBSAM          Address of bsam DCB
         LA    R1,DCBBSAML           length of bsam DCB
         L     R14,=A(DCBBSAM)         address of prototype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB
         END   ,

*
         LA    R3,OSFBSAM          Address of input bsam DCB
         WITH  (IHADCB,R3)         Addressability to input bsam DCB
*                                  Open input
         MVC   DCBDDNAM,TVTDDNAME  Set allocated ddname into DCB
         L     R0,=A(OSFREXL)      Address of exit list (ABEND exit)
         ST3   R0,DCBEXLSA         Save exit list address in DCB
         L     R0,=A(READEOF)      Address of end of data routine
         ST3   R0,DCBEODA          Set eodad in DCB
         L     R0,=A(READSYNA)     Address of SYNAD error routine
         ST3   R0,DCBSYNA          Set SYNAD address in DCB
         CLEAR TVTDCBAB            not abending yet...
         IF    TVTPBFRECEDIT,BEGIN If caller forced edit format
         SET   (DCBRECFM.DCBRECU,EQ)
         SET   TVTPBOVRRECFM       show format override
         MVI   DCBRECFM,DCBRECU    and use RECFM=U
         END   ,                     (caller force EDIT)

         ELSEIF TVTPBFRECFIX,BEGIN If caller forced FB format
         SET   (DCBRECFM.DCBRECF+DCBRECBR,EQ)
         SET   TVTPBOVRRECFM       show format override
         MVI   DCBRECFM,DCBRECU    and use RECFM=U
         L     R0,TVTPBLRECL       caller-supplied LRECL
         IF    (R0,P),BEGIN        yes he did
         STH   R0,DCBLRECL         then force it...
         SET   TVTPBOVRLRECL       show override
         END   ,                      (caller-supplied LRECL)
         END   ,                     (caller force FB)

         ELSEIF TVTPBFRECVAR,BEGIN If caller forced VB format
         SET   (DCBRECFM.DCBRECV+DCBRECBR,EQ)
         SET   TVTPBOVRRECFM       show it
         END   ,                     (caller force VB)

         ELSEIF (TVTPBLRECL,NZ),BEGIN  no RECFM but forced LRECL
         SET   TVTPBOVRRECFM+TVTPBOVRLRECL    show both forced
         SET   TVTPBFRECFIX        Assume RECFM=F
         MVI   DCBRECFM,DCBRECU    but use U in DCB...avoid
*                                  wrong-length-record errors
         END   ,                      (forced LRECL but not RECFM)

         L     R0,TVTPBBLKSIZE     caller-supplied BLKSI
         IF    (R0,P),BEGIN        yes he did
         STH   R0,DCBBLKSI         then force it...
         END   ,                      (caller-supplied BLKSI)

         OPEN  ((R3),(INPUT))      Issue open for input

*                                  Check open
         IF     TVTDCBAB,BEGIN     abend on open
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=BADOPEN ERRMSG=''OPEN ABEND ('
         ACALL FMTABEND            Add code to message
         SEG   ')'''                 Terminate message
         LA    R15,8               Set RC for fail
         EXIT  RDOPEN              Terminate open processing
         END   ,                      (ABEND)

         ELSE  BEGIN               check other problems
         TM    DCBOFLGS,DCBOFOPN   Test for successful open
         IF    Z,BEGIN             An error has occurred during open
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=BADOPEN ERRMSG=''OPEN failed for input.'''
         LA    R15,4               Set non-zero returna code
         EXIT  RDOPEN              Abort open processing
         END   ,                      (error during open)
         END   ,                      (check other)


*
*                                  PDS LIBARARY PROCESSING
         IF    TVTFISPDS,BEGIN     Find requested member in directory
         IF    (TVTPBDSMEM,NZ),BEGIN   got a member (always for read,
*                                      optional for verify)
         ACALL PDSBLDL             Locate member in directory
         IF    (R15,NZ),BEGIN      Couldn't find member
         CMDABORT ,                Abort file use operation
         END   ,                      (find fail)
         ACALL PDSFIND             Point bpam to correct ttr
         END   ,                      (member name present)
         END   ,                      (find member)
*
** the following logic needs a lot of work       mcl 1994/11/23
**
** need to:
** 1.  allow user to specify any overriding RECFM
** 2.  make no assumptions about lrecl if RECFM override
** 3.  do some checks before open (check DSCB)
** 4.  fail if recfm undefined in DSCB
*** 1-4 done, see above and below                ml950921
** 5.  allow U-not-edit
** 6.  generally, do the kind of stuff IOPROGM would do
**
         IF    ~TVTPBOVRRECFM,BEGIN  normal case is no override
*                                  extract info from DCB
*
         CLEAR TVTPBRECFM          actual RECFM will override
         IF    ('TM DCBRECFM,DCBRECU',ONES),BEGIN          RECFM=U
         SET   TVTPBFRECEDIT       Set edit format dataset
*                Note: all undefinded is treated as edit.
*                If not really edit. we will tell user.
*                We could not read real undefined anyway.
         END   ,                                          (RECFM=U)

         ELSEIF ('TM DCBRECFM,DCBRECV',ONES),BEGIN         RECFM=V
         SET   TVTPBFRECVAR        Set variable format data set
         IF    DCBRECFM.DCBRECCA,' SET TVTPBFRECCA '    VBA
         LH    R0,DCBLRECL         Get LRECL               ML940411
         C     R0,=F'5'            minimum plausible
         IF    L,BEGIN             LRECL too small
         LH    R0,DCBBLKSI         use BLKSIZE-4
         S     R0,=F'4'            -4 for BDW
         IF    (R0,LT,5),BEGIN     BLKSIZE too small
         SEGCLR ERRSCB
         SEG   'ERRID=BADLRECL ERRMSG=''LRECL and BLKSIZE too small'''
         LA    R15,4
         EXIT  RDOPEN
         END   ,                   (BLKSIZE too small)
         END   ,                   (LRECL too small
         STH   R0,DCBLRECL         (possible adjusted) LRECL
         ST    R0,TVTPBLRECL       ...save in TVT          ml950921
         END   ,                             (RECFM=V)

         ELSEIF ('TM DCBRECFM,DCBRECF',ONES),BEGIN         RECFM=F
         SET   TVTPBFRECFIX        Set fixed format data set
         LH    R0,DCBLRECL         LRECL from dataset after open
         ST    R0,TVTPBLRECL       ...save in TVT          ml950921
         IF    DCBRECFM.DCBRECCA,' SET TVTPBFRECCA '    FBA
         END   ,                                          (RECFM=F)

*                                  Do not allow VBS
         TM    DCBRECFM,X'48'      VBS
         IF    (ONES,AND,TVTPBFRECVAR),BEGIN     RECFM=VBS
         SEGCLR ERRSCB
         SEG   'ERRID=BADRECFM ERRMSG=''Input VBS record format not sup*
               ported'''
         LA    R15,4
         EXIT  RDOPEN
         END   ,                                (RECFM=VBS)

         END   ,                       (format not forced in cmd)

*  Save block size

         LH    R0,DCBBLKSI
         IF    (R0,NP),BEGIN       No blocksize set        MCL121493
** we probably can't get here, since we've had successful OPEN
**                                               mcl 1994/11/23
         L     R0,=F'32760'        default is max.         MCL121493
**   maybe oughta just bomb here, probably an empty file   MCL121493
         END   ,                   (no blocksize)          MCL121493
         IF    (R0,GE,TVTPBBLKSIZE),BEGIN    don't reduce it
         ST    R0,TVTPBBLKSIZE
         END   ,                      (don't reduce)
*
         IF    ~TVTPBFREQVERIFY,BEGIN   if not verify, get buffers
*                                  Get read buffers
         L     R0,TVTPBLRECL
         FLOOR R0,256                  ** minimum slop
         A     R0,=A(16)               ** additional slop
         VCALL GETLOW                  obtain memory for buffer
         ST    R1,TVTLINBF               save buffer address
         L     R0,TVTPBBLKSIZE
         ST    R0,TVTBUFSZ
         VCALL GETLOW                  obtain memory for buffer
         ST    R1,TVTBUFP                save buffer address
         RECVRY ROUT=BUFREC        Stack recovery routine
         END   ,                       (get buffers)
*
         CLEAR  R15                Zero return code
         PEND  ,                   Return to caller
         EJECT ,
*box
*
*  RDOPEN  - Recovery routine processing
*

RDOPRCY  PROC  ,
         LA    R2,OSFBSAM          Address of bsam DCB
         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN Close DCB if left open
         CLOSE ((R2)),MF=(E,TVTOPEN)
         END   ,
         END   ,
         ACALL WFILFREE            un-allocate it          ml940816
         LT    R1,TVTLINBF         Is there any line buffer
         IF    NZ,BEGIN            Yes - release it
         VCALL FREECORE            Release memory for line buffer
         END   ,
         PEND  ,
         LTORG ,
         TITLE 'FMTABEND -- Format completion code and return code'
*box
*
*  FMTABEND - Format the completion code and return code saved
*             by the DCB ABEND exit or other similar code.
*
*  On entry:  TVTIOAB contains the completion code in the first
*             12 bits, and the return code in the third byte.
*  On exit:   These values seg'd to message as ccc-rc
*
         SPACE 2
FMTABEND PROC  ,                   Format abend code
         L     R0,TVTIOAB          the code bits
         SRL   R0,20               as low 3 digits
         SEGHX (R0),3              to msg
         SEG   '-'
         CLEAR R0
         IC    R0,TVTIOAB+2        return code (1 byte)
         SEGHX (R0),2
         PEND  ,
         TITLE 'PDOPEN - Open PDS directory for input'
*box
*
*  PDOPEN - Open PDS directory for sequential input
*
*  On Entry:   The file has been successfully allocated the the
*              TVTDDNAME field in the TVT has been initialized to
*              the allocated DDNAME.
*
*  On Exit:
*     R15=0   File successfully opened for input processing.
*     R15=NZ  ERRSCB contains error message.
*
         SPACE 2
PDOPEN   PROC  ,
*                                  Set prototype QSAM DCB
         LA    R0,OSFQSAM          Address of QSAM DCB
         LA    R1,DCBQSAML           length of QSAM DCB
         L     R14,=A(DCBQSAM)         address of prototype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB

*
         LA    R3,OSFQSAM          Address of input QSAM DCB
         WITH  (IHADCB,R3)         Addressability to input QSAM DCB
*                                  Open input
         MVC   DCBDDNAM,TVTDDNAME  Set allocated ddname into DCB
*  2001/10/11 MCL:  moved following 4 lines here, were after open
         L     R0,=A(DIREOF)       Address of end of data routine
         ST3   R0,DCBEODA          Set eodad in DCB
         L     R0,=A(DIRSYNAD)     Address of SYNAD error routine
         ST3   R0,DCBSYNA          Set SYNAD address in DCB
*  2001/10/11 MCL:  added following before OPEN
         L     R0,=A(OSFDEXL)      Address of exit list (ABEND exit)
         ST3   R0,DCBEXLSA         Save exit list address in DCB
         CLEAR TVTDCBAB            not abending yet...

         OPEN  ((R3),(INPUT))      Issue open for input
         CLEAR TVTFEOF

*  Check OPEN                      Check open
*  2001/10/11 MCL:  added ABEND check
         IF     TVTDCBAB,BEGIN     abend on open
         SEGCLR ERRSCB             Clear error segcb
         SEG   'ERRID=BADOPEN ERRMSG=''OPEN ABEND ('
         ACALL FMTABEND            Add code to message
         SEG   ') reading directory'''
         LA    R15,4               Set RC for fail
         EXIT  PDOPEN              Abort open processing
         END

         TM    DCBOFLGS,DCBOFOPN   Test for successful open
         IF    Z,BEGIN             An error has occurred during open
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=BADOPEN'     Report error identifier
         SEG   'ERRMSG='''         Report error message
         SEG   'Open failed for directory read.'''
         LA    R15,4               Set non-zero returna code
         EXIT  PDOPEN              Abort open processing
         END

         RECVRY ROUT=PDOPRCY       Stack rdopen recovery routine

         CLEAR TVTPBRECFM          actual recfm will override
*                                  Save record length, block size
*
*                                  Get read buffers
         LA    R0,256              Directory block size
         VCALL GETLOW                  obtain memory for buffer
         ST    R1,TVTLINBF               save buffer address
*
         CLEAR  R15                Zero return code
         PEND  ,                   Return to caller
         EJECT ,
*box
*
*  PDOPEN  - Recovery routine processing
*

PDOPRCY  PROC  ,
         LA    R2,OSFQSAM          Address of QSAM DCB
         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN Close DCB if left open
         CLOSE ((R2)),MF=(E,TVTOPEN)
         FREEPOOL (R2)
         END   ,
         END   ,
         ACALL WFILFREE            un-allocate it          ml940816
         LT    R1,TVTLINBF         Is there any line buffer
         IF    NZ,BEGIN            Yes - release it
         VCALL FREECORE            Release memory for line buffer
         END   ,
         PEND  ,
         TITLE 'RDFILE - Read sequential QSAM input'
*box
*
*  RDFILE - Read sequential BSAM input file and pass data to
*           WINGS path.
*
*  On entry:   The input BSAM DCB has been successfully opened
*              and the input buffers allocated.
*
*  On Exit:
*    R15=0     File has been successfully passed to the wings path.
*    R15=NZ    Error message present in errscb.
*
         SPACE 2
RDWA     RECORD BEGIN
RDR0     DS    F
RDR1     DS    F
         END
*
RDFILE   PROC  RDWA
         CLEAR RDWA                Clear stack work area
         ST    R0,RDR0             Save called r0 value
         ST    R1,RDR1             Save called r1 value
*
         WINGSHDR SET,HEADER='FILE_READ:'
         L     R5,TVTRBINF         Address of rbinfo control block
         WITH  (RBINFO,R5),BEGIN   Addressability to rbinfo
*                                  Set up deblocking info
         IF    TVTPBFRECEDIT,'SET RBFEDIT'    set edit format
         IF    TVTPBFRECVAR,'SET RBFVAR'       set variable format
         IF    TVTPBFRECFIX,'SET RBFFIX'       set fixed format
**?CC    IF    TVTPBFRECCA,'SET RBFANSI'    set ANSI CC
         L     R0,TVTPBLRECL       Set data set logical record
         ST    R0,RBLRECL            length in rbinfo
         L     R0,TVTPBBLKSIZE     Set data set block size value
         ST    R0,RBBLKSI            length in rbinfo
*
*                                  Loop reading records
         L     R1,TVTLINBF         Address of record buffer
         L     R15,TVTRBINF        Address of rbinfo control
         ACALL GETRECD             Get first record
         WHILE (R15,Z),BEGIN
         SEGLD TVTSCB              Set address of path segcb
         SEG   (R1),(R0)           Seg record to wings path
         SEGMARK ,                 Mark end of record for ovl
         L     R1,TVTLINBF         Address of record buffer
         L     R15,TVTRBINF        Address of rbinfo control
         ACALL GETRECD             Get next record
         END   ,                   Loop
*
*                                  Process loop termination
         IF    ((R15,NZ),AND,(R15,NE,4)),BEGIN
         LA    R15,8               Set error return code
         EXIT  RDFILE              Error return
         END
*
*                                  Force out any path buffer
         SEGWR ,
         CLEAR R15
         END   ,
         PRETURN (R0,R1)
         PEND  ,
         TITLE 'GETRECD - Deblock Record from Buffer'
*box
*
*  GETRECD - Deblock record from buffer area
*
*  On entry:
*     R1       Record deblock recieve area
*     R15      RBINFO address
*
*  On Exit:
*     R0       ACTUAL RECORD LENGTH (in wings format)
*     R15=0    ALL OK
*     R15=NZ,  END OF FILE,
*              NOTE: ALL OTHER ERRORS EXIT VIA CMDCLEAN
*
*  NOTE:
*  CAUTION!:
*  Minimum record area must be LRECL+12 bytes long for FB,VB,VBS.
*  For EDIT it must be 256+12 bytes long. That is we assume that
*  the return buffer is big enough so that it will ** never **
*  overflow.
*
*  NOTE:
*  Number field for FB and VB is dummied.  Line number
*  policy is determined by WYLBUR.
*
*  NOTE:
*  Errors exit via CMDCLEAN, do not expect a return from here
*
         SPACE 2
GRWA     RECORD BEGIN
GRLOC    DS    A
GRLEN    DS    A
GRBLKEND DS    A
GRPRESS  DS    XL(256)
         END
MAXLNO   EQU   99999999
*
*
GETRECD  PROC  GRWA,TRACE=NO
         CLEAR GRWA
         ST    R1,GRLOC            Save passed location
         ST    R0,GRLEN            Save passed record length
         LR    R4,R1               Set address of record buffer
         WITH  (WGSLINE,R4),BEGIN  Addressability to output line
         LR    R6,R15              Set address of rbinfo
         WITH  (RBINFO,R6),BEGIN   Addressability to rbinfo
*
*                                  Check for records in blk
*                                  Read next block if needed
         L     R1,RBSTART
         A     R1,RBDATALN
         ST    R1,GRBLKEND
         L     R1,RBNDX
         IF    ((R1,Z),OR,(R1,GE,GRBLKEND)),BEGIN   need next block
         ACALL NEXTBLK             We read and check block
         IF    (R15,NZ),BEGIN      R15=4 eof, r15=8 error
         EXIT  GETRECD             If eof, error, exit
         END
         L     R1,RBSTART
         A     R1,RBDATALN
         ST    R1,GRBLKEND
         END
*
*                                  Deblock edit format
         IF    (RBFEDIT,AND,~RBFXEDIT),BEGIN
         LA    R1,WGSLNTXT
         L     R15,RBNDX
         ACALL UNPRESS             Unpress text
         IF    ((R0,NEG),OR,(R15,GT,=A(MAXLNO))),BEGIN
         SEGCLR ERRSCB             Clear error seg control block
         SEG   'ERRID=IOERROR ERRMSG=''Invalid EDIT format data.'''
         CMDABORT ,                Cleanup path and re-wait
         END
         A     R0,=A(L'WGSLNHDR)   Save length, line number
         ST    R0,WGSLNLEN
         LA    R1,WGSLNLNO
         LA    R0,8
         ACALL BTDZEROS
         L     R1,RBNDX            Update blk index
         CLEAR R2
         IC    R2,EDITCNT(R1) (TEXT LEN)
         A     R2,=A(5)
         AR    R1,R2
         ST    R1,RBNDX
         END
*
**? following may no longer be true...get WRNG.LEN.RECORD ml950601
*  For fixed deblocking we allow short end of block
*  record.  Because we allow fixed read of EDIT, VBS, etc.
*  in violation of the actual format.
*
*                                  Deblock fixed format
         IF    RBFFIX,BEGIN         Set up mvcl r2,r0
         L     R0,RBNDX
         L     R1,RBLRECL
         LR    R5,R0
         AR    R5,R1               R5 - end of record
         IF    (R5,GT,GRBLKEND),BEGIN short record at eob
         L     R1,GRBLKEND
         SR    R1,R0
         END
         LA    R2,WGSLNTXT
         LR    R3,R1
         LR    R5,R3               R5 - text length
         MVCL  R2,R0               Move text
         LA    R5,L'WGSLNHDR(R5)
         ST    R5,WGSLNLEN         Save length,
         CLEAR WGSLNLNO            Save dummy (zero) line no
         L     R1,RBNDX            Update blk index
         A     R1,RBLRECL
         ST    R1,RBNDX
         END
*
*
*                                  Deblock VB format
         IF    RBFVAR,BEGIN
         L     R1,RBNDX            Validity check len
         LR    R3,R1               Save RDW ptr. for msg   ML940411
         LH    R0,VBSLEN(R1)       Length from RDW         ML940411
         AR    R1,R0                                       ML940411
         IF    ((R1,GT,GRBLKEND),OR,(R0,LT,4)),BEGIN       ML940430
         SEGCLR ERRSCB             Clear error seg control block
      SEGB  'ERRID=IOERROR ERRMSG=''Invalid VB record descriptor word:'
         SEGHX @R3,8
         SEG   ''''
         CMDABORT ,
         END
         L     R0,RBNDX            Set up mvcl r2,r0
         A     R0,=A(L'VBSHDR)
         L     R1,RBNDX
         LH    R1,VBSLEN(R1)
         S     R1,=A(L'VBSHDR)
         LA    R2,WGSLNTXT
         LR    R3,R1
         LR    R5,R3               R5 - text length
         MVCL  R2,R0
         LA    R5,L'WGSLNHDR(R5)
         ST    R5,WGSLNLEN         Save length,
         CLEAR WGSLNLNO            Save dummy (zero) line no
         L     R1,RBNDX            Update blk index
         AH    R1,VBSLEN(R1)
         ST    R1,RBNDX
         END
         EJECT ,
*
*  Extended EDIT is a thing of the past, used in the
*  past for multiple active files saves.  We include
*  this only so we can read existing saved extended
*  EDIT files.   We process only a few of the xtnd
*  EDIT fields; those that were actually used.
*
*  Current multiple are saved with control info imbedded
*  in the text.  See comments in WYLBUR use/save code.
*
*  EXTENDED EDIT FORMAT, BRIEFLY
*    OFFSET   LEN    FIELD.       FLags description
*     0        1      FLAGS           x'80' - not pressed
*     1        3      USER            x'40' - marked (?)
*     4        4      CLOCK           x'20' - extended edit
*     8        2      SET NUMBER      x'10' - halfword count
*    10        4      LINE NUMBER     x'08' - reserved
*    14       1/2     PRESS COUNT
*    15/16     n      PRESS TEXT
*  ALSO FIRST BIT IN BLOCK IS SET TO 1.  (ie len is or'd x'8000')
*
*
*                                  Deblock extended edit
         IF    RBFXEDIT,BEGIN
         L     R1,RBNDX
         IF    (@R1,NE,X'20'),BEGIN
         SEGCLR ERRSCB
     SEG  'ERRID=IOERROR ERRMSG=''Invalid EXTENDED EDIT format data.'''
         CMDABORT ,
         END
         IF    (RBLNO,EQ,0),BEGIN  First line
         SETMSG '*CTL%%%%MULTIPLE FILE FORMAT VERSION 00.00'
         LR    R2,R0
         MOVE  R2,WGSLNTXT,@R1
         A     R0,=A(12)           Save length line number
         ST    R0,WGSLNLEN
         L     R15,RBLNO
         A     R15,=A(1)
         ST    R15,RBLNO
         LA    R1,WGSLNLNO
         LA    R0,8
         ACALL BTDZEROS
         END
         ELSEIF ('TM @R1+8,128',ONES),BEGIN   new set
         SETMSG '*CTL%%%%OPEN NEW ACTIVE'
         LR    R2,R0
         MOVE  R2,WGSLNTXT,@R1
         A     R0,=A(12)           Save length, line number
         ST    R0,WGSLNLEN
         L     R15,RBLNO
         A     R15,=A(1)
         ST    R15,RBLNO
         LA    R1,WGSLNLNO
         LA    R0,8
         ACALL BTDZEROS
         L     R1,RBNDX            Update blk index
         CLEAR R2
         IC    R2,14(R1)           (text len)
         LA    R2,15(R2)
         AR    R1,R2
         ST    R1,RBNDX
         END
         ELSE  BEGIN               Standard deblock
         LA    R1,WGSLNTXT+8       +8 - leave room for real lno
         L     R15,RBNDX
         LA    R15,10(R15)         Skip extended part
         ACALL UNPRESS             Unpress text
         IF    ((R0,NEG),OR,(R15,GT,=A(MAXLNO))),BEGIN
         SEGCLR ERRSCB             Clear error seg control block
     SEG  'ERRID=IOERROR ERRMSG=''Invalid EXTENDED EDIT format data.'''
         CMDABORT ,                Cleanup path and re-wait
         END
         A     R0,=A(L'WGSLNHDR+8) Save length, line number
         ST    R0,WGSLNLEN
         LA    R1,WGSLNTXT
         LA    R0,8
         ACALL BTDZEROS
         L     R15,RBLNO
         A     R15,=A(1)
         ST    R15,RBLNO
         LA    R1,WGSLNLNO
         LA    R0,8
         ACALL BTDZEROS
         L     R1,RBNDX            Update blk index
         CLEAR R2
         IC    R2,14(R1)           (text len)
         LA    R2,15(R2)
         AR    R1,R2
         ST    R1,RBNDX
         END
         END
*
*  VBS format not supported yet.
*  For now we treat VBS as VB.  But give error if multiple
*  segments are encountered.
*
*                                  Deblock VBS format
         IF    RBFVBS,BEGIN
         L     R1,RBNDX            Check segment flags
         LH    R3,VBSFLAGS(R1)
         IF    (R3,NZ),BEGIN
         SEGCLR ERRSCB
         SEG   'ERRID=BADRECFM ERRMSG=''VBS format not supported. (VB i*
               s.)'''
         CMDABORT ,
         END
         L     R1,RBNDX            Validity check len
         AH    R1,VBSLEN(R1)
         IF    (R1,GT,GRBLKEND),BEGIN
         SEGCLR ERRSCB
         SEG   'ERRID=IOERROR ERRMSG=''Invalid VBS data block.'''
         CMDABORT ,
         END
         L     R0,RBNDX            Set up mvcl r2,r0
         A     R0,=A(L'VBSHDR)
         L     R1,RBNDX
         LH    R1,VBSLEN(R1)
         S     R1,=A(L'VBSHDR)
         LA    R2,WGSLNTXT
         LR    R3,R1
         LR    R5,R3               R5 - text length
         MVCL  R2,R0
         LA    R5,L'WGSLNHDR(R5)
         ST    R5,WGSLNLEN         Save length,
         CLEAR WGSLNLNO            Save dummy (zero) line no
         L     R1,RBNDX            Update blk index
         AH    R1,VBSLEN(R1)
         ST    R1,RBNDX
         END
*
*                                  Got record ok
         L     R1,GRLOC
         L     R0,WGSLNLEN
         CLEAR R15
         PRETURN (R0,R1)
         END   ,
         END   ,
         PEND  ,
         LTORG ,
         TITLE 'NEXTBLK - Read Next Block from File'
*box
*
*  NEXTBLK - Read next sequential block from file
*
*  On entry:
*        RBINFO (RBSTART)
*        R6 - RBINFO AREA
*
*  On Exit:
*    RBINFO (RBDATALN,RBNDX)
*    R1,R0 - BLOCK START, LENGTH
*    R15=0, IF ALL OK.
*    R15=4, IF EOF
*    R15=>8, IF ERROR, R1,R0 - LOC,Len of error text
*
*  NOTE:
*  This routine reads next block, insures that block
*  contains records and is proper format for RECFM.
*
*  Note:
*  This routine updates RBNDX, RBDATALN.  The returned
*  START,LENGTH of block are somewhat useless as each
*  block type has a different header length that needs
*  to be skipped.
*
         SPACE 2
NEXTBLK  PROC  ,
*                                  Read block
         L     R6,TVTRBINF         Address of rbinfo control
         WITH  (RBINFO,R6),BEGIN   Addressability to rbinfo block
         L     R1,RBSTART          Address of physical block
         ACALL READBLK             Read next phsical block
         IF    (R15,NZ),BEGIN
         EXIT  NEXTBLK             Error return
         END   ,
* !! DEBUG THIS USED TO BE 8, IS 4 TOO SMALL, IF NO PROBLEMS
* DELETE THIS COMMENT ON 1/1/93.  EMPIRICISM RULES ALL.
         IF    (R0,LT,4),BEGIN     Minimum block size is 4 for us
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=IOERROR'     Set format error
         SEG   'ERRMSG='''         Report error message
         SEG   'Invalid data block.  block length < 4.'''
         LA    R15,8               Set return code
         EXIT  NEXTBLK             Error abort
         END   ,
*
*                                  Set block start, len
*                                  Check block header as needed
         ST    R0,RBDATALN         Save data block length in rbinfo
**-ml595 ST    R1,RBSTART          Reset block pointer
*                                  Check edit block header
         IF    (RBFEDIT,AND,~RBFXEDIT),BEGIN
         LH    R2,@R1
         IF    (R2,NEG),BEGIN
         SET   RBFXEDIT
         N     R2,=X'00007FFF'
         END
         IF    (R2,GT,R0),BEGIN    If data len GT blk len, ahhhg!
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=IOERROR'     Set format error
         SEG   'ERRMSG='''         Report error message
         SEG   'Invalid EDIT format data'''
         LA    R15,8               Set error return code
         EXIT  NEXTBLK             Error abort
         END
         IF    (R2,LT,R0),BEGIN    If data len less than blk len,
         ST    R2,RBDATALN         Use data len
         END   ,                   Actual block may be bigger
         END   ,
*                                  Check VB block header
         IF    (RBFVAR,OR,RBFVBS),BEGIN
         LH    R2,@R1
         IF    (R2,NE,R0),BEGIN
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=IOERROR'     Set format error
         SEG   'ERRMSG='''         Report error message
         SEG   'Invalid VARIABLE format data.'''
         LA    R15,8
         EXIT  NEXTBLK             Error abort
         END
         END   ,
*
*                                  Update rbndx,dataln
         IF    RBFEDIT,BEGIN
         L     R2,RBSTART
         A     R2,=A(2)
         ST    R2,RBNDX
         END
         IF    RBFFIX,BEGIN
         L     R2,RBSTART
         ST    R2,RBNDX
         END
         IF    (RBFVAR,OR,RBFVBS),BEGIN
         L     R2,RBSTART
         A     R2,=A(4)
         ST    R2,RBNDX
         END
         PRETURN (R0,R1)           Return length and location
         END   ,
         PEND  ,
         LTORG ,
         TITLE 'Low level READ block routine'
*box
*
*  READBLK - LOWEST LEVEL READ BLOCK
*
*  On Entry:
*    R1        Buffer address                              ml950526
*
*  On Exit:
*    R15=0     ALL OK
*              R1,R0 - block location, data in block length  ???
*    R15=4     End of file indication encountered.
*    R15=8     Error occurred reading block
*              R1,R0 - Loc,len of err msg
*
*  Note:
*  On entry R1 is passed as set by caller to input buffer area.
*
         SPACE 2
IOERRREC RECORD BEGIN              Map stack area for synad recovery
IOERMSG1 DC    0XL128'00'          First SYNAD error message
*  Following layout from IOPROGM   Ml 940118
SYNBDW   DS    F                   Block descriptor for msg area
SYNRDW   DS    F                   Record descriptor
SYNBUFAD DS    A                   Buffer address
SYNBLKL  DS    H                   Block length
SYNBLANK DS    CL36                Blanks
SYNJOBN  DS    CL8,C               Job name
SYNSTEPN DS    CL8,C               Step name
SYNUNIT  DS    CL3,C               Unit address
SYNUNTYP DS    CL2,C               Unit type TA, DA, or UR
SYNDDNAM DS    CL8,C               DDname
SYNOPA   DS    CL6,C               Operation attempted
SYNERRM  DS    CL15,C              Error message
*  DEVICE-DEPENDENT FIELDS
*  TAPE (yeah, lotsa luck...)
SYNBLKNO DS    CL7,C               Block count (decimal chars.)
SYNACSMT DS    CL5                 Access method
         ORG   SYNBLKNO
*  DISK
         DS    CL4                 junk (BB of disk address)
SYNCCHHR DS    CL10,C              Disk address CCHHR
SYNACSMD DS    CL5                 Access method (ask me if I care)
         ORG
SYNM2FLG DS    C'S'                'S' for second (PDSE) msg
         SPACE
IOERMSG2 DC    XL128'00'            DSE error information
         END   ,
         SPACE 2
READBLK  PROC  ,
         LA    R3,OSFBSAM          Load data control block address
*1999/11/04 mcl:  made R3 use global to READBLK/SYNAD
         WITH  (IHADCB,R3)         Addressability to DCB
         LR    R2,R1               Save buffer address
         LH    R4,DCBBLKSI         Load DCB blocksize
         CLEAR TVTDCBAB            CLEAR ANY ABEND FLAGS
         READ  OSFDECB,SF,((R3)),((R2)),((R4)),MF=E
         CHECK OSFDECB             Check for i/o completion
         IF    TVTDCBAB,BEGIN      hit the DCB ABEND routine
         QSNAP 'READBLK-ABEND EXIT TAKEN'
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=DCBABEND'    Set error identification
         SEG   'ERRMSG=''Unusual error - ABEND X('
         ACALL FMTABEND            Report abend code
         SEG   ') during READ'''   Terminate message
         CMDABORT ,                Abort!!
         END   ,                     (DCB ABEND hit)

         LA    R1,OSFDECB          Gyrations to get len of blk read
         L     R1,16(R1)           IOB ptr
         LH    R2,14(R1)           Residual blk count
         LH    R0,DCBBLKSI         Blocksize from data control block
         SR    R0,R2               Compute actual block length
         PRETURN (R0)              Return length read
         CLEAR R15                 Zero return code
         EXIT  READBLK             Exit readblk routine
         SPACE 2
READEOF  LABEL ,
         VCALL AMODE31             Re-enter 31 bit mode addressing
         LA    R15,4               Set end of file return code
         EXIT  READBLK             EXIT READ BLOCK ROUTINE
         SPACE 2
READSYNA SYNADAF ACSMETH=BSAM,PARM1=(1),PARM2=(0)
         LR    R4,R1               Save msg area ptr       ml991104
         LA    R0,L'IOERRREC       Length needed           ml991104
         GETMAIN RU,LV=(0),LOC=(BELOW,ANY) no GETLOW!    ml20020416
         LR    R2,R1               ->area                  ml991104
         WITH  (IOERRREC,R2)       Addressability to work area
         XC    IOERMSG2(4),IOERMSG2    Zero poetential PDSE info ret
         MVC   IOERMSG1(128),@R4   Move in first 128 bytes of msg
         CLI   SYNM2FLG,C'S'       Test for any PDSE information
         IF    EQ,'MVC IOERMSG2,@R4+136'     Move in PDSE section
         SYNADRLS ,                Release SYNADAF work areas
         VCALL AMODE31             Re-enter 31 bit mode addressing
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=IOERROR'     Indicate i/o error
         SEGB  'ERRMSG=''I/O Error occurred reading file'
         LA    R15,ERRSCB          ADDRESS OF ERROR SEGCB
         ACALL FMTDSN              REPORT DATA SET NAME
         SEGB  ''''                TERMINATE MESSAGE
         SEG   'ERRMSG='''         Begin error message buildup
*  Following rewritten MCL 940118 based on IOPROGM's code
         SEG   'Error is: '                                ML940118
         CLC   SYNERRM,=C'WRNG.LEN.RECORD'    Wrong block length
         IF    EQ,BEGIN            If so:
         SEG   'Invalid block length ('      A better msg.
         CLC   DCBBLKSI,SYNBLKL    block size req:got
         IF    EQ,BEGIN            truncated at DCBLKSI
         SEG   '>'                 ...so show actual size unknown
         END
         SEGDC L2:SYNBLKL          the block length
         SEG   ');'
         END
         ELSE  BEGIN
         SEG   SYNERRM             The nature of the problem
         SEG   ', block length is '                        ML940118
         SEGDC L2:SYNBLKL,5        Report bytes read
         END
         SEG   ', block address is '                       ML940118
         SEG   SYNCCHHR            (already formatted)     ML940118
         SEG   ''''                Terminate error message
         LR    R1,R2               ->stack space           ml991104
         LA    R0,L'IOERRREC                             ml20020416
         FREEMAIN R,LV=(0),A=(1)   free work area        ml20020416
         LA    R15,8               Set error return code
         DROP  R3
         DROP  R2
         PEND  ,
         TITLE 'WINGS: FILEWRIT Command processing'
*box
*
*  FILEWRIT - File write routine
*
*  On entry:   Data set name and optional parameter information
*              has been set in the TVTFILPB.
*
*  On exit:    Data set has been allocated and prepared for output
*              processing.  The next client command expected will
*              be a FILE_WRITE command.


FILEWRIT PROC VOLENTRY

         INCR  R0,TVTCNTSAVE       Count save commands

*  Enqueue within this WINGS job (MVS will protect us if another
*  WINGS has it)

         L     R0,=A(TDNQEXC)      exclusive...
         IF    TVTPBFOSHARE,'L R0,=A(TDNQSHR)'  unless SHARE=YES
         XCALL DSNENQ                 enqueue
         IF    (R15,NZ),'CMDABORT'    quit if error (msg already seg'd)

*  Allocate and init RBINFO block

         ACALL INITRB
         LR    R5,R1
         WITH  (RBINFO,R5)

*-
*-       GET FILE INFO
*-
*                                  CHECK IF FILE EXISTS
         ACALL GTCATVOL            Get cataloged vol, if any
* If RC=0, R1 has ->vollist

* 1999/11/30 mcl:  see if catlg'd on tape...can't replace!
         IF    (R15,Z),BEGIN       catlgd
         MVC   VOLENTRY,@R1        VOL LIST (1st entry)
         TM    VOLUCBDV,UCB3TAPE   unit class tape?
         IF    O,BEGIN             cataloged on tape!
         SET   TVTFISXCAT          show "cataloged other vol"
*  Can't save on tape, so catalog conflict is a problem
         IF    ~TVTPBFNOCAT,BEGIN  want to catlg/replace, can't
         SEGCLR ERRSCB             Clear error segment buffer
         SEGB  'ERRID=CATOTHER'    Already exists elsewhere
         SEG   'ERRMSG=''File '
         LA    R15,ERRSCB          Address of error segment buffer
         ACALL FMTDSN              Format dsn into message
         SEG   ' is cataloged on tape '
         SEGT  VOLVOLSR,6          Report volume
         SEG   ''''                Terminate message
         CMDABORT ,                Abort current save command
         END   ,                      (want to catlg/replace)
         END   ,                      (cataloged on tape)
         ELSE  BEGIN               cataloged on disk
         MVC   TVTVOLSER,TVTCATVOL so try to use it
         END   ,                      (catlg'd on disk)
         END   ,                      (cataloged)

*                                  SELECT VOLUME FOR OBTAIN

         IF    (TVTPBVOL,NZ),BEGIN user-specified volume
         MVC   TVTVOLSER,TVTPBVOL  ... so use it
         END   ,                      (user-spec vol)

*  if was in catalog (and catlg'd on disk) above, used CATVOL.
*  PBVOL overrides.  OK if neither (normal case, really).

         IF    (TVTPBMIGRATED),BEGIN   HSM got it
         LA    R1,TVTPBDSNAME      ->dsn
         XCALL TICKLEDS            go get it back
         ACALL GTCATVOL            find where it went
         MVC   TVTVOLSER,TVTCATVOL
         END   ,                      (HSM got it)

         IF    (TVTVOLSER,Z),BEGIN   If no volume, it's NEW
         SET   TVTFISNEW           Show NEW

         IF    (TVTPBFNOCAT,AND,(TVTPBVOL,Z)),BEGIN  NOCAT w/o volume
         SEGCLR ERRSCB
         SEG   'ERRID=NOVOL ERRMSG=''No volume given for NOCATALOG requ*
               est'''
         CMDABORT ,
         END   ,                      (NOCAT but no volume)

         B     FIXVOLXT            process NEW
         END   ,                      (No volume)

*  If we have a volume, do an OBTAIN to see if already exists

         ACALL OBTFMT1             OBTAIN FMT1
*  RC from OBTFMT1 is that from OBTAIN:
*
*  0 = got DSCB
*  4 = vol not mounted
*  8 = DSCB not in VTOC
*  other = ???

         IF    (R15,GT,8),BEGIN    VTOC error or other badness
         CMDABORT ,                OTBFMT1 seg'd errmsg
         END   ,                     (VTOC error)

         IF    (R15,Z),BEGIN       Existing dataset -- found DSCB
         SET   TVTFISOLD           show exists on given or catlg vol.
         B     FIXVOLXT            process existing
         END   ,                      (existing, found DSCB)


         ELSE  BEGIN               No DSCB (8) or no volume (4)

         IF    (R15,EQ,4),BEGIN    bad vol (user-supl. or catlg)

*  Volume was not online.  Generally this means fail NOTMTD; but
*  there are some cases where we can fix it --
*
*  (a) if request to create a new dataset, and user supplied a
*      vol. that has been removed as part of the SMS conversion,
*      we'll let the ACS routine substitute for it.
*  (b) if request is to replace an existing SMS dataset, and user
*      supplied a vol that has been removed in SMS conversion,
*      ignore the user-supplied volume.
         IF    (TVTPBVOL,Z),WVOLFAIL   bad vol must've been from cat
         LA    R1,TVTPBVOL         ->user-supplied vol
         ACALL CKSMSVSUB           see if it's one we can substitute
*  RC:  0=can substitute  8=not
         IF    (R15,NZ),WVOLFAIL   can't be fixed

*  OK, the bad vol was user-supplied and can be substituted for.
*  We could have (a) no existing dataset [i.e. not in catlg]
*                (b) exists and is SMS
*                (c) catlg entry exists, dataset not SMS

         IF    ~TVTFISCAT,BEGIN    if not catl'gd
         SET   TVTFISNEW           will be new
*  leave bad vol, SMS will fix it and generate msg
         B     FIXVOLXT            done for now.
         END   ,                      (not catlg'd) [case a]

*  Dataset is cataloged, user-given vol was bad

         MVC   TVTVOLSER,TVTCATVOL Check cataloged vol
         ACALL OBTFMT1             look for DSCB there
         SET   TVTFCHSMS           remember we looked
         IF    (R15,NZ),WBADVOL    (c) bad uservol, catvol no help
**?  Would be nice to fmt a warning msg here...
         IF    (OSFFMT1+(DS1SMSFG-DS1DSNAM).DS1SMSDS),BEGIN  (b), SMS
         CLEAR TVTPBVOL            Forget bad uservol, use catvol
         SET   TVTFEXSMS           have existing SMS dataset
         SET   TVTFISOLD           is existing dataset
         B     FIXVOLXT            Done here
         END   ,                      (case (b), existing SMS)

WBADVOL  LABEL ,                   user-supplied bad vol
*  Don't want to use msg in ERRSCB, it's about 2nd OBTAIN.
         SEGCLR ERRSCB             Clear error buffer
         SEGB  'ERRID=NOTMNTD'     Volume not mounted
         SEG   'ERRMSG='''         Report volume
         SEGB  'Volume'            Report volume serial number
         SEG   TVTPBVOL            User-supplied volume serial
         SEG   ' is not mounted.'''

*  Show error (msg seg'd by GTFMT1)
WVOLFAIL CMDABORT ,                quit "NOTMNTD"
         END   ,                      (bad vol)

*  otherwise, (8) DSCB not in VTOC

         SET   TVTFISNEW           show new
         END   ,                      (No DSCB or no volume)

*  Common to NEW, OLD

FIXVOLXT LABEL ,
*
*        Check access               (was in fileopen)      ml950914
*
         LA    R1,TVTFILPB         ->FILPB
         MVI   TVTPBRACFLG,RACF_ALTER    Check for ALTER if new,
         IF    TVTFISOLD,'MVI TVTPBRACFLG,RACF_UPDATE' REPLACE or pds
         VCALL CHKRACFA            Check access...
         IF    (R15,NZ),'CMDABORT' no access; msg has been seg'd
*
*-
*-       PROCESS EXISTING FILE SAVE
*-
*                                  Process existing file

         IF    TVTFISOLD,BEGIN     **EXISTING** dataset

         ACALL CKDSORG             Determine if PDS/regular
         ACALL CKTMPCAT            Check temp vol/cat vol conflict
*  CKTMPCAT moved here, was just before CKRECFM.           ml961213
*  otherwise SAVE ... TEMP when exists elsewhere gets EXISTS error,
*  user gets prompted Ok to replace, then gets CATOTHER error.
         ACALL CKREP               Check if ok to replace
         ACALL CKEXPDT             Check for expire date

*  Check to see if name is cataloged but we were given a different
*  volume.  For save-OLD we just believe the given volume.
*                                                          ml950807

         IF    TVTFISXCAT,BEGIN    volume conflict
         SET   TVTPBFNOCAT         Leave catalog alone
         END   ,                      (mismatch)

         ACALL CKRECFM             Check recfm validity
         LA    R1,RBINFO
         ACALL SETRECFM            Set recfm, lrecl, blksize
         LA    R1,RBINFO

         IF    TVTFISPS,BEGIN      If sequential file, check space
         ACALL CALCXSPC            Calc existing dsn space
         LR    R2,R1               Kbytes used

*  Check to see if user defined a size as PRIQTY on FILEWRITE
*  (commonly done by SPIRES)                     MCL 1999/12/14

         IF    (TVTPBALLOCPRI,NZ),BEGIN   PRIMARY specified on cmd
         L     R1,TVTPBALLOCPRI    primary value
         IF    (TVTPBALTYPMB),BEGIN  in Mbytes
         SLL   R1,10               *1024 is Kbytes
         END   ,                   (MB)
         ELSEIF (TVTPBALTYPTR),BEGIN  in TRACKS
         MH    R1,=H'56'           KB/trk, close enuf
         END   ,                   (TRK)
         ELSEIF (TVTPBALTYPCY),BEGIN  in CYLINDERS
         MH    R1,=H'840'          KB/cyl @56K/trk
         END   ,                   (CYL)
* else is in Kbytes, no calc needed
         END   ,                   (pri specified)
         ELSE  BEGIN               pri not specified
         LA    R1,RBINFO
         ACALL CALCSPC             Calc space needed
         END   ,                   (pri not spec)
         LR    R3,R1               Kbytes needed

         IF    (R3,GT,R2),BEGIN    If new file larger than existing,
         SET   TVTFRESAVE            scratch and realloc and resave

*  Do scratch-for-save.
*
*  Since we have status=old here, there are 4 possibilities.
*
*  1 catlg'd and also vol given, they agree      use catalog
*  2 catlg'd and vol given, they disagree        use given, no cat
*  3 catlg'd, no vol given                       use catalog
*  4 not catlg'd, have vol                       use given, no cat
*  5 not catlg'd, no vol given                   we won't be here!
*
*  Note that TVTPBFNOCAT only is case 2, so we don't use it here

         MVI   TVTUCFLG,0          tentative "uncatlg when scratch"
         IF    ((TVTCATVOL,Z),OR,TVTPBFNOCAT),BEGIN   NO CATLG
         MVI   TVTUCFLG,0          Show no uncatlg on scratch
         MVC   OSFCATCT,=H'1'      Dummy volume list: 1 entry
         MVC   OSFCATVV,TVTPBVOL            volser
         LA    R1,TVTPBVOL         Address of volume serial
         XCALL FINDUCB             Locate unit control block address
         IF    NZ,BEGIN            Unable to locate ucb address
* This shouldn't happen, we found the DSCB earlier -- that's how we
* decided that status=old.
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTMNTD'     No volume located
         SEGB  'ERRMSG=''Volume'
         SEGTB TVTVOLSER           Add volume serial to message
         SEG   'is not mounted.'''
         CMDABORT ,
         END   ,                      (no UCB)

         WITH  (UCBOB,R1)           ## addressability to UCB
         MVC   OSFCATVU,UCBTYP     UCBTYPE info into volume list
         END   ,                      (NO CATLG)

         LA    R0,TVTPBDSNAME      dsn
         LA    R1,OSFCATWK         volume list
         ACALL SCRPS               Do scratch
         IF    (R15,NZ),'CMDABORT'  if scratch failed

         END   ,                      (new>existing)

         END   ,                      (sequential)

         END   ,                      (EXISTING)

*  PROCESS NEW FILE SAVE

         IF    TVTFISNEW,BEGIN     NEW dataset
         ACALL CKNEWPDS            Check if PDS alloc (can not do)

         ACALL FILEALLO            Allocate the space
         END   ,                      (new dataset)

         ELSE  BEGIN               old file, just allocate a DD
*-
*-       DO DYNAMIC ALLOCATE
*-
*                                  DO DYNAMIC ALLOCATION
         LA    R1,RBINFO           Set parameter address   ML940601
         LA    R0,TVTFILPB         => FILPB                ml950227
         ACALL WFILALC             Go allocate the file
         END   ,                      (old file)

*-
*-  Common to NEW, OLD
*-

         IF    (RBOPTBLK,Z),BEGIN  we didn't know device char.
*                                  because we didn't have volser.
*                                  We do now.              ml950119
         LA    R1,RBINFO
         ACALL SETDEVCH            so try again...
*  1996/07/29 mcl:  this was in SETDEVCH
         IF    (R15,NZ),BEGIN      Unable to locate required UCB
         SEGCLR ERRSCB             Clear error seg control
        SEG 'ERRID=WINGFAIL ERRMSG=''Internal Wings failure, bad UCB lo*
               cate'''
         CMDABORT ,                Abort current command
         END   ,                      (UCB not found)
         END   ,                      (didn't know dev. char)

*-
*-       OPEN FILE FOR BSAM/BPAM PROCESSING
*-
         LA    R1,RBINFO           Set parameter address   ml950119
         ACALL WRTOPEN             Open file for output processing
         IF    NZ,BEGIN            If bad open
         CMDABORT ,                Abort file_write command
         END   ,                      (bad open)

*                                  ALLOCATE WRITE BUFFER
         L     R0,TVTPBBLKSIZE
         ST    R0,RBBLKSI
         VCALL GETLOW              Request output buffer (<16mb)
         ST    R1,TVTBUFP          Save in TVT and also... ml950526
         ST    R1,RBSTART                     in rbinfo block
         RECVRY ROUT=BUFREC        Stack recovery routine  ml950531

*  FOR PDS, MUST DO REPLACE CHECK NOW
         IF    TVTFISPDS,BEGIN     Dsorg=po library post-processing
         ACALL CKPDSREP
         END   ,                      (dsorg=po)
*
*-
*-       File is now allocated and open, send file_open to client
*-
         WINGSHDR SET,HEADER='FILE_OPEN:'
         SEGCLR TVTSCB             Clear any extraneous data
         SEG   'NAME='             Return fully qualified dsn
         SEGT  TVTPBDSNAME,44      Trim the name
         IF    (TVTPBDSMEM,NZ),BEGIN   return member also if present
         SEG   '('                 Enclose member in parens
         SEGT  TVTPBDSMEM          Add member name
         SEG   ')'                 Terminate member name
         END   ,

         IF    (TVTVOLSER,NZ),BEGIN volume is known
         SEG   ' VOLUME='
         SEGB  TVTVOLSER
         END   ,                      (volume is known)
         IF    ~TVTPBFNOCAT,BEGIN  didn't say no catalog
         SEGB  'CATALOG'           so we must have...
         END   ,                      (cataloged)

         SEGWR ,                   Return FILE_OPEN: to client
         MVC   TVTPATNX,=CL16'FILE_WRITE:'   Next command expected
         PEND  ,

         LTORG ,
         TITLE 'Check for SMS-substituted Volume'
*
*  Examine volume-serial of a volume to see if it's likely that SMS
*  would substitute a storage class for it.  The substitution is done
*  in the storage class ACS routine, so this code attempts to parallel
*  the ACS substitution logic.  Parallel code is yucky, but there does
*  not seem to be any way to have this code shared...
*
*  On entry:  TVTPBVOL contains a volume serial (of a volume that is
*             not mounted)
*
*  On exit:   R15=return code --
*              0  volume should be substituted
*              8  volume won't be substituted

CKSMSVSUB  PROC ,

*  Following from SYS2.SMS.TEST.ACS.SOURCE(STORCLAS) 1996/09/16:
*
*  /* volumes on their way out */
*  FILTLIST  NON_VOLUME INCLUDE(PUB2%%,INT%%%,'PUB0%%')
*  /* removed volumes */
*  FILTLIST  DEAD_VOLUME INCLUDE(INT%%%,PUB2%%)

         CLEAR R15
         CLC   =C'PUB2',TVTPBVOL   PUB2%%
         IF    EQ,EXIT
         CLC   =C'INT',TVTPBVOL    INT%%%
         IF    EQ,EXIT
         LA    R15,8               none of the above
         PEND  ,
         LTORG ,
         TITLE 'WINGS: Allocate a New Dataset'
*box
*
*  FILEALLO - File allocate routine, used by ALLOCATE and
*             FILE_WRITE
*
*  On entry:   Data set name and optional parameter information
*              has been set in the TVTFILPB.
*              RBINFO block may or may not exist (check TVTRBINF)
*
*  On exit:    Data set has been allocated and DD exists for it
*              Valid RBINFO block exists.
*
*  revised 1995/05/30 mcl:  use for write as well as allocate
*  written 1994/05/31 mcl
*
*  Note:  This routine is a cobbled up version of FILEWRIT.
*  Some previous FILEWRIT code is now here instead.
*
FILEALLO PROC

*
*                                  Allocate and init RBINFO block
         IF    (TVTRBINF,Z),'ACALL INITRB'  get RBINFO if needed
         L     R5,TVTRBINF         ->RBINFO
         WITH  (RBINFO,R5)
*
*-
*-       GET FILE INFO
*-
*                                  Check if file exists
*-
*-
*-       PROCESS NEW ALLOCATE FILE

*  Some preliminary checks for "exists" have been made in the
*  FILE_WRITE or FILE_ALLOCATE code that calls this (q.v.)

         IF    (TVTPBFNOCAT),BEGIN  user wants no catalog
         IF    (TVTPBVOL,Z),BEGIN  but gave no volume
         SEGCLR ERRSCB
         SEG   'ERRID=NOVOL ERRMSG=''No volume given for NOCATALOG requ*
               est'''
         CMDABORT
         END   ,                      (but no volume)

*  NOCAT request on specific volume

         LA    R1,TVTPBVOL         ->volume serial
         XCALL FINDUCB             Locate unit control block
         IF    NZ,BEGIN            Unable to locate UCB
* this failure is unlikely here, we would have found bad vol when
* we tried OBTAIN earlier...but what the heck...
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTMNTD ERRMSG=''Volume'
         SEGTB TVTVOLSER           Add volume serial to message
         SEG   'is not mounted.'''
         CMDABORT ,
         END   ,                      (no UCB)

         LR    R7,R1               ->UCB
         WITH  (UCBOB,R7)
**?      IF    UCBDVCLS.DEVCLDA,BEGIN   DISK
**?  don't bother...OBTAIN attempt would have caught it

         IF    UCBFL5.UCBSMS,BEGIN SMS vol
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=SMSVOL ERRMSG=''Volume'
         SEGTB TVTVOLSER           Add volume serial to message
         SEG   'is system-managed, NOCAT invalid.'''
         CMDABORT ,                Abort command
         END   ,                      (SMS vol)
         END   ,                      (wants no catalog)

         ELSE  BEGIN               NEW,CATALOG request (normal)
         IF    TVTFISCAT,BEGIN     is already cataloged

*  Already cataloged -- however, we won't be here (in ALLOCATE)
*  unless the DSCB was NOT found on the cataloged or user-given
*  volume.  We've previously looked at catlg and VTOC (which is
*  when we set TVTFISCAT and we set TVTFISXCAT if there is a
*  conflict between catalog and volume (i.e. user gave one vol and
*  catlg points to another)

         IF    TVTFISXCAT,BEGIN    catlg vol/uservol conflict
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=CATOTHER ERRMSG=''File'
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Set file name into message
         SEG   ' is already cataloged on another volume.'''
         CMDABORT ,                Abort command
         END   ,                      (catlg/user vol conflict)
         ELSE  BEGIN               no conflict, uservol null or =cat
         IF    (TVTPBVOL,Z),'MVC TVTPBVOL,TVTCATVOL' use cat vol
         LA    R0,TVTPBDSNAME      ->DSN
         ACALL DELCAT              delete old catlg entry
         IF    (R15,NZ),BEGIN      delcat failed
         CMDABORT ,                Cleanup path and re-wait
         END   ,                      (delcat fail)
         END   ,                      (no conflict)
         END   ,                      (already cataloged)
         END   ,                      (new, catalog)

         ACALL GTLIBVOL
         ACALL CKRECFM             Check recfm validity
         IF    (~TVTPBFREQALLOCATE),BEGIN  if write
         LA    R1,RBINFO
         ACALL SETRECFM            SET RECFM, LRECL
         END   ,                      (write, set recfm/lrecl)

*-
*-       DO DYNAMIC ALLOCATE
*-
*                                  DO DYNAMIC ALLOCATION
         LR    R1,R5               Set parameter address
         LA    R0,TVTFILPB         FILPB pointer
         ACALL WFILALC             Go allocate the file
         PEND  ,

         LTORG ,
         TITLE 'INITRB - GETMAIN and Init RBINFO'
*
*  INITRB - GETMAIN AND INIT RBINFO
*
*  ON EXIT:
*    R1 - RBINFO CONTROL BLOCK ADDR (saved in TVTRBINF)
*
INITRB   PROC
*
*                                  Allocate and init RBINFO block
         L     R1,TVTRBINF         ->existing if any
         IF    (R1,NZ),BEGIN       ERROR:  Already got one
         QSNAP 'RBINF exists at entry to INITRB'
         QSNAP @R1,L'RBINFO        dump it
         B     RBX                 and use it
         END   ,                      (already got)

         RECVRY ROUT=RBFREE        Set recovery routine
         LA    R0,L'RBINFO         Set length of RBINFO control
         VCALL GETLOW              Acquire memory for rbinfo
         ST    R1,TVTRBINF         Save address of control block
RBX      LR    R5,R1               Move RBINFO block address
         WITH  (RBINFO,R5)         Addressability to RBINFO block
         CLEAR RBINFO              Zero RBINFO control block
         MVC   RBEYE,=C'RBIN'      Set eye-catcher
         XPUSH ,,16,PTR=R2         Get stack space
         ADDSYM ENTRY=(R2),NAME='RBINFO',LOC=L:TVTRBINF,LEN=L'RBINFO
         XPOP  PTR=R2              Pop stack work area
         LA    R7,RBSPACE          Address within RBINFO for SPACALC
         WITH  (SPACALC,R7),BEGIN  Addressability to space alloc
         CLEAR SPACALC             Clear space allocation block
         MVC   SPACEYE,=C'SPAC'    Set dump eye-catcher field
         END
*
*                                  RETURN RBINFO ADDR
         LA    R1,RBINFO
         PRETURN (R1)
*
         CLEAR R15
         PEND
         LTORG ,
         TITLE 'GTCATVOL - Check if Dataset Cataloged'
*
*  GTCATVOL - CHECK IF DSN CATALOGED
*
*  ON ENTRY:
*    TVTPBDSNAME - DATA SET NAME
*
*
*  ON EXIT:
*    R15=0, FILE CATALOGED, TVTCATVOL SET, R1->volume list
*    R15=4, FILE NOT CATALOGED, TVTCATVOL AND R1 ZEROED
*    various flags set TVTFCHCAT, ..ISCAT, ..ISXCAT, MIGRATED
*
*  1999/12/01 mcl PRETURN R1, clear if notfound
*  NOTE:
*  This routine does a catalog locate.  Errors from catalog
*  locate (other than "not found") exit directly.
*
GTCATWK  RECORD BEGIN
GTCVOL   DC    XL10'00'            CATALOG RETURN AREA
         END
*
*
GTCATVOL PROC  GTCATWK
         CLEAR GTCATWK
*
         SET   TVTFCHCAT           Show we've done cat. lookup
         CLEAR TVTFISCAT           not cataloged yet
         CLEAR TVTFISXCAT          no cat conflict yet
         LA    R1,TVTPBDSNAME
         LA    R0,GTCVOL
         ACALL CATLOC

         IF    (R15,Z),BEGIN       FILE CATALOGED
         SET   TVTFISCAT           show cataloged
         MVC   TVTCATVOL,GTCVOL+4
         CLC   TVTCATVOL,=C'MIGRAT'   migrated?
         IF    EQ,'SET TVTPBMIGRATED' flag it if so

         IF    ((TVTPBVOL,NZ),AND,(TVTPBVOL,NE,TVTCATVOL)),BEGIN
*                                     catalog/uservol conflict
         SET   TVTFISXCAT          show "cataloged othervol"
         END   ,                      (catlg/uservol conflict)

         CLEAR R15
         LA    R1,GTCVOL           ->volume list           mcl19991201
         END   ,                      (cataloged)

         ELSEIF (R15,EQ,8),BEGIN   FILE NOT CATALOGED
         CLEAR TVTCATVOL
         LA    R15,4
         CLEAR R1                  no vollist
         END   ,                      (not cataloged)

         ELSE  BEGIN               ERROR IN CAT LOCATE
         CMDABORT ,
         END   ,                      (error in cat)
*
         PRETURN (R1)
         PEND
         TITLE 'GFMT1 - OBTAIN Format-1 DSCB'
*
*  GTFMT1 - OBTAIN FORMAT1 DSCB
*
*  ON ENTRY:
*    IF USER SPECIFIED VOLUME, LOOK THERE ONLY (TVTPBVOL)
*    else IF CAT VOLUME, LOOK THERE. (TVTCATVOL)
*    else If volume was already in TVTVOLSER, look there ???
*    else bomb...                  ml 1996/07/30
*
*
*  ON EXIT:
*    R15=0, File exists, format1 info put in TVT
*    R15=4  Volume not mounted              ml960711
*    R15=8, DSCB not found in VTOC          ml960711
*  for RC of 4 or 8, OBTAIN has seg'd error msg
*    R15=12 No volume given                 ml960730
*    mod 960711 ml:  used to give rc=4 for not found, fail if
*    volume not mounted.
*
*  NOTE:
*  This routine does a format1 OBTAIN,  and puts the info
*  in the TVT.  If the OBTAIN fails for other reasons than shown above,
*  exit via CMDCLEAN.              ml 960711
*
*
*
GTFMT1   PROC
*

         PEND  ,
         TITLE 'CKEXPDT - See if Dataset has Expire Date Conflict'

*  Check expiration date.  DSCB of this dataset has previously been
*  obtained and is in OSFFMT1.                   ml960922
*
*  Errors exit directly.

CKEXPDT  PROC  ,

         LA    R2,OSFFMT1          Address of format-1 DSCB
         WITH  (DS1DSNAM,R2),BEGIN Addressability to format-1 DSCB
         IF    (DS1EXPDT,NZ),BEGIN  expire date set
         LM    R0,R1,TVTLRCLK      time/date this cmd
         VCALL BDATE               get yyddd
*  R0 will have date in same format as DS1EXPDT:
*  DS1EXPDT is 1 byte yy (00=1900, 100=2000, 255=2155), H'ddd'
         CLEAR R1
         ICM   R1,7,DS1EXPDT       same fmt as today in R0
         CR    R0,R1               today: expdt
         IF    LT,BEGIN            unexpired
         SEGCLR ERRSCB             Clear error seg block
         SEGB  'ERRID=DSNEXPDT'    Expire date not passed error
         SEG   'ERRMSG=''File '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Format data set name into message
         SEG   ' has expire date of '
         LC    R0,DS1EXPDT         Get year
         MH    R0,=H'1000'         Year value
         L2    R1,DS1EXPDT+1       day of year (2 bytes)
         AR    R0,1                yy*1000+ddd for decimal yyddd
         CVD   R0,OSFCATWK         Convert to dec
         L     R0,OSFCATWK+4       Get value
         LA    R1,OSFCATWK         work area
         VCALL NDATE               Convert
         SEGB  (R1),(R0)           expdt into message
         SEG   ' and cannot be updated.'''   end of msg
         CMDABORT ,                Abort current rename command
         END   ,                      (unexpired)
         END   ,                      (expire date set)
         END   ,                      (with fmt1-DSCB)
         PEND  ,
         TITLE 'CKDSORG - See If Save Request Matches Existing DSORG'
*
*  CKDSORG - CHECK TO SEE IF SAVE REQUEST MATCHES EXISTING
*            FILES DSORG
*
*  ON ENTRY:
*    FORMAT1 OBTAIN DSCB IN TVT AT OSFFMT1.
*
*  ON EXIT:
*    TVTFISPDS, TVTFISPS FLAGS SET APPROPRIATELY
*    ALL OK.
*    ALL ERRORS EXIT DIRECTLY
*
CKDSORG  PROC
         LA    R2,OSFFMT1          Address of fmt1 dscb
         WITH  (DS1DSNAM,R2),BEGIN
         IF   ((DS1DSORG+1.X'FF',NZ),OR,                               X
               (DS1DSORG.DS1DSGIS+DS1DSGDA+DS1DSGCX,NZ)),BEGIN
         SEGCLR ERRSCB             Clear error scb
         SEGB  'ERRID=BADDSORG'    Indicate bad dsorg
         SEG   'ERRMSG=''Invalid DSORG=('
         HEXSEG DS1DSORG,2         mcl 2002/03/25
**was    L2    R1,DS1DSORG         Load data set organization
**was    SEGHX (R1),4              Convert into message
         SEG   ') for '
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Convert data set name into msg
         SEG   ''''                Terminate message
         CMDABORT
         END   ,
         IF    DS1DSORG.DS1DSGPO,BEGIN DSORG=PO DATA SET?
         SET   TVTFISPDS           Set dsorg=po for allocation
         IF    (TVTPBDSMEM,Z),BEGIN
         SEGCLR ERRSCB             Clear error scb
         SEGB  'ERRID=NOMEMBER'    Set no member specified for lib
         SEGB  'ERRMSG=''No member specified for library'
         LA    R15,ERRSCB          Address of error scb
         ACALL FMTDSN              Convert data set into message
         SEG   ''''                Terminate message
         CMDABORT
         END   ,
         END   ,
         ELSE  BEGIN                         sequential data set
         SET   TVTFISPS                      set as sequential
         IF    (TVTPBDSMEM,NZ),BEGIN
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=NOTPDS'      Report error:  not a PDS
         SEG   'ERRMSG='''
         SEGT  TVTPBDSNAME
         SEG   ' is not a partitioned data set. Member not saved.'''
         CMDABORT ,                Abort current command
         END
         END
         END
*
         CLEAR R15
         PEND
         TITLE 'CKREP - Check if Replace or Append'
*
*  CKREP - CHECK IF REPLACE OR APPEND
*
*  ON EXIT:
*     ALL OK
*     ERRORS EXIT DIRECTLY
*
CKREP    PROC  ,
*
         IF    ~TVTFISOLD,'BOMB'   Must be existing file
         IF    TVTFISPS,BEGIN      Check only PS files, not PDS
         IF    (TVTPBFREQREPLACE,OR,TVTPBFREQAPPEND),BEGIN
         END
         ELSE   BEGIN              If not ok to replace, append
         SEGCLR ERRSCB             Clear error seg control block
         SEGB  'ERRID=EXISTS'      Report data set already exists
         SEG   'ERRMSG='''
         LA    R15,ERRSCB          Address of error seg control
         ACALL FMTDSN              Convert file name into message
         SEGB  ' already exists'
         IF    (TVTPBVOL,NZ),BEGIN If user specified volume,
         SEG   ' on '                  continue building message
         SEGT  TVTVOLSER               report volume serial
         END   ,
         SEG   ''''                Terminate message
         CMDABORT  ,               Abort save operation
         END
         END
*
         CLEAR R15
         PEND
         TITLE 'CKTMPCAT - Check Conflict TEMP/cataloged vol'
*
*  CKTMPCAT - Check if user specified TEMP conflicts with
*          existing dataset.  If we're not using SMS for temp,
*          check cataloged vol against known "temp" vol(s).  If
*          we're using SMS temp storage, check storage and/or
*          management class(es) of existing file against the
*          "temp" values.                        mcl 1999/11/08
*
*  ON EXIT:
*     ALL OK.
*     ALL ERRORS EXIT DIRECTLY.
*
*  NOTE:
*  We do not let user 'SAVE xxx TEMP' if
*  file exists and is cataloged on another volume.
*

CKTSMSWK RECORD BEGIN
         SMSINFOR PFX=CKTS
         END   ,

CKTMPCAT PROC CKTSMSWK
*
         CLEAR R15
         IF    (TVTPBFOVOLTEMP,AND,(TVTCATVOL,NZ)),BEGIN
*                                            TEMP and a catvol
         IF    ((TVTTMMGC,NZ),OR,(TVTTMSTC,NZ)),BEGIN  SMS TEMP
         LA    R1,TVTPBDSNAME      ->DSN
         LA    R0,CKTSMSWK         ->result area
         XCALL SMSINFO             get storclas, etc.
         IF    (R15,NZ),EXIT       if error just do CATOTHER below
* if temp MC defined, must match; likewise SC.
         IF    ((TVTTMMGC,NZ),AND,(TVTTMMGC,NE,CKTSMGCL)),'LA R15,4'
         IF    ((TVTTMSTC,NZ),AND,(TVTTMSTC,NE,CKTSSTCL)),'LA R15,4'
* if R15 still 0, old file is temp
         END   ,                   (SMS TEMP)
         ELSE  BEGIN               non-SMS temp in use
         LA    R1,TVTCATVOL        ->catalog volser
         ACALL CHKTVOL             see if it's temp volume
         END   ,                   (non-SMS temp in use)
*  common to SMS, non
         IF    (R15,NZ),BEGIN      not temp
*  Report catalog/volser mismatch
         SEGCLR ERRSCB             Clear error segment buffer
         SEGB  'ERRID=CATOTHER'    Already exists elsewhere
         SEG   'ERRMSG=''Unable to save TEMP file. '
         LA    R15,ERRSCB          Address of error segment buffer
         ACALL FMTDSN              Format data set into message
         SEG   ' already saved permanently on '
         SEGT  TVTCATVOL,6         Report volume
         SEG   ''''                Terminate message
         CMDABORT ,                Abort current save command
         END   ,                      (not temp)
         END   ,                      (TEMP and catvol)
         PEND
         TITLE 'GTLIBVOL - Get LIB Volume from Catalog'
*
*  GTLIBVOL - GET LIB VOLUME FROM CAT
*
*  ON EXIT:
*    TVTLIBVOL - LIBRARY VOLUME  (SET TO ZEROS IF NONE)
*
*  NOTE:
*  TVTLIBVOL SET TO ZEROS IF NO LIB VOLUME FOUND OR
*  DATA SET DOES NOT BELONG TO AN ACCOUNT.  (EG. SYS1.PROCLIB)
*
*  NOTE:
*  WE USE LIB FOR THE ACCOUNT OF DATA SET BEING SAVED NOT
*  LOGGED ON ACCOUNT.
*
*
GTLIBWK  RECORD BEGIN
GTLBVOLR DS    XL10'00'
GTLBNAME DS    XL(L'TVTPBDSNAME)
         END
*
*
GTLIBVOL PROC  GTLIBWK
         CLEAR TVTLIBVOL
*
*                                  CREATE LIB DATA SET NAME
         LA    R1,TVTPBDSNAME
*                                  IF WYL.GG.UUU. ...
*                                     LOOK FOR WYL.GG.UUU.LIB
         IF    ((@R1,EQ,'WYL.'),AND,(@R1+6,EQ,'.'),AND,                X
               (@R1+10,EQ,'.')),BEGIN
         MVC   GTLBNAME,=CL(L'GTLBNAME)'WYL.GG.UUU.LIB '
         MVC   GTLBNAME+4(2),TVTPBDSNAME+4  GROUP
         MVC   GTLBNAME+7(3),TVTPBDSNAME+7  USER
         END
*                                  IF GG$UUU. ...  (TSO FORMAT)
*                                     LOOK FOR WYL.GG.UUU.LIB
         ELSEIF ((@R1+2,EQ,'$'),AND,(@R1+6,EQ,'.')),BEGIN
         MVC   GTLBNAME,=CL(L'GTLBNAME)'WYL.GG.UUU.LIB '
         MVC   GTLBNAME+4(2),TVTPBDSNAME    GROUP
         MVC   GTLBNAME+7(3),TVTPBDSNAME+3  USER
         END
         ELSE  BEGIN               DATA SET NOT OWNED BY ACCOUNT
         CLEAR TVTLIBVOL               (EG. SYS1.PROCLIB)
         B     GTLBEXIT
         END
*
*                                  DO CAT LOCATE
         LA    R0,GTLBVOLR
         LA    R1,GTLBNAME
         ACALL CATLOC
         IF    (R15,Z),BEGIN       ALL OK, RETURN VOLUME
         MVC   TVTLIBVOL,GTLBVOLR+4
         CLC   =C'PUB',TVTLIBVOL   on some PUB volume?
         IF    EQ,BEGIN            if so,
         CLEAR TVTLIBVOL             use any PUB
         B     GTLBEXIT                (save will do nonspecific)
         END   ,                      (some PUB)
         END   ,                      (RC=0)
         ELSE  BEGIN               NOT FOUND, CLEAR VOLUME
         CLEAR TVTLIBVOL
         SEGCLR ERRSCB
         END   ,                      (not found)
*
GTLBEXIT LABEL ,
         CLEAR R15
         PEND
         LTORG ,
         TITLE 'CKRECFM - Check RECFM/LRECL/BLKSIZE Validity'
*
*  CKRECFM - CHECK FOR RECORD FORMAT VALIDITY
*            IF FILE EXISTS, CHECK FOR NEW/EXISTING FORMAT CONFLICT
*
*  ON EXIT
*     ALL OK.
*     ALL ERRORS EXIT DIRECTLY
*
CKRECFM  PROC ,
*
         LA    R6,OSFFMT1
         WITH  (IECSDSL1,R6)
*
*                                  CHECK FOR RECFM IF BLKSIZE, LRECL
         IF    (TVTPBRECFM,Z),BEGIN
         IF    (TVTPBBLKSIZE,NZ),BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADRECFM'
         SEG   'ERRMSG=''BLKSIZE invalid without'
         SEG   '  record format type.'''
         CMDABORT
         END
         IF    (TVTPBLRECL,NZ),BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADRECFM'
         SEG   'ERRMSG=''LRECL invalid without'
         SEG   '  record format type.'''
         CMDABORT
         END
         END
*
*                                  CHECK FOR VALID RECFM
         IF    (TVTPBRECFM,NZ),BEGIN
         IF    TVTPBFRECEDIT,BEGIN
         END
         ELSEIF TVTPBFRECFIX,BEGIN
         END
         ELSEIF TVTPBFRECVAR,BEGIN
         END
         ELSE  BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADRECFM'
         SEG   'ERRMSG=''Unable to write file.  Record format '
         SEG   'unknown or not supported.'''
         CMDABORT
         END
         END
*
*                                  CHECK FOR VALID EXISTING RECFM
         IF    TVTFISOLD,BEGIN
         IF    (DS1RECFM,EQ,0),BEGIN
         END
         ELSEIF (DS1RECFM.DS1RECFU),BEGIN
         END
         ELSEIF (DS1RECFM.DS1RECFF),BEGIN
         END
         ELSEIF (DS1RECFM.DS1RECFV),BEGIN
         END
         ELSE  BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADRECFM'
         SEG   'ERRMSG=''Unable to write file.  Record format '
         SEG   'of existing file not supported.'''
         CMDABORT
         END
         END
*
*                                  CHECK FOR RECFM MISMATCH
         IF    (TVTFISOLD),BEGIN
         IF    ((TVTPBRECFM,NZ),AND,(DS1RECFM,NZ)),BEGIN
         IF    (DS1RECFM.DS1RECFU,AND,~TVTPBFRECEDIT),BEGIN
         ACALL CHGRECFM
         END
         ELSEIF (DS1RECFM.DS1RECFF,AND,~TVTPBFRECFIX),BEGIN
         ACALL CHGRECFM
         END
         ELSEIF (DS1RECFM.DS1RECFV,AND,~TVTPBFRECVAR),BEGIN
         ACALL CHGRECFM
         END
         END
         END
*
*                                  CHECK BLOCSIZE, LRECL
         IF    (TVTPBBLKSIZE,NZ),BEGIN
         IF    (TVTPBFRECFIX,OR,TVTPBFRECVAR),BEGIN
         IF    (TVTPBBLKSIZE,LT,64),BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADBLKSI'
         SEG   'ERRMSG=''Unable to write file.  Blocksize '
         SEG   'is too small (<64).'''
         CMDABORT
         END
         END
         ELSEIF TVTPBFRECEDIT,BEGIN
         IF    (TVTPBBLKSIZE,LT,256),BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADBLKSI'
         SEG   'ERRMSG=''Unable to write file.  Blocksize '
         SEG   'is too small (<256).'''
         CMDABORT
         END
         END
         ELSE  BEGIN
         BOMB  , UNKNOWN RECFM
         END
         IF    (TVTPBBLKSIZE,GT,32760),BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADBLKSI'
         SEG   'ERRMSG=''Unable to write file.  Blocksize must '
         SEG   'not exceed 32760.'''              ML 940622
         CMDABORT
         END
         IF    (TVTFISOLD,AND,(DS1RECFM,NZ)),BEGIN
         LH    R0,DS1BLKL
         IF    (TVTPBBLKSIZE,NE,R0),BEGIN
         ACALL CHGRECFM
         END
         END
         END
*
*                                  CHECK BLOCSIZE, LRECL
         IF    (TVTPBLRECL,NZ),BEGIN
         IF    (TVTPBLRECL,LT,0),BEGIN
         SEGCLR ERRSCB
         SEGB  'ERRID=BADLRECL'
         SEG   'ERRMSG=''Unable to write file.  Record length must '
         SEG   'greater than 0.'''
         CMDABORT
         END
         IF    (TVTPBLRECL,GT,32760),BEGIN                 ml940621
         SEGCLR ERRSCB
         SEGB  'ERRID=BADLRECL'
         SEG   'ERRMSG=''Unable to write file.  Record length must '
         SEG   'not exceed 32760.'''
         CMDABORT
         END
         IF    (TVTFISOLD,AND,(DS1RECFM,NZ)),BEGIN
         LH    R0,DS1LRECL
         IF    (TVTPBLRECL,NE,R0),BEGIN
         ACALL CHGRECFM
         END
         END
         END
*
*                                  MISC CHECKS
         IF    ((TVTPBBLKSIZE,NE,0),AND,(TVTPBLRECL,NE,0)),BEGIN
         IF    (TVTPBLRECL,GT,TVTPBBLKSIZE),BEGIN   LRECL>BLKSI
         SEGCLR ERRSCB
         SEGB  'ERRID=BADBLKSI'
         SEG   'ERRMSG=''Unable to write file.  Record length is '
         SEG   'greater than blocksize.'''
         CMDABORT
         END   ,                                     (LRECL>BLKSI)
         SPACE
         IF    TVTPBFRECFIX,BEGIN  RECFM=FB, check BLKSIZE:LRECL
         CLEAR R0
         L     R1,TVTPBBLKSIZE
         L     R2,TVTPBLRECL
* fixed the following to round down instead of carping... ml940621
* IOPROGM was here!
         DR    R0,R2               BLKSIZE/LRECL
         MR    R0,R2               *LRECL again is rounded value
         IF    (R1,Z),'LR R1,R2'   rounding zeroed it, use LRECL
         ST    R1,TVTPBBLKSIZE     Save adjusted BLKSIZE
         END   ,                        (FB BLKSIZE:LRECL)
         END   ,                        (MISC CHECKS)
*
         PEND
         TITLE 'SETRECFM - Set RECFM/LRECL'
*
*  SETRECFM
*
*  ON ENTRY:
*    R1 - RBINFO
*
*  ON EXIT:
*    RECFM, LRECL, SET
*    IN TVT AND IN RBINFO
*
*  Revised 1995/01/19 MCL:  Don't set BLKSIZE here
*
*  NOTE:
*  SEE CKRECFM TO SEE VALIDITY CHECKING THAT HAS ALREADY BEEN DONE.
*
*
SETRECFM PROC
         LR    R5,R1
         WITH  (RBINFO,R5)
*
         LA    R6,OSFFMT1
         WITH  (IECSDSL1,R6)
*
*                                  SET RECFM FOR NEW FILES
         IF    (TVTFISNEW,OR,(DS1RECFM,Z),OR,TVTPBFOCHNGFMT),BEGIN
*                                  IF NO RECFM, USE EDIT
         IF    (TVTPBRECFM,EQ,0),BEGIN
         SET   TVTPBFRECEDIT
         END
*                                  EDIT DEFAULTS
         ELSEIF (TVTPBFRECEDIT),BEGIN
         END
*                                  FIXED DEFAULTS
         ELSEIF (TVTPBFRECFIX),BEGIN
         IF    (TVTPBLRECL,EQ,0),BEGIN
         LA    R0,80
         ST    R0,TVTPBLRECL
         END
         END   ,                   (fixed)
*                                  VARIABLE DEFAULTS
         ELSEIF (TVTPBFRECVAR),BEGIN
         IF    (TVTPBLRECL,EQ,0),BEGIN           no LRECL
         LA    R0,256                            default LRECL
         ST    R0,TVTPBLRECL
         END   ,                                 (no LRECL)
         END   ,                                 (variable)

         ELSE  BEGIN
         BOMB  , INVALID RECFM
         END
         END   , OF NEW
*
*                                  SET RECFM FOR EXISTING FILES
*                                  USE SAME DCB
         ELSE  BEGIN               (IE. IF OLD, AND WITH DS1RECFM)
         IF    (DS1RECFM,Z),BEGIN  SHOULD NEVER HAPPEN ** DEBUG **
         SET   TVTPBFRECEDIT       SHOULD THIS BE ERROR ??
         L     R0,RBOPTBLK         COULD HAPPEN IF NEW PDS??
         ST    R0,TVTPBLRECL
         ST    R0,TVTPBBLKSIZE
         END
         ELSEIF (DS1RECFM.DS1RECFU),BEGIN
         SET   TVTPBFRECEDIT
*        COMMENT  FIX, PDS RESIZEING BUG, ,,, IN MOST CASES
*        COMMENT  USE EXISTING LRECL, BLKSIZE, DO NOT FORCE TO 6356
         LH    R0,DS1LRECL
         ST    R0,TVTPBLRECL
         LH    R0,DS1BLKL
         ST    R0,TVTPBBLKSIZE
*                 IF SEQUENTIAL WRITE, REPLACE, FORCE NEW LRECL!
         IF    TVTFISPS,BEGIN
         IF    (TVTPBFREQWRITE,OR,TVTPBFREQREPLACE),BEGIN
         L     R0,RBOPTBLK
         ST    R0,TVTPBLRECL
         ST    R0,TVTPBBLKSIZE
         END
         END
         END
         ELSEIF (DS1RECFM.DS1RECFF),BEGIN
         SET   TVTPBFRECFIX
         LH    R0,DS1LRECL
         ST    R0,TVTPBLRECL
         LH    R0,DS1BLKL
         ST    R0,TVTPBBLKSIZE
         IF    (DS1RECFM.DCBRECCA),' SET TVTPBFRECCA '  CC
         IF    (DS1RECFM.DCBRECCM),' SET TVTPBFRECCM '  MC
         END
         ELSEIF (DS1RECFM.DS1RECFV),BEGIN
         SET   TVTPBFRECVAR
         LH    R0,DS1LRECL
         ST    R0,TVTPBLRECL
         LH    R0,DS1BLKL
         ST    R0,TVTPBBLKSIZE
         IF    (DS1RECFM.DCBRECCA),' SET TVTPBFRECCA '  CC
         IF    (DS1RECFM.DCBRECCM),' SET TVTPBFRECCM '  MC
         END
         ELSE  BEGIN
         BOMB
         END
         END
*
*                                  SET RBINFO FROM TVT FIELDS
         IF    TVTPBFRECEDIT,'SET RBFEDIT'
         ELSEIF TVTPBFRECFIX,'SET RBFFIX'
         ELSEIF TVTPBFRECVAR,'SET RBFVAR'
         ELSE  'BOMB'  UNKNOWN, UNSUPPORTED RECFM
**?CC    IF    TVTPBFRECCA,'SET RBFANSI'    ANCI CC bit
         MVC   RBLRECL,TVTPBLRECL
         MVC   RBBLKSI,TVTPBBLKSIZE
*
         PEND
         TITLE 'CALCXSPC - Calc Space in Existing File'
*
*  CALCXSPC  - CALC SPACE IN EXISTING FILE
*
*  ON ENTRY:
*    R1 - RBINFO
*
*  ON EXIT:
*    R1 - Kbytes used
*    IN RBINFO, # TRACKS USED
*
*  Rev. 1996/07/29 mcl:  put BAD UCB code here (was in SETDEVCH)
*  rev. 1995/06/02 mcl:  return kbytes not blocks
*  NOTE:
*  THIS ROUTINE SHOULD EVENTUALLY JUST TAKE THE CODE OF
*  THE ROUTINE CNTSPACE AND PUT IT IN LINE AND DELETE
*  THE CNTSPACE ROUTINE. (WE ARE THE ONLY CALLER OF
*  THE CNTSPACE ROUTINE.)  FOR NOW WE LEAVE CNTSPACE
*  ALONE.  IT IS A DEBUGGED ROUTINE, WE CAN MESS IT UP
*  LATER.
*
CALCXSPC PROC  ,
         LR    R5,R1
         WITH  (RBINFO,R5)
*
*                                  DETERMINE DEVICE CHARACTERISTICS
         IF    ~RBDEVSET,BEGIN
         LA    R1,RBINFO
         ACALL SETDEVCH            Set device characteristics
         IF    (R15,NZ),BEGIN      Unable to locate required UCB
         SEGCLR ERRSCB             Clear erorr seg control
        SEG 'ERRID=WINGFAIL ERRMSG=''Internal Wings failure, bad UCB lo*
               cate (existing file)'''
         CMDABORT ,                Abort current command
         END   ,                      (UCB not found)

         END   ,
*
*                                  WE LET CNTSPACE DO THE WORK
         ACALL CNTSPACE
*
*                                  CONVERT TRACKS TO BLOCKS USED
         CLEAR R0
         L     R1,RBTRACKS
         M     R0,RBTRKLEN         Bytes = tracks*(bytes/track)
         A     R1,=A(512)          K bytes rounded off
         SRL   R1,10               /1024 is K bytes
         PRETURN (R1)
*
         CLEAR R15
         PEND
*
         QLTORG
         TITLE 'CALCSPC - Calculate Space Needed for File'
*
*  CALCSPC  - CALC SPACE NEEDED
*
*  ON ENTRY:
*    R1 - RBINFO
*
*  ON EXIT:
*    R1 - Primary Kbytes needed
*    In RBINFO, primary and secondary blocks and allocation blocklen
*
*  rev. 1995/06/02 mcl:  common pri/sec bytes/blks code; return kbytes

CALCSPC  PROC  ,
         LR    R5,R1
         WITH  (RBINFO,R5)
         LA    R7,RBSPACE
         WITH  (SPACALC,R7)
*
*                                  DETERMINE DEVICE CHARACTERISTICS
         IF    ~RBDEVSET,BEGIN
         LA    R1,RBINFO
         ACALL SETDEVCH            Set device characteristics
* n.b. can get RC=8 if vol not found, is not fatal error here
         END   ,
*
*  get an average-block-length for space allocation
*
         L     R0,SPACAVGB         value in space calc block
         IF    (R0,NP),BEGIN          no got
         L     R0,TVTPBBLKSIZE     so use BLKSIZE from TVT
         IF    (R0,NP),'L R0,RBOPTBLK'  else use optimum
         IF    (R0,NP),'L R0,=A(7476)'  else good pseudo-blk 3380,90
         ST    R0,SPACAVGB         Save [pseudo]blksize
         END   ,                      (no got blksi)
         SPACE
*                                  Determine space needed for file
         IF    TVTPBFRECEDIT,BEGIN Calculate for EDIT format
         L     R1,TVTLINEGUESS     Line count              ml950118
         MH    R1,=H'5'            line overhead           ml950118
         A     R1,TVTBYTEGUESS     plus byte count         ml950118
         M     R0,=A(DSOVERHD)       compute overhead allocation
         D     R0,=A(100)              adjust value
         LR    R2,R1               Save byte total
         END   ,                      (edit)
         ELSEIF TVTPBFRECFIX,BEGIN Calculate for fixed format
         L     R1,TVTLINEGUESS     Number of lines
         M     R0,TVTPBLRECL         compute required bytes
         LR    R2,R1               Save byte total
         END   ,                      (fixed)
         ELSEIF (TVTPBFRECVAR),BEGIN
         L     R1,TVTLINEGUESS     Number of lines
         M     R0,=A(4)              account for RDW overhead
         A     R1,TVTBYTEGUESS         include total bytes in file
         M     R0,=A(DSOVERHD)           compute overhead value
         D     R0,=A(100)                  adjust for percentage
         LR    R2,R1               Save byte total
         END   ,                      (variable)

         ELSE  BEGIN               bad recfm
         SEGCLR ERRSCB
         SEGB  'ERRID=BADRECFM'
         SEG   'ERRMSG=''Missing or invalid RECFM'''
         CMDABORT
         END   ,                   (bad recfm)
*
*  common to all formats                                   ml950602
*  R2 has bytes total (including record overhead)

         LR    R1,R2               Total bytes
         CLEAR R0                        clear for blocksize divide
         D     R0,SPACAVGB                 compute number of blocks
         LA    R1,@R1+1                      at least one block
         ST    R1,SPACPRIM                     save in primary
         M     R0,=A(DSSECAMT)     Compute secondary allocation amt
         D     R0,=A(100)            convert to percentage
         IF    (R1,LT,10),'LA R1,10'   at least 10 blocks (at least 5
*                                      tracks)             ml950118
         ST    R1,SPACSEC                save in secondary

*  Get Kbytes, save and return it

         LR    R1,R2               bytes
         A     R1,=A(512)          round off K bytes
         SRL   R1,10               get K bytes
         ST    R1,SPACBYTE         save in RBINFO
         PRETURN (R1)              and pass to caller

         CLEAR R15
         PEND
         LTORG ,
         TITLE 'CKNEWPDS - Chcek if New PDS Needs to Be Allocated'
*
*  CKNEWPDS - CHECK IF NEW PDS NEEDING ALLOCATE
*
*  ON EXIT:
*     ALL OK
*     IF WE NEED TO ALLOCATE, WE EXIT DIRECTLY WITH ERR MSG
*
*
CKNEWPDS PROC
         IF    (TVTFISNEW,AND,(TVTPBDSMEM,NZ)),BEGIN
*-
*-       Library <filename> does not exist
*-
         SEGCLR ERRSCB
         SEGB  'ERRID=NOTFOUND'
         SEG   'ERRMSG=''Library '
         LA    R15,ERRSCB
         ACALL FMTDSN              File name
         SEG   ' not found'
         IF    (TVTVOLSER,NZ),BEGIN  Report volume if required...
         SEG   ' on '
         SEGT  TVTVOLSER           Volser
         END
         SEG   ''''                Terminate message
         CMDABORT
         END
         PEND
         TITLE 'CKPDSREP - Check if PDS Member Replace OK'
*
*  CKPDSREP - CHECK IF PDS MEMBER REPLACE AND IF SO IS
*             REPLACE OK.
*
*  ON EXIT:
*     ALL OK
*     IF ERROR, WE EXIT DIRECTLY
*
*  NOTE:
*  THIS ROUTINE IS HERE BECAUSE FOR PDS MEMBERS WE MUST OPEN
*  FILE TO DETERMINE IF MEMBER EXISTS. OH WELL.
*
*
CKPDSREP PROC
         IF    TVTFISPDS,BEGIN     Dsorg=po library post-processing
         ACALL PDSBLDL             Attempt to locate member
         IF    (R15,GE,8),BEGIN    Unexpected error from bldl
         CMDABORT ,                Abort file_open request
         END
         IF    ((R15,Z),AND,~TVTPBFREQREPLACE),BEGIN
         SEGCLR ERRSCB             Clear error SCB
         SEGB  'ERRID=EXISTS'      Set member already exists
         SEG   'ERRMSG='''         Buildup error message
         SEGTB TVTPBDSMEM          Report member name
         SEGB  'already exists in' Buildup error message
         LA    R15,ERRSCB          Address of error SCB
         ACALL FMTDSN              Format data set name into message
         IF    ~TVTPBFOVOLSEL,BEGIN    Report volume if required
         SEG   ' on '                  Build volume suffix
         SEGT  TVTVOLSER               Report volume serial
         END   ,
         SEG   ''''                Terminate message
         CMDABORT
         END
         END
*
         CLEAR R15
         PEND
         TITLE 'WINGS: CHANGFMT - CHANGE DATA SET FORMAT ERROR'
*
*  CHGRECFM - INVALID ATTEMPT TO CHANGE DSN RECFM
*
*
CHGRECFM PROC
         IF    ~TVTPBFOCHNGFMT,BEGIN  IF FORMAT CHANGE NOT ALLOWED
         IF    TVTFISPDS,BEGIN     IF PDS, NO CHANGE ALLOWED
         SEGCLR ERRSCB             CLEAR ERROR SEG CONTROL BLOCK
         SEGB  'ERRID=CHANGFMT'
         SEG   'ERRMSG=''Unable to write file.  Requested file '
         SEG   'format different than existing format.'''
         CMDABORT
         END
         ELSE  BEGIN               IF NOT PDS, WILL PROMPT FOR CHANGE
         SEGCLR ERRSCB             CLEAR ERROR SEG CONTROL BLOCK
         SEGB  'ERRID=CHANGFMT'    INDICATE DSN FORMAT CHANGE
         SEG   'ERRMSG=''Warning: DSN format would be changed.'''
         CMDABORT
         END
         END
         PEND  ,
         TITLE 'CNTSPACE - Total space allocated for DISP=OLD'
*box
*
*  CNTSPACE - Tally total space allocacted to an old data set.
*
*  On entry:   R1  Contains the address of the RBINFO control block
*                  Data field OSFFMT1 contains the FMT1 DSCB
*
*  On exit:    R0  Contains the total number of extents allocated
*                  to the old data set.
*              R1  Contains the total number of tracks allocated
*                  to the old data set.
*

CNTSPACE PROC  ,
         LR    R7,R1               Move address of rbinfo
         WITH  (RBINFO,R7)         Addressability to rbinfo
         CLEAR R3                  Clear track counter
*-
*-       First total FMT1 extents, (up to the first three)
*-
         LA    R4,OSFFMT1          Address of fmt1 dscb
         WITH  (IECSDSL1,R4),BEGIN Addressability to fmt1 dscb
         LC    R2,DS1NOEPV         Load total number of extents
         ST    R2,RBEXTS           Save total number of extents
         LR    R0,R2               Set number of extents in fmt1
         CEIL  R0,3                Maximum of three
         SR    R2,R0               Decrement remaining extents
         LA    R1,DS1EXT1          Address of extent list
         L     R15,RBTRKCYL        Load trk/cylinder parameter
         XCALL CNTRACKS            Total tracks/extents
         A     R1,RBTRACKS         Total rbtracks
         ST    R1,RBTRACKS         Save back into rbinfo control
         END   ,
         WITH  (IECSDSL3,R4),BEGIN Addressability to fmt3 dscb
         WHILE (R2,NZ),BEGIN       Process all extents
         LA    R0,DS3PTRDS         Address of cchhr of next fmt3
**-ml    LA    R1,TVTPBVOL         Address of volume serial
         LA    R1,TVTVOLSER        ->volume serial
         ACALL OBTFMT3             Read in fmt3-DSCB
         LA    R4,OSFFMT3          Address of fmt3 area
         LR    R0,R2               Move number of extents remaining
         CEIL  R0,4                A maximum of four
         SR    R2,R0               Decrement remaining extents
         LA    R1,DS3EXTNT         Address of next four extents
         L     R15,RBTRKCYL        Load trk/cyl number
         XCALL CNTRACKS            Total tracks in this portion
         A     R1,RBTRACKS         Compute total so far
         ST    R1,RBTRACKS         Save back into rbinfo control
         LTR   R0,R2               Any remaining extents?
         IF    NZ,BEGIN            Yes - process last nine
         CEIL  R0,9                Set for a maximum of nine
         SR    R2,R0               Decrement remaining extents
         LA    R1,DS3ADEXT         Additional nine extents
         L     R15,RBTRKCYL        Load trk/cyl number
         XCALL CNTRACKS            Total tracks in this portion
         A     R1,RBTRACKS         Add to previous total
         ST    R1,RBTRACKS         And save back into rbinfo control
         END   ,
         END   ,
         END   ,
         CLEAR R15                 Zero return code
         PEND  ,
         TITLE 'WFILALC - Allocate File for Write'
*box
*
*  WFILALC - Allocate file for WRITE.  Also used by FILE_ALLOC
*
*  On entry:   R1 Contains the address of the RBINFO block
*  (REV 1994/06/01 MCL:  was SPACALC area in RBINFO)
*              R0 contains address of FILPB area, or zero  ml940601
*
*  On exit:
*     all errors exit directly to CMDCLEAN
*
*  Note:
*  For new data sets if there is no volume and no data class
*  specified, we attempt to allocate new files on the same volume
*  as WYL.GG.UUU.LIB.  If this allocation fails we retry the
*  allocation on any volume.
*
*
WFWK     RECORD BEGIN
WFRECFM  DS    X                   RECFM work byte
         END
*
*
WFILALC  PROC  WFWK
         CLEAR WFWK
*
         LR    R4,R1               Move address of rbinfo block
         WITH  (RBINFO,R4)
         LA    R5,RBSPACE          ->SPACALC area
         WITH  (SPACALC,R5)        Addressability to space block
         LR    R6,R0               ->FILPB, or is zero
** 1999/12/14 MCL V3.8:  following (up to WFARETRY) moved here, used
** to be in FILEALLO shortly before calling this.  But we need it if
** this called from FILEWRITE if PRIQTY specified on FILE_OPEN cmd
** (as may happen with SPIRES call)

*  If writing file and no priqty, figure it out (normal case)
         IF    ((TVTPBALLOCPRI,Z),AND,~TVTPBFREQALLOCATE),BEGIN
         LR    R1,R4               ->RBINFO
         ACALL CALCSPC             Calc space from BYTEGUESS etc.
         END   ,                      (no primary)

*  Have PRIQTY now.  For ALLOCATE, could be zero.

         ELSE  BEGIN               have PRIQTY, don't GUESS
**-      LA    R7,RBSPACE
**-      WITH  (SPACALC,R7)
         MVC   SPACPRIM,TVTPBALLOCPRI   primary qty
         MVC   SPACSEC,TVTPBALLOCSEC      secondary
         MVC   SPACDIR,TVTPBALLOCDIR        directory
         IF    (TVTPBALTYPKB,OR,TVTPBALTYPMB),BEGIN  K or M bytes
*
*  If space given in K, we actually use avg-block-len=7476 and divide
*  the space request by 7.812. That results in a reasonable conversion
*  of K bytes to tracks, because 7476 is exactly 1/6 track on 3380
*  and just under 1/7 track on 3390.  For 3390, we have:
*
*  maximum data on track = 2*27998 = 55996 bytes = 54.68k bytes
*  1/7 of this is 54.68/7 = 7.811+ kbytes, round up to 7.812
*
*  So for example we want 5468 kbytes (100 tracks),
*
*  5468/7.812 = 699.95 blocks (round up to 700)
*  and SPACE=(7476,700) will get us 100 tracks.
*
*  On a 3380 a track holds 2*23476 = 46952 bytes = 45.85k bytes
*  1/6 of this is 7.641k bytes so we're a little off with 7.812, but
*  consider 4585 kbytes (100 tracks), 4585/7.812 = 586.92 blocks,
*  which is 97.83 tracks so we'll get 98 tracks instead of 100.
*  We could fudge the factor so 3380 is right on and 3390 is 2% high,
*  but 3380 are mostly extinct so we optimize 3390.
*
*  We don't use AVGREC because in most cases the system ignores it
*  (i.e. if SMS not running, if LRECL or RECFM not specified, or
*  RECFM=U).  For space in M, we still use 7476 pseudoblock.
*
         L     R0,=F'7476'         pseudo blksi, good 3380,3390
         ST    R0,SPACAVGB         ...block length for alloc
         L     R1,TVTPBALLOCPRI    primary K bytes
         L     R3,TVTPBALLOCSEC    secondary K bytes
         IF    TVTPBALTYPKB,BEGIN  K bytes
         ST    R1,SPACBYTE         save in space alloc blk
         IF    (R1,NZ),BEGIN       have nonzero primary
         LA    R1,7(R1)              round up and
         SR    R0,R0
         M     R0,=F'1000'
         D     R0,=F'7812'         7.812, see discussion above
         LTR   R1,R1               any left?
         IF    Z,'LA R1,1'         gotta have one
         END   ,                      (have nonzero primary)
         LA    R3,7(R3)              round up secondary
         SR    R2,R2
         M     R2,=F'1000'         want /7.812
         D     R2,=F'7812'            ...
         END   ,                     (K bytes)
         ELSE  BEGIN               M bytes
         LR    R15,R1              Mbytes req'd
         SLL   R15,10              Kbytes req'd
         ST    R15,SPACBYTE        save Kbytes
         MH    R1,=H'131'          7.812k * 131 = 1024k = 1M
         MH    R3,=H'131'          same for secondary...
         END   ,                     (M bytes)
         ST    R1,SPACPRIM         primary for alloc request
         ST    R3,SPACSEC          secondary for alloc request
         END   ,                      (space in Kbytes/Mbytes)
         END   ,                      (have PRIQTY)

*
WFARETRY LABEL ,
*
*
*                                  Clear dynamic CB
         DYNCLEAR ,                Clear dynamic allocation control
         DYNADD (DALDSNAM,1,44),TVTPBDSNAME  set data set name
         DYNADD (DALRTVOL,1,6),GVTBLANK      return volume serial
         ST    R1,SPACRTVL                   save address of volser
         DYNADD (DALRTDDN,1,8),GVTBLANK      return ddname
         ST    R1,SPACRTDD                   save address of ddname

         IF    (TVTPBRECFM,NZ),BEGIN  RECFM specified
         IF    TVTPBFRECEDIT,BEGIN Set recfm=u for edit format
         SET   (WFRECFM.DCBRECU,EQ)
         END   ,                      (edit)
         ELSEIF TVTPBFRECFIX,BEGIN Set recfm=fb for fixed records
         SET   (WFRECFM.DCBRECF+DCBRECBR,EQ)
         END   ,                      (fb)
         ELSEIF TVTPBFRECVAR,BEGIN Set recfm=vb for variable records
         SET   (WFRECFM.DCBRECV+DCBRECBR,EQ)
         END   ,                      (vb)
         DYNADD (DALRECFM,1,1),WFRECFM
         END   ,                     (RECFM specified)
*-
*-       On DSORG=PS data set set for release of unused space
*-
         IF    (TVTFISPS,AND,~TVTPBFREQALLOCATE),BEGIN  Release unused
         DYNADD (DALRLSE,0,0)      Add release text unit
         END   ,

*-
*-       Processing for DISP=NEW data set allocations
*-
*                                  NEW DATA SET ALLOCATE
         IF     (TVTFISNEW,OR,TVTFRESAVE),BEGIN       new
* TVTFRESAVE means we're doing "scratch old and reallocate" in
* a "save...replace" operation
         DYNADD (DALSTATS,1,1),=X'04'        set new
         IF    ~TVTPBFNOCAT,BEGIN                   catalog
         DYNADD (DALNDISP,1,1),=X'02'        disp=catlg
         END   ,                                 (catalog)
         ELSE  BEGIN                   keep
         DYNADD (DALNDISP,1,1),=X'08'        disp=keep
         END   ,                         (keep)
         DYNADD (DALCDISP,1,1),=X'08'        delete on error
         IF    (R6,Z),BEGIN        If no FILPB...
         DYNADD (DALBLKLN,1,3),SPACAVGB+1  allocate by blocks
         END   ,                     (no FILPB)
         DYNADD (DALPRIME,1,3),SPACPRIM+1    include primary amount
         IF    (SPACSEC,NZ),BEGIN            non-zero secondary amount
         DYNADD (DALSECND,1,3),SPACSEC+1     include secondary amount
         END   ,                                  (secondary given)
*
         IF    (SPACDIR,NZ),BEGIN            directory quantity given
         DYNADD (DALDIR,1,3),SPACDIR+1     include secondary amount
         END   ,                                  (dir qty given)
*
*
         IF    (R6,NZ),BEGIN       FILPB was passed
         WITH  (FILPB,R6)
         IF    (FILPBALTYPTR),BEGIN  allocate TRACKS
         DYNADD (DALTRK,0,0)       show TRK
         END   ,                     (alloc TRACKS)
         ELSEIF (FILPBALTYPCY),BEGIN alloc CYLINDERS
         DYNADD (DALCYL,0,0)       show CYL
         END   ,                     (alloc CYLINDERS)
         ELSE  BEGIN               alloc blocks
         DYNADD (DALBLKLN,1,3),SPACAVGB+1 use blkl in SPACALC
         END   ,                     (alloc blocks)
         IF    (FILPBSTORCLAS,NZ),BEGIN   STORCLAS specified
         DYNADD (DALSTCL,1,8),FILPBSTORCLAS  add it to parmlist
         SET   TVTFISSMS           Show SMS-type alloc
         END   ,                     (STORCLAS)
         IF    (FILPBMGMTCLAS,NZ),BEGIN   MGMTCLAS specified
         DYNADD (DALMGCL,1,8),FILPBMGMTCLAS  add it to parmlist
         SET   TVTFISSMS           Show SMS-type alloc
         END   ,                     (MGMTCLAS)
         IF    (FILPBDATACLAS,NZ),BEGIN   DATACLAS specified
         DYNADD (DALDACL,1,8),FILPBDATACLAS  add it to parmlist
         SET   TVTFISSMS           Show SMS-type alloc
         END   ,                     (DATACLAS)
         END   ,                   (filpb)
*                                  SELECT CORRECT VOLUME
         IF    TVTFDYNRT1,BEGIN    IF RETRY, USE ANY DISK
         DYNADD (DALUNIT,1,4),=C'DISK'
         CLEAR TVTFDYNRT1
         END   ,                     (retry)
         ELSEIF (TVTPBVOL,NZ),BEGIN    User specified vol
         DYNADD (DALUNIT,1,8),=C'SYSALLDA'
         DYNADD (DALVLSER,1,6),TVTPBVOL
*                 WE CAN'T NOT SAVE SOMEWHERE, USER MAY LOSE DATA
*                 SO WE SET TO RETRY IF VOLUME IS FULL
         SET   TVTFDYNRT1          IF USER VOL DOESN'T WORK, RETRY
         END   ,                       (user vol)

         ELSEIF TVTPBFOVOLTEMP,BEGIN   Temp
         DYNADD (DALUNIT,1,5),=C'SYSDA'      UNIT=SYSDA TEMPORARY
*  1999/11/04 mcl see if storage or mgmt class used for temp
         IF    (TVTTMSTC,NZ),BEGIN   STORCLAS specified for TEMP
         DYNADD (DALSTCL,1,8),TVTTMSTC  add it to parmlist
         SET   TVTFISSMS           Show SMS-type alloc
         END   ,                     (STORCLAS)

         IF    (TVTTMMGC,NZ),BEGIN   MGMTCLAS specified for TEMP
         DYNADD (DALMGCL,1,8),TVTTMMGC  add it to parmlist
         SET   TVTFISSMS           Show SMS-type alloc
         END   ,                     (MGMTCLAS)
         END   ,                         (temp)

         ELSEIF (TVTCATVOL,NZ),BEGIN    CAT VOLUME (RESAVE)
         DYNADD (DALUNIT,1,8),=C'SYSALLDA'
         DYNADD (DALVLSER,1,6),TVTCATVOL
         SET   TVTFDYNRT1          IF CAT VOLUME DOESN'T WORK, RETRY
         END   ,                        (cat volume)
         ELSEIF (~TVTFISSMS,AND,(TVTLIBVOL,NZ)),BEGIN    LIB VOLUME
         DYNADD (DALUNIT,1,8),=C'SYSALLDA'
         DYNADD (DALVLSER,1,6),TVTLIBVOL
         SET   TVTFDYNRT1          IF LIB VOLUME DOESN'T WORK, RETRY
         END   ,                        (lib volume)
         ELSEIF ~TVTFISSMS,BEGIN   If none of above, use any disk
         DYNADD (DALUNIT,1,4),=C'DISK'       unit=disk
         END   ,                      (none of above)
         END   ,                      (new)
*-
*-       Processing for DISP=OLD data set allocations
*-
*                                  PROCESS OLD (AND NOT RESAVE)
         ELSE  BEGIN               OLD
         IF    TVTPBFOSHARE,BEGIN            SHARE option
         DYNADD (DALSTATS,1,1),=X'08'        disp=shr
         END   ,                                 (SHARE opt)
         ELSE BEGIN                              NOSHARE
         DYNADD (DALSTATS,1,1),=X'01'        disp=old
         END   ,                                 (NOSHARE)
         DYNADD (DALNDISP,1,1),=X'08'        disp=keep

         IF    (TVTPBVOL,NZ),BEGIN Specific volume request
         DYNADD (DALUNIT,1,8),=C'SYSALLDA'
         DYNADD (DALVLSER,1,6),TVTPBVOL
         END   ,                   (specific vol)
         SPACE
         IF    (TVTFISPDS,AND,~TVTPBFOEXPND),BEGIN    no expand
*                ZERO SECONDARY FOR EXISTING PDS
         DYNADD (DALTRK,0,0)
         DYNADD (DALSECND,1,3),=F'0'         include dummy secondary
         END   ,                      (no expand)
         END   ,                   (old)

*-
*-       Set BLKSIZE, LRECL, DSORG, and recfm parameters
*-
         IF    (TVTPBBLKSIZE,NZ),BEGIN set data set blocksize
         DYNADD (DALBLKSZ,1,2),TVTPBBLKSIZE+2
         END   ,                       (set blksize)
         IF    (TVTPBLRECL,NZ),BEGIN   set data set lrecl
         DYNADD (DALLRECL,1,2),TVTPBLRECL+2
         END   ,                       (set lrecl)
         IF    TVTFISPDS,BEGIN     partitioned
         DYNADD (DALDSORG,1,2),=X'0200'   DSORG=PO
         END   ,                      (partitioned)
         ELSE  BEGIN               sequential
         DYNADD (DALDSORG,1,2),=X'4000'  DSORG=PO
         END   ,                      (sequential)

*-
*-       Issue dynamic allocation call for data set
*-
         DYNCALL ,                 Issue dynamic allocation call
         PTRACE Wdyncall           Trace return from dyncall
         DYNCHECK ,                Process any return codes
         IF    (R15,GT,4),BEGIN    trouble...
         IF    ((TVTFDYNRT1,OR,TVTFDYNRT0),AND,~TVTFDYNRTX),BEGIN
*                                                        OK to retry
         SET   TVTFDYNRTX          remember this is retry, don't loop
         B     WFARETRY            go for it
         END   ,                      (retry)
         CMDABORT ,                Cleanup path and re-enter wait
         END   ,                      (trouble)

*-
*-       Retreive DDNAME and allocated volume serial
*-
         MVC   TVTDDNAME,GVTBLANK  Blank out ddname
         L     R2,SPACRTDD
         LH    R1,@R2+4            Load length of returned ddname
         DEX   R1,'MVC TVTDDNAME(0),@R2+6'   move in ddname

         MVC   TVTVOLSER,GVTBLANK  Blank out volser
         L     R2,SPACRTVL           Address of returned volser
         LH    R1,@R2+4                Set length of returned volser
         DEX   R1,'MVC TVTVOLSER(0),@R2+6'
         RECVRY ROUT=WFILFREE      Recovery reoutine to de-allocate

         PEND  ,
         TITLE 'WFILFREE - De-Allocate File After Error'
*BOX
*
*  WFILFREE - Recovery routine to de-allocate file after error
*
*
WFILFREE PROC ,
         LA    R1,TVTDDNAME        Address of potential file
         XCALL FINDDD              Attempt to locate in TIOT
         IF    Z,BEGIN             Allocation exists, deallocate
         DYNCLEAR ,                Clear dynamic allocate block
         DYNSET S99VRBUN           Set for dynamic unallocation
         DYNADD (DUNDDNAM,1,8),TVTDDNAME     Set to release
         DYNCALL ,                 Deallocate file
         IF    (R15,NZ),BEGIN
         FAIL  'Error in recovery de-allocation.'
         END   ,                   (dealloc fail)
         END   ,                   (alloc exists)
         CLEAR TVTNQFLG            no ...
         CLEAR TVTNQDSN               enqueue
         MVI   TVTDDNAME,C' '      show no allocation
         PEND  ,
         LTORG ,
         TITLE 'WRTOPEN - Open File for Output'
*box
*
*  WRTOPEN - Open file for output processing
*
*  On Entry:   File has been successfully allocated
*              R1->RBINFO                                  ml950119
*
*  ON EXIT:
*        R15=0 File is open for output
*        R15=NZ Error message has been placed in errscb
*
         SPACE 2
WRTOPWK  RECORD BEGIN              Define local work area
WRTOPNL  OPEN  (*-*,(OUTPUT)),MF=L Define open parameter list
         END   ,
WRTOPEN  PROC  WRTOPWK
         LTR   R7,R1               save RBINFO pointer
         IF    Z,BEGIN             if no RBINFO block
         ACALL INITRB              so go build one
         LR    R7,R1               and save pointer for open exit
         END   ,                      (no RBINFO)
         RECVRY ROUT=WTOPEN        Set recovery for wrtopen routine
*                                  Set address of prototype bsam DCB
         LA    R3,OSFBSAM          Address of bsam DCB
         WITH  (IHADCB,R3),BEGIN   Addressability to bsam DCB
         IF    TVTFISPDS,BEGIN     Initialize bpam DCB
         LA    R0,OSFBPAM          Address of bsam DCB
         LA    R1,DCBBPAML           length of bsam DCB
         L     R14,=A(DCBBPAM)         address of prottype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB
         END   ELSE,BEGIN          Initialize bsam DCB
         LA    R0,OSFBSAM          Address of bsam DCB
         LA    R1,DCBBSAML           length of bsam DCB
         L     R14,=A(DCBBSAM)         address of prottype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB
         END   ,                      (BSAM)
         L     R0,=A(OSFWEXL)      Address of DCB exit list
         ST3   R0,DCBEXLSA         Save exit list address in DCB
         L     R0,=A(TWSYNAD)      Address of SYNAD routine ML920118
         ST3   R0,DCBSYNA          Set SYNAD address in DCB ML920118
         SPACE 2
         MVC   DCBDDNAM,TVTDDNAME  Set ddname into output DCB
         IF    TVTPBFRECEDIT,BEGIN Set recfm=u for edit format
         SET   (DCBRECFM.DCBRECU,EQ)
         END   ,                      (edit)
         ELSEIF TVTPBFRECFIX,BEGIN Set recfm=fb for fixed records
         SET   (DCBRECFM.DCBRECF+DCBRECBR,EQ)
         IF    TVTPBFRECCA,' SET DCBRECFM.DCBRECCA'  CC
         IF    TVTPBFRECCM,' SET DCBRECFM.DCBRECCM'  MC
         END   ,                      (fb)
         ELSEIF TVTPBFRECVAR,BEGIN Set recfm=vb for variable records
         SET   (DCBRECFM.DCBRECV+DCBRECBR,EQ)
         IF    TVTPBFRECCA,' SET DCBRECFM.DCBRECCA'  CC
         IF    TVTPBFRECCM,' SET DCBRECFM.DCBRECCM'  MC
         END   ,                      (vb)
         MVC   DCBLRECL,TVTPBLRECL+2   set lrecl size (+2 IS OFFSET)
         MVC   DCBBLKSI,TVTPBBLKSIZE+2 set block size into DCB
*                                  Open output
         ST    R3,WRTOPNL          Save address of DCB
         OI    WRTOPNL,X'80'         indicate only one DCB
         CLEAR TVTDCBAB            not abending yet...
         OPEN  ((R3),(OUTPUT)),MF=(E,WRTOPNL)
*                                  Check for sucessful open
         TM    DCBOFLGS,DCBOFOPN   Test DCB open flags

         IF    Z,BEGIN             File failed to open
         SEGCLR ERRSCB             CLEAR ERROR SEGCB

         IF    TVTDCBAB,BEGIN      ABEND in OPEN
         SEG   'ERRID=BADOPEN ERRMSG=''OPEN ABEND ('
         ACALL FMTABEND            ADD CODE TO MESSAGE
         SEG   ')'''               TERMINATE MESSAGE
         LA    R15,8               RC for ABEND
         EXIT  WRTOPEN             TERMINATE OPEN PROCESSING
         END   ,                      (ABEND)

*  OPEN fail, not ABEND
         SEG   'ERRID=BADOPEN ERRMSG=''OPEN failed for output.'''
         LA    R15,4               Set non-zero return code
         EXIT  WRTOPEN             Abort open processing
         END   ,                      (open fail)

         TM    DCBRECFM,X'48'      VBS
         IF    (ONES,AND,TVTPBFRECVAR),BEGIN     vbs
         SEGCLR ERRSCB             Clear error segcb
       SEG  'ERRID=BADRECFM ERRMSG=''Output VBS format not supported'''
         LA    R15,4               Set non-zero return code
         EXIT  WRTOPEN
         END   ,                      (vbs)
         END   ,                      (with IHADCB)
*-
*-       DETERMINE CURRENT TTR FOR Data set
*-
         IF    TVTFISPDS,BEGIN     Only need for partitioned
         L     R5,TVTRBINF         ADDRESS OF RBINFO
         WITH  (RBINFO,R5)
         ACALL NOTEDSN             Note current ttr location
         ST    R1,RBTTR            Save current ttr location
         ST    R0,RBTRKBAL         Save track balance
**-L     IF    TVTREPT,BEGIN
**-L     SEGCLR OSFSCB             Log value
**-L     SEG   'CURRENT TTR='
**-L     SEGHX RBTTR,8
**-L     SEG   ', TRACK BALANCE='
**-L     SEGDC RBTRKBAL
**-L     SEGWR ,
**-L     END   ,                      (report)
         END   ,                      (get ttr)
         CLEAR  R15
         DROP  R5                  Release rbinfo control block
         PEND
         TITLE 'WINGS: WTOPEN - Recovery Routine for WRTOPEN'
*BOX
*
*  WTOPEN - Recovery routine for WRTOPEN
*
         SPACE 2
WTOPENWK RECORD BEGIN              Define local data
WTOPENOL CLOSE (*-*),MF=L          Define close parameter list
         END   ,

WTOPEN   PROC  WTOPENWK
         LA    R2,OSFBSAM          Address of BSAM/BPAM DCB
         ST    R2,WTOPENOL           Save in close parameter list
         OI    WTOPENOL,X'80'          Mark as only one DCB

         WITH  (IHADCB,R2),BEGIN   Addressability to DCB
         IF    DCBOFLGS.DCBOFOPN,BEGIN       Close if file is open
         CLOSE ,MF=(E,WTOPENOL)    Close file
         END   ,
         END   ,
         ACALL WFILFREE            un-allocate it          ml940816
         PEND  ,
         TITLE 'UPDOPEN - Open File for Update'
*box
*
*  UPDOPEN - Open file for update processing
*
*  On Entry:   File has been successfully allocated
*              R1->RBINFO
*
*  ON EXIT:
*        R15=0 File is open for output
*        R15=NZ Error message has been placed in errscb
*
         SPACE 2
UPDOPWK  RECORD BEGIN              Define local work area
UPDOPNL  OPEN  (*-*,(UPDATE)),MF=L Define open parameter list
         END   ,
UPDOPEN  PROC  UPDOPWK
         LTR   R7,R1               save RBINFO pointer
         IF    Z,BEGIN             if no RBINFO block
         ACALL INITRB              so go build one
         LR    R7,R1               and save pointer for open exit
         END   ,                      (no RBINFO)
         RECVRY ROUT=WTOPEN        recovery same as for wrtopen
*                                  Set address of prototype bsam DCB
         LA    R3,OSFBSAM          Address of bsam DCB
         WITH  (IHADCB,R3),BEGIN   Addressability to bsam DCB
         IF    TVTFISPDS,BEGIN     Initialize bpam DCB
         LA    R0,OSFBPAM          Address of bsam DCB
         LA    R1,DCBBPAML           length of bsam DCB
         L     R14,=A(DCBBPAM)         address of prottype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB
         END   ELSE,BEGIN          Initialize bsam DCB
         LA    R0,OSFBSAM          Address of bsam DCB
         LA    R1,DCBBSAML           length of bsam DCB
         L     R14,=A(DCBBSAM)         address of prottype DCB
         LR    R15,R1                    set copy from length
         MVCL  R0,R14                      move in prototype DCB
         END   ,                      (BSAM)
         L     R0,=A(OSFWEXL)      Address of DCB exit list
         ST3   R0,DCBEXLSA         Save exit list address in DCB
         L     R0,=A(TWSYNAD)      Address of SYNAD routine ML920118
         ST3   R0,DCBSYNA          Set SYNAD address in DCB ML920118
         SPACE 2
         MVC   DCBDDNAM,TVTDDNAME  Set ddname into output DCB
*                                  Open output
         ST    R3,UPDOPNL          Save address of DCB
         OI    UPDOPNL,X'80'         indicate only one DCB
         CLEAR TVTDCBAB            not abending yet...
         OPEN  ((R3),(UPDATE)),MF=(E,UPDOPNL)
*                                  Check for sucessful open
         TM    DCBOFLGS,DCBOFOPN   Test DCB open flags
         IF    Z,BEGIN             File failed to open
         IF    TVTDCBAB,BEGIN      REPORT DCB ABEND EXIT CODES
         SEGCLR ERRSCB             CLEAR ERROR SEGCB
         SEGB  'ERRID=BADOPEN'     REPORT ERROR CODE
         SEG   'ERRMSG='''         BUILDUP ERROR MESSAGE
         SEG   'DCB open abend=x'''''    REPORT DCB ABEND CODE
         ACALL FMTABEND            ADD CODE TO MESSAGE
         SEG   ''''''''            TERMINATE MESSAGE
         CMDABORT ,                TERMINATE OPEN PROCESSING
         END   ,                      (ABEND)
         SEGCLR ERRSCB             Clear error segment control
         SEGB  'ERRID=BADOPEN'     Set error id to badopen
         SEG   'ERRMSG='''         Report error message
         SEG   'Error in update open code'''
         LA    R15,4               Set non-zero return code
         EXIT  UPDOPEN             Abort open processing
         END   ,                      (open fail)
         TM    DCBRECFM,X'48'      VBS
         IF    (ONES,AND,TVTPBFRECVAR),BEGIN     vbs
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=BADRECFM'    Set error identification
         SEG   'ERRMSG=''Output VBS format not supported'''
         LA    R15,4               Set non-zero return code
         EXIT  UPDOPEN
         END   ,                      (vbs)
         END   ,                      (with IHADCB)
*-
*-       DETERMINE CURRENT TTR FOR Data set
*-
         IF    TVTFISPDS,BEGIN     Only need for partitioned
         L     R5,TVTRBINF         ADDRESS OF RBINFO
         WITH  (RBINFO,R5)
         ACALL NOTEDSN             Note current ttr location
         ST    R1,RBTTR            Save current ttr location
         ST    R0,RBTRKBAL         Save track balance
         END   ,                      (get ttr)
         CLEAR  R15
         DROP  R5                  Release rbinfo control block
         PEND
         TITLE 'WINGS: RBFREE'
*BOX
*
*  RBFREE - Release RBINFRO blocking control
*

RBFREE   PROC  ,
         LT    R2,TVTRBINF         Any RBINFO block exist?
         IF    NZ,BEGIN            Yes - Release block
         WITH  (RBINFO,R2)         Addressability to rbinfo
         DROP  R2
         DELSYM NAME='RBINFO',LOC=(R2) delete from symbol table
         LR    R1,R2               Address of rbinfo
         VCALL FREECORE            Release rbinfo block
         CLEAR TVTRBINF            Zero rbinfo pointer
         END   ,
         PEND  ,
         SPACE 2
         LTORG ,
         TITLE 'WRTFILE - Block and Write Data'
*box
*
*  WRTFILE - Block and write data from client path
*
*  ON ENTRY:   (R0,R1) Contains the length and address of the
*              client data.
*
*  ON EXIT:
*              R15=0 -- ALL OK
*              R15=NZ - ERROR, MSG At r1,r0
*
*
         SPACE 2
WRTFILE  PROC  ,
         L     R5,TVTRBINF         Address of rbinfo control
         WITH  (RBINFO,R5),BEGIN   Addressability to rbinfo
         LR    R2,R1               Save start of client data
         AR    R1,R0               Compute last address of data
         LR    R4,R1               Save last address of data
         WHILE (R2,LT,R4),BEGIN    Loop putting records
         L     R0,@R2              Load total line length
         LR    R1,R2               Set address of line data
         LR    R15,R5              Set address of rbinfo control
         ACALL PUTRECD             Put current in buffer
         IF    (R15,NZ),BEGIN      Error,
**mcl    LA    R15,8
         EXIT  WRTFILE
         END
         AL    R2,@R2              Bump to next record
         END   ,                   Loop putting records
         CLEAR R15
         END   ,
         PEND
         LTORG ,
         TITLE 'PUTRECD - Block Record'
*box
*
*  PUTRECD - BLOCK RECORD
*
*  ON ENTRY:
*    R1,R0 - RECORD LOCATION LENGTH
*    R15 - RBINFO AREA
*
*  ON EXIT
*    R15=0, ALL OK
*    R15=NZ, ERROR, R1,R0 CONTAIN ERrmsg location, len
*
*  NOTE:
*  SHORT FIXED FORMAT RECORDS WILL Be blank padded.
*  LONG FIXED FORMAT RECORDS WILL BE truncated.
*  VBS NOT SUPPORTED FOR WRITE.
*  EXTENDED EDIT IS HISTORY AND NOT supported for write.
*
*  NOTE:
*  BLOCK SIZE MUST BE REASONABLE.
*  THAT IS ALL RECORDS WRITTEN MUST be able to fit
*  ON AN EMPTY BLOCK.
*
*

PRWA     RECORD BEGIN
PRLOC    DS    A
PRLEN    DS    A
PRLNO    DS    F
PRBLKEND DS    A
PRPRSLOC DS    A
PRPRSLEN DS    F
PRPRESS  DS    XL(256+16)
         END
*
*
PUTRECD  PROC  PRWA,TRACE=NO
*
         LR    R6,R15
         USING RBINFO,R6
         LR    R4,R1
         USING WGSLINE,R4
*
         CLEAR PRWA
         ST    R1,PRLOC
         ST    R0,PRLEN
         L     R1,RBSTART
         A     R1,RBBLKSI
         ST    R1,PRBLKEND
*
*                                  If first call, init rbndx
         IF    (RBNDX,EQ,0),BEGIN
         L     R1,RBSTART
         IF    RBFEDIT,BEGIN
         LA    R1,@R1+2
         END
         IF    (RBFVAR,OR,RBFVBS),BEGIN
         LA    R1,L'VBSHDR(R1)
         END
         ST    R1,RBNDX
         END
*
*                                  If edit do it
*                                  Check length
         IF    RBFEDIT,BEGIN
         L     R0,WGSLNLEN
         S     R0,=A(L'WGSLNHDR)
         IF    (R0,GT,&LINESZ),BEGIN  should we just truncate
         SETMSG 'Line(s) too long for edit format.'
         LA    R15,8
         B     PUTREXIT
         END
*                                  Get line number
         LA    R1,WGSLNLNO
         LA    R0,L'WGSLNLNO
         ACALL GTINTVAL
         IF    (R15,NEG),BEGIN
         SETMSG 'Invalid WINGS datablock'  never !
         LA    R15,8
         B     PUTREXIT
         END
         ST    R15,PRLNO
*                                  Press line
         LA    R1,WGSLNTXT
         L     R0,WGSLNLEN
         S     R0,=A(L'WGSLNHDR)
         L     R15,PRLNO
         LA    R2,PRPRESS
         ACALL PRESS
         ST    R1,PRPRSLOC
         ST    R0,PRPRSLEN
*                                  If rec wont fit, write block
         L     R2,RBNDX
         AR    R2,R0
         IF    (R2,GT,PRBLKEND),BEGIN
         L     R15,RBIOINFO
         L     R1,RBSTART
         L     R0,RBNDX
         SR    R0,R1
         STH   R0,@R1              Save edit block len
         ACALL WRITEBLK
         IF    (R15,NZ),BEGIN
         B     PUTREXIT
         END
**-ml    ST    R1,RBSTART
         LA    R1,@R1+2
         ST    R1,RBNDX
         END
*                                  Put record in block
*                ,                 (record must fit is empty block!)
         L     R0,PRPRSLOC
         L     R1,PRPRSLEN
         L     R2,RBNDX
         LR    R3,R1
         MVCL  R2,R0
         L     R2,RBNDX            Update block index
         A     R2,PRPRSLEN
         ST    R2,RBNDX
         END
*
*
*                                  If fixed do it
         IF    RBFFIX,BEGIN
         L     R2,RBNDX
         A     R2,RBLRECL
         IF    (R2,GT,PRBLKEND),BEGIN
         L     R15,RBIOINFO
         L     R1,RBSTART
         L     R0,RBNDX
         SR    R0,R1
         PTRACE BEFWRTBL
         ACALL WRITEBLK
         IF    (R15,NZ),BEGIN
         B     PUTREXIT
         END
         PTRACE AFTWRTBL
**-ml    ST    R1,RBSTART
         ST    R1,RBNDX
         END
*                                  Put record in block
*                ,                 (record must fit is empty block!)
         LA    R0,WGSLNTXT
         L     R1,WGSLNLEN
         S     R1,=A(L'WGSLNHDR)
         L     R2,RBNDX
         L     R3,RBLRECL
         O     R1,=X'40000000'     Blank pad
         MVCL  R2,R0
         L     R2,RBNDX            Update block index
         A     R2,RBLRECL
         ST    R2,RBNDX
         END
*
*
*                                  If vb do it
         IF    RBFVAR,BEGIN
         L     R2,RBNDX
         A     R2,WGSLNLEN
         A     R2,=A(L'VBSHDR-L'WGSLNHDR)
         IF    (R2,GT,PRBLKEND),BEGIN
         L     R15,RBIOINFO
         L     R1,RBSTART
         L     R0,RBNDX
         SR    R0,R1
         STH   R0,VBSLEN(R1)       Do vbs, block hdr
         CLEAR R3
         STH   R3,VBSFLAGS(R1)
         ACALL WRITEBLK
         IF    (R15,NZ),BEGIN
         B     PUTREXIT
         END
**-ml    ST    R1,RBSTART
         LA    R1,L'VBSHDR(R1)
         ST    R1,RBNDX
         END
*                                  Put record in block
*                ,                 (record must fit is empty block!)
         LA    R0,WGSLNTXT
         L     R1,WGSLNLEN
         S     R1,=A(L'WGSLNHDR)
         L     R2,RBNDX
         A     R2,=A(L'VBSHDR)
         LR    R3,R1
         O     R1,=X'40000000'     Blank pad
         MVCL  R2,R0
         L     R2,RBNDX            Do vbs header
         L     R0,WGSLNLEN
         A     R0,=A(L'VBSHDR-L'WGSLNHDR)
         STH   R0,@R2
         CLEAR R3
         STH   R3,VBSFLAGS(R2)
         L     R1,RBNDX            Update block index
         AH    R1,VBSLEN(R1)
         ST    R1,RBNDX
         END
*
*                                  Vbs is not allowed (yet, ever ?)
         IF    RBFVBS,BEGIN
         SETMSG 'Output VBS record format not allowed. (VB ok)'
         LA    R15,4
         B     PUTREXIT
         END
*
*                                  If all ok, restore r0,r1
         L     R1,PRLOC
         L     R2,PRLEN
         CLEAR R15
*
PUTREXIT LABEL ,
         PRETURN (R0,R1)
         PEND  ,
         DROP  R4
         TITLE 'PUTDONE'
*box
*
*  PUTDONE
*
*  WRITE FINAL (MAY BE PARTIAL) BLOCk
*
*  ON ENTRY:
*    R15 - RBINFO AREA
*
*  ON EXIT:
*    R15=0; ALL OK.
*    R15=NZ; ERROR; R1,R0 - LOC, LEN of error msg
*
*

PUTDONE  PROC  ,
         LR    R6,R15
         USING RBINFO,R6
*
         L     R1,RBSTART
         L     R0,RBNDX
         SR    R0,R1
*                                  If edit
         IF    (RBFEDIT,AND,(R0,GT,2)),BEGIN
         STH   R0,@R1
         ACALL WRITEBLK
         IF    (R15,NZ),BEGIN
         EXIT  PUTDONE
         END
**-ml    ST    R1,RBSTART
         LA    R1,@R1+2
         ST    R1,RBNDX
         END
*                                  If fixed
         ELSEIF (RBFFIX,AND,(R0,POS)),BEGIN
         ACALL WRITEBLK
         IF    (R15,NZ),BEGIN
         EXIT  PUTDONE
         END
**-ml    ST    R1,RBSTART
         ST    R1,RBNDX
         END
*                                  If vb, vbs
         ELSEIF ((RBFVAR,OR,RBFVBS),AND,(R0,GT,4)),BEGIN
         STH   R0,VBSLEN(R1)
         CLEAR R3
         STH   R3,VBSFLAGS(R1)
         ACALL WRITEBLK
         IF    (R15,NZ),BEGIN
         EXIT  PUTDONE
         END
**-ml    ST    R1,RBSTART
         LA    R1,L'VBSHDR(R1)
         ST    R1,RBNDX
         END
         CLEAR R15
         PEND
         DROP  R6                  Release rbinfo addressability
         TITLE 'Low level write block routine'
*box
*
*  WRITEBLK - LOWEST LEVEL READ WRITe
*
*  ON ENTRY:
*    R0 - ACTUAL BLOCK LENGTH
*    R1 - BLOCK START
*    R15 - USER INFO (TVT ADDRESS)
*  ON EXIT:
*    R15=0, ALL OK
*    R15=8, I/O error
*      R1,R0 - LOC,LEN OF ERR MSG
*    Note:  x37 ABEND exits to CMDCLEAN
*
** 1995/05/26 ml delete comments re: buffer ptr changes on exit
*
         SPACE 2
WRITEBLK PROC  ,
         LA    R3,OSFBSAM          Address of BSAM DCB
         WITH  (IHADCB,R3)         Addressability to BSAM DCB
         LR    R2,R1               Buffer address
         LH    R4,DCBBLKSI         Save nominal blocksize,
         STH   R0,DCBBLKSI         Set actual blocksize
         CLEAR TVTDCBAB            CLEAR ANY ABEND FLAGS
         WRITE OSFDECB,SF,((R3)),((R2)),'S',,MF=E
         CHECK OSFDECB
         IF    TVTDCBAB,BEGIN      hit the DCB ABEND routine
         ACALL ABNDX37
         END   ,
         STH   R4,DCBBLKSI         Restore nominal blocksize
***      END
         CLEAR R15                 Zero return code
         EXIT  WRITEBLK            Exit write block code
         SPACE 2
TWSYNAD  SYNADAF ACSMETH=BSAM,PARM1=(1),PARM2=(0)
         LR    R4,R1               Save msg area ptr       ml991104
         LA    R0,L'IOERRREC       Length needed           ml991104
         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)              ml 20020416
         LR    R2,R1               ->area                  ml991104
         WITH  (IOERRREC,R2)       Addressability to work area
         XC    IOERMSG2(4),IOERMSG2    Zero poetential PDSE info ret
         MVC   IOERMSG1(128),@R4   Move in first 128 bytes of msg
         CLI   SYNM2FLG,C'S'       Test for any PDSE information
         IF    EQ,'MVC IOERMSG2,@R4+136'     Move in PDSE section
         SYNADRLS ,                Release syandaf work areas
         VCALL AMODE31             Re-enter 31 bit addressing mode
         QSNAP 'WRITE-SYNAD'
         QSNAP SYNUNIT,40
         SEGCLR ERRSCB             Clear error segcb
         SEGB  'ERRID=IOERROR'     Indicate i/o error
         SEGB  'ERRMSG=''I/O Error occurred writing file'
         LA    R15,ERRSCB          Address of error segcb
         ACALL FMTDSN              Report data set name
         SEGB  ''''                Terminate message
         SEG   'ERRMSG='''         Begin error message buildup
*  Following rewritten MCL 940120
         SEG   'Error is: '                                ML940120
         SEG   SYNERRM             The nature of the problem
         SEG   ', block address is '                       ML940120
         SEG   SYNCCHHR            (already formatted)     ML940120
         SEG   ''''                Terminate error message
         LR    R1,R2               ->stack space           ml991104
         LA    R0,L'IOERRREC       Length needed           ml991104
         FREEMAIN R,LV=(0),A=(1)   free stack space      ml20020416
         CLEAR DCBOFLGS.DCBOFLWR   Don't write filemark    ML940201
         LA    R15,8               Set error return code   ML940125
         PEND  ,
         DROP  R3
         TITLE 'BSAM/BPAM X37 ABEND Module'
*box
*
*  ABNDX37 - Report x37 abend and terminate processing
*

ABNDX37  PROC  ,
         SEGCLR ERRSCB             Clear error seg control block
         IF    TVTFISPDS,BEGIN     PDS PROCESSING FOR FULL LIBRARY
         SEGB  'ERRID=LIBFULL'     INDICATE LIBRARY FULL
         SEGB  'ERRMSG=''Not enough space in'
         LA    R15,ERRSCB          ADDRESS OF ERROR SEGCB
         ACALL FMTDSN              FORMAT NAME INTO MESSAGE
         SEG   ''''                TERMINATE MESSAGE
         END   ELSE,BEGIN
         SEGB  'ERRID=NOSPACE'     Set error identification
         SEG   'ERRMSG=''Insufficient space x('
         ACALL FMTABEND            Report abend code
         SEG   ')'''               Terminate message
         END   ,
         CMDABORT
         PEND  ,
         TITLE 'DCB exit list processing routines'
*box
*
*  BSAM/BPAM DCB exit list processing routines
*
*        Define the DCB ABEND exit for BSAM/BPAM I/O.  The exit
*        operates in 24-bit addressing mode.  When the
*        exit is taken the register contents are as follows:
*
*              R0  - No applicable data
*              R1  - Address of DCB abend option parameter list
*          R2-R13  - Contents before I/O macro issued
*             R14  - Return address, (must not be altered)
*             R15  - Address of exit routine entry point
*
*  revised 1999/10/30:  save R14!
*  revised 1994/08/16:  this is now used for input also
*
         SPACE 2
         DC    0F'0'               align
OSFREXL  DC    X'11',AL3(OSFWAB)   DCB exit list for read:  ABEND
         DC    X'85',AL3(OSFWIP)   exit and open exit

OSFWEXL  DC    X'11',AL3(OSFWAB)   DCB exit list for write: ABEND
         DC    X'85',AL3(OSFWOP)   exit and open exit

OSFDEXL  DC    X'91',AL3(OSFWAB)   DCB exit list for read DIR: ABEND

OSFWAB   LABEL ,                   Entry point to DCB abend exit
         LR    R10,R15             Move exit base register
         USING OSFWAB,R10          Addressability to exit
         LR    R2,R1               Save pointer to parameter list
         LR    R7,R14              Save return reg   ml19991030
         QSNAP 'DCBABEND'
         QSNAP @R2,32
         GETMAIN R,LV=256          Request seconday save stack
         QSNAP (R1)
         LR    SPR,R1              Set into stack register
         LR    WAR,R1              Ditto to stack frame pointer
         L     R0,@R2              Load abend parameter list word
         PTRACE DCBABEND           Trace entry to abend
         IF    @R2+3.X'04',BEGIN   This abend is okay to ignore
         SET   TVTDCBAB            Set abend occurred
         MVC   TVTIOAB,@R2         Set abend code for recovery
         MVI   @R2+3,04            Indicate ignore abend
         END   ,
         FREEMAIN R,LV=256,A=(SPR) Release secondary save stack
         LR    R14,R7              Restore return reg  ml19991030
         BR    R14                 Return to caller
         DROP  R10                 Release exit routine addr
         TITLE 'Input DCB OPEN Exit'
*box
*
*  BSAM/BPAM DCB OPEN exit for input
*
*        Define the DCB OPEN exit for BSAM/BPAM input.  The exit
*        operates in 24-bit addressing mode.  When the
*        exit is taken the register contents are as follows:
*
*              R0  - No applicable data
*              R1  - Address of DCB
*          R2-R13  - Contents before OPEN macro issued
*              R7  ->RBINFO
*
*             R14  - Return address, (must not be altered)
*             R15  - Address of exit routine entry point
*
*  created 1995/08/10 mcl from OUTPUT exit routine
*
*  General Notes:  For most normal opens of disk input files,
*  one doesn't need an open exit.  This was added specifically
*  to support override of RECFM/LRECL by user, e.g. when salvaging
*  members from a library of mixed formats.  In such a case we may
*  need to override BLKSIZE.
*
         SPACE 2
OSFWIP   LABEL ,                   Entry point to DCB OPEN exit
         LR    R10,R15             Move exit base register
         USING OSFWIP,R10          Addressability to exit
         USING RBINFO,R7           addressability to RBINFO
         LR    R6,R1               Save pointer to DCB
         USING IHADCB,R6           addressability to DCB
         L2    R1,DCBBLKSI         BLKSIZE so far
         IF    (R1,NP),BEGIN       if somehow no blksize
         L     R1,=F'32760'        so use max, always works
         END   ,                      (no blksize)
         LH    R2,DCBLRECL         LRECL
*
*  In following IF tests, note that DCBRECU=DCBRECF+DCBRECV, so the
*  test for U must come first
*
         TM    DCBRECFM,DCBRECU    RECFM = U
         IF    ONES,BEGIN          U is both bits on
         CR    R1,R2               BLKSI:LRECL
         IF    L,'LR R1,R2'        if low, use LRECL
         STH   R1,DCBLRECL         set LRECL same as BLKSIZE
         END   ,                      (U)

         ELSEIF (DCBRECFM.DCBRECF),BEGIN     RECFM=F[B]
*  RECFM=F[B], check LRECL/BLKSIZE relationship
         CLEAR R0
         LR    R3,R1               Save BLKSIZE
         DR    R0,R2               BLKSIZE/LRECL
         IF    (R0,NZ),BEGIN       we had a remainder
         LA    R1,1(R1)            so bump recs-per-block
         END   ,                      (had remainder)
         MR    R0,R2               *LRECL to get rounded-UP value
         END   ,                        (FB BLKSIZE:LRECL)

         ELSEIF (DCBRECFM.DCBRECV),BEGIN     RECFM=V[B]
*  RECFM=V[B], check LRECL/BLKSIZE relationship
         LA    R2,4(R2)            LRECL+L'BDW
         CR    R1,R2               BLKSIZE:min. blksi
         IF    L,'LR R1,R2'        if too low, use min.
         END   ,                      (VB)


         STH   R1,DCBBLKSI         Save adjusted BLKSIZE
         ST    R1,TVTPBBLKSIZE      ...
         ST    R1,RBBLKSI           ...
         BR    R14                 Return to caller
         DROP  R6
         DROP  R7
         DROP  R10                 Release exit routine addr
         TITLE 'Output DCB OPEN Exit'
*box
*
*  BSAM/BPAM DCB OPEN exit for output
*
*        Define the DCB OPEN exit for BSAM/BPAM output.  The exit
*        operates in 24-bit addressing mode.  When the
*        exit is taken the register contents are as follows:
*
*              R0  - No applicable data
*              R1  - Address of DCB
*          R2-R13  - Contents before OPEN macro issued
*  we have set R7->RBINFO
*
*             R14  - Return address, (must not be altered)
*             R15  - Address of exit routine entry point
*
*  revised 1996/07/03 mcl:  pick new blksize on sequential save repl
*  revised 1995/03/24 mcl:  look at DCBRECFM, not TVTPBFRECx (fixed
*                           problem with open for directory update)
*  created 1995/01/19 mcl.  previously we set BLISIZE before open
*
         SPACE 2
OSFWOP   LABEL ,                   Entry point to DCB OPEN exit
         LR    R10,R15             Move exit base register
         USING OSFWOP,R10          Addressability to exit
         USING RBINFO,R7           addressability to RBINFO
         LR    R6,R1               Save pointer to DCB
         USING IHADCB,R6           addressability to DCB
         L     R5,RBOPTBLK         "optimum" block size
         IF    (R5,NP),BEGIN       if not set
         L     R5,=F'6356'         so punt
         ST    R5,RBOPTBLK
         END   ,                     (optblk not set)
         L2    R1,DCBBLKSI         BLKSIZE if set
         IF    (R1,NP),'LR R1,R5'  if not, use ours
         LH    R2,DCBLRECL         LRECL
*
*  In following IF tests, note that DCBRECU=DCBRECF+DCBRECV, so the
*  test for U must come first
*
         TM    DCBRECFM,DCBRECU    RECFM = U
         IF    ONES,BEGIN          U is both bits on
* force reblocking for edit/sequential replace
         IF    (TVTPBFREQREPLACE,AND,~TVTPBFREQAPPEND,AND,DCBDSORG.DCBD*
               SGPS),BEGIN         seq, replace, not append:
         LR    R1,R5               BLKSIZE=OPTBLK
         LR    R2,R1               LRECL=BLKSIZE
         STH   R2,DCBLRECL         save LRECL
         END   ,                      (seq/rep/not app)
         ELSE  BEGIN               not forcing reblock
         CR    R1,R2               BLKSI:LRECL
         IF    L,'LR R1,R2'        if low, use LRECL
         STH   R1,DCBLRECL         set LRECL same as BLKSIZE
         END   ,                      (not forcing reblock)
         END   ,                      (U)

         ELSEIF (DCBRECFM.DCBRECF),BEGIN     RECFM=F[B]
*  RECFM=F[B], check LRECL/BLKSIZE relationship
         CLEAR R0
         DR    R0,R2               BLKSIZE/LRECL
         MR    R0,R2               *LRECL again is rounded value
         IF    (R1,Z),'LR R1,R2'   rounding zeroed it, use LRECL
         END   ,                        (FB BLKSIZE:LRECL)

         ELSEIF (DCBRECFM.DCBRECV),BEGIN     RECFM=V[B]
*  RECFM=V[B], check LRECL/BLKSIZE relationship
         LA    R2,4(R2)            LRECL+L'BDW
         CR    R1,R2               BLKSIZE:min. blksi
         IF    L,'LR R1,R2'        if too low, use min.
         END   ,                      (VB)


         STH   R1,DCBBLKSI         Save adjusted BLKSIZE
         ST    R1,TVTPBBLKSIZE      ...
         ST    R1,RBBLKSI           ...
         BR    R14                 Return to caller
         DROP  R6
         DROP  R7
         DROP  R10                 Release exit routine addr
         TITLE 'Line press routine'
*box
*
*  PRESS
*
*  PRESS LINE INTO EDIT FORMAT.
*
*  ON ENTRY:
*    R1,R0 - text loc, len
*    R2 - pressed line area (at least &pressz long)
*    R15 - line-number
*
*    On exit:
*    R1,R0 - location, length of pressed line (includes lno)
*
*  note:
*  R1 will be same as R2 at exit.
*  This routine can press text inplace (ie. on entry r1=r2 is ok).
*  This routine adapted from WYLBUR press routine.
*
*
         SPACE 2
PRSWA    RECORD BEGIN
PRSTXT   DS    A                   Input text
PRSTXTLN DS    F                   Input text length
PRSPTR   DS    A                   Output buffer
PRSLINE  DS    XL(&PRESSZ)         Room for a pressed line
         END
*
*
PRESS    PROC  PRSWA,TRACE=NO
         ST    R0,PRSTXTLN
         ST    R1,PRSTXT
         ST    R2,PRSPTR
         ST    R15,PRSLINE         Put line-no into pressed
         CEIL  R0,&LINESZ          Not too big
*
         CLEAR R6                  Start output count
         LA    R13,PRSLINE+4       Yuk
         LTR   R5,R0               Set and test input count
         BNP   ALLBL               Blank line
         LA    R3,@R1              Set input pointer (zero 1st byte)
         CLEAR R1                  Make sure high order byte is zero
         LA    R0,15               Set constant 15 into reg
         LA    R2,1                Set const 1 into reg (will remain)
         DECR  R5                  Set to ex trt inst
*
OVER     EX    R5,'TRT @R3(1),BLTRT'  Find a non-blank
         BZ    ALLBL               None
         SR    R1,R3               Length blank string to r1
         LR    R4,R1               And to r4
         AR    R3,R1               Move pointer
         SR    R5,R1               Decrease counter
         EX    R5,'TRT @R3(1),NBTRT'  Find next blank
         BNZ   EVALA               None
         LA    R1,1(R3,R5)         Pretend its after interesting strng
EVALA    CR    R4,R0               Blank string over 15?
         BH    EVALB               Yes
         SLL   R4,4                Move blank str len to left half-byt
         SR    R1,R3               Length non-blank string to r1
         LA    R6,1(R6,R1)         Add non-bl ct & ct-byte to counter
         SR    R5,R1               Decrease counter
EVALC    CR    R1,R0               Over 15 non-blanks?
         BH    EVALD               Yes
         OR    R4,R1               Combine blank & non-blank counts
         STC   R4,@R13+1           Store count-byte
         DEX   R1,'MVC @R13+2(1),@R3'  move non-blanks
         LA    R13,@R1+2(R13)      Move output pointer
         LA    R3,1(R3,R1)         Reset pointer (in)
         LTR   R5,R5               Any more?
         BP    OVER                Yes
         B     ALLBL
*
EVALB    MVI   @R13+1,X'F0'        Set a blank-only count byte
         AR    R6,R2               Kick counter
         AR    R13,R2              Kick pointer
         SR    R4,R0               Reduce blank count by 15
         B     EVALA               Another round
EVALD    OR    R4,R0               Combine bl & non-bl counts
         STC   R4,@R13+1           Insert non-bl count byte
         SR    R1,R0               Reduce remaining non-bl count by 15
         SR    R4,R4               Zero remaining bl count
         MVC   @R13+2(15),@R3      Move a non-blank string
         AR    R3,R0               Move pointer
         AR    R6,R2               Count control char
         LA    R13,@R13+16         Increase count by 16
         B     EVALC               More?
*
ALLBL    STC   R6,PRSLINE+4        Store total pressed count
         L     R1,PRSPTR           Return addr for pressed line
         LA    R5,@R6+5-1          Mvc count
         EX    R5,'MVC @R1(1),PRSLINE'  move pressed (without line-no)
         LTR   R0,R6               Set pressed count return
         A     R0,=A(5)            R0 - total length
         PRETURN (R0,R1)
         PEND  ,
*
BLTRT    DC    256X'01'            Skip blank trt table
         ORG   BLTRT+C' '
         DC    X'00'
         ORG
*
NBTRT    DC    256X'00'            Skip non-blank trt table
         ORG   NBTRT+C' '
         DC    X'01'
         ORG
*
         QLTORG
         TITLE 'UNPRESS a line of EDIT Format Data'
*box
*
*
*  UNPRESS -- Unpresses a line in WYlbur edit format.
*
*    On entry:
*      R15- pressed line ptr (before lineno)
*      R1 - unpress area (at least &linesz bytes)
*
*    On exit:
*      R1,R0 - unpress loc, len
*              (R0 neg if invalid press format)
*      R15   - WYLBUR line-number
*
*    NOTE:
*    LINE MAY NOT BE UNPRESSED IN PLace.
*
*
*
         SPACE 2
UPWA     RECORD BEGIN
UPOUTLOC DS    F
UPINLOC  DS    F
UPINLEN  DS    F
UPLINENO DS    F
         END
*
*
UNPRESS  PROC  UPWA,TRACE=NO
         CLEAR UPWA
         ST    R1,UPOUTLOC
         ST    R15,UPINLOC
         LC    R2,@R15+5
         ST    R2,UPINLEN
         MVC   UPLINENO,@R15
*
*                                  CLEAR RETURN AREA
         MVI   @R1,C' '            Blank return area
         MVC   @R1+1(&LINESZ-1),@R1
*
*                                  SET UP LOOP INDEXES
*                                  R1,R0 - output loc, end of buf
         LR    R0,R1
         A     R0,=A(&LINESZ)
         LA    R2,@R15+5           R2,R3 - input loc, end of buf
         LC    R3,@R15+4
         LA    R3,5(R15,R3)
         CLEAR R4                  R4 - blank/char count ndx
         LA    R5,X'0F'            R5 - mask
*
         WHILE (R2,LT,R3),BEGIN
         IC    R4,@R2              DO BLANKS
         SRL   R4,4
         NR    R4,R5
         LA    R6,0(R1,R4)
         IF    (R6,GT,R0),BADEDIT
         LA    R1,0(R1,R4)
         IC    R4,@R2              DO CHARS
         NR    R4,R5
         LA    R6,0(R1,R4)
         IF    (R6,GT,R0),BADEDIT
         IF    (R4,NZ),BEGIN
         DEX   R4,' MVC @R1(1),@R2+1 '
         LA    R1,1(R1,R4)
         LA    R2,1(R2,R4)
         END
         INCR  R2
         END
         IF    (R2,NE,R3),BADEDIT
*
         LR    R0,R1
         L     R1,UPOUTLOC
         SR    R0,R1
         B     UNPRDONE
*
BADEDIT  LABEL ,
         L     R0,=A(-1)
*
UNPRDONE LABEL ,
         L     R15,UPLINENO
         PRETURN (R0)
         PEND  ,
         TITLE 'Conversion support routines'
*box
*
*  BTDZEROS - BTD with LEADING ZEROS
*
*  on entry:
*    r1,r0 - loc, len of result
*    r15 - value
*
*  note:
*  r0 must be > 0
*  r15 must be >= 0
*
*
         SPACE 2
BZWA     RECORD BEGIN
DW       DS    D
DEC      DS    D
HEXS     DS    XL16
BZFUDGE  DS    XL256               Not needed ?
         END
*
*
BTDZEROS PROC  BZWA,TRACE=NO
         LA    R6,DW               Get a double word
         N     R6,=XL4'FFFFF8'
         CVD   R15,DEC             Convert number to packed
         MVC   HEXS(16),EDZ15      Edit mask
         LR    R4,R1               Save result loc.
         LA    R1,HEXS+15
         EDMK  HEXS(16),DEC
         LA    R3,HEXS+16          Compute actual length
         SR    R3,R1
         LR    R1,R4               Restore result pointer
         LR    R3,R0               Field length
         LA    R2,HEXS+16          Compute starting addr
         SR    R2,R3
         DEX   R3,' MVC @R1(1),@R2 '  Move to result loc.
         PRETURN (R0,R1)
         PEND  ,
*
EDZ15    DC    C' ',X'21',14X'20'
         TITLE 'GTINTVAL - Get Integer Value'
*box
*
*  GTINTVAL - GET INTEGER VALUE
*
*  ON ENTRY: R1,R0 - INTEGER LOCATIOn length
*
*  ON EXIT:
*    R15=VALUE  (>=0)
*    R15=NEGATIVE, STRING IS NOT INTeger
*
*
*   NOTE:
*      INTEGER MUST BE ALL DIGITS (No blanks).
*      MAY BE 9 DIGITS MAX.
*
*   CAUTION:
*      VALUE RETURNED IS ACTUAL INTEger value, not numberx1000.
*
         SPACE 2
GTINTVAL PROC  TRACE=NO
         IF    ((R0,Z),OR,(R0,GT,9)),BEGIN
         L     R15,=F'-4'
         EXIT  GTINTVAL            Error abort
         END
*
*                                  R1,r0 - integer string loc, len
         LR    R2,R0               R2 - digit index
         AR    R2,R1
         DECR  R2
         LA    R3,X'0F'            R3 - mask
         CLEAR R5                  R5 - digit value
         LA    R6,1                R6 - multiplier
         CLEAR R15                 R15 - total
*
*                                  Loop thru integer, r. to left.
         WHILE (R2,GE,R1),BEGIN
         IF    ((@R2,LT,'0'),OR,(@R2,GT,'9')),BEGIN IF NOT DIGIT,,
         L     R15,=F'-4'
         EXIT  GTINTVAL            Error abort
         END
         CLEAR R4
         CLEAR R5
         IC    R5,@R2              Get digit
         NR    R5,R3
         MR    R4,R6               Digit*multiplier
         AR    R15,R5              Accumulate total
         MH    R6,=H'10'
         DECR  R2
         END
         PEND  ,
         SPACE 2
         LTORG ,
         TITLE 'OSFILE - Disk I/O support: ESTAE exit'
*box
*
*   ESTAE exit
*
*        The purpose for this ESTAE exit is to release all acquired
*        resources before to completing abterm processing.
*
*        All abend are condsidered non-recoverable from this exit.
*

OSFESTAE LABEL ,
         USING OSFESTAE,R15        Declare esate routine base
         QSNAP 'OSFESTAE'
         QSNAP (R0,R1,R13,R14,R15)
         IF    (R0,EQ,12),BEGIN    Insufficient memory to get sdwa
         CLEAR R15                 Indicate continue abending
         BR    R14                 Return to RTM2
         END   ,
         SPACE 2
*-
*-       Setup register values
*-
         STM   R14,R12,@R13+12     Save initial registers
         L     BRR,OSFESTC         Load initial base
         DROP  R15                 Release initial basing
         BASE  ,                   Declare estae addressability
         LR    R2,R1               Set sdwa address
         USING SDWA,R2             Declare sdwa addressability
         QSNAP SDWA,240
         L     R3,SDWAXPAD
         WITH  (SDWAPTRS,R3),'L R3,SDWASRVP'
         WITH  (SDWARC1,R3),BEGIN
*  2002/06/26 mcl:  get the reason code
         IF    (SDWACMPF.SDWARCF,AND,(R3,NZ)),BEGIN got a code
         QSNAP SDWACRC,8           reason code
         END   ,                      (got a code)
         END   ,                      (with SDWARC1)
         L     TVTR,SDWAPARM       Load address of tvt from estae
         L     GVTR,TVTGVTP        Load address of gvt from tvt
         L     WAR,TVTESTAK        Set estae stack address
         ST    R13,@WAR            Save vs save area address
         LA    WAR,@WAR+4          Push stack pointer
         LR    SPR,WAR             Reset to our stack
*-
*-       Log entry to ESTAE routine
*-
         SET   TVTFABND            Set abending if not already
         IF    TVTREPT,BEGIN       Report error if reporting active
         LA    R15,OSFSCB          Address of log SCB
         ACALL LOGTIME             Add time to message
         SEGWR 'Cleaning up control blocks...',,OSFSCB
         END   ,
* 2002/06/18 mcl see if we're in supv state -- shouldn't be
         TESTAUTH STATE=YES        RC=0 is bad news here
         IF    (R15,Z),BEGIN       in supervisor state
         QSNAP 'ESTAE entered in supervisor state'
         MODESET MODE=PROB         get out
         END   ,                   (supervisor state)
         ACALL OSFTERM             Cleanup control blocks
         DROP  R2                  Release ESTAE CB addressability
         S     SPR,=A(4)           Retrieve ESTAE save area address
         L     R13,@R13            Restore ESTAE save area address
         CLEAR WAR                 Insure save stack no longed used
*-
*-       Release ESTAE save stack
*-
         LT    R1,TVTESTAK         Get save stack origin
         IF    NZ,BEGIN            Test for stack existence
         L     R0,=A(ESTAESZ)      Load save stack size
         FREEMAIN R,A=(1),LV=(0)   Release save stack
         END   ,
*-
*-       Release save stack
*-
         L     R1,TVTSTPTR         Get save stack origin
         L     R0,=A(STACKSZ)      Load save stack size
         FREEMAIN R,A=(1),LV=(0)   Release save stack
*-
*-       Return to RTM set for percolate abend
*-
**       QSNAP @R13,72
**       QSNAP (R0,R1,R13,R14,R15)
         SETRP WKAREA=(R2),REGS=(14,12),RC=0
OSFESTC  DC    A(OSFCOMMN)         Address of common routines
         DROP  ,                   Release all addressability
         LTORG ,
         TITLE 'OSFILE - Error table definitions'
*box
*
*  Define error table for DASDM allocate functions
*

DADSMTAB ETAB  X'00','Successful completion'
         ETAB  X'04','Duplicate data set name'
         ETAB  X'08','No room in VTOC or VTOC index'
         ETAB  X'0C','Permanent I/O error or CVAF error'
         ETAB  X'10','Requested absolute track not available'
         ETAB  X'14','Requested quantity not available'
         ETAB  X'18','Average record length exceeds 65,535 bytes'
         ETAB  X'1C','Invalid DSORG for ISAM index request'
         ETAB  X'20','No prime area requested for ISAM'
         ETAB  X'24','ISAM overflow area requested before prime'
         ETAB  X'28','ISAM space request does not start on cylinder'
         ETAB  X'2C','Duplicate ISAM data set element'
         ETAB  X'30','Invalid DADSM realloc parameter list'
         ETAB  X'34','Invalid JFCB or parital DSCB pointer'
         ETAB  X'38','Not enough space on volume for directory'
         ETAB  X'3C','Realloc alloc=abs is not supported on OS VTOC'
         ETAB  X'40','Invalid user label request'
         ETAB  X'44','Invalid UCB pointer'
         ETAB  X'48','DOS VTOC cannot be converted to an OS VTOC'
         ETAB  X'4C','No space parameter for new data set'
         ETAB  -1
         SPACE 2
*box
*
*  SVC99 - Dynamic allocation, return code 4, environmental error
*

S99ERR42 ETAB  X'0204','Real storage unavailable'
         ETAB  X'0208','Reserved'
         ETAB  X'020C','Requst for exclusive use failed'
         ETAB  X'0210','Requsted data set unavailable'
         ETAB  X'0214','Unit(s) not available'
         ETAB  X'0218','Specified volume is not mounted'
         ETAB  X'021C','Unit name specified is undefined'
         ETAB  X'0220','Requested volume not available'
         ETAB  X'0224','Eligible device types: not enough units'
         ETAB  X'0228','Specified volume or unit in use by system'
         ETAB  X'022C','Volume mounted on ineligible unit'
         ETAB  X'0230','Perm res or rsvd volume on required unit'
         ETAB  X'0234','More than one device required'
         ETAB  X'0238','Space unavailable in TIOT'
         ETAB  X'023C','Required catalog not mounted'
         ETAB  X'0240','Requested device is a console'
         ETAB  X'0244','Telecommunication device not accessible'
         ETAB  X'0248','MSS virtual volume unable to be mounted'
         ETAB  X'024C','OS managed resource was unavailable'
         ETAB  X'0250','Subsystem resource not available'
         ETAB  X'0254','TIOT resource unavailable'
         ETAB  X'0258','Not enough non-restricted units'
         ETAB  X'025C','Requested device is boxed'
         ETAB  X'9700','SMS error:  IDAX error'
         ETAB  X'9704','SMS error:  catalog error'
         ETAB  X'9708','SMS error:  volref error'
         ETAB  X'970C','SMS error:  VTOC error'
         ETAB  X'9710','SMS error:  DISP error'
         ETAB  X'9714','SMS error:  COPY SWB error'
         ETAB  -1
         EJECT ,
*BOX
*
*  DEFINE ERROR TABLES FOR LSPACE SVC
*

LSPACTB  ETAB  X'00','Successful completion'
         ETAB  X'04','Permanent I/O error'
         ETAB  X'08','Non-standard OS volume'
         ETAB  X'0C','Invalid parameter or UCB not ready'
         ETAB  X'10','Invalid parameter list'
         ETAB  -1
         TITLE 'Direct Access Device Table'
         COPY  DEVTABLE
         TITLE 'OSFILE - Prototype control blocks'
*box
*
*   DEFINE PROTOTYPE CONTROL BLOCKS
*
         SPACE 2
*GEN
         ECBLIST TYPE=MODEL        Generate adcons for ecb routs

CAMCATMD CAMLST NAME,*-*,,*-*

CAMCATCT CAMLST CATBX,*-*,,*-*,DSCBTTR=*-*

CAMCATDL CAMLST UCATDX,*-*

CAMOBT   CAMLST SEARCH,*-*,*-*,*-*

CAMOBSK  CAMLST SEEK,*-*,*-*,*-*

CAMSCR   CAMLST SCRATCH,*-*,,*-*

CAMREN   CAMLST RENAME,*-*,*-*,*-*

ENQMOD#  ENQ   (*-*,*-*,E,*-*,SYSTEMS),RET=USE,MF=L
ENQMODL  EQU   ENQMOD#,*-ENQMOD#,C'C'

DEQMOD#  DEQ   (*-*,*-*,*-*,SYSTEMS),RET=NONE,MF=L
DEQMODL  EQU   DEQMOD#,*-DEQMOD#,C'C'

RACCMOD# RACROUTE REQUEST=AUTH, KAREA=*-*,                             X
               RELEASE=1.9,MF=L
RACCMODL EQU   RACCMOD#,*-RACCMOD#,C'C'
         SPACE 2
RACIMOD# RACROUTE REQUEST=VERIFY,LOC=ANY, KAREA=*-*,                   X
               RELEASE=1.9,MF=L
RACIMODL EQU   RACIMOD#,*-RACIMOD#,C'C'
         SPACE 2
RACDMOD# RACROUTE REQUEST=DEFINE,RELEASE=1.9,TYPE=DELETE,DSTYPE=N,     *
               WORKA=*-*,ENTITY=*-*,GENERIC=YES,MF=L
RACDMODL EQU   RACDMOD#,*-RACDMOD#,C'C'
         SPACE 2
STIMERM  STIMERM SET,MF=L
STIMERL  EQU   STIMERM,*-STIMERM,C'C'

MODSETZM MODESET KEY=ZERO,MF=L
MODSETPM MODESET KEY=NZERO,MF=L
*NOGEN
         SPACE 2
DCBPS    DCB   DDNAME=DUMMY,MACRF=PM,RECFM=VB,DSORG=PS
DCBPSLEN EQU   *-DCBPS             DEFINE QSAM PROTOTYPE LENGTH
         SPACE 2
DCBBSAM  DCB   DDNAME=DUMMY,MACRF=(RP,WP),DSORG=PS
DCBBSAML EQU   *-DCBBSAM           DEFINE BSAM PROTOTYPE LENGTH
         SPACE 2
DCBBPAM  DCB   DDNAME=DUMMY,MACRF=(R,W),DSORG=PO
DCBBPAML EQU   *-DCBBPAM           DEFINE BPAM PROTOTYPE LENGTH

DCBQSAM  DCB   DDNAME=DUMMY,MACRF=GL,DSORG=PS,KEYLEN=0,RECFM=F,        *
               LRECL=256,BLKSIZE=256,OPTCD=CZ,BUFNO=10
DCBQSAML EQU   *-DCBQSAM           DEFINE QSAM PROTOTYPE LENGTH

*GEN
PROTESP# ESPIE SET,*-*,MF=L
PROTESP  EQU   PROTESP#,*-PROTESP#,C'C'

LSPLST   LSPACE MF=L
LSPLSTL  EQU   *-LSPLST
*NOGEN

ACBPS    ACB   DDNAME=DUMMY        DEFINE VSAM ACCESS CONTROL BLOCK
ACBPSLEN EQU   *-ACBPS             LENGTH OF VSAM ACCESS CONTROL BLK
         TITLE 'Final literals and symbol table definitions'
*box
*
*  Define last literal pool and module csect length
*
*    If you've made it this far, congratulations!
*
         SPACE 2
         LTORG ,                   Define final literal pool
         SPACE 2
         DC    0D'0'               Force out to double-word
OSFSYM   DC    CL8'OSFILE',A(OSFILE),A(OSFILEX-OSFILE)
OSFILEX  EQU   *                   Define last address of OSFILE
         END   .
