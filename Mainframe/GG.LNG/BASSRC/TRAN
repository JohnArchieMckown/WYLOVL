TRAN     TITLE 'TRANSLATOR ROUTINE'
TRANS    CSECT
***********************************************************************
*
*   THIS ROUTINE IS CALLED BY THE CONTROLLER WITH REGISTER 1 POINTING
*   AT A LINE OF INTERNALLY CODED SOURCE (GENERATED BY THE INLINE
*   ROUTINE).  THE FORMAT OF THIS LINE IS:
*
*             1ST HALFWORD - STATEMENT NUMBER
*             2ND HALFWORD - STATEMENT TYPE CODE
*                 .
*                 .      INTERNAL CODE FOR STATEMENT
*                 .
*             LAST HALFWORD - END CODE (X'0D05')
*
*   ON ENTRY TO THIS ROUTINE REGISTER 11 POINTS AT THE USER AREA.
*
*   TRANS DOES THE TRANSLATION OF EACH STATEMENT.  IT MAKES ENTRIES
*   IN THE LINES TABLE FOR ALL STATEMENTS.  IT MAKES ENTRIES IN THE
*   PSEUDO TABLE FOR ALL EXECUTABLE STATEMENTS.  IT MAKES ENTRIES
*   IN THE FORC TABLE FOR 'FOR' AND 'NEXT' STATEMENTS.  IT PLACES
*   VALUES IN DATA STATEMENTS INTO THE DATA TABLE.
*   FOR DIM STATEMENTS, IT PLACES DIMENSIONING INFORMATION IN THE ATOZ
*   AND ATOZSTRG  TABLES.
*   FOR DEFFN STATEMENTS IT PLACES VALUES IN THE ATOZFCT TABLE.
*
*
*   RETURN TO THE CONTROL PROGRAM IS CONTROLLED BY THE CONTENTS OF
*   REG 14 AND THE TYPE OF STATEMENT BEING PROCESSED.
*       1. BRANCH TO ADDRESS IN REG 14   - NORMAL RETURN
*       2. BRANCH TO 4 PAST REG 14       - A DEFINE FILE STATEMENT HAS
*                                          BEEN ENTERED
*       3. BRANCH TO 8 PAST REG 14       - A DEFINE FILE STATEMENT HAS
*                                          BEEN REPLACED
*       4. BRANCH TO 12 PAST REG 14      - A DEFINE FILE STATEMENT HAS
*                                          BEEN DELETED
*
*   ON A NORMAL (ALL IS WELL) RETURN TO THE CONTROL PROGRAM FROM
*   TRANS, REGISTER 0 CONTAINS 0.  IF ANY OF THE ABOVE MENTIONED
*   TABLES HAS OVERFLOWED, REGISTER 0 IS SET TO INDICATE THIS.
*
*         REGISTER 0         ERROR CONDITION
*         __________         _______________
*             1              PSEUDO TABLE OVERFLOW
*             2              LINES TABLE OVERFLOW
*             3              DATA TABLE OVERFLOW
*             4              FORC TABLE OVERFLOW
*
*   FOR THESE OVERFLOW CONDITIONS TRANS CALLS RUNERR FOR PRINTING OF
*   AN ERROR MESSAGE, BEFORE RETURNING TO THE CONTROL PROGRAM.
*   FURTHER TRANSLATION OR EXECUTION OF THIS USERS PROGRAM IS SUSPENDED
*   UNTIL THE OVERFLOW CONDITION HAS BEEN RESOLVED.
*
*   THERE ARE TWO NON-FATAL TRANSLATION TIME ERRORS.
*           1. AN ATTEMPT HAS BEEN MADE TO REDIMENSION A VARIABLE
*              ALREADY DIMENSIONED.
*           2. AN ATTEMPT HAS BEEN MADE TO REDEFINE A FUNCTION THAT
*              HAS ALREADY BEEN DEFINED.
*
*   FOR THESE ERRORS, RUNERR IS CALLED TO PRINT A MESSAGE
*   TELLING THE USER THAT THE ERROR OCCURRED AND THAT THE STATEMENT
*   HAS BEEN IGNORED.  CONTINUED TRANSLATION AND EXECUTION IS
*   PERMITTED AFTER THESE TYPES OF ERRORS.
*
*   THE CONTROL PROGRAM SUSPENDS PROCESSING OF A USER WHEN A DEF OR
*   A DIM IS ENTERED SO THAT ERROR MESSAGES FOR THESE STATEMENTS
*   (IF ANY) WILL BE PRINTED IMMEDIATELY FOLLOWING THE STATEMENT.
*
*
*             ----------------------------------
*   THE FORMAT OF EACH OF THE TABLES GENERATED BY TRANS IS SHOWN BELOW.
*
*       PSEUDO TABLE - EACH ENTRY IS 3 HALFWORDS LONG
*               1ST HALFWORD - OPERATION CODE
*               2ND HALFWORD - OPERAND 1 (IF NEEDED)
*               3RD HALFWORD - OPERAND 2 (IF NEEDED)
*
*       LINES TABLE - EACH ENTRY IS 2 HALFWORDS LONG
*               1ST HALFWORD - STATEMENT NUMBER
*               2ND HALFWORD - PSEUDO TABLE POINTER
*                              OR STATEMENT DESCRIPTOR
*
*       FORC TABLE - EACH ENTRY IS 2 HALFWORDS LONG
*               1ST HALFWORD - STATEMENT NUMBER
*               2ND HALFWORD - FOR OR NEXT INDEX
*
*        DATA TABLE - EACH ENTRY IS (N+2)*4 BYTES LONG
*                     WHERE N IS THE NUMBER OF ITEMS IN THE CORRES-
*                     PONDING DATA STATEMENT.
*          1ST HALFWORD - STATEMENT NUMBER
*          2ND HALFWORD - NUMBER OF BYTES IN THIS ENTRY IN THE
*                         DATA TABLE (N+2)*4
*          2ND FULL WORD - FIRST DATA ITEM
*          .
*          .
*          (N+1)TH FULL WORD - LAST DATA ITEM
*          LAST FULL WORD - X'80000000'
*
*             -----------------------------------
*   FOR EACH EXECUTABLE STATEMENT, THE SECOND HALFWORD OF EACH LINES
*   TABLE ENTRY CONTAINS A POINTER TO THE ASSOCIATED PSEUDO CODE.
*
*   FOR NON-EXECUTABLE STATEMENTS THE SECOND HALFWORD IS A STATEMENT
*   DESCRIPTOR.
*               0001  DIM
*               0003  DATA
*               0005  REM
*               0007  DEF
*               0009  STATEMENT WITH A SYNTAX ERROR
*               000B  DEFINE FILE STATEMENT
*
*          during execution phase, these lines will be skipped over.
*          the exception is the syntax error statement which will
*          give the user a message and continue processing.
*
*   ENTRIES ARE MADE IN THE LINES TABLE FOR NON-EXECUTABLE STATEMENTS
*   SO THAT INFORMATION ABOUT THEM IS READILY AVAILABLE FOR LATER
*   DELETION OR MODIFICATION OF THAT STATEMENT.
*
*
***********************************************************************
*
*
         SAVE  (14,12),,*          SAVE REGISTERS
         BALR  BASE,0              ESTABLISH ADDRESSABILITY
         USING *,BASE
         USING AREA,USER
         ST    SAVER,76(SAVER)     POINT AT OUR SAVE AREA
         LA    ST,72(SAVER)
         ST    ST,8(SAVER)
         LR    SAVER,ST
*
*   THROUGHOUT THE EXECUTION OF TRANS REGISTER STMT POINTS AT THE
*   LINE OF INTERNALLY CODED SOURCE BEING TRANSLATED.
*
         LR    STMT,R1
*
*   R0 CONTAINS THE STATEMENT NUMBER THROUGHOUT THE EXECUTION OF
*   TRANS.  BINARY SEARCH EXPECTS THE STATEMENT NUMBER IN RO BUT
*   DOES NOT ALTER IT SO THE NUMBER IS STILL THERE AFTER THE RETURN.
*   RUNERR ALSO EXPECTS THE STATEMENT NUMBER IN R0.
*
         LH    R0,0(STMT)          PUT THE ST # IN R0.
*
*
*   THROUGHOUT EXECUTION OF TRANS REGISTER R7 CONTAINS THE RETURN
*   ADDRESS.  IT IS BUMPED DURING TRANS EXECUTION IF ONE OF THE
*   NON-STANDARD RETURNS IS TO BE TAKEN.  REG 14 IS RESTORED FROM
*   R7 BEFORE THE RETURN TO THE CONTROL PROGRAM.
*
         LR    R7,RETURN
*
         CLI   3(STMT),SYMDEL      IS THIS A DELETE STATEMENT?
         BE    DELR                YES-THEN DON'T TOUCH THE LINES TABLE
         CLI   3(STMT),SYMDEF      IS THIS A DEFINE FILE STATEMENT?
         BNE   STORLN              NO
         LA    R7,4(R7)            YES BUMP RETURN REGISTER
*
         B     STORLN              GO TO MAKE ENTRY FOR THIS STMT IN
*                                  TABLE LINES
*
SETEXPB  L     EXPREG,EXPBASE      SET UP BASE TO EXPR
TRANS1   SR    ST,ST
         IC    ST,3(STMT)          PICK UP STATEMENT TYPE CODE
         SLL   ST,2                PLACE STMT TYPE CODE TIMES 4 IN LOW
*                                  ORDER BITS OF REGISTER TO USE AS
*                                  INDEX IN TRANSFER TABLE.
         EX    0,TYPES(ST)         BRANCH TO APPROPRIATE STATEMENT
*                                  PROCESSING ROUTINE
*
*
*    TRANSFER TABLE
*                                  CODE   STATEMENT TO BE PROCESSED
TYPES    B     LETR                 0        ARITHMETIC EXPR HANDLER
         B     IFR                  1        IF
         B     FORR                 2        FOR
         B     GOSUBR               3        GOSUB
         B     RETURNR              4        RETURN
         B     DIMR                 5        DIMENSION STATEMENT
         B     ENDR                 6        END
         B     STOPR                7        STOP
         B     RESTORER             8        RESTORE
         B     READR                9        READ
         B     WRITER               10       WRITE
         B     PRINTR               11       PRINT
         B     INPUTR               12       INPUT
         B     MATR                 13       MAT
         B     DEFR                 14       DEF
         B     NEXTR                15       NEXT
         B     GOTOR                16       GO TO
         B     DUMPR                17       DUMP
         B     PAUSER               18       PAUSE
         B     REMR                 19       REM
         B     DELR                 20       DELETE A LINE
         B     DATAR                21       DATA
         B     SYNTAXER             22       SYNTAX ERROR
         B     CGOTOR               23       COMPUTED GO TO
         B     CLEARR               24       CLEAR DATA
         B     DEFFR                25       DEFINE FILE
         B     PRNTUR               26       PRINT USING
         B     IMAGER               27       IMAGE
*
*********************************************************************
         EJECT
********************************************************************
*
*         RETURN TO CONTROL PROGRAM
*
*   EACH STATEMENT PROCESSOR RETURNS CONTROL HERE AFTER IT IS
*   FINISHED.  ANY CLEAN UP NECESSARY IS DONE HERE AND CONTROL
*   IS RETURNED TO THE CONTROL PROGRAM.
*
RET      L     CUR,ACODEBEG        TURN ON HIGH ORDER BIT OF 1ST WORD
         LA    CUR,0(CUR,USER)     OF LAST ENTRY IN PSEUDO TABLE
         AL    CUR,ACODEPTR        INDICATING THAT THIS ENTRY IS THE
         S     CUR,SIX             LAST ONE FOR THIS STATEMENT.
         OI    0(CUR),X'80'
RET1     SR    R0,R0               SET R0 FOR NORMAL RETURN
RET2     L     SAVER,4(SAVER)      RESTORE REGISTERS
         LR    RETURN,R7
         L     15,16(13)
         LM    1,12,24(13)
         BR    14                  RETURN TO CONTROL PROGRAM
*
***********************************************************************
         EJECT
***********************************************************************
*
*             LET STATEMENT PROCESSOR
*
*   THIS STATEMENT IS OF THE FORM:
*
*       ST #   LET  <EXPR>
*
*   THE ARITHMETIC EXPRESSION HANDLER IS CALLED TO GENERATE PSEUDO
*   CODE TO EVALUATE EXPR.
*
LETR     LA    STMT,4(STMT)        BUMP STMT PNTR PAST # & 'LET'
         BALR  RETURN,EXPREG       CALL ARITHMETIC EXPR HANDLER
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
         B     RET
*
*
***********************************************************************
*
*             IF STATEMENT PROCESSOR
*
*   THE IF STATEMENT IS OF THE FORM:
*
*     ST #1  IF  <EXPR1>  (COMPARISON OPERATOR)  <EXPR2>   THEN  ST
*
*   THE PSEUDO CODE GENERATED FOR THIS STATEMENT IS:
*
*     OP CODE                   OPERAND 1         OPERAND 2
*     _______                   _________         _________
*
*     (CODE GENERATED BY ARITHMETIC EXPRESSION HANDLER
*      FOR EVALUATION OF EXPR1 AND EXPR2)
*      THE COMPARISON)
*
*   ST IS ANY EXECUTABLE STATEMENT EXCEPT 'FOR' AND 'NEXT'
*
IFR      LA    STMT,4(STMT)        POINT REG 'STMT' TO EXPRESSION
         BALR  RETURN,EXPREG       GO TO ARITHMETIC EXPR HANDLER
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
         B     TRANS1              RETURN
*
******************************************************************
         EJECT
******************FOR STATEMENT PROCESSOR******************************
*
*             FOR STATEMENT PROCESSOR
*
*  THE PSEUDO CODE GENERATED BY TRANS FOR A 'FOR' STATEMENT IS
*  INDICATED BELOW:
*
*       ST. #   FOR  I = <EXPR1>   TO   <EXPR2>   STEP   <EXPR3>
*
*    PSEUDO CODE                           OPERAND 1   OPERAND 2
*    ___________                           _________   _________
*
*   (CODE GENERATED BY EXPR)
*   (TO EVALUATE I=EXPR1   )
*
*       STACKFOR OP CODE
*
*   (CODE GENERATED BY EXPR)
*   (TO EVALUATE EXPR2     )
*   (IF ANY IS NEEDED      )
*
*       MAX OP CODE                        VALUE OF EXPR2
*
*   (CODE GENERATED BY EXPR)
*   (TO EVALUATE EXPR3     )
*   (IF ANY IS NEEDED      )
*
*       STEP OP CODE                       VALUE OF EXPR3
*
*       COMPFOR OP CODE                         I
*
*   TRANS ALSO PUTS AN ENTRY IN THE FORC TABLE FOR EACH
*   FOR STATEMENT WHICH CONSISTS OF 2 HALFWORDS:
*
*            1ST HALFWORD - STATEMENT NUMBER
*            2ND HALFWORD - FOR INDEX
*
FORR     LH    T1,4(STMT)          PICK UP INDEX
         LR    R9,T1               SAVE FOR COMP FOR INSTRUCTION
         BAL   RETURN,STORFC       GO TO STORE ENTRY IN FORC TABLE
         LA    STMT,4(STMT)        BUMP STMT TO POINT AT INDEX
         BALR  RETURN,EXPREG       GO TO ARITH EXPR HANDLER FOR
*                                  EVALUATION OF INDEX=EXPR
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
         LA    ST,OPSTACK          STORE STACK FOR OP CODE
         BAL   RETURN,STORPS1
         LA    STMT,2(STMT)        BUMP STMT PAST 'TO' KEYWORD
         CLI   2(STMT),SYMEND      IS WHAT FOLLOWS 'TO' A SINGLE
*                                  VALUE FOLLOWED BY STEP OR BLANK
         BE    FORMX               YES
         BALR  RETURN,EXPREG       NO-GO EVALUATE EXPR FOLLOWING 'TO'
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
FORBK1   LA    ST,OPMAX            PICK UP OP MAX OP CODE
         BAL   RETURN,STORPS2      GO PUT IN PSEUDO TABLE
         CLI   1(STMT),SYMSTEP     IS KEYWORD 'STEP' SPECIFIED
         BE    FORMX2              YES
         LH    T1,FCODE1           NO-ASSUME A DEFAULT STEP OF 1
         B     FORBK3
FORMX    LH    T1,0(STMT)          MOVE UPPER LIMIT ON FOR INTO
*                                  REG FOR STORPS2
         LA    STMT,2(STMT)        BUMP POINTER TO INTERNAL LINE
         B     FORBK1
FORMX2   CLI   4(STMT),SYMEND      IS THE VALUE FOLLOWING 'STEP'
*                                  A SINGLE VALUE?
         BNE   FORLT               NO
         LH    T1,2(STMT)          YES-PICK UP OP STEP INST.
         B     FORBK3
FORLT    LA    STMT,2(STMT)        BUMP POINTER TO INTERNAL LINE
         BALR  RETURN,EXPREG       GO TO EVALUATE EXPR FOLLOWING 'STEP'
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
FORBK3   LA    ST,OPSTEP           PICK UP OP STEP INSTRUCTION
         BAL   RETURN,STORPS2      GO PUT IN PSEUDO TABLE
         LR    T1,R9               PICK UP FOR INDEX
         LA    ST,OPCMPTBR         PICK UP COMP FOR INSTRUCTION
         BAL   RETURN,STORPS2      PUT IN PSEUDO TABLE
         B     RET                 GO BACK
*
**********************************************************************
         EJECT
***********************************************************************
*
*             GOSUB STATEMENT PROCESSOR
*
*   THIS STATEMENT IS OF THE FORM:
*
*          ST #1  GOSUB  ST #2
*
*   THE PSEUDO CODE GENERATED IS
*               OP CODE             OPERAND 1        OPERAND 2
*               _______             _________        _________
*
*             GOSUB BRANCH            ST #2
*
GOSUBR   LA    ST,OPGOSBR          PICK UP STACK FOR OP CODE.
         LH    T1,4(STMT)          PICK UP ST # FOR PSEUDO TABLE ENTRY
         BAL   RETURN,STORPS2      GO PUT BRANCH OP IN PSEUDO TABLE
         B     RET                 RETURN
*
***********************************************************************
*
*             RETURN STATEMENT PROCESSOR
*
RETURNR  LA    ST,OPRET            PICK UP RETURN OP CODE
         BAL   RETURN,STORPS1      GO PUT THIS IN PSEUDO TABLE
         B     RET
*
***********************************************************************
*
*             END STATEMENT PROCESSOR
*
ENDR     LA    ST,OPEND            PICK UP END OP CODE
         BAL   RETURN,STORPS1      GO PUT THIS IN PSEUDO TABLE
         B     RET
*
***********************************************************************
*
*             STOP STATEMENT PROCESSOR
*
STOPR    LA    ST,OPSTOP           PICK UP STOP OP CODE
         BAL   RETURN,STORPS1      GO PUT THIS IN PSEUDO TABLE
         B     RET
*
***********************************************************************
*
*             RESTORE STATEMENT PROCESSOR
*
RESTORER LA    ST,OPRES            PICK UP RESTORE OP CODE
         BAL   RETURN,STORPS1      GO PUT IN PSEUDO TABLE
         B     RET
*
*********************************************************************
         EJECT
***********************************************************************
*
*             READ STATEMENT PROCESSOR
*
*
*   THE READ STATEMENT IS OF THE FORM
*
*        ST #   READ   LIST
*    IT READS VALUES SPECIFIED IN DATA STATEMENTS.  THE LIST
*   MAY CONTAIN SUBSCRIPTED VARIABLES.  IF SO, EXPR WILL BE CALLED
*   TO PLACE IN THE PSEUDO TABLE CODE TO EVALUATE THE SUBSCRIPTS.
*   THE PSEUDO CODE GENERATED FOR THE READ STATEMENT IS:
*
*        OP CODE                         OPERAND 1    OPERAND 2
*        _______                        ___________   __________
*
*       RIO (0400)                    1ST ELEMENT IN
*         .                           LIST
*         .
*         .
*       RIO (0400)                    LAST ELEMENT
*                                     IN LIST
*
READR    CLI   4(STMT),SYMPRN      IS THIS A READ(I) STATEMENT?
         BE    READI               YES
         LA    ST,RIO              PICK UP READ OP CODE
READ1    LA    STMT,4(STMT)        BUMP STATEMENT POINTER TO BEGINNING
*                                  OF LIST
READ4    CLI   2(STMT),SYMEND      IS NEXT ITEM IN LIST A SINGLE VAR
*                                  FOLLOWED BY A COMMA OR BLANK?
         BNE   READ5               NO
         LH    T1,0(STMT)          YES-PLACE THIS VAR IN REG FOR
*                                  STORPS3
         BAL   RETURN,STORPS3
         CLI   3(STMT),SYMBLNK     ARE WE AT AN END SYMBOL?
         BE    READ8               YES
         LA    STMT,4(STMT)        BUMP LINE POINTER
         B     READ4
READ5    BALR  RETURN,EXPREG       NO-GO TO ARITH EXPR HANDLER
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
         BAL   RETURN,STORPS3
         CLI   1(STMT),SYMBLNK     ARE WE AT END OF LIST?
         BE    READ8               YES-RETURN
         LA    STMT,2(STMT)        BUMP STATEMENT PNTR PAST COMMA
         B     READ4
READ8    NI    AFLAGS,X'FF'-AMATFLAG TURN OFF MAT FLAG
         B     RET                 RETURN
*
*******************************************************************
         EJECT
**********THE READ I STATEMENT PROCESSOR***************************
*
*   THIS STATEMENT IS OF THE FORM:
*
*     ST #  READ (N,I, ST #) LIST
*
*   N HERE IS THE NAME OF THE DATA SET WHICH IS TO BE READ AND
*   I SPECIFIES WHICH LINE IN THE DATA SET IS TO BE READ.
*   THE STATEMENT NUMBER SPECIFIED IS THE NUMBER OF THE STATEMENT THE
*   USER WISHES CONTROL RETURNED TO IF AN END OF FILE OCCURRS.
*   THIS IS OPTIONAL.  IF THE USER OMITS THE STATEMENT NUMBER, INLINE
*   PASSES ON TO TRANS ZEROS IN THE HALFWORD OF THE INTERNALLY CODED
*   LINE THAT NORMALLY CONTAINS THE STATEMENT NUMBER.  THIS 0 IS PUT
*   IN THE SECOND OPERAND FIELD.  IN THIS CASE THE USERS JOB TERMINATES
*   IF AN END OF FILE IS ENCOUNTERED.
*
*   THE PSEUDO CODE GENERATED IS:
*
*      OP CODE            OPERAND 1                 OPERAND 2
*      _______            _________                 _________
*
*    RINIO (0402)            N                         I
*
*    RIO(0403)            1ST ELEMENT IN LIST        ST #
*     .
*     .
*    RIO (0403)           LAST ELEMENT IN LIST       ST #
*
READI    LA    R8,RIIO             PICK UP READ I OP CODE
READI2   LA    ST,RINIO            PICK UP INITIAL READ(I) OP CODE
         CLI   8(STMT),SYMEND      IS 1ST ARG A SIMPLE VARIABLE?
         BE    READI1              YES
         LA    STMT,6(STMT)        BUMP PNTR TO BEG OF EXPRESSION
         BALR  RETURN,EXPREG       CALL ARITHMETIC EXPR HANDLER
         B     NOSPACP             ERROR RETURN, EXPR HAS OVERFLOWED
*                                  PSEUDO TABLE
         LH    T2,2(STMT)          PICK UP THE 'I' FOR STORPS3
         BAL   RETURN,STORPS3      GO PUT ENTRY IN PSEUDO TABLE
         LR    ST,R8               PICK UP READ(I) OP CODE
         LH    T2,6(STMT)          PICK UP EOF RETURN ST #
         LA    STMT,10(STMT)       BUMP ST PNTR TO BEG OF LIST
         B     READ4               GO TO PROCESS LIST
READI1   LH    T2,10(STMT)         PLACE THE 'I' IN REG FOR STOREPS3
         LH    T1,6(STMT)          PLACE THE 'N' IN REG FOR STORPS3
         BAL   RETURN,STORPS3      GO STORE IN PSEUDO TABLE
         LR    ST,R8               MOVE READ(I) OP CODE INTO REG FOR
*                                  STORING IN PSEUDO TABLE
         LH    T2,14(STMT)         PICK UP EOF RETURN ST #
         LA    STMT,18(STMT)       BUMP STATEMENT POINTER TO BEGINNING
*                                  OF LIST
         B     READ4               GO TO PROCESS LIST
*
*********************************************************************
         EJECT
************ THE WRITE I STATEMENT PROCESSOR*********************
*
*   THIS STATEMENT IS OF THE FORM:
*
*     ST #  WRITE (N,I)  LIST
*
*  N HERE IS THE NAME OF THE DATA SET WHICH IS TO BE WRITTEN AND
*  I SPECIFIES WHICH LINE IN THE DATA SET IS TO BE WRITTEN.
*
*   THE PSEUDO CODE GENERATED IS:
*
*    OP CODE                 OPERAND 1                 OPERAND 2
*    _______                 ___________               ___________
*
*   WINIO (0404)                N                         I
*
*   WIIO (0405)              1ST ELEMENT IN LIST
*     .
*     .
*   WIIO (0405)              LAST ELEMENT IN LIST
*
WRITER   LA    R8,WIIO             PICK UP WRITE I OP CODE
WRITER3  LA    ST,WINIO            PICK UP INITIAL WRITE OP CODE
         CLI   8(STMT),SYMEND      IS 1ST ARG A SIMPLE VARIABLE?
         BE    WRITER1             YES
         LA    STMT,6(STMT)        BUMP PNTR TO BEG OF EXPRESSION
         BALR  RETURN,EXPREG       CALL ARITHMETIC EXPR HANDLER
         B     NOSPACP             ERROR RETURN-EXPR HAS OVERFLOWED
*                                  PSEUDO TABLE
         LH    T2,2(STMT)          PICK UP 'I' FOR STORPS3
         BAL   RETURN,STORPS3      GO STORE ENTRY IN PSEUDO TABLE
         LH    T2,2(STMT)
         LA    STMT,6(STMT)        BUMP STMT PNTR TO BEG OF LIST
         B     WRITER2
WRITER1  LH    T2,10(STMT)         PLACE THE 'I' IN REG FOR STORPS3
         LH    T1,6(STMT)          PLACE THE 'N' IN REG FOR STORPS3
         BAL   RETURN,STORPS3
         LA    STMT,14(STMT)       BUMP STATEMENT POINTER TO BEGINNING
*                                  OF LIST
WRITER2  LR    ST,R8               PUT WRITE(I) OP CODE IN REG FOR
*                                  STORPS3
         B     READ4               GO PROCESS LIST
*
*********************************************************************
         EJECT
***********************************************************************
*
*             PRINT STATEMENT PROCESSOR
*
*  THE PRINT STATEMENT IS OF THE FORM:
*         ST #   PRINT   LIST
*   WHERE LIST IS
*      ELEMENT 1 (DELIMETER) ELEMENT 2 (DELIMETER) ...
*   EACH ELEMENT OF THE LIST MAY BE AN EXPRESSION, A VARIABLE
*   OR A CHARACTER STRING.  THE DELIMETERS ARE COMMAS, SEMICOLONS,
*   BLANKS OR END.
*
*   THE PSEUDO CODE GENERATED FOR EACH ELEMENT IS:
*
*      OP CODE                 OPERAND 1           OPERAND 2
*      _______                 _________          ___________
*
*     (CODE GENERATED BY EXPR TO
*      EVALUATE ELEMENT 1 IF ANY
*      IS NEEDED)
*
*        PIO (0401)           POINTER TO VALUE     DELIMETER
*                             OF ELEMENT 1
*
PRNTUR   LA    ST,PUIO            GET PRINT USING OP CODE
         B     PRINTR1
PRINTR   LA    ST,PIO              PLACE PRINT OP CODE IN REG FOR
*                                  STORPS3
PRINTR1  CLI   4(STMT),SYMEND      ARE THERE ANY ITEMS IN THE PRINT
*                                  LIST
         BNE   PRINT0              YES
         SR    T1,T1               NO-SET NULL OPERAND IN PSEUDO TABLE
         LH    T2,4(STMT)          PICK UP DELIMETER
         BAL   RETURN,STORPS3      GO TO STORE IN PSEUDO TABLE
         B     RET                 RETURN
PRINT0   LA    STMT,4(STMT)        BUMP ST PNTR TO BEGINNING OF LIST
PRINT1   CLI   0(STMT),X'FF'
         BNE   PRINT1X            IF NOT LINE NO. ENTRY GO ON
         LH    T1,0(STMT)         PICK UP INDICATOR OF LINE NO.
         IC    T1,5(STMT)         GET DELIM CODE
         LH    T2,2(STMT)         AND ACTUAL LINE NO.
         BAL   RETURN,STORPS3     AND STORE IT
         LA    STMT,2(STMT)       SO X'FFFF' CODE IS SKIPPED
         B     PRINT1Y            GO FINISH UP
PRINT1X  CLI   2(STMT),SYMEND      IS NEXT ITEM IN LIST A SINGLE VAR
*                                  FOLLOWED BY A DELIMETER?
         BNE   PRINT2              NO
         LH    T1,0(STMT)          MOVE VAR & DELIMETER INTO REG FOR
         LH    T2,2(STMT)          STORPS3
         BAL   RETURN,STORPS3      GO PUT IN PSEUDO TABLE
PRINT1Y  CH    ST,PUH1            WAS IT PRINT USING ON 1ST ITEM
         BNE   PRINT1A            NO, GO CHECK MAT PRINT USING
         LA    ST,PIOU            YES, SET PRINT USING ITEMS CODE
         B     PRINT1B            AND GO CONTINUE
PRINT1A  CH    ST,MPUH1           WAS IT MAT PRINT USING ON 1ST ITEM
         BNE   PRINT1B            NO, GO CONTINUE
         LA    ST,MATPRU          YES, SET MAT PRINT USING ITEMS CODE
PRINT1B  CLI   3(STMT),SYMBLNK     ARE WE AT END OF LIST?
         BE    MATOFF              YES
         CLI   4(STMT),SYMEND      DOES END SYMBOL FOLLOW?
         BE    MATOFF              GO TURN OFF THE MAT FLAG IF IT IS
*                                  ON
         B     PRINT0              NO-GO PROCESS NEXT ITEM IN LIST
PRINT2   BALR  RETURN,EXPREG       NO-GO TO ARITH EXPR HANDLER
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
         LH    T2,0(STMT)          MOVE DELIMETER INTO 3RD HALFWORD OF
*                                  INSTRUCTION
         BAL   RETURN,STORPS3      GO TO STORE IN PSEUDO TABLE
         CH    ST,PUH1            WAS IT PRINT USING ON 1ST ITEM
         BNE   PRINT2A            NO, GO CHECK MAT PRINT USING
         LA    ST,PIOU            YES, SET PRINT USING ITEMS CODE
         B     PRINT2B            AND GO CONTINUE
PRINT2A  CH    ST,MPUH1           WAS IT MAT PRINT USING ON 1ST ITEM
         BNE   PRINT2B            NO, GO CONTINUE
         LA    ST,MATPRU          YES, SET MAT PRINT USING ITEMS CODE
PRINT2B  CLI   1(STMT),SYMBLNK     IS NEXT ITEM IN LIST A BLANK?
         BE    MATOFF              YES-WE'RE DONE
         CLI   2(STMT),SYMEND      DOES END SYMBOL FOLLOW?
         BE    MATOFF              GO TURN OFF MAT FLAG IF IT IS ON
         LA    STMT,2(STMT)        BUMP LINE POINTER
         B     PRINT1
*
***********************************************************************
*
*      INPUT STATEMENT PROCESSOR
*
*   THE INPUT STATEMENT IS OF THE FORM:
*
*          ST #  INPUT   LIST
*
*   IT CAUSES THE USER AT THE TERMINAL TO BE PROMPTED FOR VALUES
*   FOR ELEMENTS IN THE LIST.
*
*   THE PSEUDO CODE GENERATED IS:
*
*       OP CODE            OPERAND 1                  OPERAND 2
*       _______            _________                  _________
*
*      IIO  (0406)      1ST ELEMENT IN LIST
*         .
*         .
*      IIO  (0406)      LAST ELEMENT IN LIST
*
INPUTR   LA    ST,IIO              PLACE INPUT I/O OP CODE IN REG FOR
*                                  STORPS3
         B     READ1               GO PROCESS LIST
*
********************************************************************
*************************************************************
*
*       IMAGE STMT PROCESSOR
*
IMAGER   LH    T1,4(STMT)         GET STRING POINTER
         LA    ST,IMGIO           GET IMAGE OP CODE (EXECUTES AS NO-OP)
         BAL   RETURN,STORPS2     SET UP PSEUDO CODE
         B     RET
*
*************************************************************
         EJECT
***********************************************************************
*
*             MAT STATEMENT PROCESSOR
*
*   THERE ARE 13 TYPES OF MAT STATEMENTS.
*
*         1.  MAT READ LIST
*         2.  MAT PRINT LIST
*         3.  MAT C = A + B
*         4.  MAT C = A - B
*         5.  MAT C = A * B
*         6.  MAT C = (EXPR) * A  SCALAR MULTIPLY
*         7.  MAT C = INV(A)
*         8.  MAT C = TRN(A)
*         9.  MAT C = ZER
*        10.  MAT C = CON
*        11.  MAT C = IDN
*        12.  MAT C = TRI(A)
*        13.  MAT C = NOR(A)
*
*   CONTROL IS TRANSFERRED TO THIS ROUTINE WHEN THE MAT KEYWORD IS
*   RECOGNIZED.  THE HIGH ORDER BIT OF THE FLAGWORD AFLAG IN USER AREA
*   IS TURNED ON TO INDICATE THAT WE ARE PROCESSING A MAT STATEMENT.
*   THEN A CHECK IS MADE TO SEE IF WE ARE HANDLING A MAT I/O STATEMENT
*   (TYPES 1 AND 2 ABOVE).  IF WE ARE THE APPROPRIATE I/O OP CODE IS
*   PLACED IN A REGISTER AND WE TRANSFER TO THE LIST PROCESSING PART
*   OF TRANS TO GENERATE CODE FOR THE I/O LIST.  IF THE MAT STATEMENT
*   BEING PROCESSED IS NOT AN I/O ST THEN WE GO TO EXPR FOR GENERATION
*   OF PSEUDO CODE FOR THESE STATEMENTS.  THE MAT FLAG TELLS EXPR IT IS
*   PROCESSING A MAT RATHER THAN A SCALAR STATEMENT.
*
MATR     OI    AFLAGS,AMATFLAG     TURN THE MAT FLAG ON
         CLI   4(STMT),SYMIO       IS THIS A MAT I/O STATEMENT?
         BNE   MATCALL             NO
         CLI   5(STMT),X'0B'      WAS IT PRINT
         BE    MATPRN
         CLI   5(STMT),X'1A'      WAS IT PRINT USING
         BE    MATPRNU
         CLI   5(STMT),X'0C'      WAI IT INPUT
         BNE   MAT2
         LA    STMT,6(STMT)        YES-BUMP STMT POINTER TO BEG OF LIST
MATIPT   LA    ST,MATIP            PICK UP MAT INPUT OP CODE
         B     READ4               GO PROCESS LIST
MATPRN   LA    STMT,6(STMT)
         LA    ST,MATPR            PICK UP MAT PRINT OP CODE
         B     PRINT1
MATPRNU  LA    STMT,6(STMT)
         LA    ST,MATPUIO         PICK UP MAT PRINT USING OP CODE
         B     PRINT1
MAT2     LA    STMT,2(STMT)        BUMP STATEMENT POINTER
         TM    3(STMT),X'01'       IS THIS A MAT WRITE I?
         BZ    MATWRITI            YES
         CLI   4(STMT),SYMPRN      NO-IS THIS A MAT READ(I)?
         BE    MATREDI             YES
MATRED   LA    STMT,4(STMT)        NO-THEN IT MUST BE MAT READ
         LA    ST,MATRD            PICK UP MAT READ OP CODE
         B     READ4               GO PROCESS LIST
MATREDI  LA    R8,MATRDI           PICK UP MAT READ (I) OP CODE
         B     READI2              GO PROCESS LIST
MATWRITI LA    R8,MATWRI           PICK UP MAT WRITE (I) OP CODE
         B     WRITER3
MATCALL  LA    STMT,4(STMT)        BUMP STATEMENT POINTER PAST ST. #
*                                  AND MAT KEYWORD
         BALR  RETURN,EXPREG       GO TO ARITH ST HANDLER
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
MATOFF   NI    AFLAGS,X'FF'-AMATFLAG TURN OFF MAT FLAG
         B     RET
*
**********************************************************************
         EJECT
***********************************************************************
*
*             DEF FN STATEMENT PROCESSOR
*
*   THE DEFINE FUNCTION STATEMENT IS OF THE FORM:
*
*         ST #   DEF  FN&(VAR) = <EXPR>
*
*   WHERE & CAN BE THE LETTERS A - Z.
*   THERE IS A TABLE (ATOZFCT) IN THE USER AREA OF 26 FULL WORDS, ONE
*   FOR EACH OF THE POSSIBLE FUNCTIONS.  FOR EACH FUNCTION WHICH HAS
*   BEEN DEFINED, ITS ENTRY CONTAINS THE FOLLOWING VALUES:
*
*          1ST HALFWORD - ST # WHERE THE FUNCTION IS DEFINED
*          2ND HALFWORD - POINTER TO ASSOCIATED PSEUDO CODE
*
*   ROUTINE STORFN IS CALLED TO MAKE ENTRIES IN THIS TABLE AND TO
*   CHECK FOR DUPLICATE DEFINITIONS.
*
*   THE PSEUDO CODE GENERATED FOR THIS STATEMENT IS:
*
*     OP CODE               OPERAND 1        OPERAND 2
*     _______               _________        _________
*
*     SAVDF (0209)                              VAR
*
*     (CODE GENERATED BY THE ARITHMETIC EXPRESSION HANDLER
*      TO EVALUATE EXPR)
*
*     UNSTACKDF (020A)    VALUE OF FN&          VAR
*
*   THROUGHOUT THE PROCESSING OF THIS STATEMENT R1 CONTAINS THE
*   DISPLACEMENT PAST USER OF THE LINES TABLE ENTRY FOR THIS STATEMENT.
*   THE SECOND HALFWORD OF THE LINES TABLE ENTRY IS MADE X'0007' TO
*   INDICATE THAT THE STATEMENT IS A DEF.
*
DEFR     SR    ST,ST
         IC    ST,5(STMT)          PICK UP FUNCTION CODE
         BAL   RETURN,STORFN       GO TO MAKE ENTRY IN FNSYM TABLE
         LH    T2,8(STMT)          PICK UP ARG FOR SAVDF INST.
         LA    ST,OPSAVDF          PICK UP SAVDF OP CODE
         BAL   RETURN,STORPS3      PUT IN PSEUDO TABLE
         LA    STMT,14(STMT)       BUMP STMT TO POINT AT FUNCTION
*                                  EXPRESSION
         BALR  RETURN,EXPREG       GO TO ARITH EXPR HANDLER
         B     NOSPACP             ERROR-EXPR HAS OVERFLOWED A TABLE
         LA    ST,OPUNSDFB         PICK UP UNSTACK DF INST.
         BAL   RETURN,STORPS3      PUT IN PSEUDO TABLE
         LA    CUR,DEFCODE         SET 2ND HALFWORD OF LINES
         STH   CUR,2(R1,USER)      TO INDICATE A DEFN STATEMENT
         B     RET                 RETURN
*
**********************************************************************
         EJECT
***********************************************************************
*
*             NEXT STATEMENT PROCESSOR
*
*   THIS STATEMENT IS OF THE FORM:
*           ST #  NEXT  I
*  ONE ENTRY IS MADE IN THE PSEUDO TABLE FOR THE NEXT STATEMENT.
*
*      OP CODE        OPERAND 1       OPERAND 2
*      _______        _________       _________
*      + FOR (0104)       I
*
*   ROUTINE STORFC IS CALLED TO MAKE AN ENTRY IN THE FORC TABLE FOR
*   THIS STATEMENT.
*
NEXTR    LH    T1,4(STMT)          PICK UP INDEX FOLLOWING NEXT
         LA    ST,OPPFR            STORE IN REG FOR STORPS2
         BAL   RETURN,STORPS2      PUT IN PSEUDO TABLE
         OI    4(STMT),X'80'       TURN ON HIGH ORDER BIT OF INDEX
         LH    T1,4(STMT)          BEFORE STORING IN FORC TABLE.
         BAL   RETURN,STORFC       GO PUT ENTRY IN FORC TABLE
         B     RET                 RETURN
*
***********************************************************************
*
*             GO TO STATEMENT PROCESSOR
*
*   THIS STATEMENT IS OF THE FORM:
*    ST #1  GO TO ST #2
*   THE PSEUDO CODE GENERATED IS:
*       OP CODE             OPERAND 1         OPERAND 2
*       _______             _________         _________
*       BRANCH                ST #2
*
GOTOR    LH    T1,4(STMT)          PICK UP ST # FOR PSEUDO TABLE ENTRY
         LA    ST,OPBRNCH          PICK UP NEXT PSEUDO TABLE ENTRY
         BAL   RETURN,STORPS2      GO PUT THIS IN PSEUDO TABLE
         B     RET                 RETURN
*
***********************************************************************
*
*              DUMP STATEMENT PROCESSOR
*
DUMPR    LA    ST,OPDMP            PICK UP DUMP OP CODE
         BAL   RETURN,STORPS1      GO STORE IN PSEUDO TABLE
         B     RET
*
***********************************************************************
*
*              PAUSE STATEMENT PROCESSOR
*
PAUSER   LA    ST,OPPAUS           PICK UP PAUSE OP CODE
         BAL   RETURN,STORPS1      GO STORE IN PSEUDO TABLE
         B     RET
*
***********************************************************************
*
*            REMARK STATEMENT PROCESSOR
*
REMR     LA    CUR,REMCODE         SET LOW ORDER BYTE
         STH   CUR,2(R1,USER)      OF LINES TABLE TO INDICATE A REM
         B     RET1                RETURN
*
*******************************************************************
*
*   DEFINE FILE STATEMENT PROCESSOR
*
*   NO PSEUDO CODE IS GENERATED FOR THE DEFINE FILE STATEMENT.
*   REGISTER 14 HAS BEEN BUMPED PRIOR TO REACHING THIS CODE SO THAT:
*
*        1. IF A NEW DEFINE FILE STATEMENT HAS BEEN ENTERED WE BRANCH
*           BACK TO THE CONTROL PROGRAM AT 4 PAST R14.
*        2. IF A DEFINE FILE STATEMENT HAS BEEN REPLACED BY ANOTHER
*           DEFINE FILE WE RETURN TO 8 PAST R14.
*        3. IF A DEFINE FILE HAS BEEN DELETED WE RETURN TO 12 PAST
*           R14.
*
DEFFR    LA    CUR,DEFFCODE        SET LOW ORDER BYTE OF LINES TABLE TO
         STH   CUR,2(R1,USER)      INDICATE A DEFINE FILE STATEMENT
         B     RET1                RETURN
*
******************************************************************
         EJECT
**********************************************************************
*
*          COMPUTED GO TO STATEMENT HANDLER
*
*   THIS STATEMENT IS OF THE FORM:
*
*      ST #0  ON  <EXPR>  GO TO  ST #1, ST #2, ... ST #N
*
*   THE COMPUTED GO TO COMES TO TRANS IN THE FORM SHOWN BELOW.
*        1ST HALFWORD - STATEMENT NUMBER OF THIS STATEMENT
*        2ND HALFWORD - ON CODE (0B17)
*        3RD - (M)TH HALFWORDS - CODE FOR <EXPR>
*        (M+1)TH HALFWORD - GO TO CODE
*        (M+2)TH HALFWORD - NUMBER OF ST #'S IN GO TO LIST (N)
*        (M+3)TH HALFWORD - ST #1
*          .
*        LAST HALFWORD - ST #N
*
*   THE PSEUDO CODE GENERATED IS:
*
*         OP CODE                       OPERAND 1      OPERAND 2
*         _______                       _________      _________
*
*       (CODE GENERATED BY THE ARITHMETIC
*        EXPRESSION HANDLER TO EVALUATE EXPR)
*
*        ON (020B)                   VALUE OF EXPR         N
*
*        BRANCH (0200)                   ST #1
*        BRANCH (0200)                   ST #2
*            .                            .
*            .                            .
*        BRANCH (0200)                   ST #N
*
CGOTOR   LA    STMT,4(STMT)        BUMP LINE POINTER TO EXPR
         CLI   2(STMT),SYMEND      IS EXPR A SIMPLE VARIABLE?
         BE    CGO1                YES-THEN DON'T CALL EXPR HANDLER
         BALR  RETURN,EXPREG       CALL EXPR HANDLER TO EVALUATE EXPR
         B     NOSPACP             ERROR RETURN FROM EXPR FOR PSEUDO
*                                  TABLE OVERFLOW
CGO6     CLI   1(STMT),X'07'       IS THIS A GOSUB
         BE    CGO4                YES
         LA    R9,OPCONDBR         NO
         B     CGO5
CGO4     LA    R9,OPGOSBR
CGO5     LA    STMT,2(STMT)        BUMP LINE POINTER PAST GOTO
CGO2     LH    T2,0(STMT)          PICK UP 'N', # OF ST NUMBERS IN LIST
         LA    ST,OPON             PICK UP ON OP CODE
         BAL   RETURN,STORPS3      GO STORE ENTRY IN PSEUDO TABLE
         LR    ST,R9               PICK UP BRANCH OP CODE
         LH    R9,0(STMT)          PICK UP # OF NOS IN LIST
CGO3     LA    STMT,2(STMT)        BUMP LINE POINTER TO NEXT ST #
         LH    T1,0(STMT)          PICK UP STATEMENT NUMBER
         BAL   RETURN,STORPS2      GO STORE ENTRY IN PSEUDO TABLE
         BCT   R9,CGO3             ARE WE AT END OF LIST?
*                                  NO-GO PROCESS NEXT NUMBER
         B     RET                 YES-RETURN
CGO1     LH    T1,0(STMT)          PICK UP SIMPLE VARIABLE
         LA    STMT,2(STMT)        BUMP LINE POINTER
         B     CGO6
*
**********************************************************************
         EJECT
*****************DIMENSION STATEMENT PROCESSOR***********************
*
*
*        THIS SECTION HANDLES THE TRANSLATED DIMENSION STATEMENT.
*
*
*        THE DIM STATEMENT COMES TO THIS ROUTINE WITH THE FOLLOWING
*        TRANSLATION:
*            1ST HALF-WORD - LINE #
*            2ND HALF-WORD - CODE FOR DIM STATEMENT
*            3RD HALF-WORD - INDEX OF SUBSCRIPTED ARRAY
*            4TH HALF-WORD - FIRST DIMENSION
*            5TH HALF-WORD - SECOND DIMENSION (0 IF SINGLE-DIMENSION)
*                .
*                .
*               REPEAT GROUPS OF 3 HALFWORDS (3RD - 5TH ABOVE)
*               UNTIL BLANK (X'0D05') IS FOUND.
*     THE DIMENSIONING INFORMATION IS SPECIFIED AS FIXED POINT
*     NUMBERS.
*
*   THE DIMENSION INFORMATION IS STORED IN THE ATOZ AND ATOZSTRG TABLES
*   IN USER AREA.
*        EACH ENTRY IN THE ATOZ TABLE IS 4 FULL WORDS LONG.
*              1ST HALFWORD - DIM STATEMENT NUMBER
*              2ND HALFWORD - DISPLACEMENT IN USER AREA OF THIS ARRAY
*                              (FILLED IN BY THE LOADER)
*              2ND FULLWORD - LEFT DIMENSION
*              3RD FULLWORD - RIGHT DIMENSION
*              4TH FULLWORD - TOTAL SIZE OF ARRAY
*
*        EACH ENTRY IN THE ATOZSTRG TABLE IS 2 FULL WORDS LONG.
*              1ST HALFWORD - DIM STATEMENT NUMBER
*              2ND HALFWORD - DISPLACEMENT IN USER AREA OF THIS ARRAY
*              2ND FULLWORD - DIMENSION OF STRING VARIABLE A$ TO Z$
*
*   A CHECK IS MADE BEFORE THE DIM INFORMATION FOR EACH VARIABLE
*   IS STORED TO SEE IF IT HAS ALREADY BEEN DIMED.  IF IT HAS, A
*   MESSAGE IS SENT TO THE USER TELLING HIM HE HAS ATTEMPTED TO DIM
*   AN ALREADY DIMED VARIABLE AND THAT THE STATEMENT HAS BEEN
*   IGNORED.  PROCESSING OF THE STATEMENT THEN STOPS AND ANY DIM
*   INFORMATION STORED BY THE STATEMENT IS REMOVED.
*   ON ENTRY TO THIS ROUTINE, REG R1 CONTAINS THE DISPLACEMENT PAST
*   USER OF THE ENTRY IN THE LINES TABLE OF THE STATEMENT CURRENTLY
*   BEING PROCESSED.
*
*
DIMR     LA    CUR,DIMCODE         SET LOW ORDER BYTE
         STH   CUR,2(R1,USER)      OF LINES TABLE TO INDICATE A DIM
         LA    CUR,ATOZ            PICK UP ADDR OF ATOZ TABLE
         LA    PSD,ATOZSTRG        PICK UP ADDRESS OF ATOZSTRG TABLE
         LA    STMT,4(STMT)        BUMP STMT PNTR TO VAR CODE
DIMLOOP  SR    ST,ST
         IC    ST,1(STMT)          PICK UP VARIABLE CODE
         CLI   0(STMT),X'30'       IS THIS A STRING VARIABLE?
         BE    DIMSTR              YES
         SLL   ST,4                MULTIPLY BY 16
         LH    T2,0(CUR,ST)        HAS THIS VARIABLE ALREADY BEEN
         LTR   T2,T2               DIMENSIONED?
         BNZ   DIMDUP              YES-ERROR
         SR    T2,T2               SET ARRAYIDX BACK TO ZERO FOR
         STH   T2,2(CUR,ST)        LODR
         STH   R0,0(CUR,ST)        STORE STATEMENT NUMBER
         LH    T2,2(STMT)          PICK UP LEFT SUBSCRIPT
         ST    T2,4(CUR,ST)        STORE IN ATOZ TABLE
         LH    T2,4(STMT)          PICK UP RIGHT SUBSCRIPT
         ST    T2,8(CUR,ST)        STORE IN ATOZ TABLE
DIMCOM   LA    STMT,6(STMT)        BUMP TO NEXT ITEM IN LIST
         CLI   0(STMT),SYMEND      ARE WE AT END OF LIST?
         BNE   DIMLOOP             NO
         B     RET1                YES-RETURN
*
DIMSTR   SLL   ST,3                MULTIPLY VARIABLE CODE BY 8
         LH    T2,0(PSD,ST)        HAS THIS VARIABLE ALREADY BEEN
         LTR   T2,T2               DIMENSIONED?
         BNZ   DIMDUP              YES-ERROR
         STH   R0,0(PSD,ST)        NO-STORE STATEMENT #
         SR    T2,T2               SET ASTRGIDX TO ZERO FOR STRING
         STH   T2,2(PSD,ST)        ARRAY TO BE ALLOCATED
         LH    T2,2(STMT)          PICK UP SUBSCRIPT
         ST    T2,4(PSD,ST)        STORE IT
         B     DIMCOM
*
DIMDUP   LPR   ST,SAVER            SET FLAG REGISTER TO POSITIVE TO
*                                  CONTROL MESSAGE PRINTING
         B     DEL10               GO TO DELETE ROUTINE TO REMOVE DIM
*                                  INFO STORED BY THIS STATEMENT
*
********************************************************************
         EJECT
****************DELETE A STATEMENT*************************************
*
*          THE DELETE STATEMENT PROCESSOR
*
*   THIS CODE IS ENTERED WHEN A USER WISHES A STATEMENT DELETED FROM
*   HIS PROGRAM.  ON ENTRY R0 CONTAINS A BINARY NUMBER, THE
*   NUMBER OF THE STATEMENT TO BE DELETED.
*
*   THIS ROUTINE DELETES THE ENTRY FOR THIS STATEMENT IN THE LINES
*   TABLE.  THE FORC TABLE IS SEARCHED TO SEE IF THIS
*   NUMBER IS THERE.  IT IS REMOVED IF FOUND.  IF THE STATEMENT WAS A
*   DATA STATEMENT, THE DATA IT ENTERED IN THE DATA TABLE IS REMOVED.
*   IF IT WAS A DIM, THE ATOZ AND ATOZSTRG TABLES ARE SEARCHED FOR THIS
*   STATEMENT #.  VARIABLES DIMED BY THIS STATEMENT ARE UNDIMED.
*   IF IT WAS A DEF FN STATEMENT, THE ATOZFCT TABLE IS SEARCHED FOR
*   THIS ST #, AND THE CORRESPONDING ENTRY IS REMOVED.
*
*                                  ARE WE DELETING ST # 10000?
DELR     CH    R0,TENTHOU          (ST # 10000 IS THE IMMEDIATE
*                                  STATEMENT KLUGE)
         BNE   DEL9                NO
         L     T1,ALINEPTR         BUMP LINES TABLE POINTER BACK BY 4
         S     T1,FOUR
         AL    T1,ALINEBEG
         LH    R1,2(T1,USER)       PICK UP LAST PSEUDO TABLE POINTER
         ST    R1,ACODEPTR         SET THE CODE TABLE BACK
*
*
DEL9     SR    ST,ST               SET MESSAGE CODE FLAG TO 0 FOR
*                                  DELETE
         LA    R1,ALINEBEG         PICK UP LINES TABLE BEGINNING
*                                  FOR BINARY SEARCH
         L     EXPREG,BINSRCH
         BALR  RETURN,EXPREG       CALL BINARY SEARCH
         LTR   R1,R1               WAS THIS ST # FOUND IN TABLE?
         BM    RET1                NO
         LA    RETURN,0(R1,USER)   IS THE STATEMENT BEING DELETED A
         CLI   3(RETURN),DEFFCODE  DEFINE FILE?
         BNE   DEL10               NO
         LA    R7,12(R7)           YES-BUMP RETURN REGISTER
* * * * * * * * * * * * * * * * * *
*   THE DIM STATEMENT PROCESSOR BRANCHES HERE IF IT FINDS A STATEMENT
*   WHICH REDIMS AN ALREADY DIMED VARIABLE.  DELETE REMOVES THE DIM
*   INFO AND THE LINES TABLE ENTRY FOR THIS STATEMENT.
* * * * * * * * * * * * * * * * * *
DEL10    L     T1,ALINEPTR         PICK UP CURRENT SIZE OF LINES TABLE
         S     T1,FOUR             UPDATE THE PNTR TO THE LINES TABLE
         ST    T1,ALINEPTR         AND STORE IT AWAY
         LA    PSD,0(R1,USER)      PICK UP LOC OF ENTRY TO BE DELETED
         S     R1,ALINEBEG
         SR    T1,R1               COMPUTE # OF BYTES TO BE MOVED
         SR    R9,R9               SET STORE LINE ENTRY FLAG OFF
* * * *
*   THE STORE LINE ROUTINE BRANCHES HERE IF IT IS PROCESSING A
*   STATEMENT WHICH ALREADY EXISTS IN THE LINES TABLE (I.E. A
*   REPLACEMENT).  THIS ROUTINE WILL DELETE ANY FORC, DEF, DIM
*   AND DATA INFO STORED BY THE OLD STATEMENT BEFORE THE NEW
*   STATEMENT IS PROCESSED.
* * * * *
DELHERE  TM    3(PSD),X'01'        WAS THIS ST A REM,DIM,DATA,
*                                  SYNTAX ER OR DEF?
         BZ    DELFORC             NO
         TM    3(PSD),X'08'        WAS THIS A SYNTAX ER ST?
         BO    DELLINE             YES
         TM    3(PSD),X'06'
         BZ    DELDIM              BRANCH IF IT WAS A DIM ST
         BO    DELDEF              BRANCH IF IT WAS A DEF FN ST
         TM    3(PSD),X'04'
         BZ    DELDATA             BRANCH IF IT WAS A DATA ST
DELLINE  LTR   R9,R9               DID WE COME HERE FROM STORE LINE?
         BNZ   STLN2               YES-THEN GO BACK THERE.  WE DO NOT
*                                  NEED TO DO A DELETE OF THE LINES
*                                  ENTRY IF STORE LINE IS PROCESSING A
*                                  REPLACE STATEMENT.
* * * * * * * * *
*   THE STORFN ROUTINE BRANCHES HERE IF IT FINDS THAT THE DEF FN STATE-
*   MENT IT IS PROCESSING DUPLICATED ONE ALREADY ENTERED.  THE LINES
*   TABLE ENTRY FOR THIS DUPLICATE STATEMENT IS REMOVED.
* * * * * * * * * * * * *
DEL21    LTR   T1,T1
         BZ    DEL2A
         LA    T2,256              FALL THRU TO HERE IF IT WAS A REM
         CR    T1,T2               IS # OF BYTES TO BE MOVED > 256?
         BH    DEL1                YES
DEL2     BCTR  T1,0                DEC CNT TO BE MOVED BY 1 FOR MVC
         EX    T1,MOVER            DO THE MOVE
DEL2A    LTR   ST,ST               ARE WE PROCESSING A DELETE ST?
         BZ    RET1                YES
         BM    DEL22               BRANCH IF WE ARE PROCESSING A
*                                  DELETE DEF FN
         LA    R1,CDIMDUP          PICK UP DUPLICATE DIM ERROR CODE
         B     TORUNER             GO PRINT ERROR MESSAGE
DEL22    LA    R1,CDEFDUP          PICK DUP DEF ERROR CODE
TORUNER  L     EXPREG,ARUNER       PICK UP ADDRESS OF RUNER
         BALR  RETURN,EXPREG       GO TO RUNER
         B     RET1                RETURN
DEL1     LA    CUR,255
DEL3     EX    CUR,MOVER           MOVE 256 BYTES OF THE LINES TABLE
         AR    PSD,T2              MOVE POINTER TO NEXT BLOCK TO BE
*                                  MOVED
         SR    T1,T2               DECREMENT COUNT BY 256
         CR    T1,T2               ARE THERE MORE THAN 256 YET TO BE
*                                  MOVED?
         BNH   DEL2                NO
         B     DEL3                YES
*
* * * *    DELETE  ENTRY FROM THE ATOZFCT TABLE
*
DELDEF   LA    CUR,ATOZFCT         PICK UP ADDRESS OF DEFN TABLE
DEL5     CH    R0,0(CUR)           DOES ST # OF THIS DEFN ENTRY MATCH
*                                  THE # OF THE STATEMENT WE ARE
*                                  DELETING?
         BE    DEL4                YES
         LA    CUR,4(CUR)          N0-BUMP POINTER TO NEXT DEFN ENTRY
         B     DEL5                GO SEARCH FURTHER
DEL4     SR    R1,R1               ZERO OUT DEFN ENTRY FOR THIS
         ST    R1,0(CUR)           DELETED STATEMENT
         B     DELLINE             GO REMOVE LINES TABLE ENTRY
*
* * *   DELETE AN ENTRY FROM THE FORC TABLE
*
DELFORC  LA    R1,AFORCBEG         PICK UP FORC TABLE BEGINNING
*                                  FOR BINARY SEARCH
         L     EXPREG,BINSRCH
         BALR  RETURN,EXPREG       CALL BINARY SEARCH
         LTR   R1,R1               IS THIS # IN THE FORC TABLE?
         BM    DELLINE             NO
         L     T2,AFORCPTR         YES-PICK UP CURRENT SIZE OF FORC
*                                  TABLE
         S     T2,FOUR             BUMP BACK BY FOUR BYTES TO REFLECT
         ST    T2,AFORCPTR         NEW SIZE AFTER WE DELETE THIS ENTRY
         LA    CUR,0(R1,USER)      PICK UP LOC OF ENTRY TO BE DELETED
         S     R1,ALINEBEG         COMPUTE NUMBER OF BYTES
         SR    T2,R1               TO BE MOVED
         LA    R1,256
         CR    T2,R1               IS # OF BYTES TO BE MOVED > 256?
         BH    DEL6                YES
DEL8     BCTR  T2,0                DECREMENT THIS CNT BY 1 FOR THE MVC
         EX    T2,MOVERC           DO THE MOVE
         B     DELLINE             GO FIX UP THE LINES TABLE
DEL6     LA    R8,255
DEL7     EX    R8,MOVERC           MOVE 256 BYTES OF FORC TABLE
         AR    CUR,R1              MOVE POINTER TO NEXT BLOCK TO BE
*                                  MOVED
         SR    T2,R1               DECREMENT COUNT BY 256
         CR    T2,R1               ARE THERE MORE THAN 256 YET TO BE
*                                  MOVED?
         BNH   DEL8                NO
         B     DEL7                YES
*
* * * *   DELETE AN ENTRY FROM THE DATA TABLE
*
DELDATA  SR    ST,ST               INITIALIZE DATA TABLE POINTER
         L     CUR,ADATABEG        PICK UP POINTER TO BEGINNING
         LA    CUR,0(CUR,USER)     OF DATA TABLE
         LH    RETURN,0(CUR,ST)
DEL12    CH    R0,0(CUR,ST)        IS THIS THE ENTRY TO BE DELETED
         BE    DEL11               YES
         LH    RETURN,0(CUR,ST)
         AH    ST,2(CUR,ST)        NO-BUMP POINTER TO NEXT ENTRY
         B     DEL12               GO CHECK IT
DEL11    LA    CUR,0(CUR,ST)       COMPUTE TARGET LOCATION OF THE MOVE
         L     T2,ADATAPTR         UPDATE THE DATA TABLE POINTER TO
         SH    T2,2(CUR)           REFLECT THE FACT THAT ITEMS HAVE
         ST    T2,ADATAPTR         BEEN DELETED
         LTR   T2,T2               IS THE PTR 0? I.E. IS THE TABLE NOW
*                                  EMPTY?
         BZ    DEL20               YES
         CLC   0(2,CUR),ADATALST   ARE WE DELETING THE LAST ENTRY IN
*                                  THE DATA TABLE
         BE    DEL24               YES
         LR    R1,CUR
         AH    R1,2(CUR)           COMPUTE LOCATION OF 1ST DATA ITEM
*                                  TO BE MOVED
         SR    T2,ST               NO-COMPUTE # OF BYTES TO BE MOVED
         LA    ST,256
         CR    T2,ST               IS # OF BYTES TO BE MOVED > 256?
         BH    DEL14               YES
DEL16    BCTR  T2,0                NO-DECREMENT CNT BY 1 FOR MVC
         EX    T2,MOVERD           DO THE MOVE
DEL23    SR    ST,ST               SET MESSAGE FLAG OFF
         B     DELLINE             GO TO DELETE THE LINES TABLE ENTRY
DEL14    LA    R8,255              LOAD CONSTANT FOR MOVING 256 BYTES
DEL15    EX    R8,MOVERD           MOVE 256 BYTES
         AR    CUR,ST              BUMP SOURCE AND TARGET POINTERS
         AR    R1,ST               FOR NEXT MOVE
         SR    T2,ST               DECREMENT COUNT BY 256
         CR    T2,ST               ARE THERE MORE THAN 256 BYTES YET
*                                  TO BE MOVED?
         BH    DEL15               YES
         B     DEL16               NO
*
DEL20    SR    ST,ST               SET ADATALAST TO 0 SINCE DATA
         ST    ST,ADATALST         TABLE IS EMPTY
         B     DELLINE             GO TO DELETE LINES ENTRY
*
DEL24    STH   RETURN,ADATALST     SET ADATALAST TO # OF LAST ENTRY IN
         B     DEL23               TABLE
*
* * * * * DELETE A DIMENSION STATEMENT
*
DELDIM   LA    CUR,ATOZ            PICK UP ADDR OF ATOZ TABLE
         SR    R1,R1               SET REGS TO 0 AND -0
         L     R8,MNZERO           FOR STORING IN DELETED
*                                  DIMS
         LA    T2,416(CUR)         MAX DISPLACEMENT IN ATOZ
DIMNEXT  CH    R0,0(CUR)           IS THERE A # THERE EQUAL TO ST #
*                                  CURRENTLY BEING PROCESSED?
         BNE   DIMNO               NO
         ST    R1,0(CUR)           YES-DELETE FROM THE ATOZ TABLE
         ST    R1,4(CUR)           THE INFORMATION PLACED THERE
         ST    R8,8(CUR)           BY THIS DIM STATEMENT
         STH   R1,14(CUR)
DIMNO    LA    CUR,16(CUR)         BUMP PNTR TO ATOZ TABLE
         CR    CUR,T2              ARE WE AT END OF TABLE?
         BL    DIMNEXT             NO-GO CHECK NEXT VARIABLE
         LA    CUR,ATOZSTRG        INITIALIZE PNTR TO ATOZSTRG
         LA    T2,208(CUR)         MAX DISPLACEMENT IN ATOZSTRG
DIMNEXTS CH    R0,0(CUR)           IS THERE A # EQUAL TO ST #
*                                  CURRENTLY BEING PROCESSED?
         BNE   DIMNOS              NO
         ST    R1,0(CUR)           YES-DELETE FROM ATOZSTRG TABLE
         ST    R8,4(CUR)           THE INFORMATION PLACED THERE BY
*                                  THIS DIM STATEMENT
DIMNOS   LA    CUR,8(CUR)          BUMP PNTR TO ATOZSTRG TABLE
         CR    CUR,T2              ARE WE AT END OF TABLE?
         BL    DIMNEXTS            NO-GO CHECK NEXT VARIABLE
         B     DELLINE             YES-GO DELETE LINES ENTRY
*
MOVER    MVC   0(1,PSD),4(PSD)     LINES TABLE MOVE INSTRUCTION
MOVERD   MVC   0(1,CUR),0(R1)      DATA TABLE MOVE INSTRUCTION
MOVERC   MVC   0(1,CUR),4(CUR)     FORC TABLE MOVE INSTRUCTION
*
********************************************************************
         EJECT
***************DATA STATEMENT PROCESSOR********************************
*
*       DATA STATEMENT PROCESSOR
*
*  INPUT TO TRANS FOR A DATA STATEMENT IS SHOWN BELOW:
*
*        1ST HALFWORD - STATEMENT NUMBER
*        2ND HALFWORD - DATA STATEMENT CODE
*        2ND FULL WORD - NUMBER OF ITEMS IN THE DATA LIST WHICH
*                        FOLLOWS (N)
*        3RD FULL WORD - 1ST DATA ITEM - A FLOATING POINT NUMBER
*        .
*        .
*        (N+2)TH FULLWORD - LAST DATA ITEM
*
*    THIS INFORMATION IS STORED IN A DATA TABLE.  THE FORMAT OF THE
*    DATA TABLE IS SHOWN BELOW:
*
*          1ST HALFWORD - STATEMENT NUMBER
*          2ND HALFWORD - NUMBER OF BYTES IN THIS ENTRY IN THE
*                         DATA TABLE (N+2)*4
*          2ND FULL WORD - FIRST DATA ITEM
*          .
*          .
*          (N+1)TH FULL WORD - LAST DATA ITEM
*          LAST FULL WORD - X'80000000'
*
*   THIS TABLE IS AN ORDERED TABLE - BY STATEMENT NUMBER.
*   IF STATEMENTS COME IN OUT OF ORDER - THIS ROUTINE MAKES
*   THE NECESSARY MOVES TO KEEP THE TABLE ORDERED.
*
*   AN ENTRY IS MADE IN THE LINES TABLE FOR EACH DATA
*   STATEMENT.  THE SECOND HALFWORD OF THE LINES ENTRY IS
*   0003, TO INDICATE THAT THE STATEMENT IS A DATA STATEMENT.
*   ON ENTRY TO THIS ROUTINE, REG R1 CONTAINS THE DISPLACEMENT PAST
*   USER OF THE ENTRY IN THE LINES TABLE OF THE STATEMENT CURRENTLY
*   BEING PROCESSED.
*
DATAR    LA    CUR,DATCODE         SET 2ND HALFWORD OF LINES
         STH   CUR,2(R1,USER)      TO INDICATE A DATA
         L     T1,4(STMT)          COMPUTE # OF BYTES IN DATA TABLE
         LA    T1,2(T1)            ENTRY FOR THIS STATEMENT
         SLL   T1,2
         L     CUR,ADATAPTR        PICK UP DISP OF NEXT ENTRY IN DATA
*                                  TABLE
         L     PSD,ADATABEG        PICK UP PNTR TO BEGINNING OF
         LA    PSD,0(PSD,USER)     DATA TABLE
         LTR   CUR,CUR             IS THIS THE FIRST ENTRY IN DATA
*                                  TABLE
         BZ    DATZER              YES
         CH    R0,ADATALST         NO-IS THIS STATEMENT # >=
*                                  LAST ONE ENTERED IN TABLE?
         BL    DATINSRT            NO
         BH    DATZER              BRANCH IF IT IS GREATER
         LR    CUR,PSD             COMPUTE BEG OF DATA TABLE
DATLOOP1 CH    R0,0(CUR)           DOES CURRENT ST # = # IN TABLE?
         BE    DATFND              YES
         AH    CUR,2(CUR)          NO-BUMP TO NEXT ENTRY
         B     DATLOOP1
DATFND   SR    CUR,PSD
DATZER   LR    ST,CUR              SAVE DATA TABLE POINTER
         AR    CUR,T1              COMPUTE DISP IN DATA TABLE
*                                  IF THIS ENTRY WERE TO BE ADDED
         C     CUR,ACONSPTR        IS THERE ROOM FOR IT?
         BH    NOSPACD             NO
         STH   R0,ADATALST         YES-STORE THIS ST #
*                                  FOR COMPARE NEXT TIME IN
         ST    CUR,ADATAPTR        STORE UPDATED DATA TABLE PNTR
         S     CUR,FOUR
DATA0    STH   R0,0(ST,PSD)        STORE ST # IN DATA TABLE
         STH   T1,2(ST,PSD)        STORE SIZE OF ENTRY IN DATA TABLE
DATA1    LA    STMT,8(STMT)        BUMP LINE PNTR TO 1ST DATA ITEM
DATLOOP  LA    ST,4(ST)            BUMP PNTR TO DATA TABLE
         CR    ST,CUR              HAVE WE GOT ALL THE ITEMS STORED?
         BNL   DATFIL              YES
         L     R1,0(STMT)          NO-PICK UP NEXT DATA ITEM
         ST    R1,0(ST,PSD)        AND MOVE TO DATA TABLE
         LA    STMT,4(STMT)        BUMP PNTR TO LINE
         B     DATLOOP             GO PROCESS NEXT ITEM
*
DATFIL   L     T1,MNZERO           MAKE LAST ENTRY IN DATA TABLE FOR
         ST    T1,0(ST,PSD)        THIS ENTRY MINUS ZERO
         B     RET1
*
DATINSRT SR    ST,ST               INITIALIZE DATA TABLE POINTER
DATSRCH  CH    R0,0(PSD,ST)        IS THIS ST # < # IN TABLE?
         BNH   DATHERE             YES
         AH    ST,2(PSD,ST)        NO-BUMP DATA TABLE POINTER
*                                  TO PICK UP NEXT ENTRY
         B     DATSRCH
DATHERE  BNE   DATMOVE             IS THIS ST # = # IN TABLE
         CH    T1,2(PSD,ST)        YES-IS # OF ITEMS COMING IN SAME AS
*                                  BEFORE?
         BNE   DATMOV1             NO
DATA3    LA    CUR,0(ST,T1)        YES-THEN GO PUT NEW ITEMS IN
         S     CUR,FOUR
         B     DATA1               TABLE
DATMOVE  LA    CUR,0(T1,CUR)       BUMP PTR BY SIZE OF INCOMING INFO
         C     CUR,ACONSPTR        WILL THIS NEW DATA FIT IN TABLE?
         BH    NOSPACD             NO
         ST    CUR,ADATAPTR        YES-SAVE THE NEW PTR
         S     CUR,FOUR
DATA2    LR    R1,CUR              COMPUTE DISPLACEMENT OF 1ST DATA
         SR    R1,T1               TO BE MOVED
DATMOV   L     R8,0(R1,PSD)        PICK UP WORD TO BE MOVED
         ST    R8,0(CUR,PSD)       PUT IN NEW LOCATION
         S     R1,FOUR             BUMP POINTERS TO SOURCE AND
         S     CUR,FOUR            TARGET AREAS
         CR    R1,ST               HAVE WE MOVED EVERYTHING?
         BNL   DATMOV              NO
         CH    R0,0(ST,PSD)        IS THIS AN INSERT OF A NEW DATA
*                                  STATEMENT
         BNE   DATA0               YES
         B     DATA3               GO STORE NEW ENTRY
*
DATMOV1  LH    T2,2(PSD,ST)        PICK UP SIZE OF PREVIOUS ENTRY
         LR    R9,T1               COMPUTE DISPLACEMENT OF THE MOVE
         SR    R9,T2               (+IF FORWARD, - IF BACKWARD)
         CR    T1,T2               IS THIS A FORWARD MOVE
         BL    DATA4               NO
         AR    CUR,R9              COMPUTE NEW SIZE OF DATA TABLE
         C     CUR,ACONSPTR        IS THERE SPACE FOR THIS LARGER ENTRY
*                                  IN THE DATA TABLE?
         BH    NOSPACD             NO
         ST    CUR,ADATAPTR        YES-STORE THE NEW PTR
         STH   T1,2(PSD,ST)        STORE SIZE OF THIS NEW ENTRY IN
*                                  DATA TABLE
         S     CUR,FOUR
         LR    R1,CUR              COMPUTE DISP OF 1ST DATA ITEM
         SR    R1,R9               TO BE MOVED
         AR    T2,ST               COMPUTE DISP OF ITS LOC AFTER MOVE
         B     DATMOV              GO DO THE MOVE
DATA4    LA    R1,0(CUR,R9)        COMPUTE NEW SIZE OF DATA TABLE
         ST    R1,ADATAPTR         STORE THE NEW PTR
         AR    T2,ST               COMPUTE DISPLACEMENT OF 1ST ITEM TO
*                                  BE MOVED AND ITS LOCATION AFTER THE
         AR    R9,T2               MOVE
         STH   T1,2(PSD,ST)        STORE SIZE OF THIS NEW ENTRY IN
*                                  DATA TABLE
DATA5    L     R8,0(PSD,T2)        PICK UP WORD TO BE MOVED
         ST    R8,0(PSD,R9)        PUT IN NEW LOCATION
         LA    R9,4(R9)            BUMP POINTERS TO SOURCE AND
         LA    T2,4(T2)            TARGET AREAS
         CR    T2,CUR              HAVE WE MOVED EVERYTHING?
         BNH   DATA5               NO
         B     DATA3
*
*******************************************************************
         EJECT
********************************************************************
*
*                 SYNTAX ERROR HANDLER
*
*   THIS ROUTINE IS CALLED WHEN A STATEMENT HAS BEEN ENTERED WHICH HAS
*   A SYNTAX ERROR.  THE INPUT TO TRANS IS:
*
*     1ST HALFWORD - STATEMENT NUMBER
*     2ND HALFWORD - SYNTAX ERROR CODE X'0016'
*
*   AN ENTRY IS MADE IN THE LINES TABLE FOR THIS STATEMENT
*   NUMBER WITH THE SECOND HALFWORD X'0009'.
*
*   ON ENTRY TO THIS ROUTINE, REG R1 CONTAINS THE DISPLACEMENT PAST
*   USER OF THE ENTRY IN THE LINES TABLE OF THE STATEMENT CURRENTLY
*   BEING PROCESSED.
*
SYNTAXER LA    CUR,SYNCODE         SET SECOND HALFWORD OF LINES
         STH   CUR,2(R1,USER)      TO INDICATE A SYNTAX ERROR
         B     RET                 RETURN
*
*******************************************************************
*
*       CLEAR DATA STATEMENT PROCESSOR
*
*   THIS STATEMENT CAUSES THE ATOZ AND A0TOZ9 AREAS TO BE RESET TO
*   ZEROES AND THE ATOZSTRG AREA TO BE SET TO BLANK AT EXECUTION
*   TIME.
*
CLEARR   LA    ST,OPCLR            PICK UP CLEAR OP CODE
         BAL   RETURN,STORPS1      STORE IN PSEUDO TABLE
         B     RET
*
**********************************************************************
         EJECT
****************TABLE OVERFLOW ROUTINES*******************************
*
*   THESE ROUTINES ARE CALLED WHEN THERE HAS BEEN A TABLE OVERFLOW -
*   (EITHER A PSEUDO CODE, LINES, DATA OR FORC TABLE).  RUNERR IS
*   CALLED WITH R0 CONTAINING THE NUMBER OF THE STATEMENT
*   CURRENTLY BEING PROCESSED AND R1 AN ERROR CODE INDICATING
*   WHICH TABLE HAS OVERFLOWED.  RUNERR PRINTS AN ERROR MESSAGE
*   AND RETURNS TO TRANS.  REGISTER 0 IS THEN SET TO INDICATE WHICH
*   TABLE HAS OVERFLOWED AND TRANS RETURNS TO THE CONTROL PROGRAM.
*   TRANS WILL NOT BE CALLED AGAIN FOR THIS USER UNTIL THE OVERFLOW
*   PROBLEM HAS BEEN RESOLVED.
*
*            REGISTER 0        ERROR CONDITION
*            __________        _______________
*               1              PSEUDO TABLE OVERFLOW
*               2              LINES TABLE OVERFLOW
*               3              DATA TABLE OVERFLOW
*               4              FORC TABLE OVERFLOW
*
*     ********PSEUDO TABLE OVERFLOW*************
*
NOSPACP  LA    R1,CNOSPACP         PUT ERROR CODE IN REG 1
         L     EXPREG,ARUNER       CALL RUNERR TO PRINT
         BALR  RETURN,EXPREG       ERROR MESSAGE
         LA    R0,1                PUT ERROR CODE IN R0 FOR
*                                  CONTROL PROGRAM
         B     RET2                RETURN
*
*     ********LINES TABLE OVERFLOW**************
*
NOSPACL  LA    R1,CNOSPACL         PUT ERROR CODE IN REG 1
         L     EXPREG,ARUNER       CALL RUNERR TO PRINT
         BALR  RETURN,EXPREG       ERROR MESSAGE
         LA    R0,2                PUT ERROR CODE IN R0 FOR CONTROL
*                                  PROGRAM
         B     RET2                RETURN
*
*     ********DATA TABLE OVERFLOW***************
*
NOSPACD  LA    R1,CNOSPACD         PUT ERROR CODE IN REG 1
         L     EXPREG,ARUNER       CALL RUNERR TO PRINT
         BALR  RETURN,EXPREG       ERROR MESSAGE
         LA    R0,3                PUT ERROR CODE IN RO FOR CONTROL
*                                  PROGRAM
         B     RET2                RETURN
*
*     ********FORC TABLE OVERFLOW***************
*
NOSPACF  LA    R1,CNOSPACF         PUT ERROR CODE IN REG 1
         L     EXPREG,ARUNER       CALL RUNERR TO PRINT
         BALR  RETURN,EXPREG       ERROR MESSAGE
         LA    R0,4                PUT ERROR CODE IN R0 FOR CONTROL
*                                  PROGRAM
         B     RET2                RETURN
*
**********************************************************************
         EJECT
******************PSEUDO TABLE STORE ROUTINES***********************
*
*   THESE ROUTINES STORE INFORMATION IN THE PSEUDO TABLE.  EACH ENTRY
*   IN THE PSEUDO TABLE IS 3 HALFWORDS LONG.
*
*        1ST HALFWORD - OPERATION CODE
*        2ND HALFWORD - FIRST OPERAND (IF ANY)
*        3RD HALFWORD - SECOND OPERAND (IF ANY)
*
*   ON ENTRY TO THESE ROUTINES, THE 3 ARGS ARE CONTAINED IN REGISTERS
*   ST, T1, T2 RESPECTIVELY.
*   THE PSEUDO TABLE IS NOT AN ORDERED TABLE.
*   IF A USER DELETES OR REPLACES A STATEMENT, THE PSEUDO CODE FOR THIS
*   STATEMENT REMAINS IN THE TABLE.  IT CANNOT BE REMOVED SINCE
*   REMOVING IT WOULD MAKE THE LINES TABLE POINTERS WRONG.  THIS
*   PSEUDO IS NEVER EXECUTED SINCE NO LINES TABLE POINTERS POINT TO IT.
*
STORPS1  L     CUR,ACODEPTR        PICK UP DISPLACEMENT IN USER AREA OF
*                                  LAST PSEUDO TABLE ENTRY
         C     CUR,ACODESIZ        IS THERE SPACE FOR ANOTHER ENTRY IN
*                                  THE TABLE?
         BNL   NOSPACP             NO
         LA    PSD,6(CUR)          BUMP TO NEXT ENTRY
         AL    CUR,ACODEBEG
         STH   ST,0(CUR,USER)      STORE THE PSEUDO CODE
         ST    PSD,ACODEPTR        YES-SAVE POINTER TO THIS ENTRY
         BR    RETURN              RETURN
*
**********************************************************************
*
STORPS2  L     CUR,ACODEPTR        PICK UP DISPLACEMENT IN USER AREA OF
*                                  LAST PSEUDO TABLE ENTRY
         C     CUR,ACODESIZ        IS THERE SPACE FOR ANOTHER ENTRY IN
*                                  THE TABLE?
         BNL   NOSPACP             NO
         LA    PSD,6(CUR)          BUMP TO NEXT ENTRY
         AL    CUR,ACODEBEG
         STH   ST,0(CUR,USER)      SAVE PSEUDO CODE
         STH   T1,2(CUR,USER)      SAVE 2ND HALFWORD OF PSEUDO CODE
         ST    PSD,ACODEPTR        YES-SAVE POINTER TO THIS ENTRY
         BR    RETURN              RETURN
***********************************************************************
*
STORPS3  L     CUR,ACODEPTR        PICK UP DISPLACEMENT IN USER AREA OF
*                                  LAST PSEUDO TABLE ENTRY
         C     CUR,ACODESIZ        IS THERE SPACE FOR ANOTHER ENTRY IN
*                                  THE TABLE?
         BNL   NOSPACP             NO
         LA    PSD,6(CUR)          BUMP TO NEXT ENTRY
         AL    CUR,ACODEBEG
         STH   ST,0(CUR,USER)      SAVE PSEUDO CODE
         STH   T1,2(CUR,USER)      SAVE 2ND HALFWORD OF PSEUDO CODE
         STH   T2,4(CUR,USER)
         ST    PSD,ACODEPTR        YES-SAVE POINTER TO THIS ENTRY
         BR    RETURN              RETURN
********************************************************************
         EJECT
**************************STORE LINE***********************************
*
*   THIS ROUTINE BUILDS THE LINES TABLE.  ENTRIES IN THIS TABLE ARE
*   2 HALFWORDS LONG.
*
*       1ST HALFWORD - STATEMENT NUMBER
*       2ND HALFWORD - POINTER TO PSEUDO TABLE CODE FOR THIS STATEMENT
*
*   FOR NON-EXECUTABLE STATEMENTS THE SECOND HALFWORD IS A STATEMENT
*   DESCRIPTOR.
*               0001  DIM
*               0003  DATA
*               0005  REM
*               0007  DEF
*               0009  STATEMENT WITH A SYNTAX ERROR
*
*   STORLN IS ENTERED WITH REG 'R0' CONTAINING A HALFWORD
*   BINARY STATEMENT NUMBER.  THIS NUMBER IS A USER SPECIFIED LINE
*   NUMBER. ON EXIT FROM THIS ROUTINE R1 CONTAINS THE DISPLACEMENT
*   PAST USER WHERE THIS ENTRY WAS PLACED IN THE LINES TABLE.
*
*   THE LINES TABLE IS AN ORDERED TABLE - BY STATEMENT NUMBER.  IF
*   STATEMENTS COME IN OUT OF ORDER, THIS ROUTINE MOVES PART OF THE
*   TABLE DOWN AND MAKES AN INSERTION.
*
*   IF A STATEMENT NUMBER BEING PROCESSED ALREADY EXISTS IN THE LINES
*   TABLE (I.E. A USER IS REPLACING A STATEMENT) THEN THE DELETE
*   STATEMENT ROUTINE IS CALLED TO DELETE ANY POSSIBLE ENTRIES
*   MADE IN THE FORC, ATOZ, ATOZSTRG OR ATOZFCT TABLES BY THE OLD
*   STATEMENT.  THEN PROCESSING OF THE NEW STATEMENT CONTINUES.
*
STORLN   L     R1,ALINEPTR         PICK UP DISP OF LINE POINTER
         LR    PSD,R1              SAVE FOR LATER
         AL    R1,ALINEBEG         BUMP BY DISP OF LINE TABLE
         LTR   PSD,PSD             IS THIS FIRST ENTRY IN LINES?
         BZ    PUTAWAY             YES
         S     R1,FOUR             NO-BUMP BACK TO LAST ENTRY
         CH    R0,0(R1,USER)       IS THIS ST # > LAST # IN LINES TABLE
         BE    STLN1
         BL    SEARCH              NO
         LA    R1,4(R1)            BUMP PNTR BACK TO THIS ENTRY
         C     PSD,ALINESIZ        IS THERE SPACE FOR ANOTHER ENTRY?
         BNL   NOSPACL             NO
PUTAWAY  STH   R0,0(R1,USER)       STORE ST. # IN LINES TABLE
         LA    PSD,4(PSD)          BUMP POINTER TO NEXT ENTRY
         ST    PSD,ALINEPTR        STORE UPDATED POINTER
STPSDISP L     ST,ACODEPTR         PICK UP DISP OF CURRENT ENTRY IN
*                                  PSEUDO TABLE
         STH   ST,2(R1,USER)       STORE THIS DISP IN LINES TABLE
         B     SETEXPB             RETURN
SEARCH   LA    R1,ALINEBEG         PICK UP LINES TABLE BEGINNING FOR
*                                  BINARY SEARCH
* * * * * *
*   BINARY SEARCH IS CALLED WITH TWO ARGUMENTS - R0 CONTAINS THE LINE
*   NUMBER TO BE SEARCHED FOR IN THE TABLE;  R1 CONTAINS THE
*   DISPLACEMENT IN THE USER AREA OF THE TABLE TO BE SEARCHED.
*   BINARY SEARCH RETURNS IN R1 THE DISPLACEMENT PAST USER OF THE
*   ENTRY FOR THIS STATEMENT NUMBER, IF IT WAS FOUND.  IF IT WAS NOT
*   FOUND, R1 CONTAINS THE DISPLACEMENT PAST USER WHERE THE NEW
*   ENTRY SHOULD BE PLACED AND THE HIGH ORDER BIT OF R1 IS ON TO
*   INDICATE THE NOT FOUND CONDITION.
*
         L     EXPREG,BINSRCH
         BALR  RETURN,EXPREG       CALL THE BINARY SEARCH ROUTINE
         LTR   CUR,R1              WAS THERE AN ENTRY FOR THIS ST #
*                                  IN LINES TABLE?
         BP    STLN1               YES
         C     PSD,ALINESIZ        IS THERE SPACE FOR ANOTHER ENTRY?
         BNL   NOSPACL             NO
         LA    PSD,4(PSD)          YES-BUMP THE LINES TABLE POINTER
         ST    PSD,ALINEPTR        SAVE THE BUMPED POINTER
         L     T1,ACODEPTR         PICK UP DISP OF CURRENT ENTRY IN
*                                  PSEUDO TABLE
         AL    PSD,ALINEBEG
         L     T2,0(CUR,USER)      PICK UP 1ST LINES ENTRY TO BE MOVED
         STH   R0,0(CUR,USER)      STORE LINE # OF NEW ENTRY IN LINES
         STH   T1,2(CUR,USER)      STORE PSEUDO TABLE DISP FOR THIS
*                                  LINE
         LA    CUR,4(CUR)          BUMP LINES PNTR TO NEXT ENTRY
AGAIN    L     T1,0(CUR,USER)      PICK UP NEXT LINES ENTRY
         ST    T2,0(CUR,USER)      STORE LAST LINES ENTRY
         LR    T2,T1               MOVE LINES ENTRY
         LA    CUR,4(CUR)          BUMP LINES TABLE POINTER
         CR    CUR,PSD             ARE THERE MORE ENTRIES TO BE MOVED
         BL    AGAIN               YES
         B     SETEXPB             NO-RETURN
*
STLN1    LR    R9,R1               SAVE REG R1
         LA    RETURN,0(R1,USER)   WAS THE STATEMENT BEING REPLACED A
         CLI   3(RETURN),DEFFCODE  DEFINE FILE STATEMENT?
         BNE   STLN3               NO
         LA    R7,4(R7)            YES-BUMP RETURN REGISTER
         CLI   3(STMT),SYMDEF      IS THE STATEMENT COMING IN A DEFINE
*                                  FILE
         BE    STLN3               YES
         LA    R7,8(R7)            NO-BUMP RETURN REG AGAIN
STLN3    LA    PSD,0(R1,USER)
         CLI   3(PSD),X'03'        IS THE STATEMENT BEING REPLACED A
*                                  DATA STATEMENT?
         BNE   DELHERE             NO-GO TO DELETE
         CLI   3(STMT),X'15'       YES-IS THE INCOMING STATEMENT A
*                                  DATA STATEMENT?
         BE    SETEXPB             YES -RETURN - A DATA STATEMENT ST
*                                  REPLACEMENT CAN BE HANDLED BY THE
*                                  DATA STATEMENT PROCESSOR.
         B     DELHERE             GO TO DELETE ROUTINE TO DELETE
*                                  POSSIBLE TABLE ENTRIES MADE BY OLD
*                                  STATEMENT BEFORE WE UPDATE TO NEW
*
STLN2    LR    R1,R9
         B     STPSDISP
********************************************************************
         EJECT
************************STORE FORC************************************
*
*   THIS ROUTINE BUILDS THE FORC TABLE.  AN ENTRY IS PUT IN THIS TABLE
*   FOR EACH FOR AND NEXT STATEMENT IN THE USERS PROGRAM.  ENTRIES IN
*   THE TABLE ARE 2 HALFWORDS LONG.
*
*       1ST HALFWORD - STATEMENT NUMBER
*       2ND HALFWORD - FOR OR NEXT INDEX
*
*   IF THE ENTRY IS FOR A NEXT STATEMENT (RATHER THAN A FOR) THE HIGH
*   ORDER BIT OF THE 2ND HALFWORD IS ON TO INDICATE THIS.
*
*   THE FORC TABLE IS AN ORDERED TABLE - BY STATEMENT NUMBER.  IF
*   STATEMENTS COME IN OUT OF ORDER, THIS ROUTINE MOVES PART OF THE
*   TABLE DOWN AND MAKES THE INSERTION IN THE REQUIRED PLACE.
*
*   THERE ARE TWO ARGUMENTS TO THIS ROUTINE AND THEY ARE CONTAINED
*   IN TWO REGISTERS:
*               REGISTER R0 CONTAINS THE STATEMENT NUMBER
*               REGISTER T1 CONTAINS THE FOR OR NEXT INDEX
*
*
STORFC   L     CUR,AFORCPTR        PICK UP DISP IN FORC TABLE OF LAST
*                                  ENTRY
         LR    PSD,CUR             SAVE FOR LATER
         AL    CUR,AFORCBEG        BUMP BY DISP OF FORC TABLE
         LTR   PSD,PSD             IS THIS FIRST ENTRY IN FORC?
         BZ    FIRST               YES
         C     PSD,AFORCSIZ        IS THERE SPACE FOR ANOTHER ENTRY?
         BNL   NOSPACF             NO
         S     CUR,FOUR            BUMP BACK TO LAST ENTRY
         CH    R0,0(CUR,USER)      IS THIS ST # > LAST # IN LINES TABLE
         BL    FSEARCH             NO
         LA    CUR,4(CUR)          BUMP PNTR BACK TO THIS ENTRY
FIRST    STH   R0,0(CUR,USER)      STORE STATEMENT #
         LA    PSD,4(PSD)          BUMP POINTER TO NEXT ENTRY
         ST    PSD,AFORCPTR        SAVE
         STH   T1,2(CUR,USER)      STORE FOR OR NEXT INDEX
         BR    RETURN              RETURN
FSEARCH  LA    R1,AFORCBEG         PICK UP FORC TABLE BEGINNING FOR
*                                  BINARY SEARCH
         LR    T2,RETURN
         LR    CUR,EXPREG          SAVE REGISTERS
* * * * * *
*   BINARY SEARCH IS CALLED WITH TWO ARGUMENTS - R0 CONTAINS THE LINE
*   NUMBER TO BE SEARCHED FOR IN THE TABLE;  R1 CONTAINS THE
*   DISPLACEMENT IN THE USER AREA OF THE TABLE TO BE SEARCHED.
*   BINARY SEARCH RETURNS IN R1 THE DISPLACEMENT PAST USER OF THE
*   ENTRY FOR THIS STATEMENT NUMBER, IF IT WAS FOUND.  IF IT WAS NOT
*   FOUND, R1 CONTAINS THE DISPLACEMENT PAST USER WHERE THE NEW
*   ENTRY SHOULD BE PLACED AND THE HIGH ORDER BIT OF R1 IS ON TO
*   INDICATE THE NOT FOUND CONDITION.
*
         L     EXPREG,BINSRCH
         BALR RETURN,EXPREG        CALL BINARY SEARCH
         LR    RETURN,T2           RESTORE REGISTERS
         LR    EXPREG,CUR
         LR    CUR,R1              PICK UP DISP OF ENTRY IN LINES
*                                  WHERE THIS NEW ENTRY IS TO BE
*                                  PLACED.
         LA    PSD,4(PSD)          BUMP FORC POINTER
         ST    PSD,AFORCPTR        SAVE
         AL    PSD,AFORCBEG
         L     T2,0(CUR,USER)      PICK UP 1ST FORC ENTRY TO BE MOVED
         STH   R0,0(CUR,USER)      STORE LINE # IN FORC TABLE
         STH   T1,2(CUR,USER)      STORE FOR OR NEXT INDEX IN FORC
*                                  TABLE
         LA    CUR,4(CUR)          BUMP PNTR TO NEXT ENTRY
FAGAIN   L     T1,0(CUR,USER)      PICK UP NEXT FORC ENTRY
         ST    T2,0(CUR,USER)      STORE LAST FORC ENTRY
         LR    T2,T1               MOVE FORC ENTRY
         LA    CUR,4(CUR)          BUMP FORC TABLE POINTER
         CR    CUR,PSD             ARE THERE MORE ENTRIES TO BE MOVED?
         BL    FAGAIN              YES
         BR    RETURN              NO-RETURN
*
*******************************************************************
         EJECT
********************STORE IN FNA-FNZ TABLE***********************
*
*   THIS ROUTINE IS ENTERED WITH REG 'R0' CONTAINING A
*   STATEMENT NUMBER AND REG 'ST' CONTAINING AN INDEX
*   00 TO 19, INDICATING WHICH FUNCTION (FNA TO FNZ)
*   IS BEING PROCESSED.  THE STATEMENT NUMBER IS
*   STORED IN THE FIRST HALFWORD OF THE ENTRY IN THE ATOZFCT TABLE.
*   THE CURRENT PSEUDO TABLE POINTER IS STORED IN THE SECOND
*   HALFWORD OF THE ENTRY FOR THIS ST. R1 CONTAINS THE DISPLACEMENT
*   PAST USER WHERE THE LINES ENTRY FOR THIS STATEMENT IS MADE.
*   IF THE FUNCTION BEING DEFINED HAS PREVIOUSLY BEEN DEFINED, AN ERROR
*   MESSAGE IS PRINTED TELLING THE USER THIS STATEMENT IS BEING
*   IGNORED SINCE THE FUNCTION WAS ALREADY DEFINED.  PROCESSING
*   CONTINUES.
*
STORFN   SLL   ST,2                MULTIPLY FUNCTION CODE BY 4 TO FIND
*                                  DISPLACEMENT IN FN TABLE.
         LA    CUR,ATOZFCT         PICK UP ADDR OF FN TABLE
         L     T1,0(CUR,ST)        PICK UP FIRST HALFWORD OF ENTRY
         LTR   T1,T1               IS IT ZERO?
         BZ    DEFNEW              YES-THIS FUNCTION HAS NOT YET BEEN
*                                  DEFINED.
         L     T1,ALINEPTR         PICK UP CURRENT SIZE OF LINES TABLE
         S     T1,FOUR             UPDATE THE PNTR TO LINES TABLE
         ST    T1,ALINEPTR         AND STORE IT AWAY
         LA    PSD,0(R1,USER)      PICK UP LOC OF ENTRY IN LINES TO BE
*                                  DELETED
         S     R1,ALINEBEG
         SR    T1,R1               COMPUTE # OF BYTES TO BE MOVED
         LNR   ST,SAVER            SET MESSAGE CODE FLAG TO  MINUS FOR
*                                  DUP DEF
         B     DEL21               GO TO DELETE LINES ENTRY
DEFNEW   LA    CUR,ATOZFCT         PICK UP ADDRESS OF DEFN TABLE
         STH   R0,0(ST,CUR)        STORE ST. # IN DEFN TABLE
         L     T2,ACODEPTR         STORE PSEUDO TABLE POINTER IN 2ND
         STH   T2,2(ST,CUR)        WORD OF DEFN TABLE.
         BR    RETURN
*
*****************************************************************
         EJECT
************************** local storage ***************************
         DS    0F
FOUR     DC    F'4'
SIX      DC    F'6'
MNZERO   DC    X'80000000'         MINUS ZERO FOR DATA TABLE
TENTHOU  DC    H'9999'
*
FCODE1   DC    X'6001'             INTERNAL CODE FOR 1-DEFAULT FOR STEP
OPCONDBR EQU   X'0200'             COND. BRANCH INST.
OPBRNCH  EQU   X'0201'             BRANCH INSTRUCTION
OPRES    EQU   X'0203'             RESTORE OP CODE
OPGOSBR  EQU   X'0202'             GO SUB STACK AND BRANCH OP CODE
OPEND    EQU   X'0204'             END OP CODE
OPSTOP   EQU   X'0205'             STOP OP CODE
OPPAUS   EQU   X'0206'             PAUSE OP CODE
OPRET    EQU   X'0207'             UNSTKGSBR OP CODE
OPDMP    EQU   X'0208'             DUMP OP CODE
OPSAVDF  EQU   X'0209'             SAVEDF OP CODE
OPUNSDFB EQU   X'020A'             UNSTACK DF BR OP CODE
OPON     EQU   X'020B'             COMPUTED GO TO OP CODE
OPCLR    EQU   X'020C'             CLEAR DATA OP CODE
*
OPSTACK  EQU   X'0100'             FOR STACK OP CODE
OPMAX    EQU   X'0101'             OP MAX OP CODE
OPSTEP   EQU   X'0102'             OP STEP OP CODE
OPCMPTBR EQU   X'0103'             COMPARE,TEST AND BRANCH OP CODE
OPPFR    EQU   X'0104'             + FOR OP CODE
*
RIO      EQU   X'0400'             READ OP CODE
PIO      EQU   X'0401'             PRINT OP CODE
RINIO    EQU   X'0402'             READ(I) INITIALIZER OP CODE
RIIO     EQU   X'0403'             READ(I) OP CODE
WINIO    EQU   X'0404'             WRITE(N,I) INITIALIZER OP CODE
WIIO     EQU   X'0405'             WRITE(I) OP CODE
IIO      EQU   X'0406'             INPUT OP CODE
MATRD    EQU   X'0407'             MAT READ OP CODE
MATPR    EQU   X'0408'             MAT PRINT OP CODE
MATIP    EQU   X'0409'             MAT INPUT OP CODE
MATRDI   EQU   X'040A'             MAT READ (I) OP CODE
MATWRI   EQU   X'040B'             MAT WRITE (I) OP CODE
PUIO     EQU   X'040C'             PRINT USING OP CODE
IMGIO    EQU   X'040D'            IMAGE STMT OP CODE
PIOU     EQU   X'040E'            ADD. I/O ITEMS OF PRINT USING
MATPUIO  EQU   X'040F'            MAT PRINT USING OP CODE
MATPRU   EQU   X'0410'            ADD. I/O ITEMS OF MAT PRINT USING
SYMEND   EQU   X'0D'
SYMSTEP  EQU   X'01'
SYMBLNK  EQU   X'05'
SYMDEF   EQU   X'19'
SYMPRN   EQU   X'0C'
SYMDEL   EQU   X'14'               CODE FOR DELETE STATEMENT
SYMIO    EQU   X'0B'
DIMCODE  EQU   X'01'               CODE FOR DIM STATEMENT IN LINES
DATCODE  EQU   X'03'               CODE FOR DATA IN LINES
REMCODE  EQU   X'05'               CODE FOR REM STATEMENT IN LINES
DEFCODE  EQU   X'07'               CODE FOR DEFN STATEMENT IN LINES
SYNCODE  EQU   X'09'               LINES TABLE CODE FOR STATEMENT WITH
*                                  SYNTAX ERROR
DEFFCODE EQU   X'0B'               CODE FOR DEFINE FILE STATEMENT IN
*                                  LINES
*
CDIMDUP  EQU   2001                DUPLICATE DIM ERROR CODE
CDEFDUP  EQU   2002                DUPLICATE DEF ERROR CODE
CNOSPACP EQU   2003                ERROR CODE FOR NO MORE SPACE IN
*                                  PSEUDO TABLE
CNOSPACL EQU   2004                ERROR CODE FOR LINES TABLE OVERFLOW
CNOSPACD EQU   2005                ERROR CODE FOR DATA TABLE OVERFLOW
CNOSPACF EQU   2006                ERROR CODE FOR FORC TABLE OVERFLOW
         DS    0F
EXPBASE  DC    V(EXPR)             BASE OF 'EXPR'
BINSRCH  DC    V(BINR)             BASE OF 'BINR'
ARUNER   DC    V(RUNERR)
         DS    0H
PUH1     DC    X'040C'            PRINT USING
MPUH1    DC    X'040F'            MAT PRINT USING
R0       EQU   0                   CONTAINS # OF STATEMENT BEING
*                                  PROCESSED
R1       EQU   1                   TEMPORARY REGISTER
CUR      EQU   2                   TEMPORARY REGISTER
BASE     EQU   3                   BASE REGISTER
T2       EQU   4                   TEMPORARY REGISTER
PSD      EQU   5                   TEMPORARY REGISTER
ST       EQU   6                   TEMPORARY REGISTER
R7       EQU   7                   HOLDS RETURN ADDRESS
R8       EQU   8                   TEMPORARY REGISTER
R9       EQU   9                   TEMPORARY REGISTER
T1       EQU   10                  TEMPORARY REGISTER
USER     EQU   11                  POINTS TO USER AREA
STMT     EQU   12                  POINTER TO LINE BEING PROCESSED
SAVER    EQU   13                  POINTER TO SAVE AREA
RETURN   EQU   14                  RETURN REG USED FOR BAL'S TO THE
*                                  STORX,EXPR & INLINE ROUTINES.
EXPREG   EQU   15                  BASE OF 'EXPR'
         EJECT
AREA     DSECT
         COPY  AREA
         END
