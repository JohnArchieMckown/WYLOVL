PAGESERV TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         COPY  HEADER
RPCB     REG   RY                      For addressing the PCB
RPAG     REG   RX                      For addressing the PAGSERV CB
RCPCB    REG   RK                      For addressing the common PCB
         SPACE
         COPY  VSWAP                   Do virtual swaps?
         SPACE
         COPY  VLEN                    Virtual len swaps?
         SPACE
         DEFCC VAOK,8                  Virtual addr OK (LRA)
         DEFCC SEGI,4                  Segment table entry invalid
         DEFCC PAGI,2                  Page table entry invalid
         DEFCC SPLI,1                  Segment/Page tbl len invalid
         DEFCC VAXI,6                  Virtual addr translation
*                                      Either page/segment invalid
         SPACE
         DEFCC NOREF,8                 Frame not referenced/changed
         DEFCC OCHG,4                  Frame changed
         DEFCC OREF,2                  Frame referenced
         DEFCC REFCH,1                 Frame referenced & changed
         DEFCC REF,3                   Frame referenced
         DEFCC CHG,5                   Frame changed
         SPACE
PAGESERV MODULE TRCNUM=4
         EJECT
*  Notes on muliple faults in one AS:
*    Need a PCB extension per task
*    PIO completion must be signaled with a PID, not just an ASB
*    Page fault resolve notes:
*     BEFORE any routines that could wait (and release the local
*        PAGING lock) the page fault routines must:
*      set the real address of the frame in PGAD
*        any subsequent faults seeing "fault handled" will use this
*        real address to find the waiting PCB and queue itself up
*      short term fixes for page table should be incremented
*        if not incremented, then the page table could be trimmed
*        from the working set if no pages were set as active in it
*      flag set for page fault handled
*  PAGESERV:
*    PTLB considerations
*     If a segment table is swapped out, and is then reused as
*     a segment table for another address space on a CPU which
*     hasn't purged its TLB, the DAT process could be in error.
*  Optimizations:
*    Could PAGWAIT use cell ECB for some waits & be task based?
*    SWAP on pages
         EJECT
*                     PAGE/SEGMENT FAULT NOTES
*
*   When a page I/O is in progress, the page table entry is marked
* as "in I/O", using one of the available software flags in the
* page table entry (PGTFIO).
*   When a segment I/O is in progress, the shadow segment table is
* marked as "in I/O" using the SSTFIO flag.
*   Page tables also have virtual addresses, and the page table entry
* for a page table's virtual address is marked to show that this
* is a page table page (PGTFPGT).
*   If a page fault occurs on a page that is "in I/O", the page
* table entry contains the frame address of the I/O.  The faulting
* process should look in the page frame table for the I/O control
* block, and queue itself up as a waiting process.
*   Page faults on pages not "in I/O" are handled differently for
* normal pages and page table pages.  For non page table pages
* the shadow page table holds the external block number, the
* page in is requested, and the page table entry is marked as
* "in I/O".
*   Page faults on page table pages (not "in I/O") have
* to deal with fixing up segment table entries as well as page
* table entries.  Because of this, when a page table is not
* in main store, the frame address is set to the segment number
* that this page table represents.  For example, the page table for
* segment 5 will have a page table entry like X'005004xx'.  This
* indicates an invalid page, but the software flag that says it's
* a page table page indicates that the frame address is
* significant.
*   When a page table is not in core, the segment table entry is set
* to the virtual address of the page table.  A segment fault uses
* this address to set the page table entry as "in I/O", as well
* as setting the
*
*                        SWAP flags and Frame counts
*
*  Each PCB has flags that indicate the swap in/out status of
*  an address space, and whether it's frames have been reused
*  after a swap out.
*
*    PCBFSOUT  indicates that the address space is considered
*              swapped out by the dispatcher (and not requested
*              to be brought back in)
*    PCBFISOUT indicates that the address space is considered out
*              by the paging/swapping manager
*    PCBFRSIN  indicates that a swap-in was requested before
*              the swap-out I/O completed, and the request
*              will be handled at the swap-out I/O completion.
*
*    MATPAGFN  This number is managed by PAGESERV and looked at
*              by DISPATCH.  The number is computed absolutely
*              when an address space is sent out by the dispatcher
*              (PAGOSWAP), and when a swap out segment finishes
*              it's I/O (PAGOSEND).  Otherwise the MATPAGFN number
*              is simply computed as a difference between its
*              old value and a specific delta.
*
*                        PAGESERV LOCK NOTES
* 1) Local address space lock
*    Location: PCBLOCK
*    Prio:     This lock is usually the first to be obtained when
*              doing management of an address space's real memory.
*              If the global lock is to be held too, this lock must
*              be obtained first.
*    Use:      This lock serializes the manipulation of all segment
*              and page tables (hardware and shadow) for the
*              local section of this address space, and the
*              manipulation of page frame table entries (PFTEs)
*              that are linked on this PCB as used frames.
*              Flags and other entries in the PCB are also
*              serialized by this lock.  The exception is the flag
*              for frames of a swapped address space.  This flag is
*              governed by the Frames lock.
* 2) Common address space lock
*    Location: PCBLOCK in ASB pointed to by PAGCASB
*    Prio:     If a local lock is to be held too, the local lock must
*              be obtained first.
*    Use:      This lock serializes the manipulation of all segment
*              and page tables (hardware and shadow) for the common
*              section of all address spaces, the manipulation of
*              fields within the common PCB, and the manipulation of
*              page frame table entries (PFTEs) that are linked on
*              the ASB as used frames.
* 3) Free frames lock
*    Location: PAGFRAL
*    Prio:     If this lock is to be held concurrently with another
*              AS lock, the other AS lock must be held first, unless
*              the AS lock is obtained for an AS being swapped in.
*    Use:      This lock serializes the manipulation of the free
*              frames pool.
* 4) Swap control lock
*    Location: PAGSWAPL
*    Prio:     If this lock is to be held concurrently with another
*              AS lock, the other AS lock must be held first.
*    Use:      This lock serializes the manipulation of swapped out
*              address spaces, and whether or not they own frames.
*              This lock governs the swap flags in a
*              PCB (PCBSFLG). This lock is used for manipulating the
*              queues of swapped out address spaces and the frame
*              counts represented by those queues.
* 5) ASN maniuplation lock
*    Location: PAGASNL
*    Prio:     If this lock is to be held concurrently with another
*              PAGESERV lock (PCBLOCK or otherwise) the other lock
*              must be held first.
*    Use:      This lock serializes the manipulation the ASN tables.
         TITLE 'PAGESERV - Local macros'
         COPY  LISTPARM
         EJECT
         COPY  LSTMAC
         EJECT
         MACRO
&L       LKOB  &LOCK
.*
.* AUTOMATE THE CALLING SEQUENCE FOR LOCKOB
.*
&L       PSET  @LOCKS,CLEAR=NO
         PMOV  @LOCKID,&LOCK
         ACALL PAGLKOB
         MEND
         SPACE
         MACRO
&L       LKREL &LOCK
.*
.* AUTOMATE THE CALLING SEQUENCE FOR LOCKRL
.*
&L       PSET  @LOCKS,CLEAR=NO
         PMOV  @LOCKID,&LOCK
         ACALL PAGLKREL
         MEND
         SPACE
         MACRO
&L       SLKOB &LOCK,&PSWM             Get spin lock - disabling
&L       STNSM &PSWM,DISABLE           Only leave DAT on
         LKOB  &LOCK
         MEND
         SPACE
         MACRO
&L       SLKRL &LOCK,&PSWM             Release spin lock - reenable
&L       LKREL &LOCK
         SSM   &PSWM
         MEND
         SPACE
         MACRO
&L       PAGNTRY &TYPE,&MASK,&FLG
         GBLC  &$PROC
         LCLC  &SYNC
         AIF   ('&TYPE' EQ 'SYNC').OK,('&TYPE' EQ 'ASYNC').OK
         MNOTE 8,'&TYPE is invalid, must be ASYNC or SYNC'
.OK      ANOP  ,
         MNOTE *,'Disable, get PCB lock, and save lock flags'
         AIF   ('&TYPE' EQ 'ASYNC').NOTSYNC
&SYNC    SETC  '*PCBFSYNC'
.NOTSYNC ANOP  ,
&L       SLKOB PCBLOCK,&MASK           Get local lock
         MVC   &FLG,PCBLOCKF           | save old flags
         SET   (PCBFLCL&SYNC,EQ)
         IF    PCBFGBLC,'SET (PCBFGBL&SYNC,EQ)' this IS global AS
         MEND  ,
         SPACE
         MACRO
&L       PAGXIT &TYPE,&MASK,&FLG,&CPCB=,&WR=
         GBLB  &$OK
         GBLA  &$REG#
         LCLA  &USREG
         LCLB  &SYNC
         LCLC  &COMPCB                 Common PCB register
         AIF   ('&TYPE' EQ 'SYNC').OK,('&TYPE' EQ 'ASYNC').OK
         MNOTE 8,'&TYPE is invalid, must be ASYNC or SYNC'
.OK      ANOP  ,
         AIF   ('&TYPE' NE 'SYNC').AFLG
&SYNC    SETB  1
.AFLG    ANOP
.*
         MNOTE *,'Restore old lock flags, free PCB lock, and enable'
&COMPCB  SETC  '&CPCB'
&L       DS    0H
         IC    &WR,PCBLOCKF
         MVC   PCBLOCKF,&FLG           Restore previous locks
         STC   &WR,&FLG
         IF    &FLG..PCBFGBL,BEGIN     Global lock held?
.*
.*  Get global PCB addressability
.*
         AIF   ('&COMPCB' NE '').INREGAS
         L     RCPCB,PAGCASB
         WITH  (ASB,RCPCB),'L RCPCB,ASBPAGB'
&COMPCB  SETC  'RCPCB'
.*
.*  Only use a WITH statement if the PCB does not have an active
.*  using, or the using is with a register other than the one
.*  specified
.*
.INREGAS $USLKUP ASBPCB
         AIF   (NOT &$OK).USEAS
&USREG   SETA  &$REG#
         $RGLKUP &COMPCB
         AIF   (NOT &$OK).USEAS
         AIF   (&USREG NE &$REG#).USEAS
         LKREL PCBLOCK
         AGO   .NOUSEAS
.USEAS   WITH  (ASBPCB,&COMPCB),'LKREL PCBLOCK' Free lock
.NOUSEAS ANOP  ,
         END   ,                       OF Global lock held?
         IF    &FLG..PCBFLCL,BEGIN     Local lock held?
         LKREL PCBLOCK                 Free lock
         END   ,                       OF Local lock held?
         SSM   &MASK                   Reset the system mask - enable
         MEND  ,
         SPACE
         MACRO
&L       PAGAD &REG,&BEGIN             Get addr to PAG ctl block
         USING PZERO,R0
&L       L     &REG,PZMATP
         DROP  R0
         WITH  (MAT,&REG),'L &REG,MATPAGCB'
         AIF   ('&BEGIN' NE 'BEGIN').NOBLK
         WITH  (PAGCB,&REG),BEGIN
         MEXIT ,
.NOBLK   WITH  (PAGCB,&REG)
         MEND
         SPACE
         MACRO
&L       PAGPRC &RA,&PCB,&PCBC,&IOCB
&L       PSET  @PAGPIOC
         PMOV  @PCRA,&RA               Real frame address
         PMOV  @PCPCB,&PCB             PCB that owns frame
         PMOV  @PCPCBC,&PCBC           PCB in control
         AIF   ('&IOCB' EQ '').NOIOCB
         PMOV  @PCIOCB,&IOCB           I/O Control block
.NOIOCB  ANOP  ,
         ACALL PAGPRC
         MEND  ,
         SPACE
         MACRO
&L       VIRTABL &VA,&PCB
&L       PSET  @VIRTABL
         PMOV  @VPVA,&VA
         PMOV  @VPPCB,&PCB
         ACALL VIRTABL
         MEND
         SPACE
         MACRO
&L       RTOV  &ADDR                   Real to Virtual
&L       LABEL ,
         PSET  @PAGRV
         PMOV  @PAGRVAD,&ADDR          Real address
         ACALL PAGRV
         MEND
         SPACE
         MACRO
&L       QSFIX &FRAME,&PFTE=           Short term fix
&L       LABEL ,
        $L     EPAR,&FRAME
         SRL   EPAR,L'PAGPAGM
         SLL   EPAR,PFTLOG
         AL    EPAR,PAGPFTO
         WITH  (PFTE,EPAR),BEGIN
         INCR  RAR,PFTSFIX
         END   ,
         MEND
         SPACE
         MACRO
&L       QUSFIX &FRAME                 Short term un-fix
&L       LABEL ,
        $L     EPAR,&FRAME
         SRL   EPAR,L'PAGPAGM
         SLL   EPAR,PFTLOG
         AL    EPAR,PAGPFTO
         WITH  (PFTE,EPAR),BEGIN
         LH    RAR,PFTSFIX
         DECR  RAR
         FLOOR RAR,0
         STH   RAR,PFTSFIX
         END   ,
         MEND
         SPACE
         MACRO ,
&L       PAGWT &QHEAD,&LOCK,&PCB
&L       PSET  @PAGWAIT
         AIF   ('&QHEAD' EQ '').NOQ
         PMOV  @WTHEAD,&QHEAD,OP=LA
.NOQ     ANOP  ,
         AIF   ('&LOCK' EQ '').NOSLOK  No specific lock
         PMOV  @WTLOCK,&LOCK
.NOSLOK  ANOP  ,
         PMOV  @WTPCB,&PCB
         ACALL PAGWAIT
         MEND  ,
         SPACE
         MACRO
&L       CELLGET &FAMT,&TYPE=
.*  If &WAIT has the value YES/NO, then the wait flag will be
.*  set or not for allocation.  If the value of &WAIT is anything
.*  other than YES/NO, then that value is treated as a flag which
.*  determines whether the wait parameter is set.
         LCLC  &T,&AMT
         AIF   ('&TYPE' NE 'PAGE').CHKSWP
&T       SETC  'LA:PAGPGCEL'
         AGO   .DOCALL
.CHKSWP  AIF   ('&TYPE' NE 'SWAP').CHKFILE
&T       SETC  'LA:PAGSWCEL'
         AGO   .DOCALL
.CHKFILE MNOTE 8,'TYPE=&TYPE is invalid'
         MEXIT ,
.DOCALL  ANOP  ,
&AMT     SETC  '&FAMT'
         AIF   ('&AMT' NE '').DEF
&AMT     SETC  'LA:1'
.DEF     ANOP  ,
&L       PSET  @CELLGET
         PMOV  @CGTYP,&T
         PMOV  @CGAMT,&AMT
         ACALL CELLGET
         MEND
         SPACE
         MACRO
&L       CELLFREE &ITEMF,&FITEML,&FCNT,&TYPE=
         LCLC  &T,&ITEML,&CNT
         AIF   ('&TYPE' NE 'PAGE').CHKSWP
&T       SETC  'LA:PAGPGCEL'
         AGO   .DOCALL
.CHKSWP  AIF   ('&TYPE' NE 'SWAP').CHKFILE
&T       SETC  'LA:PAGSWCEL'
         AGO   .DOCALL
.CHKFILE MNOTE 8,'TYPE=&TYPE is invalid'
         MEXIT ,
.DOCALL  ANOP  ,
&ITEML   SETC  '&FITEML'
&CNT     SETC  '&FCNT'
         AIF   ('&FITEML' NE '').MULT
&ITEML   SETC  '&ITEMF'                There is only one
&CNT     SETC  'LA:1'                  |
         AGO   .NOCHK
.MULT    ANOP  ,
         AIF   ('&CNT' NE '').MULTOK
         MNOTE 8,'CNT must be specified for plural additions'
.MULTOK  ANOP  ,
.NOCHK   ANOP  ,
&L       PSET  @CELLFREE
         PMOV  @CFTYP,&T
         PMOV  @CFLOC,&ITEMF
         PMOV  @CFLAST,&ITEML
         PMOV  @CFAMT,&CNT
         ACALL CELLFREE
         MEND
         SPACE
         MACRO
&L       XPGET &PCB                    External page mgr
&L       PSET  @XPGET
         AIF   ('&PCB' EQ '').NOPCB
         PMOV  @XPPCB,&PCB
.NOPCB   ANOP  ,
         ACALL XPGET
         MEND
         SPACE
         MACRO
&L       XPREL &ADD
&L       PSET  @XPREL
         PMOV  @XPRLBLK,&ADD
         ACALL XPREL
         MEND
         SPACE
         MACRO
&L       BLKDSID &BLK
         PSET  @BLKDSID
         PMOV  @BLKNUM,&BLK
         ACALL BLKDSID
         MEND  ,
         SPACE
         MACRO
&L       FRAMEGET &PCBC,&PCB,&FLCL,&CNT=LA:1,&TYPE=UNFIX
         AIF   ('&TYPE' EQ 'UNFIX').OK,('&TYPE' EQ 'FIX').OK
         AIF   ('&TYPE' EQ 'PT').OK,('&TYPE' EQ 'LOCAL').OK
         MNOTE 8,'Invalid page allocation type'
         MEXIT ,
.OK      ANOP  ,
&L       PSET  @FRAMGET
         PMOV  @FRAPCBC,&PCBC          PCB in control
         PMOV  @FRANUM,&CNT            Number of frames
         AIF   ('&TYPE' NE 'UNFIX').NOUFIX
         PMOV  @FRAPCB,&PCB,REG=EPAR   PCB to own frame
         WITH  (ASBPCB,EPAR),'PMOV @FRALIST,LA:PCBUFLH'
         AGO   .CALL
.NOUFIX  ANOP  ,
         AIF   ('&TYPE' NE 'FIX').NOFIX
         SET   @FRAFIX                 Get a fixed frame
         PMOV  @FRAPCB,&PCB,REG=EPAR   PCB to own frame
         WITH  (ASBPCB,EPAR),'PMOV @FRALIST,LA:PCBLFLH'
         AGO   .CALL
.NOFIX   AIF   ('&TYPE' NE 'PT').NOPT
         SET   @FRAFPT                 Get a page table frame
         PMOV  @FRAPCB,&PCB,REG=EPAR   PCB to own frame
         WITH  (ASBPCB,EPAR),'PMOV @FRALIST,LA:PCBPFLH'
         AGO   .CALL
.NOPT    ANOP  ,
         AIF   ('&TYPE' NE 'LOCAL').NOLOCL
         SET   @FRAFLCL
         PMOV  @FRAPCB,&PCB            PCB to own frame
         PMOV  @FRALIST,&FLCL
         AGO   .CALL
.NOLCL   ANOP  ,
.CALL    ACALL FRAMEGET
         MEND
         SPACE
         MACRO
&L       FRAMEREL &FRA1ST
&L       PSET  @FRAMREL
         PMOV  @FRARFRA,&FRA1ST        1st frame being rel
         ACALL FRAMEREL
         MEND
         SPACE
         MACRO
&L       DATOFF &LOC
&L       STNSM &LOC,X'FF'-PAGDAT
         MEND
         SPACE
         MACRO
&L       DATON &LOC
&L       SSM   &LOC
         MEND
         EJECT
         MACRO
         VPPARM &PFX=
         DS    0A
*PUSH,GEN
         MNOTE *,'-- Return parms --'
&PFX.FLG FLAG  (&PFX.FOK,0,EQ)         Both seg & page in table len
         FLAG  (&PFX.FSLI,X'80',EQ)    Over segment length
         FLAG  (&PFX.FPLI,X'40',EQ)    Over page length
         FLAG  (&PFX.FSEI,X'20',EQ)    Segment entry invalid
         FLAG  (&PFX.FPEI,X'10',EQ)    Page entry invalid
           DS  3X                      - Available -
&PFX.SGTE  DS  A                       Segment table engtry
&PFX.SSTE  DS  A                       Shadow-seg table entry
&PFX.PGTE  DS  A                       Page table entry
&PFX.SPTE  DS  A                       Shadow-pag table entry
&PFX.FPCB  DS  A                       PCB that would own frame
&PFX.PARM EQU  &PFX.FLG,*-&PFX.FLG
*POP
         MEND  ,
         TITLE 'PAGESERV - Interface parms for external routines'
         COPY  VMPARM
         EJECT
         COPY  DISPPARM
         EJECT
         COPY  SIGPARM                 Signal/Await parameters
         EJECT
         COPY  LOCKPARM
         EJECT
         COPY  IOSPARM                 IO Supervisor routine parms
         EJECT
         COPY  DSALPARM                Dynamic alloc parms
         EJECT ,
         COPY  PFINFO                  Open parameters
         EJECT
         COPY  PARMPARM
         EJECT
         COPY  SEGPARM
         SPACE 4
         COPY  SEGCBD
         EJECT
         COPY  PAGEPARM                PAGESERV's global interface
         TITLE 'PAGESERV - Global DSECTs'
         COPY  PZERO
         EJECT
         COPY  MAT
         EJECT
         COPY  ASB
         EJECT
         COPY  SMFPFX                  SMF record prefix
         SPACE 2
         COPY  SMFPAGE                 SMF paging record
         TITLE 'PAGESERV - Local DSECTs'
         COPY  PAGCB
         EJECT
         COPY  ASBPCB
         EJECT
*        COPY  PFTE
PFTE     RECORD BEGIN                  Page Frame Table Entry
PFTL     LELEM PFX=PFT
PFTVA    DS    A                       Current/recent virt addr
PFTASB   DS    A                       ASB of current/recent owner
PFTIOCB  DS    A                       Ctl blk for frames paging IO
PFTSEG   DS    H                       Segment for PT page
PFTSEGM  EQU   X'000003FF'             | mask for seg number
PFTHIST  DS    H                       Working set history
PFTFIX   DS    H                       Number of page fixes for frame
PFTSFIX  DS    H                       Short term fixes for frame
PFTQ     DS    X                       Queue that frame is on
PFTFLG   FLAG  ,
         FLAG  PFTFPGT                 Frame is for a page table
         FLAG  PFTFPWR                 Page IO is a write
         FLAG  PFTFUFIX                Unfix frame on IO complete
         FLAG  PFTFREL                 Release frame on IO complete
         DS    X                       - Available -
*-
*- Flags that stay permanent across frame allocation
*-
PFTFLG2  FLAG  ,
         FLAG  PFTPAGING               Frame is OK for paging
PFTNXT   DS    0X                      Next page frame entry
PFTLOG   RECLOG ,                      Logarithm of entry length
         END   ,
         EJECT
*        COPY  AFTE
AFTE     RECORD BEGIN                  ASN First Table Entry
AFTASTO  DS    A
         FLAG  (AFTFINV,AFTASTO.X'80') This table unavailable
AFTASTM  EQU   X'7FFFFFF0'             ASTO mask
AFTNXT   DS    0A                      Next entry
AFTLOG   RECLOG ,
         END   ,                       OF ASN First Table Entry
         SPACE
*        COPY  ASTE
ASTE     RECORD BEGIN                  ASN Second Table Entry
ASTATO   DS    A                       Authority Table Origin
         FLAG  (ASTFINV,ASTATO.X'80')  This address space unavailable
ASTAX    DS    H                       Authority Index
ASTATL   DS    H                       Authority Table Length
ASTSTD   DS    A                       Segment Table Descriptor
         FLAG  (ASTFSSE,ASTSTD.X'80')  Space Switch Event control
ASTSTO   EQU   X'7FFFF000'             Segment Table Origin mask
ASTSTL   EQU   X'0000007F'             Segment Table Length mask
ASTLTD   DS    A                       Linkage Table Descriptor
         FLAG  (ASTFSLC,ASTLTD.X'80')  Subsys Linkage Control
ASTLTO   EQU   X'7FFFFF80'             Linkage Table Origin mask
ASTLTL   EQU   X'0000007F'             Linkage Table Length mask
ASTNXT   DS    0A                      Next entry
ASTLOG   RECLOG ,
         END   ,                       OF ASN Second Table Entry
         EJECT
*        COPY  SGTE
SGTE     RECORD BEGIN                  Segment Table Entry
SGTAD    DS    0A,AL3                  High 24 bits of real address
SGTPTLEN FLAG  ,                       Flags + page table length
         FLAG  (SGTFINV,X'20')         Segment is invalid
         FLAG  (SGTFCOMM,X'10')        Segment is common
SGTADMSK EQU   X'7FFFFFC0',6           Page table address mask
SGTFLMSK EQU   X'0000003F'             Mask for all flags
SGTFLIMSK EQU  X'0000001F'             All flags except invalid
SGPTLMSK EQU   X'0000000F'             Page table length mask
SGTNXT   DS    0X                      Next segment table entry
SGTLOG   RECLOG ,                      Logarithm of entry length
         END   ,
         SPACE
*        COPY  SSTE
SSTE     RECORD BEGIN                  Shadow Segment Table Entry
SSXSLOT  DS    A                       External segment slot number
SSKEY    DS    X                       Access key
SSTNUM   DS    X                       Number of valid pages in PT
SSTFLG1  FLAG  ,
         FLAG  SSTFDEF                 This is a defined segment
         FLAG  SSTFCOMM                This is a common segment
         FLAG  SSTFIO                  This seg fault dealt with
         FLAG  SSTFSWAP                This seg table in swapped set
SSINIT   DS    X                       Hash value for segment
SSTNXT   DS    0X                      Next shadow segment table entry
SSTLOG   RECLOG ,                      Logarithm of entry length
         END   ,                       OF Shadow Segment Table Entry
         EJECT
*        COPY  PGTE
PGTE     RECORD BEGIN                  Page Table Entry
PGAD     DS    0A,H                    High 15 bits of real address
PGTADMSK EQU   X'7FFFF000',12          Page frame address mask
PGTFLMSK EQU   X'000006FF'             PGTE flag mask
PGTFLG1  FLAG  ,
         FLAG  (PGTFINV,X'04')         Page is invalid
         FLAG  (PGTFPROT,X'02')        Page is protected
PGTAIMSK EQU   PGTFLMSK-(256*L'PGTFINV)         clear addr & invalid
PGTFLG2  FLAG  ,
         FLAG  PGTFDEF                 Page has been defined
         FLAG  PGTFREF                 Page has been referenced once
         FLAG  PGTFCOMM                Page is in common segment
         FLAG  PGTFPGT                 Page table page
         FLAG  PGTFIO                  Page fault dealt with
         FLAG  PGTFXDEF                External page defined
         FLAG  PGTFXSWAP               External page in swap set
PGTNXT   DS    0X                      Next page table entry
PGTLOG   RECLOG ,                      Logarithm of entry length
         END   ,                       OF Page Table Entry
         SPACE
*        COPY  SPTE
SPTE     RECORD BEGIN                  Shadow Page Table Entry
SPXSLOT  DS    A                       External page slot number
SPHIST   DS    X                       Reference history
SPKEY    DS    X                       Access key
         FLAG  (SPFPROT,SPKEY.X'10')   | Fetch protection bit
* SPINIT   DS    X                       Page initialization value
         DS    2X                      - Available -
SPTNXT   DS    0X                      Next shadow page table entry
SPTLOG   RECLOG ,                      Logarithm of entry length
         END   ,                       OF Shadow Page Table Entry
         SPACE
*        COPY  PAGTABLE
PAGTABLE RECORD BEGIN                  Page/Shadow Page Table
PGT      DS    256XL(L'PGTE)           Hardware Page Table
PGTL     EQU   *-PAGTABLE              | len of hardware sect
SPGT     DS    256XL(L'SPTE)           Shadow Page Table
         ORG   PGT+4096                - Use a whole page -
         END   ,                       OF Page/Shadow Page Table
         EJECT
         COPY  PIOPARM                 Host paging parameters
PSCPFX   RECORD BEGIN                  Page/Swap cell prefix
PSCFP    DS    A                       Pointer to next cell
PSCBP    DS    A                         and pointer backwards
PSCID    DC    CL4'PGIO'               Control block ID
PSCIO    DS    A                       I/O Supervisor ID
PSCDEV   DS    A                       Device descriptor
PSCASB   DS    A                       ASB
         END   ,
*
PGDPAGE  RECORD BEGIN                  Paging work descriptor
PGDPGPFX DS    XL(L'PSCPFX)
PGDPGWT  DS    A                       Waiting tasks
PGDPGVA  DS    A                       Virtual addr of page
PGDPGFLG FLAG  ,
         FLAG  PGDFPGT                 I/O is for page table
PGDIOF   DS    X                   ddf IO finished flag (TS)
PGDPGSEG DS    H                       Segment number of PT page
PGDPIO   DS    0A,(L'#PIODO)X          @PIO Parm control block
         DS    0D
         END   ,
         EJECT
         COPY  SWAPPARM                Host swapping parameters
         EJECT
*-
*- A swapping control block is made up of nested DSECTS
*- - The lowest level is made up of the lists of real, and virtual
*-   addresses, and segment numbers, history etc.
*- - The next level is an extent, one or more of which describe an
*-   address space's working set.
*- - The highest level contains internal work areas and the swap
*-   parameters required for the external swap request.
*-
PGDSLIST RECORD BEGIN                  Element Real addr for swap
PGDSLAD  DS    A                       Address
         FLAG  (PGDSLAX,PGDSLAD.X'80') | last in list
PGDSLNXT DS    0X
PGDSLLOG RECLOG ,                      Logarithm of record length
         END   ,
         SPACE
PGDSVLST RECORD BEGIN                  Virtual addr list for swap
PGDSVA   DS    A                       Address
PGDSFKEY DS    X                       Storage key
PGDSFHST DS    X                       History byte
PGDSFFIX DS    H                       Short fix count
PGDSFPTF EQU   PGDSFHST,L'PGDSFHST     PT short fixes
PGDSFSEG EQU   PGDSFFIX,L'PGDSFFIX     Segment number for PT
         FLAG (PGDFNOF,PGDSFSEG.X'80') No short fixes for PT
PGDSVNXT DS    0X
PGDSVLOG RECLOG ,                      Logarithm of record length
         END   ,
         SPACE 4
*-
*- Swapping control block base
*-
PGDSWAP  RECORD BEGIN                  Swapping work descriptor
PGDSWPFX DS    XL(L'PSCPFX)
PGDSWLNK DS    A                       Next swap control block
PGDSWFRA LHEAD PFX=PGDSW               Frames for this CB
PGDSWPF  FLAG  ,
         FLAG  PGDSFLOUT               Logically out
         FLAG  PGDSFFALLO              Frames allocated
         FLAG  PGDSFSINP               Swap in progress
         FLAG  PGDSFDAT                Update DAT tables for CB
         FLAG  PGDSFSGT                Seg table in this segment
PGDSFLGS EQU   PGDSWPF,*-PGDSWPF,C'A'  Flags for swap CB
         DS    X                       - Available -
         DS    H                       - Available -
         DS    0A
PGDSWP   DS    (L'#SWPDO)X             @SWPIO Parm control block
PGDSWNXT DS    A                       Next extent (if ^ zero)
PGDSWEXT DS    0A
PGDSWNUM EQU   40,,C'N'                Default # of addr per extent
         END   ,
         EJECT
PGDDAL   RECORD BEGIN                  DASD allocate/open
DALCP    DS    0A                      Channel programs
DALPDAT  DS    XL(L'#PIOOPEN)          Paging open cp
         ORG   DALCP
DALPRSET DS    XL(L'#PIRESET)          Paging reset cp
         ORG   DALCP
DALSDAT  DS    XL(L'#SWPOPEN)          Swapping open cp
         ORG   DALCP
DALSRSET DS    XL(L'#SWPRSET)          Swapping reset cp
         ORG   ,
         DS    0A
DALAINFO DS    XL(L'@DSALLO)           Allocation info
         DS    0A
DALOINFO DS    XL(L'#PFINFO)           Open info
         DS    0D
         END   ,
         EJECT
*-
*-  The bitmaps indicate a reserved paging slot or swapping set by
*- a 0 bit, and a free slot by a 1 bit.
*-
DSDES    RECORD BEGIN                  Data set descriptor
DSAID    DS    A                       Alpha ID
DSLOC    DS    A                       Starting address of bitmap
DSLEN    DS    A                       Length of bitmap (in bytes)
DSCOUNT  DS    A                       Number of bits in map
DSAVAIL  DS    A                       Available bits left
DSCHID   DS    A                       Channel ID for resource
DSOFFSET DS    A                       Logical bit 0's physical #
DSCHAIN  DS    A                       Next data set descriptor
*-
*- Statistics
*-
DSINCNT  DS    A                       Number of reads from device
DSOUTCNT DS    A                       Number of writes to device
DSINTIME DS    D                       Total read time for device
DSOUTTIME DS   D                       Total write time for device
DSNEXT   DS    0A
         END   ,
*
RADD     REG   RVR                     Bit address register
RLOC     REG   RA                      Bitmap location register
RLEN     REG   RB                      Remaining bitmap length reg
RCNT     REG   RJ                      Count of bit shifts
RWANT    REG   RK                      Number of bits wanted
RMAPL    REG   RAR
RMAP     REG   EPAR                    Current segment of bitmap
         REGCH (RAR,R14),(EPAR,R15)
         TITLE 'PAGESERV - Local routine calling parameters'
@BMALLOC RECORD BEGIN
@BMACB   DS    A                       Address of bitmap control blk
@BMAADD  DS    A                       Start address
@BMANUM  DS    A                       Number of units desired
@BMALEFT DS    A                       Bits on left
@BMAFLG  FLAG  @BMAOK                  Allocation went OK
         END   ,
         SPACE
@BMFREE  RECORD BEGIN
@BMFCB   DS    A                       Address of bitmap control blk
@BMFADD  DS    A                       Start address
@BMFNUM  DS    A                       Number of units to free
@BMFFLG  FLAG  @BMFOK                  Release went OK
         END   ,
         SPACE
@ASNGET  RECORD BEGIN
@AGSASTE DS    0XL(L'ASTE)
@AGATO   DS    A                       Authority Table Origin
         FLAG  (@AGFINV,@AGATO.X'80')  This address space unavailable
@AGAX    DS    H                       Authority Index
@AGATL   DS    H                       Authority Table Length
@AGSTD   DS    A                       Segment Table Descriptor
         FLAG  (@AGFSSE,@AGSTD.X'80')  Space Switch Event control
@AGLTD   DS    A                       Linkage Table Descriptor
@AGPCB   DS    A                       PCB Address
         END   ,
         SPACE
@FRAMGET RECORD BEGIN                  Frame allocation
@FRAPCBC DS    A                       PCB in control
@FRAPCB  DS    A                       PCB to own frame
@FRANUM  DS    A                       Number of frames
@FRALIST DS    A                       Local list addr (if spec)
@FRATYPE FLAG  ,
         FLAG  (@FRAFUFIX,0,EQ)        Unfixed frame
         FLAG  (@FRAFIX,1,EQ)          Fixed frame
         FLAG  (@FRAFPT,2,EQ)          Page table frame
         FLAG  (@FRAFLCL,3,EQ)         Local frame list (not PCB)
* -- FRAMEGET Return parameters --
@FRA1ST  DS    A                       First frame in list
@FRFLG   FLAG  @FRAOK                  Allocation OK
         FLAG  @FRAROOM                Need to make more room
         END   ,
         SPACE
@FRAMREL RECORD BEGIN                  Frame deallocation
@FRARPCB DS    A                       PCB for unit of work
@FRARFRA DS    A                       Frame to release (0=first)
         END   ,
         SPACE
@XPGET   RECORD BEGIN                  Allocate external frames
@XPCNT   DS    A                       Number of blocks requested
@XPPCB   DS    A                       PCB in control
* -- Return parameters --
@XPRBLK  DS    A                       Relative block in DS
@XPDSDES DS    A                       Data set descriptor of alloc
@XPFLG   FLAG  @XPOK                   Successful - for swapping
         END   ,
         EJECT
@CELLGET RECORD BEGIN
@CGTYP   DS    A                       Address of cell type pool
@CGAMT   DS    A                       Number of cells desired
*  -- Return parameters --
@CGLAST  DS    A                       Addr of last cell alloc
         END   ,
         SPACE
@CELLFREE RECORD BEGIN
@CFTYP   DS    A                       Address of cell type pool
@CFLOC   DS    A                       Addr of first cell
@CFLAST  DS    A                       Addr of last cell alloc
@CFAMT   DS    A                       Number of cells being released
         END   ,
         SPACE
@RESWAKE RECORD BEGIN
@RESFREE DS    A                       Number of units available
@RESWAIT DS    A                       List address of waiting PCBs
@RESLOCK DS    A                       Lock controlling resource
@RESF    FLAG  ,
         FLAG  @RESFLKRL               Lock was released
         END   ,
         EJECT
@VIRTABL RECORD BEGIN                  Virtual addr to table entries
@VPVA    DS    A                       Virtual addr
@VPPCB   DS    A                       PCB in control for this event
         VPPARM PFX=@VP
         END   ,
         SPACE 2
@RESOLVE RECORD BEGIN                  Resolve Page/Segment
@PRVA    DS    A                       Virtual addr to bring in
@PRPCB   DS    A                       PCB in control of request
@PRPSWM  DS    X                       PSW mask
* -- Return Parms --
@PRRESCD FLAG  ,
         FLAG  (@PRROK,0,EQ)           Fault resolved
         FLAG  (@PRRADDR,1,EQ)         Addressing exception
         END   ,
         SPACE
@RESPT   RECORD BEGIN
@PTVA    DS    A                       Virtual address - PT maps it
@PTPCB   DS    A                       PCB of address
@PTPSWM  DS    X                       PSW mask to restore to
* -- Return parameters --
@PTPGTE  DS    A                       Page table entry addr
@PTSPTE  DS    A                       Shadow page table entry addr
@PTRC    FLAG  ,
         FLAG  (@PTFOK,0,EQ)           PT in core now
         FLAG  (@PTFADDR,1,EQ)         Addressing exception
         END   ,
         EJECT
@PAGIN   RECORD BEGIN
@PGISLOT DS    A                       Slot number for paging
@PGIRA   DS    A                       Real address
@PGIVA   DS    A                       Virtual address
@PGIPCBC DS    A                       PCB in control
@PGIPCB  DS    A                       PCB to own the frame
@PGISEG  DS    A                       Segment addr if it's a PT
@PGIPGD  DS    A                   ddf PGDPAGE addr (returned)
@PGFLG   FLAG  ,
         FLAG  @PGIFPT                 It's a page table
         FLAG  @PGIUFIX                Unfix on IO completion
* -- Return Parm --
         FLAG  @PGINOK                 Page in started
         END   ,
         SPACE
@PAGOUT  RECORD BEGIN
@PGOSLOT DS    A                       Slot number for paging
@PGORA   DS    A                       Real address
@PGOPGD  DS    A                   ddf PGDPAGE addr (returned)
@PGOFLG  FLAG  ,
         FLAG  @PGOUFIX                Unfix on IO completion
         FLAG  @PGOREL                 Free on IO completion
* -- Return Parm --
         FLAG  @PGOOK                  Page out started
         END   ,
         EJECT
#LCLLOCK RECORD BEGIN
#LCLPSWM DS    X                       Byte for PSW mask on disable
         END   ,
         SPACE
#PAGE    RECORD BEGIN
#PAGFLGS DS    X                       Lock flags
#PAGPSWM DS    X                       PSW mask for disabling
         END   ,
         SPACE
@SETSWAP RECORD BEGIN
@SSPCB   DS    A                       Address of paging ctl block
@SSFLAG  FLAG  ,
         END   ,
         SPACE
         AGO   .NOLSTCHK
@LSTCHK  RECORD BEGIN
@LCHEAD  DS    A
         END   ,
         SPACE ,
LSTCHK   PROC  @LSTCHK
         L     RN,@LCHEAD
         WITH  (LHEAD,RN)
         L     RM,LHCNT                Number of elems
         LR    RB,RN                   Previous element
         L     RA,LHFP
         IF    (RM,NEG),'ABORT LST_BAD_COUNT'
         WHILE (RM,NZ),BEGIN           Loop through list
         WITH  (LELEM,RA)
         IF    (RB,NE,LBP),'ABORT LST_BACK_PTR'
         IF    (RA,EQ,RN),'ABORT LST_SHORT'
         LR    RB,RA
         L     RA,LFP
         DECR  RM
         END   ,                       OF Loop through list
         IF    (RA,NE,RN),'ABORT LST_LONG'
         IF    (RB,NE,LHBP),'ABORT LST_BACK_PTR2'
         PEND  ,
.NOLSTCHK ANOP ,
         EJECT
@PAGPIOC RECORD BEGIN                  Page I/O completion
@PCRA    DS    A                       Real address
@PCPCB   DS    A                       PCB that owns frame
@PCPCBC  DS    A                       PCB in control of I/O
@PCIOCB  DS    A                       Paging ctl block - real I/O
         END   ,
         TITLE 'Page/Segment fault handling routine'
*NEST,1
*box
*
*  Handle page/segment faults
*
*   Input - Hardware areas in PZERO and the PZCURASB
*
*  Output - RVR indicates the status of the operation
*
*
         SPACE
#PAGFLT  RECORD BEGIN
#PFPGD   DS    A                   ddf PGD save
#PFVA    DS    A                       Fault address
         FLAG  (#PFF2ND,#PFVA.X'80')   Secondary fault
#PFRC    FLAG  ,
         FLAG  (#PFRINP,@PFRINP,EQ)
         FLAG  (#PFRADDR,@PFRADDR,EQ)
         FLAG  (#PFROK,@PFROK,EQ)
         FLAG  (#PFRWAIT,@PFRWAIT,EQ)
#PFPSWM  DS    X                       PSW mask for disabling
#PFLKFLG DS    X                       Lock flags for this PCB
#PFACFLG FLAG  ,                       Action flags
         FLAG  #PFFROOM                Call makeroom w/out locks held
         VPPARM PFX=#PF
         END   ,
         SPACE
PAGFAULT PROC  ,#PAGFLT,SCOPE=GLOBAL   Page/segment faults
         PAGAD RPAG                    |
         CLEAR #PFACFLG
         CLEAR #PFPGD              ddf
*-
*- Get translation exception address, and then get locks
*-
         USING PZERO,R0                Address space block addr
         L     RPCB,PZCURASB           |
         L     RA,PZTREXA              Translation exception address
         N     RA,=X'FFFFF000'         | page align
         ST    RA,#PFVA                |
         DROP  R0                      |
         WITH  (ASB,RPCB),BEGIN        ASB addr
*  Can't handle 2ndary faults for now.  We will need to wait proper
* unit of work for asynchronous operations: the unit of work in
* control, not necessarily the current ASB
         IF    #PFF2ND,'ABORT PAGFLT2' Secondary space fault
         L     RPCB,ASBPAGB            Paging block
         END   ,                       |
         WITH  (ASBPCB,RPCB)           |
         PAGNTRY ASYNC,#PFPSWM,#PFLKFLG
         IF    ('LT RJ,PCBPFOUT',NZ),'ABORT MULPF'
*-
*- Trim this Address space if it is over the working set size
*- limit
*-
         IF    ('LT RJ,PCBFLIMIT',POS),BEGIN    Limit total size
         L     RB,PCBFCNT              Add frames together
         AL    RB,PCBPFCNT             | page tables
         AL    RB,PCBLFCNT             | long term fixed
         IF    (RB,GE,RJ),BEGIN        Trim needed
         PSET  @PAGWSMA
         PMOV  @WSLIMIT,(RJ)
         ACALL PAGWSMAN
         END   ,                       OF Trim needed
         END   ,                       Limit total size
*
PAGPFVAL BEGIN ,                       Valid entrys
         SET   #PFROK                  Assume OK to start
*-
*- Break down the virtual address of the fault, and check for
*- errors that are from seg/page lengths
*-
         VIRTABL (RA),(RPCB)           Page/Seg table ptrs
         PMOV  #PFPARM,@VPPARM         | save return parms
         IF    (#PFFSLI,OR,#PFFPLI),BEGIN       Over segment/page len
         SET   #PFRADDR                | indicate protection
         EXIT  PAGPFVAL                |
         END   ,                       OF Over segment/page lengths
         TITLE 'Page fault handling routine'
*box
*
* Handle page fault
*
         IF    #PFFPEI,BEGIN           Page fault
         L     RK,#PFPGTE              Page table entry address
         WITH  (PGTE,RK),BEGIN         |
         L     RJ,#PFSPTE              Shadow page table entry addr
         WITH  (SPTE,RJ),BEGIN         |
*-
*- Addressing error - page not defined
*-
         IF    ^PGTFDEF,BEGIN          Page hasn't been defined
         SET   #PFRADDR
         EXIT  PAGPFVAL
         END   ,                       OF Page hasn't been defined
*-
*- I/O isn't in progress, so we have work to do other than just
*- wait for completion
*-
         IF    ^PGTFIO,BEGIN           Must handle page fault
         FRAMEGET (RPCB),#PFFPCB,TYPE=FIX
         IF    @FRAROOM,'SET #PFFROOM'
         IF    ^@FRAOK,BEGIN           Frame not avail
         SET   #PFRWAIT                |
         EXIT  PAGPFVAL                |
         END   ,                       OF Frame not avail
         LR    RB,RVR                  Real address
*
         PUSH  USING
*-
*- This isn't the first reference, so we need to read the page
*- in from external store.
*-
         IF    PGTFREF,BEGIN           Page is referenced, get it ...
*
         PSET  @PAGIN                  Page in the page
         PMOV  @PGISLOT,SPXSLOT        | external slot
         PMOV  @PGIRA,(RB)             | real addr
         PMOV  @PGIVA,#PFVA            | virtual addr
         PMOV  @PGIPCBC,(RPCB)         | PCB in control
         SET   @PGIUFIX                | unfix on completion
         IF    PGTFPGT,BEGIN           Page fault on page table page
         SET   @PGIFPT
         PMOV  @PGISEG,PGAD            VA with segment of PT
         END   ,                       OF Page fault on page table...
         LCALL PAGIN
         IF    ^@PGINOK,BEGIN          Couldn't do it
         SET   #PFRWAIT                must wait
         EXIT  PAGPFVAL
         END   ,                       OF Couldn't do it
         MVC   #PFPGD,@PGIPGD      ddf Save address
*-
*-   Set seg in I/O if its a page table (page table holds the
*- segment number)
*-
         IF    PGTFPGT,BEGIN           It's a page table page
         L     RM,PGAD                 Set real addr, "in I/O"
         SRL   RM,L'PAGSGNM            |
         LR    RA,RM                   | shadow
         SLL   RA,SSTLOG               | |
         AH    RA,PAGSEGL              | |
         SLL   RM,SGTLOG               |
         L     EPAR,#PFFPCB            |
         WITH  (ASBPCB,EPAR),LABEL=OWN,BEGIN    Owning PCB addr
         AL    RM,OWN.PCBPSTO          | seg
         AL    RA,OWN.PCBPSTO          | shadow seg
         END   ,                                OF Owning PCB addr
         WITH  (SGTE,RM),BEGIN         Set real addr in seg
         L     RVR,SGTAD               |
         N     RVR,=A(SGTFLMSK)        |
         OR    RVR,RB                  |
         ST    RVR,SGTAD
         END   ,                       OF Set real addr in seg
         WITH  (SSTE,RA),BEGIN         Set as "in I/O"
         SET   SSTFIO                  |
         END   ,                       OF Set "in I/O" in shadow seg
         END   ,                       OF It's a page table page
*-
*- Put frame real address in page table, mark as "in I/O"
*-
         N     RB,=A(PAGPAGM)          Set page's real address
         L     EPAR,PGAD               |
         N     EPAR,=A(PGTFLMSK)       |
         OR    EPAR,RB                 |
         ST    EPAR,PGAD               |
         SET   PGTFIO                  | in I/O
         L     EPAR,PCBPFOUT
         LOOP  BEGIN                   One more PF
         LA    RAR,@EPAR+1
         CS    EPAR,RAR,PCBPFOUT
         UNTIL (EQUAL),END             OF One more PF
         SET   #PFRINP                 | in progress
         END   ,                       OF Page is ref, get it ...
         POP   USING
*-
*- This is the first reference to the page, so we just
*- initialize it to its proper value
*-
         ELSE  BEGIN                   Page isn't referenced
*  RB is the frame real address
         L     RA,@FRA1ST              Frame table entry
         WITH  (PFTE,RA),BEGIN         |
*-
*- If the external frame isn't allocated, we need to get one
*- now.
*-
         IF    (NOT,(PGTFXDEF,OR,PAGXF1DEF)),BEGIN      Alloc ext
         XPGET ,
         IF    ^@XPOK,BEGIN            Couldn't alloc ext frame
         SET   #PFRWAIT                Must wait
         EXIT  PAGPFVAL
         END   ,                       OF Couldn't alloc ext frame
         ST    RVR,SPXSLOT
         SET   PGTFXDEF                External frame now allocated
         END   ,                       OF Allocate external frame
         MVC   PFTVA,#PFVA             |
         SET   PFTFUFIX                | unfix on completion
         END   ,                       OF Frame table entry
         LR    RM,RB                   Save real addr
         LH    RN,=Y(PAGPAGEL)         | len to init
         REGCH (RVR,R0),(RS,R1)        |
         L     EPAR,#PFSSTE
         WITH  (SSTE,EPAR),BEGIN
         LCM   RS,B'1000',SSINIT       | Initialization value
         END   ,
         L     EPAR,PCBRA
         WITH  (ASBPCB,EPAR),LABEL=REAL,BEGIN   Real addr of PCB
         DATOFF PCBPSWM
         MVCL  RM,RVR                  | init page
         DATON REAL.PCBPSWM
         END   ,                       OF Real addr of PCB
         CLEAR PGTFIO                  Through handling page fault
         SET   PGTFREF                 | Set as referenced now
         PAGPRC (RB),#PFFPCB,LA:ASBPCB | and page "read" complete
         ISKE  RM,RB                   Set change bit in key
         O     RM,=A(PAGKCHG)          |
         SSKE  RM,RB                   |
         SET   #PFROK                  |
         END   ,                       OF Page isn't referenced
*-
*- For any page that is now valid we now put one more short
*- term fix on the page table for this page.  This keeps
*- this page table in core while pages in it are defined.
*-
         L     RB,#PFSGTE              One more page in segment
         WITH  (SGTE,RB),BEGIN         SGTE addr
         QSFIX SGTAD                   |
         END   ,                       OF SGTE addr
         END   ,                       OF Must handle page fault
*-
*- The page in question is currently "in I/O".  We need to wait
*- for that I/O to complete before we can continue
*-
         ELSE  BEGIN                   Wait for page to come in
         L     RB,PGAD                 Page Frame points to Wait PCB
         N     RB,=A(PGTADMSK)         |
         SRL   RB,L'PAGPAGM-PFTLOG     |
         AL    RB,PAGPFTO              |
         WITH  (PFTE,RB),'L RB,PFTIOCB'
         IF    (RB,ZERO),'ABORT PAGPGWT'
*-
*- Add to wait list - putting ourselves at head
*-
         WITH  (PGDPAGE,RB),BEGIN
         L     RJ,PGDPGWT              | save old waiting PCB
         ST    RPCB,PGDPGWT            | point at this PCB
         END   ,                       |
         ST    RJ,PCBWAIT              |
         L     EPAR,PCBPFOUT
         LOOP  BEGIN                   One more PF
         LA    RAR,@EPAR+1
         CS    EPAR,RAR,PCBPFOUT
         UNTIL (EQUAL),END             OF One more PF
         SET   PCBFREAD                Waiting on a page read
         SET   #PFRINP                 Handling in progress
         END   ,                       OF Wait for page to come in
         END   ,                       OF Shadow pg table entry addr
         END   ,                       OF Page table entry address
         END   ,                       OF Page fault
         TITLE 'Segment fault handling routine'
*box
*
* Handle segment fault
*
         ELSEIF #PFFSEI,BEGIN          Segment Fault
         L     RK,#PFSSTE              Shadow seg table addr
         WITH  (SSTE,RK),BEGIN         |
*-
*- It's an error if this isn't a defined segment
*-
         IF    ^SSTFDEF,BEGIN          Addressing exception
         SET   #PFRADDR                |
         EXIT  PAGPFVAL                | leave
         END   ,                       OF Addressing exception
         L     RJ,#PFSGTE              Segment table addr
         WITH  (SGTE,RJ),BEGIN         |
*-
*- If the segment table is not "in I/O" we need to bring it in
*-
CHAINSEG IF    ^SSTFIO,BEGIN           Must deal w/ fault
*  Page frame in
         L     RS,SGTAD                This is VA when seg is out
         N     RS,=A(PAGPAGM)          |
*-
*-   If the LRA indicates page invalid then the virtual
*- address lives in another page table, and that page table
*- entry needs to be marked as in Page-I/O.
*-   If a LRA on the virtual address of this page table
*- indicates segment invalid, then this page table's virtual addr
*- is in another segment that is out.  If this page table
*- translates its own virtual address, no further work
*- needs to be done.  Otherwise, that other page table must be
*- brought in.  - daisy chain to the proper page.
*-
         LRA   RB,@RS
         IF    SEGI,BEGIN              PT's VA in invalid seg
         RTOV  (RB)
         IF    (RVR,EQ,RJ),EXIT        This PT maps its own VA
         LR    RJ,RVR                  Seg entry VA
         LR    RK,RVR                  Shadow Seg entry VA
         LR    RS,RVR                  |
*-
*-    NB: Assumes that a hardware segment table is at most 4K
*-
         N     RS,=A(PAGPAGM)          |
         N     RK,=A(PAGOFFM)          |
         LR    RA,RK                   | VA in this segment
         SLL   RA,L'PAGSGNM-SGTLOG     | |
         ST    RA,#PFVA                | |
         SLL   RK,SSTLOG-SGTLOG        |
         AH    RK,PAGSEGL              |
         ALR   RK,RS                   |
         B     CHAINSEG                Chain loop
         END   ,                       OF PT's VA in invalid seg
         ELSEIF (NOT,PAGI),SFABORT     Error if VA in, or length bad
*-
*- Allocate a frame for this I/O
*-
         FRAMEGET (RPCB),#PFFPCB,TYPE=FIX
         IF    @FRAROOM,'SET #PFFROOM'
         IF    ^@FRAOK,BEGIN
         SET   #PFRWAIT
         EXIT  PAGPFVAL
         END   ,
*-
*- Try to start up the I/O to bring in the segment table
*-
         N     RVR,=A(SGTADMSK)        Save real addr
         LR    RB,RVR                  |
         PSET  @PAGIN                  Bring page in
         PMOV  @PGISLOT,SSXSLOT        | external slot number
         PMOV  @PGIRA,(RB)             | real addr
         N     RS,=A(PAGPAGM)          |
         PMOV  @PGIVA,(RS)             | virtual addr
         PMOV  @PGIPCBC,LA:ASBPCB      | PCB in control
         SET   @PGIUFIX*@PGIFPT        | it is a page table - unfix
         PMOV  @PGISEG,#PFVA           | VA in this segment
         LCALL PAGIN                   |
         IF    ^@PGINOK,BEGIN          Can't do it
         SET   #PFRWAIT
         EXIT  PAGPFVAL
         END   ,                       OF Can't do it
         MVC   #PFPGD,@PGIPGD      ddf Save address
*box
*
*    Set the real address of this page table in the entry for this
*  this virtual address.  Also set the entry as "in I/O".
*    This is not necessary if this page table maps its own
*  virtual address.
*
         LRA   RA,@RS                  RS is the VA of this PT
         IF    PAGI,BEGIN              Represented in another PT
         L     RM,PCBRA
         WITH  (ASBPCB,RM),LABEL=REAL
         DATOFF PCBPSWM
         WITH  (PGTE,RA),BEGIN         Page table addr
         L     EPAR,PGAD
         N     EPAR,=A(PGTFLMSK)
         OR    EPAR,RB
         ST    EPAR,PGAD
         SET   PGTFIO                  Fault being handled
         END   ,                       OF Page table addr
         DATON REAL.PCBPSWM
         END   ,                       OF Represented in another PT
*box
*
*  Put the real address in the segment table, and mark the shadow
*  segment table as "in I/O"
*
         L     RA,SGTAD                Put real addr in segment tbl
         N     RA,=A(SGTFLMSK)         |
         OR    RA,RB                   |
         ST    RA,SGTAD                |
         SET   SSTFIO                  Dealing with fault
*-
*- Put another short fix on the page table that references this
*- virtual address.  RS has the VA of this page table.
*-
         SRL   RS,L'PAGSGNM            One more short fix
         SLL   RS,SGTLOG               | seg table addr
         L     EPAR,#PFFPCB
         WITH  (ASBPCB,EPAR),'AL RS,PCBPSTO'
         WITH  (SGTE,RS),BEGIN         |  which gives page table RA
         QSFIX SGTAD                   |
         END   ,                       | OF SGTE addr
         L     EPAR,PCBPFOUT
         LOOP  BEGIN                   One more PF
         LA    RAR,@EPAR+1
         CS    EPAR,RAR,PCBPFOUT
         UNTIL (EQUAL),END             OF One more PF
         SET   #PFRINP                 In progress
         END   ,                       OF Must deal w/ fault
*-
*- The segment table I/O is already in progress, and so we need
*- to set up to wait for the I/O to complete
*-
         ELSE  BEGIN                   Segment fault dealt with
         L     RB,SGTAD                Page Frame points to Wait PCB
         SRL   RB,L'PAGPAGM            |
         SLL   RB,PFTLOG               |
         AL    RB,PAGPFTO              |
         WITH  (PFTE,RB),'L RB,PFTIOCB'
         IF    (RB,ZERO),'ABORT PAGSGWT'
         WITH  (PGDPAGE,RB),BEGIN      Add to wait list
         L     RJ,PGDPGWT              | save old waiting PCB
         ST    RPCB,PGDPGWT            | point at this PCB
         END   ,                       |
         ST    RJ,PCBWAIT              |
         L     EPAR,PCBPFOUT
         LOOP  BEGIN                   One more PF
         LA    RAR,@EPAR+1
         CS    EPAR,RAR,PCBPFOUT
         UNTIL (EQUAL),END             OF One more PF
         SET   PCBFREAD                Waiting on a page read
         SET   #PFRINP                 Handling in progress
         END   ,                       OF Segment fault dealt with
         END   ,                       OF Segment table addr
         END   ,                       OF Shadow segment table addr
         END   ,                       OF Segment Fault
         END   ,                       OF Valid entry code
         PAGXIT ASYNC,#PFPSWM,#PFLKFLG,WR=RS
*-
*- If we need to, call the page io termination routine when
*- all locks are freed
*-
         IF    ('LT R15,#PFPGD',NZ),BEGIN ddf
         WITH  (PGDPAGE,R15),'TS PGDIOF' ddf IO already done?
         IF    NZ,BEGIN            ddf Yes, that sure was fast!
         PSET  @IOTERM             ddf
         PMOV  @IOTPARM,#PFPGD     ddf PCB in control
         ACALL PAGTERM             ddf Do page IO termination now
         END   ,                   ddf
         END   ,                   ddf
*-
*- If we need to, call the make-room routine when all locks are freed
*-
         IF    #PFFROOM,BEGIN
         ACALL MAKEROOM
         END   ,
         LC    RVR,#PFRC               Indicate return status
         PEND  ,
         SPACE
SFABORT  ABORT SEGFBAD                 Error on segment fault
*NEST,2
         TITLE 'Compute virtual table entry addresses'
*box
*
*  Computes virtual segment/shadow-segment table
*   entry addresses and page/shadow-page table entry
*   addresses for a given virtual address and ASB
*  If the segment table is invalid, then the page/shadow-page table
*   entry addresses are not provided.
*
*   Input - @VIRTABL
*
*  Output - @VIRTABL
*      The stack area contains the virtual table addresses for
*    the given virtual address.  Flags indicate whether or not
*    the segment and page table entries are valid, and which
*    address space locks have been obtained.
*
*
         SPACE
VIRTABL  PROC  @VIRTABL                Virtual addr to table entries
         PAGAD RM                      |
         L     RY,@VPPCB               Paging control block addr
         WITH  (ASBPCB,RY),BEGIN       |
         ST    RY,@VPFPCB              | defaults as frame owner too
         L     RJ,PCBPSTO              Segment table origin
         LC    RS,PCBPSTL              | last entry
         SLL   RS,4                    |  *16
         LA    RS,@RS+16-1             |
         N     RJ,=A(PCBSTM)           Clean up segment start
         LR    RK,RJ                   |  save for shadow offset
         END   ,                       OF Paging control block addr
*-
*- Get segment table entry/page table address
*-
VPVALID  BEGIN ,                       Address is valid
         L     RA,@VPVA                Address dissecting
         N     RA,=A(PAGPAGM)          | remove high bit/offset
         CLEAR (RB)
         SRDL  RA,L'PAGSGNM            | RA = seg number
         SRL   RB,24                   | RB = pg number
         LR    RX,RA                   Use RX as seg table index
         SLL   RX,SGTLOG               | seg table offset (4 bytes ea)
         LA    RJ,@RJ(RX)              |
         ST    RJ,@VPSGTE              | seg table entry addr
         SLL   RX,SSTLOG-SGTLOG        Shadow table offset
         AH    RK,PAGSEGL              Shadow seg table entry addr
         LA    RK,@RK(RX)              |
         ST    RK,@VPSSTE              |
         SET   @VPFSLI                 Assume segment over length
         IF    (RA,GT,RS),EXIT,VPVALID | and exit if so
         WITH  (SGTE,RJ),BEGIN         Segment table entry addr
         IF    SGTFCOMM,BEGIN          Need global lock
         L     RY,@VPPCB               PCB addr
         WITH  (ASBPCB,RY),BEGIN       |
         L     RX,PAGCASB              |
         WITH  (ASB,RX),'L RX,ASBPAGB' |
         ST    RX,@VPFPCB              Common PCB = new frame's owner
         IF    ^PCBFGBL,BEGIN          Check for global lock
         WITH  (ASBPCB,RX),LABEL=COMM  | Common PCB addr
         LKOB  COMM.PCBLOCK            | get global lock
         SET   PCBFGBL                 |  and set as held
         END   ,                       OF Check for global lock
         END   ,                       OF PCB addr
         END   ,                       OF Need global lock
         SET   @VPFSEI                 Assume seg entry invalid
         IF    SGTFINV,EXIT,VPVALID    | and exit if so
         L     RJ,SGTAD                Page table addr
         END   ,                       OF Segment table entry addr
         LR    RK,RJ                   | length
         N     RK,=A(SGPTLMSK)         | |
         SLL   RK,4                    | |
         LA    RK,@RK+16-1             | | last entry
         N     RJ,=A(SGTADMSK)         |
         SET   @VPFPLI                 Assume page tbl len invalid
         IF    (RB,GT,RK),EXIT,VPVALID | and exit if so
*-
*- Get page table entry addr
*-
         RTOV  (RJ)                    Convert real addr to virt
         LR    RX,RVR                  |
         WITH  (PAGTABLE,RX),'LA RY,SPGT '      Shadow Page table add
         LR    RA,RB                   | entry
         SLL   RB,SPTLOG               |
         LA    RY,@RY(RB)              |
         ST    RY,@VPSPTE              | shadow addr
         SLL   RA,PGTLOG               Page table entry address
         LA    RX,@RX(RA)              |
         ST    RX,@VPPGTE              |
         WITH  (PGTE,RX),BEGIN         |
         SET   @VPFPEI                 Assume entry invalid
         IF    PGTFINV,EXIT,VPVALID    | and exit if so
         SET   @VPFOK                  Everything went OK
         END   ,                       OF Page table entry addr
         END   ,                       OF Address is valid
         PEND  ,
         TITLE 'Real address to Virtual address'
*box
*
*  Returns the virtual address/ASN when passed a real address
*   Input - @PAGRV
*
*  Output - RVR
*    RVR contains the virtual address for the given real address
*
*
         SPACE
PAGRV    PROC  @PAGRV,SCOPE=GLOBAL     Real to virtual addresses
         PAGAD RM
         L     RA,PAGPFTO              Page frame table origin
         L     RB,@PAGRVAD             Compute frame table index
         LR    RJ,RB                   | save offset
         N     RJ,=A(PAGOFFM)          | |
         N     RB,=A(PAGPAGM)          |
         SRL   RB,L'PAGPAGM            | frame number
         IF    (RB,GE,PAGFRAN),BEGIN
         ABORT PAGFRAN                 not a valid frame number
         END   ,
         SLL   RB,PFTLOG               | frame number index
         LA    RA,@RA(RB)              |
         WITH  (PFTE,RA),BEGIN         Page Frame Table Entry addr
         MVC   @PAGRVASB,PFTASB        Current/Recent ASB
         L     RVR,PFTVA               Current/Recent Virtual addr
         N     RVR,=A(PAGPAGM)         |
         OR    RVR,RJ                  | and put back offset
         END   ,                       OF Page Frame Table Entry addr
         PEND  ,
         TITLE 'Internal page table resolve'
*NEST,1
*box
*
*  Resolve paged out page tables
*    This routine brings in the page table for a given address, but
*  doesn't bring in the actual page.  The page table is locked in
*  main store.
*    The virtual addresses of the page and shadow page table
*  addresses are set
*    Only for synchronous routines
*
*   Input - @RESPT
*
*  Output - @RESPT
*              RVR = contents of @PTRC
*                0 = page table now in core
*
*
         SPACE
RESPT    PROC  @RESPT                  Resolve page/segment out
         PAGAD RPAG                    |
         L     RPCB,@PTPCB             Get PCB address
         WITH  (ASBPCB,RPCB)           |
         SET   @PTFOK                  Assume OK to start
PAGPTVAL BEGIN ,                       Bring in PT
         VIRTABL @PTVA,LA:ASBPCB
         IF    (@VPFSLI,OR,@VPFPLI),BEGIN       Addr exception - len
         SET   @PTFADDR                Set addressing exception
         EXIT  PAGPTVAL
         END   ,                       OF Addr exception - len
*box
*
*
*  Segment invalid set - try to read in PT
*
*
         MVC   @PTPGTE(8),@VPPGTE      Set page table addrs
         LM    RM,RN,@VPSGTE
         WITH  (SSTE,RN),BEGIN         SSTE addr
         WITH  (SGTE,RM)
*
         IF    @VPFSEI,BEGIN           Need to bring in PT
         IF    ^SSTFDEF,BEGIN          Undefined seg addr exception
         SET   @PTFADDR
         EXIT  PAGPTVAL
         END   ,                       OF Undef seg addr exception
*-
*- Get PT's virtual addr
*-
         L     RA,SGTAD                This is VA if not in I/O
         N     RA,=A(SGTADMSK)         |
         IF    SSTFIO,BEGIN            PT in I/O - get VA from PFTE
         LR    RB,RA
         SRL   RB,L'PAGPAGM-PFTLOG
         AL    RB,PAGPFTO
         WITH  (PFTE,RB),BEGIN         PFTE addr
         L     RA,PFTVA
         END   ,                       OF PFTE addr
         N     RA,=A(PAGPAGM)
         END   ,                       OF PT in I/O - get VA from PFTE
*
         PSET  @RESOLVE                Bring in PT
         PMOV  @PRVA,(RA)              |
         PMOV  @PRPCB,LA:ASBPCB        |
         PMOV  @PRPSWM,@PTPSWM         |
         ACALL PAGRESLV                |
         IF    ^@PRROK,PAGPTABO
*
         L     RJ,@PTVA                Page/shadow page addrs
         N     RJ,=A(PAGPGNM)          |
         SRL   RJ,L'PAGPAGM            |
         LR    RK,RJ                   | shadow
         SLL   RK,SPTLOG               | |
         LA    RK,@RK+PGTL             | |
         ALR   RK,RA                   | |
         SLL   RJ,PGTLOG               |
         ALR   RJ,RA                   |
         STM   RJ,RK,@PTPGTE           | save tbl ptrs
         END   ,                       OF Need to bring in PT
*box
*
*  Page table is in - fix it
*
         L     RB,SGTAD                PT real addr
         N     RB,=A(SGTADMSK)         |
         PSET  @QFIX                   Fix PT page
         PMOV  @QFIXRA,(RB)            |
         ACALL QFIX                    |
         END   ,                       OF SSTE addr
         END   ,                       OF Bring in PT
         LC    RVR,@PTRC               Set return code
         PEND  ,
         SPACE
PAGPTABO ABORT PAGPTERR                Addr error on PT
*NEST,2
         TITLE 'Internal segment/page resolve'
*NEST,1
*box
*
*  Resolve paged out segments/pages
*    Only for synchronous routines
*
*   Input - @RESOLVE
*
*  Output - @RESOLVE
*             If @PRROK then RVR = frame real address
*
*
         SPACE
#RESOLVE RECORD BEGIN
#RESPSWM DS    X                       Old PSW mask
#RESWTF  FLAG  ,                       PCB lock flags - waiting
         FLAG  (#RESFGBL,PCBFGBL)      Global lock held
         FLAG  (#RESFLCL,PCBFLCL)      Local lock held
         END   ,
         SPACE
RESOLVE  PROC  @RESOLVE,#RESOLVE       Resolve page/segment out
         PAGAD RPAG                    |
         L     RPCB,@PRPCB             Get PCB address
         WITH  (ASBPCB,RPCB)           |
         SET   @PRROK                  Assume ok to start
         L     RA,@PRVA                Get virtual addr to resolve
         IF    ^PCBFGBL,BEGIN          Might need global lock
         LR    RB,RA                   | segment offset
         SRL   RB,L'PAGSGNM            |
         SLL   RB,SGTLOG               |
         AL    RB,PCBPSTO              |
         WITH  (SGTE,RB)               |
         IF    SGTFCOMM,BEGIN          Do need common lock
         L     RCPCB,PAGCASB
         WITH  (ASB,RCPCB),'L RCPCB,ASBPAGB'
         WITH  (ASBPCB,RCPCB),LABEL=COMM
         LKOB  COMM.PCBLOCK            Get global lock
         SET   PCBFGBL                 Set as held
         END   ,                       OF DO need common lock
         END   ,                       OF Might need global lock
         LRA   RVR,@RA                 |
*-
*- If page is not in - bring it in
*-
         IF    (NOT,VAOK),BEGIN        Page not in - bring it in
         LOOP  BEGIN                   Bring in Page
*-
*- Check for segment/page length error
*-
         IF    SPLI,BEGIN              Page/Seg len error
         SET   @PRRADDR
         EXIT  RESOLVE
         END   ,                       OF Page/Seg len error
         VIRTABL @PRVA,(RPCB)          Page/Seg table ptrs
         SET   @PRRADDR                Assume addr error
*-
*- Check for defined page
*-
         IF    (@VPFSLI,OR,@VPFPLI),EXIT,RESOLVE
         IF    @VPFPEI,BEGIN           Page entry invalid
         L     RJ,@VPPGTE
         WITH  (PGTE,RJ)
         IF    ^PGTFDEF,EXIT,RESOLVE
         END   ,                       OF Page entry invalid
*-
*- Check for defined segment
*-
         ELSEIF @VPFSEI,BEGIN          Segment entry invalid
         L     RJ,@VPSSTE
         WITH  (SSTE,RJ)
         IF    ^SSTFDEF,EXIT,RESOLVE
         END   ,                       OF Segment entry invalid
*-
*- If VAOK is returned from VIRTABL, but not through LRA, its an
*- error.
*-
         ELSE  BEGIN
         ABORT PAGRESOLVE
         END   ,
*-
*-   Not an addressing error - so reference frame to bring it it
*- We must free the spin locks so we can page fault
*-
         SET   @PRROK                  Assume OK
*
         MVC   #RESWTF,PCBLOCKF        Save lock flags
         CLEAR (RM),(RN)               Zero count of locks held
         IF    PCBFGBL,BEGIN           Global lock held
         L     RS,PAGCASB
         WITH  (ASB,RS),'L RS,ASBPAGB'
         LOOP  BEGIN
         WITH  (ASBPCB,RS),LABEL=GBL
         LA    RM,@RM+1
         LKREL GBL.PCBLOCK
         UNTIL (RVR,ZERO),END
         END   ,                       Of global lock held
*
         IF    PCBFLCL,BEGIN           Local lock held
         LOOP  BEGIN
         LA    RN,@RN+1
         LKREL PCBLOCK
         UNTIL (RVR,ZERO),END
         END   ,                       OF Local lock held
         STOSM #RESPSWM,0
         SSM   @PRPSWM
*box
*
*
*  Reference the frame to bring it in
*
*
         CLI   @RA,0
*
         SSM   #RESPSWM
         IF    #RESFLCL,BEGIN          Get local lock again
         LOOP  BEGIN
         LKOB  PCBLOCK                 |
         UNTIL (BCT,RN),END
         END   ,                       OF Get local lock again
         IF    #RESFGBL,BEGIN          Get global lock again
         WITH  (ASBPCB,RS),LABEL=GBL   |
         LOOP  BEGIN
         LKOB  GBL.PCBLOCK             |
         UNTIL (BCT,RM),END
         END   ,                       OF Get global lock again
         MVC   PCBLOCKF,#RESWTF        Reset locks-held flags
         SET   PCBFSYNC
*
         LRA   RVR,@RA
         UNTIL VAOK,END                OF Bring in Page
         END   ,                       OF Page not in - bring it in
         PEND  ,
         SPACE
SRABORT  ABORT SRABORT                 Segment resolve error
*NEST,2
         TITLE 'Page in a page'
*box
*
*  Allocate a frame and read into it.
*
*   Input - @PAGIN
*
*  Output - For asynchronous operations
*             IF @PGINOK the page-in was started and
*              RVR contains the real address of the new page
*             ELSE
*              It was not possible to start the operation
*
*
         SPACE
PAGIN    PROC  @PAGIN
*        CLEAR @PGINOK                 Set page-in not ok to start
         PAGAD RPAG
         L     RPCB,@PGIPCBC           PCB in control
         WITH  (ASBPCB,RPCB)
         L     RA,@PGIRA               Frame real address
         LR    RB,RA                   Frame table entry addr
         SRL   RB,L'PAGPAGM            |
         SLL   RB,PFTLOG               |
         AL    RB,PAGPFTO              |
         WITH  (PFTE,RB),BEGIN         Set up Page frame table
*-
*- Get control block memory
*-
         CELLGET TYPE=PAGE
         IF    (RVR,ZERO),BEGIN        | only on async ops
         FRAMEREL LA:PFTE              |  remove from fixed list
         EXIT  PAGIN                   |
         END   ,                       OF No Memory
*-
*- Fill in the page-frame-table entry.  Fill in the new
*- virtual address, and point at the I/O control block
*- for this frame's I/O.  ...
*-
         LR    RM,RVR                  I/O cell addr - from CELLGET
         ST    RM,@PGIPGD          ddf Return address to caller
         WITH  (PGDPAGE,RM),BEGIN      I/O cb addr
         WITH  (PSCPFX,PGDPGPFX)
         PMOV  PFTIOCB,LA:PGDPAGE      |
         PMOV  PSCASB,PCBASB           | ASB in control of I/O
         CLEAR PGDPGWT                 | no one else waiting yet
         CLEAR PGDIOF              ddf | clear io finished flag
         END   ,                       OF I/O cb addr
         MVC   PFTVA,@PGIVA            | Virt Addr
         IF    @PGIFPT,BEGIN           | Page table page
         SET   PFTFPGT                 |
         L     RJ,@PGISEG              |
         SRL   RJ,L'PAGSGNM            |
         STH   RJ,PFTSEG               |
         END   ,                       | OF Page table page
         IF    @PGIUFIX,'SET PFTFUFIX' | Unfix on IO completion
         END   ,                       OF Frame table entry addr
*-
*- Set up the I/O control block, and call the I/O supervisor to
*- get this one going.
*-
         WITH  (PGDPAGE,RM),BEGIN      I/O cb addr
         WITH  (PSCPFX,PGDPGPFX)
         USING PZERO,R0
         WITH  (#PIODO,PGDPIO)         Fill in parms
         PMOV  #PIODCMD,=A(#PCREAD)    | action code
         PMOV  #PIOLOC,(RA)            | real address
         LA    RJ,CPAGIOKEY            Set key for IO
         SSKE  RJ,RA                   |
         BLKDSID @PGISLOT              Get DSID/block no from slot #
         PMOV  #PIOBLK,@BLKRNUM        | block number
         PMOV  PSCDEV,@BLKBCB          |
         L     RK,@BLKID               | DSID
         PSET  @IOSDOIO                Call IO Supervisor
         PMOV  @IOSCHID,(RK)           |
         PMOV  @IOSID,PSCIO            | I/O supervisor ID
         PMOV  @IOSPID,PZCURPID        |
         PMOV  @IOSCP,LA:#PIODO        |
         PMOV  @IOSXID,LA:PAGTERM      | return addr
         PMOV  @IOSXPAR,LA:PGDPAGE     |
         PMOV  @IOSKEY,LA:CPAGIOKEY    | key of I/O
         SET   @IOSFAST                | fast path I/O
         VCALL IOSDOIO                 |
         DROP  R0
         END   ,                       OF I/O cell addr - from CELLGET
         SET   @PGINOK                 Page-In Started
         LR    RVR,RA                  | real addr
         PEND  ,
         SPACE ,
PAGIERR  ABORT PAGIERR
         TITLE 'Page out a page'
*box
*
*  Page out a page.
*
*   Input - @PAGOUT
*
*  Output -  IF @PGOOK the page-out was started
*            ELSE
*             It was not possible to start the operation
*
*
         SPACE
PAGOUT   PROC  @PAGOUT
*        CLEAR @PGOOK                  Set page out not ok to start
         PAGAD RPAG
*-
*- Allocate a paging I/O cell
*-
         CELLGET TYPE=PAGE             Get cell
         IF    (RVR,ZERO),EXIT,PAGOUT  | none available
*-
*- Set up page frame entry for I/O completion
*-
         LR    RB,RVR                  Cell address
         ST    RB,@PGOPGD          ddf Return addr to caller
         WITH  (PGDPAGE,RB),BEGIN      |
         WITH  (PSCPFX,PGDPGPFX)
         L     RA,@PGORA               Get RA and frame tbl addr
         N     RA,=A(PAGPAGM)          |
         LR    RK,RA                   |
         SRL   RK,L'PAGPAGM-PFTLOG     | entry offset in table
         AL    RK,PAGPFTO              |
         WITH  (PFTE,RK),BEGIN         |
         L     RPCB,PFTASB
         PMOV  PFTIOCB,LA:PGDPAGE      I/O control block for frame
         PMOV  PSCASB,(RPCB)           | ASB in control of I/O
         CLEAR PGDPGWT                 | no one else waiting yet
         CLEAR PGDIOF              ddf | clear io finished flag
         IF    @PGOUFIX,'SET PFTFUFIX' | Unfix on IO completion
         IF    @PGOREL,'SET PFTFREL'   | Release on IO completion
         END   ,                       OF Frame table entry addr
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB),BEGIN
         INCR  RS,PCBWCNT              Another page write outstanding
         END   ,
*-
*- Fix the frame, and clear the ref/change bits
*-
         PSET  @QFIX                   Quickly fix this page
         PMOV  @QFIXRA,(RA)            |
         ACALL QFIX                    |
         ISKE  RJ,RA                   Clear ref/change bits
         N     RJ,=A(PAGKEYM)          |
         SSKE  RJ,RA                   |
         USING PZERO,R0
*-
*- Set up the "channel program" and call the I/O supervisor to
*- get this I/O going
*-
         WITH  (#PIODO,PGDPIO)         Fill in parms
         PMOV  #PIODCMD,=A(#PCWRITE)   | action code
         PMOV  #PIOLOC,(RA)            | real address
         BLKDSID @PGOSLOT              Get DSID/block no from slot #
         PMOV  #PIOBLK,@BLKRNUM        | block number
         L     RK,@BLKID               | DSID
         PMOV  PSCDEV,@BLKBCB          | data set control block
         PSET  @IOSDOIO                Call IO Supervisor
         PMOV  @IOSCHID,(RK)           |
         PMOV  @IOSID,PSCIO            | I/O supervisor ID
         PMOV  @IOSPID,PZCURPID        |
         PMOV  @IOSCP,LA:#PIODO        |
         PMOV  @IOSXID,LA:PAGTERM      | return addr
         PMOV  @IOSXPAR,LA:PGDPAGE     |
         PMOV  @IOSKEY,LA:0            | write in key 0
         SET   @IOSFAST                | fast path I/O
         VCALL IOSDOIO                 |
         END   ,                       OF PGDPAGE address
         SET   @PGOOK                  Page-Out Started
         PEND  ,
         SPACE
PAGOERR  ABORT PAGOERR                 Page-out I/O error
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Page I/O termination'
*box
*
*  Page I/O termination
*
*   Input - @IOTERM
*       The PGDPAGE control block contains the PCB address that is
*     in control of the I/O.  The owner of the frame in I/O is
*     determined from the frame table entry.
*
*  Output - NONE
*
*
         SPACE
#PAGTERM RECORD BEGIN
#PTPSWM  DS    X                       PSW mask for disabling
#PTLKFLG DS    X                       Lock flags this PCB
#PTFLAG  FLAG  ,
         FLAG  #PTFCRL                 Release I/O cell
         END   ,
         SPACE
PAGTERM  PROC  @IOTERM,#PAGTERM,SCOPE=GLOBAL
         PAGAD RPAG
         SET   #PTFCRL                 Release I/O cell by default
         IF    ('LT RJ,@IOTEND',NZ),PGTABORT
         L     RJ,@IOTPARM             Get control block addr
         WITH  (PGDPAGE,RJ)
         TS    PGDIOF              ddf Ready for IO termination yet?
         IF    Z,EXIT              ddf No, this routine will be
*                                  ddf called again when ready.
         WITH  (PSCPFX,PGDPGPFX)
         WITH  (#PIODO,PGDPIO)
         L     RPCB,PSCASB             PCB address in control
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
*
*  Get needed locks
*   We need the local address space lock, and if this I/O is
*   for a global frame, we need the global address space lock.
*
*  NB - This logic would need to change if one address space could
*    fault in a secondary address space.  Currently the only
*    other address space one can fault in is the global address
*    space.
         PAGNTRY ASYNC,#PTPSWM,#PTLKFLG
         REGCH (RCPCB,RK)
         L     RB,#PIOLOC              Frame address
         SRL   RB,L'PAGPAGM-PFTLOG     |
         AL    RB,PAGPFTO              |
*-
*- Check for the global address space, and get the global lock
*- if we need it
*-
         WITH  (PFTE,RB),BEGIN         |
         L     RCPCB,PFTASB
         WITH  (ASB,RCPCB),'L RCPCB,ASBPAGB'
         WITH  (ASBPCB,RCPCB),LABEL=COMM,BEGIN
         IF    (COMM:PCBFGBLC,AND,^PCBFGBL),BEGIN       Get global lock
         LKOB  COMM.PCBLOCK            |
         SET   PCBFGBL                 |
         END   ,                       OF Get global lock
         END   ,                       OF frame owner PCB addr
*-
*- Set up to call write or read completion routines.  Do general
*- stuff first.
*-
         PSET  @PAGPIOC
         PMOV  @PCRA,#PIOLOC
         PMOV  @PCPCB,(RCPCB)          PCB that owns frame
         PMOV  @PCIOCB,LA:PGDPAGE      I/O control block
         PMOV  @PCPCBC,LA:ASBPCB       PCB in control of I/O
*-
*- I/O command was a read, so call read completion routine
*-
         IF    (#PIODCMD,EQ,=A(#PCREAD)),BEGIN  Read completion
         LCALL PAGPRC
         L     EPAR,PCBPFOUT
         LOOP  BEGIN                   One less PF
         LR    RAR,EPAR
         DECR  RAR
         CS    EPAR,RAR,PCBPFOUT
         UNTIL (EQUAL),END             OF One less PF
         IF    (RAR,NZ),'ABORT MULPFEND'
         L     RA,PCBASB               AS to notify about
         END   ,                       OF Read completion
*-
*- I/O command was a write, so call the page write completion routine
*-
         ELSE  BEGIN                   Write completion
         MVC   PGDPGVA,PFTVA           Save virtual address
         CLEAR PGDFPGT
         IF    PFTFPGT,BEGIN
         SET   PGDFPGT                   and page table flag
         MVC   PGDPGSEG,PFTSEG             and segment of PT
         END   ,
         IF    PCBFISOUT,BEGIN         AS swapped out
         MVC   PSCFP,PCBWPEND          Queue up this I/O
         PMOV  PCBWPEND,LA:PGDPAGE
         CLEAR #PTFCRL                 Don't release I/O cell
         END   ,                       OF AS swapped out
         ELSE  BEGIN
         LCALL PAGPWC                  |
         END   ,
         CLEAR RA                      No notify
         END   ,                       OF Write completion
*-
*-  If we are supposed to release or unfix this frame at I/O
*- completion, do it.
*-  If a frame is to be released, don't unfix it first, just
*- relase it.  This needs to be done this way so that the lists
*- of unfixed frames in the PCB do not change while a swap is in
*- progress.  The long term fixed frames are allowed to change
*- during this time however.
*-
         IF    PFTFREL,BEGIN           Release frame
         CLEAR PFTFREL*PFTFUFIX        |
         FRAMEREL LA:PFTE              |
         END   ,                       OF Release frame
         ELSEIF PFTFUFIX,BEGIN         Unfix the frame
         PSET  @QUFIX                  |
         PMOV  @QUFRA,#PIOLOC          | frame table entry addr
         ACALL QUFIX                   |
         CLEAR PFTFUFIX                |
         END   ,                       OF Unfix the frame
         END   ,                       OF PFTE addr
*-
*- Free up locks for this AS
*-
         PAGXIT ASYNC,#PTPSWM,#PTLKFLG,WR=RS ,CPCB=RCPCB
*-
*- Now that the locks are released, we can make our requests
*- of the dispatcher to start up waiting tasks.
*-
         IF    (RA,NZ),BEGIN           Do notify
         PSET  @DISPPIOC
         PMOV  @DPIOASB,(RA)
         VCALL DISPPIOC
         END   ,                       OF Do notify
*-
*- Notify all PCBs that are waiting for this I/O that it is
*- complete.
*-
         L     RA,PGDPGWT              Process any waiting ASs
         CLEAR PGDPGWT                 | clear for next time
         WHILE (RA,^ZERO),BEGIN
         WITH  (ASBPCB,RA),LABEL=WAIT
         L     RB,WAIT.PCBWAIT         Get next waiting PCB
*
         IF    WAIT:PCBFREAD,BEGIN     Wait is because of a read
*-
*- This PCB is waiting because of a page read request,
*- so we need to notify the dispatcher to wake it up.
*-
         L     EPAR,WAIT.PCBPFOUT
         LOOP  BEGIN                   One less PF
         LR    RAR,EPAR
         DECR  RAR
         CS    EPAR,RAR,WAIT.PCBPFOUT
         UNTIL (EQUAL),END             OF One less PF
         IF    (RAR,NZ),'ABORT MULPFEND2'
         PSET  @DISPPIOC               Call I/O completion
         PMOV  @DPIOASB,WAIT.PCBASB    |
         VCALL DISPPIOC                |
         END   ,                       OF Wait is because of a read
*-
*- This PCB is waiting for the I/O to complete and the frame to
*- be released.
*-
         ELSEIF WAIT:PCBFREL,BEGIN     Wait for frame to be released
         SIGNL WAIT.PCBECB,TYPE=AS
         END   ,                       OF Wait for frame to be released
         LR    RA,RB                   Advance pointer
         END   ,                       OF Process any waiting ASs
*-
*- Free up IO cell
*-
         IF    #PTFCRL,BEGIN           Release I/O cell
         CELLFREE LA:PGDPAGE,TYPE=PAGE
         END   ,
         PEND  ,
         SPACE
PGTABORT ABORT PGTABORT                Page I/O error
         TITLE 'Page read complete'
*box
*
* Page read I/O comlete
*   May Run off of dispatcher stack.
*
*   Input - @PAGPIOC
*           If @PCIOCB is non zero, I/O statistics are gathered
*             Appropriate address space locks must be held before
*           entry to routine.
*
*  Output - @PAGPIOC
*
*
         SPACE
PAGPRC   PROC  @PAGPIOC                Page read complete
         PAGAD RPAG                    Get addr to PAGCB
*-
*- Gather stats
*-
         L     RJ,@PCIOCB
         IF    (RJ,NZ),BEGIN           Gather Stats
         WITH  (PGDPAGE,RJ)
         WITH  (PSCPFX,PGDPGPFX)
         PSET  @IOSTIME
         PMOV  @IOSTID,PSCIO
         VCALL IOSTIME
*
         INCR  RS,PAGMPIN              One more page in
         LM    RM,RN,@IOSIOTIME        Total time
         LM    RA,RB,PAGMPIT           |
         ADLR  RM,RA                   |
         STM   RM,RN,PAGMPIT           |
*
         L     RK,PSCDEV
         WITH  (DSDES,RK)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         INCR  RS,DSINCNT              Another page in this device
         LM    RM,RN,@IOSIOTIME        Total time
         LM    RA,RB,DSINTIME          |
         ADLR  RM,RA                   |
         STM   RM,RN,DSINTIME          |
         END   ,                       OF Gather Stats
*-
*- Get addressability to the page-frame-table entry, (also clearing
*- the I/O control block address)
*-
         L     RJ,@PCRA                Real addr of frame
         LR    RK,RJ                   Get frame table addr
         SRL   RK,L'PAGPAGM            |
         SLL   RK,PFTLOG               |
         AL    RK,PAGPFTO              |
         WITH  (PFTE,RK)               |
         CLEAR PFTIOCB                 | disconnect frame from I/O
         L     RPCB,@PCPCB             Address of PCB that owns frame
         WITH  (ASBPCB,RPCB)           |
         L     RA,PCBPSTO              Seg tbl origin
         LRA   RA,@RA                  |
         L     RPCB,@PCPCBC            Addr of PCB in control of I/O
         L     RM,PCBRA                Real PCB addr
         WITH  (ASBPCB,RM),LABEL=REAL  |
*-
*- This frame isn't being released, so fix up all the translation
*- tables for this real address.
*-
         IF    ^PFTFREL,BEGIN          Don't release the frame
*box
*
*  Page table coming in
*
         IF    PFTFPGT,BEGIN           Page table coming in
*-
*- Get addressability to the segment table entry
*-
         LH    RS,PFTSEG               Get seg table addresses
         LR    RB,RS                   |
         SLL   RS,SGTLOG               |
         ALR   RS,RA                   |
         SLL   RB,SSTLOG               | shadow seg addr
         AH    RB,PAGSEGL              |
         ALR   RB,RA                   |
         DATOFF PCBPSWM                |
*-
*- Segment is no longer invalid, and it's no longer in I/O either
*-
         WITH  (SGTE,RS),BEGIN         Clear invalid segment
         IF    ^SGTFINV,PEABORT        | Should be invalid segment
         CLEAR SGTFINV
         END   ,                       OF Clear invalid segment
         WITH  (SSTE,RB),BEGIN         Clear segment fault flag
         CLEAR SSTFIO                  |
         END   ,                       |
         DATON REAL.PCBPSWM            DAT-On
*-
*- Frame-table-entry flags may require us to unfix the frame
*-
         IF    PFTFUFIX,BEGIN          Unfix the frame
         PSET  @QUFIX                  |
         PMOV  @QUFRA,@PCRA            | frame addr
         ACALL QUFIX                   |
         CLEAR PFTFUFIX                |
         END   ,                       OF Unfix the frame
         END   ,                       OF Page table coming in
*box
*
*  Mark page table entry as valid
*
         L     EPAR,PFTVA
         LRA   BRR,PAGCB
         WITH  (PAGCB,BRR),LABEL=PREAL,BEGIN    Page CB real addr
         DATOFF PCBPSWM                |
*-
*- Compute table entry addresses (page table and shadow)
*-
         LR    RB,EPAR                 Compute table entries
         SRL   RB,L'PAGSGNM            |
         SLL   RB,SGTLOG               |
         ALR   RB,RA                   |
         WITH  (SGTE,RB),'L RS,SGTAD'  | Page table address
         N     RS,=A(SGTADMSK)         |
         LR    RB,EPAR                 | VA
         N     RB,=A(PAGPGNM)          |
         LR    RA,RB                   |
         SRL   RB,L'PAGPGNM-SPTLOG     |
         SRL   RA,L'PAGPGNM-PGTLOG     |
         ALR   RA,RS                   | page table entry
         ALR   RB,RS                   | shadow page addr
         LA    RB,@RB+PGTL             |
*-
*- Fix up page table/shadow page table w/ real addresses
*-
         WITH  (PGTE,RA),BEGIN
         L     RVR,PGAD                Contents of page table entry
         N     RVR,=A(PGTAIMSK-L'PGTFIO)    not in I/O, fault handled
         OR    RVR,RJ                  | this is RA + flags
         ST    RVR,PGAD                |
*-
*- Set the key for the new page
*-
         WITH  (SPTE,RB)               Shadow page table entry
         IC    RVR,SPKEY               Set storage key
         N     RVR,=A(PAGKREF)         | no reference bits
         STC   RVR,SPKEY               |
         SSKE  RVR,RJ                  | RJ is Real Addr
*-
*- If the cards are right, we're supposed to release this
*- external frame.  We don't do this however for the external
*- frames of page tables because the external frame number is in
*- both the page table and the segment table...
*- just too darn complex!
*-
         IF    (PGTFXDEF,AND,          Release external frame          *
               (^PGTFPGT,AND,PREAL:PAGXF1DEF)),BEGIN
         CLEAR PGTFXDEF                Not defined any more
         L     RS,SPXSLOT              Get external frame number
         CLEAR SPXSLOT
         DATON REAL.PCBPSWM
         XPREL (RS)                    Release external frame
         END   ,                       OF Release external frame
         ELSE  BEGIN
         DATON REAL.PCBPSWM            DAT-On
         END   ,
         END   ,                       OF Page table entry addr
         END   ,                       OF Page CB real addr
         END   ,                       OF Don't release the frame
*-
*- For the case where a frame is marked to be released as soon
*- as the I/O completes we do the following...
*-
         ELSE  BEGIN                   This frame is being released
         L     EPAR,PFTVA
         DATOFF PCBPSWM                |
*-
*- Compute page table entry address
*-
         LR    RB,EPAR                 Compute table entries
         SRL   RB,L'PAGSGNM            |
         SLL   RB,SGTLOG               |
         ALR   RB,RA                   |
         WITH  (SGTE,RB),'L RS,SGTAD'  | Page table address
         N     RS,=A(SGTADMSK)         |
         LR    RA,EPAR                 | VA
         N     RA,=A(PAGPGNM)          |
         SRL   RA,L'PAGPGNM-PGTLOG     |
         ALR   RA,RS                   | page table entry
*-
*- Clear flag for I/O in progress
*-
         WITH  (PGTE,RA),BEGIN
         CLEAR PGTFIO                  No longer in I/O
         END   ,
*-
*- A released page is one less valid page in the segment, which
*- results in one less short term fix for the page table frame.
*-
         QUSFIX (RS)                   Real address of PT
         DATON REAL.PCBPSWM
         END   ,                       OF This frame is being released
**
*  If we are supposed to unfix this frame at I/O completion, do it
**
         IF    PFTFUFIX,BEGIN          Unfix the frame
         PSET  @QUFIX                  |
         PMOV  @QUFRA,@PCRA            | frame table entry addr
         ACALL QUFIX                   |
         CLEAR PFTFUFIX                |
         END   ,                       OF Unfix the frame
*-
*- Update accounting
*-
         INCR  RS,PCBMPFR              Page frame reads
         PEND  ,
         SPACE
PEABORT  ABORT PAGPIOR                 PT coming in already valid
         TITLE 'Page write complete'
*box
*
* Page write I/O comlete
*   May run off of dispatcher stack.
*
*   Input - @PAGPIOC
*           If @PCIOCB is non zero, I/O statistics are gathered
*             Appropriate address space locks must be held before
*           entry to routine.
*
*  Output - @PAGPIOC
*
*
         SPACE
#PAGPWC  RECORD BEGIN
#PWCKEY  DS    A                       Area to save PSW key
         END   ,
         SPACE ,
PAGPWC   PROC  @PAGPIOC,#PAGPWC        Page write complete
         PAGAD RPAG                    Get addr to PAGCB
*-
*- Gather stats
*-
         L     RK,@PCIOCB
         WITH  (PGDPAGE,RK)            Gather Stats
         WITH  (PSCPFX,PGDPGPFX)
         PSET  @IOSTIME
         PMOV  @IOSTID,PSCIO
         VCALL IOSTIME
*
         INCR  RS,PAGMPON              One more page out
         LM    RM,RN,@IOSIOTIME        Total time
         LM    RA,RB,PAGMPOT           |
         ADLR  RM,RA                   |
         STM   RM,RN,PAGMPOT           |
*
         L     RJ,PSCDEV
         WITH  (DSDES,RJ)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         INCR  RS,DSOUTCNT             Another page out this device
         LM    RM,RN,@IOSIOTIME        Total time
         LM    RA,RB,DSOUTTIME         |
         ADLR  RM,RA                   |
         STM   RM,RN,DSOUTTIME         |
*
         L     RPCB,@PCPCB             Address of PCB that owns frame
         WITH  (ASBPCB,RPCB)           |
         REGCH (RA,R2)
         IPK   ,                       Save off the old key
         ST    RA,#PWCKEY
         SPKA  0                         and get into key 0
         L     RA,PCBPSTO              Seg tbl origin
         LRA   RA,@RA                  |
         L     RM,PCBRA                | and it's real addr
         WITH  (ASBPCB,RM),LABEL=REAL  |
*box
*
*  Page table written
*
         IF    PGDFPGT,BEGIN           Page table gone out
*-
*-   Work with this page table's own virtual address
*- Now that the page table I/O is complete, store the segment
*- number that this page table maps as this VAs frame
*-
         LH    RJ,PGDPGSEG
         SLL   RJ,L'PAGSGNM
*-
*- Get the page table entry for this page table's virtual addr
*-
         L     RB,PGDPGVA              Get page table entry
         LR    RVR,RB                  |
         SRL   RB,L'PAGSGNM            |
         SLL   RB,SGTLOG               |
         ALR   RB,RA                   |
         DATOFF PCBPSWM                |
         WITH  (SGTE,RB),BEGIN         |
         IF    SGTFINV,PWCPTI          | PTs own VA must be valid seg
         L     RB,SGTAD                |
         END   ,                       | OF SGTE addr
         N     RB,=A(SGTADMSK)         |
         N     RVR,=A(PAGPGNM)         |
         SRL   RVR,L'PAGPGNM-PGTLOG    |
         ALR   RB,RVR                  |
         WITH  (PGTE,RB),BEGIN         | PGTE addr
         IF    ^PGTFINV,PWCPTI         PTs own VA must be invalid page
         L     RVR,PGAD                | set segment number as frame
         N     RVR,=A(PGTFLMSK)        | | save flags
         OR    RVR,RJ                  | |
         ST    RVR,PGAD                | |
         END   ,                       OF PGTE addr
         DATON REAL.PCBPSWM
*box
*
*    Set segment table entry with the virtual address of the
*  page table.
*    Clear segment fault in progress
*
         LH    RJ,PGDPGSEG             Get seg/shadow seg table addrs
         LR    RB,RJ                   | seg
         SLL   RB,SGTLOG               | |
         ALR   RB,RA                   | |
         SLL   RJ,SSTLOG               | shadow
         AH    RJ,PAGSEGL              | |
         ALR   RJ,RA                   | |
         L     RN,PGDPGVA              | VA of PT
         N     RN,=A(PAGPAGM)          | |
         DATOFF PCBPSWM                DAT-Off
         WITH  (SGTE,RB),BEGIN         SGTE addr (real)
         L     RVR,SGTAD               Put PTs VA in segment table
         N     RVR,=A(SGTFLMSK)        |
         OR    RVR,RN                  |
         ST    RVR,SGTAD               |
         END   ,                       OF SGTE addr (real)
         WITH  (SSTE,RJ),BEGIN         Clear segment "in I/O"
         CLEAR SSTFIO                  |
         END   ,                       |
         DATON REAL.PCBPSWM            DAT-On
         END   ,                       OF Page table gone out
*box
*
*  Page written out
*
         L     RJ,PGDPGVA
         DATOFF PCBPSWM                DAT-Off
         LR    RB,RJ                   Compute table entries
         N     RB,=A(PAGSGNM)          |
         SRL   RB,L'PAGSGNM-SGTLOG     |
         ALR   RB,RA                   |
         WITH  (SGTE,RB),'L RS,SGTAD'  | Page table address
         N     RS,=A(SGTADMSK)         |
         LR    RA,RJ                   |
         N     RA,=A(PAGPGNM)          |
         SRL   RA,L'PAGPGNM-PGTLOG     |
         ALR   RA,RS                   | page table entry addr
*-
*- Fix up page table/shadow page table
*-
         WITH  (PGTE,RA),BEGIN         |
         CLEAR PGTFIO                  Page write done
         END   ,                       OF Page table entry addr
         DATON REAL.PCBPSWM
*-
*- Now go back to the old key which we were called in
*-
         L     RA,#PWCKEY
         SPKA  @RA
*-
*- A stolen page is one less valid page in the segment, which
*- results in one less short term fix for the page table frame.
*-
         QUSFIX (RS)
*-
*- When an address space terminates, it may have to wait for frame
*- writes to complete.
*-   If we're terminating this address space and this is the last
*- page write outstanding, then signal the waiting level of control
*- to finish the termination
*-
         DECR  RS,PCBWCNT              One less I/O outstanding
         IF    ((RS,NPOS),AND,PCBFTERM),BEGIN
         SIGNL PCBWECB,TYPE=AS
         END   ,
         PEND  ,
         SPACE
PWCPTI   ABORT PAGPWC
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Swap an address space out'
*box
*
*   Notify that address space is ready to be send out of main
* store
*
*   Input - @PAGSWAP
*
*  Output - @PAGSWAP
*            RVR indicates the state of the swap-out
*
*
#OSWAP   RECORD BEGIN
#OSPSWM  DS    X                       PSW mask for disabling
#OSLKFLG DS    X                       Save area for AS lock flags
         END   ,
         SPACE ,
PAGOSWAP PROC  @PAGSWAP,#OSWAP,SCOPE=GLOBAL     Swap an address space
         PAGAD RPAG
         CLEAR #OSWAP
         L     RPCB,@SWASB             Address space block addr
         WITH  (ASB,RPCB),BEGIN        |
         IF    (ASBPASN,ZERO),'ABORT SWAP0INIT'
         L     RPCB,ASBPAGB            |
         END   ,                       |
         WITH  (ASBPCB,RPCB)           |
         PAGNTRY ASYNC,#OSPSWM,#OSLKFLG
         IF    PCBFSOUT,'ABORT PAGSWINV'        Already swapped out
*-
*- This will be a logical swap, so tell the dispatcher we're done,
*- and set the address space as out, logically, and with its
*- frames still in allocated
*-
         SET   @SWFOK                  Set as done - logically
         SET   PCBFSOUT                Now it is swapped out
         SET   PCBFISOUT
*-
*- Count frames in this swap set
*-
         LH    RM,PAGSEGP              Complete number of swap frames
         AL    RM,PCBFCNT              | + non fixed frames
         AL    RM,PCBPFCNT             |  + page table frames
         STH   RM,PCBSWCNT
         CLEAR PCBSWFS                 No frames stolen yet
*-
*- One more swap out - requested and virtual
*-
         INCR  RS,PAGMSORN             | one more swap requested
         INCR  RS,PAGMSOVN
*-
*- One less user in memory
*-
         L     RA,PAGASIN
         LOOP  BEGIN
         LR    RB,RA
         DECR  RB
         CS    RA,RB,PAGASIN
         UNTIL EQUAL,END
*-
*- Set this up as a logical swap
*-
         LKOB  PAGSWAPL                Get swap resource lock
         SET   PCBFLOUT                Logically out
*-
*- Add to list of logical swaps
*-
         LADD  PAGLASB,LA:ASBPCB,WR=RS Add to logical swaps
         L     RJ,PAGFLS               |  and more logical frames
         ALR   RJ,RM                   |
         ST    RJ,PAGFLS               |
*-
*- Compute paging function number - adding these frames
*-
         L     RA,PAGFTCNT             Compute paging funcion number
         L     RB,PAGASIN              | reserved/address space
         CEIL  RB,PFRESLIM             |  (up to a
         SLR   RA,RB                   |    limit)
         SL    RA,PAGFRES              |  this many "reserved"
         ALR   RA,RJ                   |   and this many logical
         L     EPAR,MATPTR             |
         WITH  (MAT,EPAR),'ST RA,MATPAGFN'
         LKREL PAGSWAPL
         PAGXIT ASYNC,#OSPSWM,#OSLKFLG,WR=RS
*-
*- If we're low on frames, post the swap address space
*- Low is when we have more frames waiting to come in than
*- we have room in main store.
*-
         ACALL MAKEROOM
         LR    RVR,RM                  Return working set size
         PEND  ,
         TITLE 'Make room routine - post swap address space'
*box
*
*  Make room.  If we're tight it means swapping someone out
*
*   Input -  None
*
*  Output -  None
*
*
         SPACE ,
MAKEROOM PROC  ,                       Paging room - post swap AS
         PAGAD RPAG
*-
*- The items which contribute to the number of frames we need:
*- 1) The current swap-in rate x for which there is a function
*-    f(x) which determines the reserved frame count for this
*-    level of activity. (PAGRESAMT)
*- 2) Frames waiting to be swapped in (minus the number of frames
*-    currently being swapped out)
*-
         L     RK,PAGRESAMT            Reserve due to swap-in rate
         AL    RK,PAGFRES                plus other reserved frames
*-
*- Pick the number of frames we need to swap in other waiting ASs
*-
         L     RN,PAGFWSI              Number we need to swap in
         S     RN,PAGFSOIP             | + swap-out in progress
*-
*- Compute the number of extra frames we need
*-
         ALR   RN,RK                   Total frames needed
         S     RN,PAGFTCNT
*-
*- If we need frames and there are logically swapped address
*- spaces, post the swap address space
*-
         IF    ((RN,POS),AND,('LT RS,PAGLCNT',NZ)),BEGIN
         SIGNL PAGSWECB,TYPE=AS        Post the Swap AS
         END   ,
         PEND
         TITLE 'Swap address space - swap out logically swapped ASs'
*NEST,1
*box
*
*  Swap out address spaces if we're tight on room
*
*   Input - NONE
*
*  Output - NONE
*
*
#PAGESWAP RECORD BEGIN
#PSSSF   DS    X                       Flag for Set Swap RC
#PSPSWM  DS    X                       PSW mask for disabling
         END   ,
         SPACE ,
PAGESWAP PROC  ,#PAGESWAP              Swap-Address space routine
         PAGAD RPAG
*-
*- Set address space as non-swappable
*-
         PSET  @DISPSWP
         VCALL DISPSHLD
*-
*- Give this address space system-AS priority
*-
         VCALL ASSYSTSK
*
PSWAIT   LOOP  BEGIN                   Main processing loop
*-
*- Call the routine to wake up those who were waiting for a
*- resource
*-
         ACALL WAKELOOK
*-
*- Wait for work
*-
         AWAIT PAGSWECB,TYPE=AS
*-
*-  The items which contribute to the number of frames we need:
*-  1) The current swap-in rate x for which there is a function
*-     f(x) which determines the reserved frame count for this
*-     level of activity. (PAGRESAMT)
*-  2) Frames waiting to be swapped in (minus the number of frames
*-     currently being swapped out)
*-
         L     RK,PAGRESAMT            Reserve due to swap-in rate
         AL    RK,PAGFRES                plus other reserved frames
*-
*- Pick the number of frames we need to swap in other waiting ASs
*-
         L     RN,PAGFWSI              Number we need to swap in
         S     RN,PAGFSOIP             | + swap-out in progress
*-
*- Compute the number of extra frames we need
*-
         ALR   RN,RK                   Total frames needed
         S     RN,PAGFTCNT
         IF    (RN,NPOS),NEXT          Wait some more...
*
         SLKOB PAGSWAPL,#PSPSWM
PSLOOP   WHILE (RN,POS),BEGIN          Send out until enough frames
*-
*- Start sending out the Address spaces already in progress
*-
         IF    (PAGLICNT,NZ),BEGIN     There are ASs in-progress
         PSET  @SWAPOUT
         PMOV  @SOAMT,(RN)
         LCALL SWAPOUT
         SR    RN,RVR                  Fewer needed
         IF    NPOS,EXIT,PSLOOP
         END   ,                       OF There are ASs in-progress
*-
*- We still need more room, so take from Logically swapped
*-
         IF    (PAGLCNT,ZERO),EXIT,PSLOOP
         LREM  PAGLASB,WR=RS
         LR    RPCB,RVR
         WITH  (ASBPCB,RPCB)
         SET   PCBFLIP                 This AS is in progress
*-
*- Try to prepare this AS for swapping out
*-
         SLKRL PAGSWAPL,#PSPSWM
         PSET  @SETSWAP
         PMOV  @SSPCB,LA:ASBPCB
         LCALL SETSWAP
         PMOV  #PSSSF,@SSFLAG          Save RC from SetSwap
         SLKOB PAGSWAPL,#PSPSWM
*box
*
*  Swap in not requested
*
         IF    ^PCBFRSIN,BEGIN         Swap in not requested
         IF    #PSSSF.@SWFOK,BEGIN     Swap setup OK
         CLEAR PCBFLOUT                Not logically swapped anymore
         LADD  PAGLIP,LA:ASBPCB,WR=RS  One more AS in-progress
         PSET  @NVLDASN                Invalidate the ASN
         PMOV  @IAASB,PCBASB           |
         ACALL NVALDASN                |
         END   ,                       OF Swap setup OK
*-
*- Couldn't prepare this AS, so we queue it back up as logically
*- swapped and then we're done.
*-
         ELSE  BEGIN                   Couldn't set up swap
         CLEAR PCBFLIP                 Not in-progress anymore
         INCR  RS,PAGMFSO              Count failed swap-outs
         LADD  PAGLASB,LA:ASBPCB,WR=RS
         SLKRL PAGSWAPL,#PSPSWM
         NEXT  PSWAIT
         END   ,                       OF Couldn't set up swap
         END   ,                       OF Swap in not requested
*box
*
*  Swap-in requested
*
         ELSE  BEGIN                   Swap in requested
*-
*- While we were trying to set up for a swap out, there was a
*- moment when we didn't hold the swap lock and this
*- address space was marked as being in transition between
*- logically swapped, and in-progress.  If this address space
*- was requested to be brought back into core during that time,
*- we need to do it now.
*-
         L     RS,PAGFLS               Fewer logically
         SH    RS,PCBSWCNT               swapped
         ST    RS,PAGFLS                   frames
         L     EPAR,MATPTR             Update
         WITH  (MAT,EPAR),BEGIN          paging
         L     RS,MATPAGFN                 function
         SH    RS,PCBSWCNT                   number
         ST    RS,MATPAGFN
         END   ,                       OF Update paging function num
         SLKRL PAGSWAPL,#PSPSWM
*-
*- Now we have released the swap lock, and can request services
*- of the dispatcher again.  We will notify it of any address
*- spaces that are now considered "back in"
*-
*- Do work to bring AS back in
*-
         PSET  @SWDONE                 Bring in this logical one
         PMOV  @SWDPCB,LA:ASBPCB       |
         ACALL SWAPILOG
*-
*- Notify the dispatcher that this AS is now in core again
*-
         PSET  @DISPSIOC
         PMOV  @DSIOASB,PCBASB
         VCALL DISPSIOC
         IF    ^#PSSSF.@SWFOK,'NEXT PSWAIT'
         SLKOB PAGSWAPL,#PSPSWM
         END   ,                       OF Swap in requested
         END   ,                       OF Send out until enough frames
         SLKRL PAGSWAPL,#PSPSWM
         END   ,                       OF Main processing loop
         PEND  ,
*NEST,2
         TITLE 'Set up an address space to be swapped'
*box
*
*
*             Set up an address space to be swapped
*  Swap frames are put into the swap control block in a specific
*  order.  Segment table frame(s), then page table frames, then
*  other non-fixed frames.
*
*   Input -    @SETSWAP
*
*  Output -    @SSFLAG indicates success or failure of setup
*
*
#SSWAP   RECORD BEGIN                  Local work for PAGSWAP
#SSDBAD  DS    A                       Descriptor block addr
#SSSLNXT DS    A                       Next slot in descriptor block
#SSSLNXV DS    A                       | and aux block
#SSNXDB  DS    A                       Next descriptor block
#ADPARM  EQU   #SSDBAD,*-#SSDBAD
#SSCLAST DS    A                       Last I/O cell address
#SSPSWM  DS    X                       PSW mask for disabling
#SSLKFLG DS    X                       Locks for this PCB
         END   ,
         SPACE
         REGCH (RPCB,RY),(RPAG,RX),(RCPCB,RK)
SETSWAP  PROC  @SETSWAP,#SSWAP ,SCOPE=GLOBAL    Swap an address space
         PAGAD RPAG
         CLEAR #SSWAP
         L     RPCB,@SSPCB             Address space block addr
         WITH  (ASBPCB,RPCB)           |
         SET   @SSFLAG.@SWFOK          Swap setup OK
PAGSWVAL BEGIN ,                       Set as swap in progress
*-
*- First we must allocate swap control blocks and external frames
*- for the I/O.
*- Here we figure out how many swap control blocks we need.
*-
         PMOV  (RS),PCBSWCNT           Size of working set
         LH    RK,PAGSWXN              Compute # swap CBs
         ALR   RS,RK                   |
         DECR  RS                      |
         CLEAR RVR                     |
         DR    RVR,RK                  |
         PMOV  PCBSWCBN,(RS)           Number of cells
         CELLGET (RS),TYPE=SWAP        Get swap CB
*-
*- Control block allocation failed.  Return unsuccessfully.
*-
         IF    ('LTR RN,RVR',Z),BEGIN  | No control blocks avail
         SET   @SSFLAG.@SWFWAIT        |  we'll have to wait on this
         EXIT  PAGSWVAL                |
         END   ,                       OF Get swap CB
         WITH  (PGDSWAP,RN)            Swap descriptor addr
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (#SWPDO,PGDSWP)
*-
*- Setup master swap control block for AS
*-
         PMOV  PCBSWCB,LA:PGDSWAP      Save PCB's swap CB addr
         PMOV  #SSCLAST,@CGLAST         and last cell address
         PMOV  PCBSWPCT,PCBPFCNT         num of page table frames
*box
*
*  Initialize the control blocks
*
         L     RS,#SSCLAST
         WITH  (PGDSWAP,RS),LABEL=LAST,BEGIN
         WITH  (PSCPFX,LAST.PGDSWPFX),LABEL=LSTPFX
         CLEAR LSTPFX.PSCFP            No forward link on last
         END   ,
*-
*- Add all control blocks to local list
*-
         PMOV  (RA),PCBSWCBN           Number of CBs
         LOOP  BEGIN                   Link all CBs
         L     RJ,PSCFP                Forward link
         ST    RJ,PGDSWLNK
         LADD  PCBSWIN,LA:PGDSWAP,WR=RS
         LR    RN,RJ
         UNTIL (BCT,RA),END
*-
*- Get external page frames
*-
         L     RN,PCBSWCB              First CB
         PMOV  (RA),PCBSWCBN             Number of CBs
         PMOV  (RJ),PCBSWCNT               and number of frames
         LOOP  BEGIN                   Fill in all CBs
         PSET  @XPGET                  Get pages
         PMOV  @XPCNT,LA:1             | number of swap groups
         ACALL SWPGET                  |
         IF    ^@XPOK,DOSXPF           Block allocation failed
         ST    RVR,#SWPBLK             Start block of swap set
         PMOV  PSCDEV,@XPDSDES           and device descriptor
         LH    RK,PAGSWXN              Frames in this extent
         STMIN RJ,RK                   |
         STH   RK,#SWPCNT              |
         MVC   PSCASB,PCBASB           Setup -  ASB in control
         SET   (PGDSFLOUT+PGDSFFALLO,EQ)
         MVC   #SWPDCMD,=A(#SWCWRIT)   Action code
         LRA   RS,PGDSWNXT             Store extent RA in cb
         ST    RS,#SWPLIST             |
         WITH  (LHEAD,RS),BEGIN        Set up page frame list
         LA    RS,PGDSWFRA
         ST    RS,LHFP                 |
         ST    RS,LHBP                 |
         CLEAR LHCNT                   |
         END   ,                       OF Set up page frame list
         REGCH (RS,R1),(RVR,R0),(RAR,R14),(EPAR,R15)
         LH    EPAR,PAGSWXTL           Clear channel pgm area
         LA    EPAR,@EPAR+L'PGDSWNXT   |
         LA    RAR,PGDSWNXT            |
         CLEAR RS                      |
         MVCL  RAR,RVR                 |
*-
*- Link to next CB
*-
         SR    RJ,RK                   Blocks to go
         L     RN,PGDSWLNK             Next CB
         UNTIL (BCT,RA),END            OF Fill in all CBs
         IF    FALSE,BEGIN             Branch around error code
DOSXPF   LABEL ,
         LREMALL PCBSWIN,LAST=(RN),COUNT=(RB),WR=RS
         LR    RN,RVR                  Start w/ first swap CB
         LCR   RA,RA                     and those w/ ext frames
         AR    RA,RB
         LOOP  BEGIN                   Free things up
         IF    (RA,POS),BEGIN          External frame to free
*-
*- Free external swap group
*-
         PSET  @XPREL
         PMOV  @XPRLBLK,#SWPBLK        External block number
         PMOV  @XPRNUM,LA:1            Free 1 cluster at a time
         PMOV  @XPRCB,PSCDEV           Device ID
         ACALL SWPREL
         END   ,                       OF External frame to free
*-
*- Free I/O cell
*-
         L     RM,PSCFP                Link to next CB
         CELLFREE LA:PGDSWAP,TYPE=SWAP
         LR    RN,RM
         DECR  RA
         UNTIL (BCT,RB),END            OF Free things up
         SET   @SSFLAG.@SWFWAIT        Must wait and try again
         EXIT  PAGSWVAL                |
         END   ,                       OF Branch around error code
*-
*- Count largest working set
*-
         PMOV  (RS),PCBSWCNT           Track largest swap
         STMAX RS,PAGMSMAX             |
*
         L     RN,PCBSWCB              Back to master CB
         SET   PGDSFSGT                This CB contains Seg tbl
*-
*- Set up stack area to add frames to swap control blocks
*-
         PMOV  #SSDBAD,LA:PGDSWAP      First extent addr
         LA    RA,PGDSWEXT             First elements in swap list
         LH    RB,PAGSWXL              |
         LA    RB,@RB(RA)              | and virtual addresses
         STM   RA,RB,#SSSLNXT          |
*
         EJECT ,
*box
*
*  Set up swap out control block - this means adding frame pointers
*    Add segment table frame(s), then page table frames, then the
*    unfixed frames to the swapped frames list.
*
         LA    RA,L'LHEAD              Increment
         LCR   RA,RA                   | negative
         LA    RB,PCBUFLH-1            Unfixed frames list - last
         LA    RJ,PCBSFLH              Segment frames list - first
         WITH  (LHEAD,RJ),BEGIN
SWADLOOP PSET  @ADDSWAP
         PMOV  @ASLHEAD,LA:LHEAD
         PMOV  @ASPARM,LA:#ADPARM
         LCALL ADDSWAP
         BXH   RJ,RA,SWADLOOP
         END   ,
*-
*- Now mark the last frame entry as the end of the list
*-
         L     RS,#SSSLNXT             Mark last frame addr as last
         SH    RS,=Y(L'PGDSLIST)       | this is now the last
         WITH  (PGDSLIST,RS),'SET PGDSLAX'
         END   ,                       OF Setting swap in progress
         PEND  ,
         SPACE
PAGOSOUT ABORT PAGSWINV                Already swapped out
         TITLE 'Add frames to swapping descriptor block'
*box
*
*  Add frames' real address to a swapping IO descriptor block
*
*   Input - @ADDSWAP
*
*  Output - @ADDSWAP
*
*
@ADDSWAP RECORD BEGIN                  Add frame to swapping ctl blk
@ASLHEAD DS    A                       Address of frame list
@ASPARM  DS    A                       Pointer to work area
         END   ,
         SPACE
         REGCH (RPAG,RX)
ADDSWAP  PROC  @ADDSWAP                Add frame to swapping ctl blk
         L     RM,@ASPARM              Addr to caller's work area
         WITH  (#ADPARM,RM)            |
         L     RY,#SSDBAD              This extent addr
         WITH  (PGDSWAP,RY)            |
         PAGAD RPAG
         L     RN,@ASLHEAD             Frame list to be added
         WITH  (LHEAD,RN),BEGIN        Head of list
         L     RS,LHCNT
         IF    (RS,ZERO),EXIT,ADDSWAP  No frames on this list
*-
*- Move frames to swap CB list
*-
         LH    RB,PAGSWXN              Room in control block
         S     RB,PGDSWCNT
         STMIN RS,RB                   MIN(room in CB, # in list)
         LREM  LHEAD,,LAST=(RK),(RB),WR=RA
         END   ,                       OF Head of list
         LR    RN,RVR
         LADD  PGDSWFRA,(RN),(RK),(RB),WR=RA
         LM    RJ,RK,#SSSLNXT          Next element this extent list
         LA    BRR,PGDSWEXT            | and one past last
         AH    BRR,PAGSWXL             |
*-
*- Add all frames in this list to the swap set
*-
         LOOP  BEGIN                   Add all elements on this list
         WITH  (PFTE,RN)
*-
*- Link to the next extent if we need more room
*-
         IF    (RJ,GE,BRR),BEGIN       Need a new extent
         LR    RA,RY                   Save old extent addr
         WITH  (PGDSWAP,RA),LABEL=OLD  |
         WITH  (PSCPFX,PGDSWPFX)
*-
*-   NB - This code uses the fact that swap-extent cells are
*- are linked together after a call to CELLGET.
*-
         L     RY,PSCFP                New extent (must be there)
         IF    (RY,ZERO),ASABORT
         ST    RY,#SSDBAD                and set it as current
*-
*- Move frames to swap CB list
*-
         L     RN,@ASLHEAD
         WITH  (LHEAD,RN),BEGIN        Addr to head of frame list
         L     RA,LHCNT
         LH    RB,PAGSWXN              Room in control block
         S     RB,PGDSWCNT
         STMIN RA,RB                   MIN(room in CB, # in list)
         LREM  LHEAD,,LAST=(RK),(RB),WR=RA
         END   ,                       OF Addr to head of frame list
         LR    RN,RVR
         LADD  PGDSWFRA,(RN),(RK),(RB),WR=RA
         LA    RJ,PGDSWEXT             Next element
         LH    RK,PAGSWXL              |
         ALR   RK,RJ                   |
         LR    BRR,RK                  | one past last frame ptr
         END   ,                       OF Need a new extent
         WITH  (PGDSLIST,RJ),BEGIN     Real addresses
         WITH  (PGDSVLST,RK)           Virtual addresses +
         LR    RA,RN                   Frame addr
         SL    RA,PAGPFTO              |
         SLL   RA,L'PAGPAGM-PFTLOG     |
         ST    RA,PGDSLAD              |
         MVC   PGDSVA,PFTVA            Virtual address
         ISKE  RB,RA                   Set Key
         STC   RB,PGDSFKEY             |
         IF    PFTFPGT,BEGIN           Page table frame
         MVC   PGDSFSEG,PFTSEG         |
         LH    RB,PFTSFIX              | short term fixes
         IF    (RB,ZERO),'SET PGDFNOF' |  there are none
         DECR  RB                      |
         STC   RB,PGDSFPTF             |   set number of fixes-1
         END   ELSE,BEGIN              Non page-table frame
         MVC   PGDSFHST(1),PFTHIST
         MVC   PGDSFFIX,PFTSFIX
         END   ,                       OF Non page-table frame
         LR    RB,RJ
         L     RN,PFTFP                Next frame in list
         LA    RJ,PGDSLNXT             Next element addr in list
         LA    RK,PGDSVNXT             |
         IF    (RJ,GE,BRR),BEGIN       That was the last in list
         WITH  (PGDSLIST,RB),LABEL=PREV
         SET   PREV:PGDSLAX
         END   ,                       OF This is the last in list
         END   ,                       OF Next swap frame address
         UNTIL (BCT,RS),END            OF Add all elements on list
         ST    RY,#SSDBAD              Descriptor block addr
         STM   RJ,RK,#SSSLNXT          |
         PEND  ,
ASABORT  ABORT PAGADSWP                CB not in memory/invalid
         TITLE 'Do Swap out I/Os'
*box
*
*  Start up swap out I/Os for an address space
*
*   Input -    @SWAPOUT
*
*  Output -    RVR contains number of frames swapped
*
*
         SPACE ,
@SWAPOUT RECORD BEGIN
@SOAMT   DS    A
         END   ,
         SPACE ,
SWAPOUT  PROC  @SWAPOUT
         PAGAD RPAG
         CLEAR RM                      Count of frames sent out
DOSLOOP  WHILE (PAGLICNT,NZ),BEGIN     Loop through all LIP ASs
         L     RPCB,PAGLIFP            First In-Progress AS
         WITH  (ASBPCB,RPCB)
         WHILE (PCBSICNT,NZ),BEGIN     Loop through swap CBs
         LREM  PCBSWIN,WR=RS           Get first swap CB
         LR    RN,RVR
         IF    (PCBSICNT,Z),BEGIN      AS No longer In-Progress
         LREM  PAGLIP,LA:ASBPCB,WR=RS
         CLEAR PCBFLIP                 Not In-Progress
         END   ,                       OF AS No longer In-Progress
*box
*
*  Do the SWAP I/O
*
         WITH  (PGDSWAP,RN)
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (#SWPDO,PGDSWP)
         AH    RM,#SWPCNT              Count of swap frames
         CLEAR PGDSFLOUT               Not logically swapped anymore
         SET   PGDSFSINP
         L     RA,PSCDEV
         WITH  (DSDES,RA),'L RA,DSCHID'         channel ID
         PSET  @IOSDOIO                Call IO Supervisor
         PMOV  @IOSCHID,(RA)           | channel ID
         PMOV  @IOSID,PSCIO            | I/O supervisor ID
         PMOV  @IOSPID,PCBASB,LEFTADJ=YES
         PMOV  @IOSCP,LA:#SWPDO        |
         PMOV  @IOSXID,LA:PAGOSEND     | completion addr
         PMOV  @IOSXPAR,LA:PGDSWAP     |
         MVI   @IOSKEY,0               | key of I/O
         SET   @IOSFAST                | fast path I/O
         VCALL IOSDOIO                 |
         IF    (RM,GE,@SOAMT),EXIT,DOSLOOP
         END   ,                       OF Loop through swap CBs
         END   ,                       OF Loop through all LIP ASs
*-
*- Frames written out aren't logically swapped, so decrement that
*- frame count.
*-
         L     RN,PAGFLS               Fewer logically swapped
         SLR   RN,RM
         ST    RN,PAGFLS
         L     RN,PAGFSOIP             More in progress - out
         ALR   RN,RM
         ST    RN,PAGFSOIP
         LR    RVR,RM                  Return count of frames written
         PEND  ,
         TITLE 'Swap-out I/O completion routine'
*box
*
*  Swap out IO completion routine
*
*   Input - @IOTERM
*
*  Output -
*
*
         SPACE
#OSEND   RECORD BEGIN
#OSEPSWM DS    X                       PSW mask for disabling
#OSELKF  DS    X                       Locks for this PSW
#OSEFLAG FLAG  ,
         FLAG  #OSEDISP                Notify dispatcher of completion
         END   ,
         SPACE
PAGOSEND PROC  @IOTERM,#OSEND,SCOPE=GLOBAL
         PAGAD RPAG
         CLEAR #OSEFLAG
         IF    ('LT RK,@IOTEND',NZ),BEGIN
         ORVSNAP @IOTEND,4
         ABORT PAGSWOUT
         END
         L     RK,@IOTPARM             Addr to control block
         WITH  (PGDSWAP,RK),BEGIN      |
         WITH  (PSCPFX,PGDSWPFX)
         L     RPCB,PSCASB             Lock AS
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         PAGNTRY ASYNC,#OSEPSWM,#OSELKF
         EJECT
*-
*- Gather stats
*-
         PSET  @IOSTIME
         PMOV  @IOSTID,PSCIO
         VCALL IOSTIME
*
         INCR  RS,PAGMSON              One more swap out
         LM    RM,RN,@IOSIOTIME        Total time
         LM    RA,RB,PAGMSOTM          |
         ADLR  RM,RA                   |
         STM   RM,RN,PAGMSOTM          |
*
         L     RJ,PSCDEV
         WITH  (DSDES,RJ),BEGIN        DSDES addr
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         INCR  RS,DSOUTCNT             Another swap out this device
         LM    RM,RN,@IOSIOTIME        Total time
         LM    RA,RB,DSOUTTIME         |
         ADLR  RM,RA                   |
         STM   RM,RN,DSOUTTIME         |
         END   ,                       OF DSDES addr
*
         WITH  (#SWPDO,PGDSWP),BEGIN
         LH    RS,#SWPCNT              Track largest swap
         STMAX RS,PAGMSMAX             |
         IF    (RS,GT,PAGSWXN),BEGIN   Count number over 1 extent
         INCR  RM,PAGMSOVR             |
         END   ,                       |
         END   ,
         WITH  (#SWPDO,PGDSWP),BEGIN
         LH    RS,#SWPCNT              Count frames swapped out
         AL    RS,PAGMSOF              |
         ST    RS,PAGMSOF              |
         END   ,
*box
*
*  Swap-write completion
*
         SPACE ,
*-
*- Swap is complete - set state flags
*-   If the swap was originally a logical swap, the dispatcher
*-   isn't expecting a notification of completion, because from
*-   it's standpoint the swap is already done.
*-
         LKOB  PAGSWAPL
         CLEAR PGDSFSINP               Swap no longer in progress
         CLEAR #OSEDISP                Don't notify dispatcher
         L     RS,PAGFSOIP             Decr frames in-progress
         SH    RS,#SWPCNT              |
         ST    RS,PAGFSOIP             |
         IF    PCBFRSIN,BEGIN          Swap in requested
*-
*-  Swap in requested - frames still there so do it quick like
*- Decrement amount of available frames
*-
         WITH  (#SWPDO,PGDSWP)
         L     EPAR,MATPTR
         WITH  (MAT,EPAR),BEGIN        Decr avail frames
         L     RS,MATPAGFN
         SH    RS,#SWPCNT
         ST    RS,MATPAGFN
         END   ,                       OF Decr avail frames
         LADD  PCBSWIN,LA:PGDSWAP,WR=RS
         LH    RA,PCBSWCBN
         L     RB,PCBSICNT
         LKREL PAGSWAPL
         IF    (RA,EQ,RB),BEGIN        All segments are in ...
         SET   #OSEDISP                Notify dispatcher
         PSET  @SWDONE
         PMOV  @SWDPCB,LA:ASBPCB
         LCALL SWAPIDONE
         END   ,                       OF All segments are in ...
         END   ,                       OF Swap in requested
         ELSE  BEGIN                   Swap in not requested
*-
*- Update frame counts
*-
         WITH  (#SWPDO,PGDSWP)
         L     RA,PAGFTCNT             Update available frame count
         LOOP  BEGIN                   |
         LR    RS,RA                   |
         AH    RS,#SWPCNT              |
         CS    RA,RS,PAGFTCNT          |
         UNTIL EQUAL,END               |
         L     EPAR,MATPTR             Update paging function
         WITH  (MAT,EPAR),BEGIN        |
         L     RA,PAGASIN              | save 1 frame/AS in core
         CEIL  RA,PFRESLIM             |  up to a point
         SLR   RS,RA                   |
         SL    RS,PAGFRES              |  and reserved amt
         AL    RS,PAGFLS               |   plus logical swap frames
         ST    RS,MATPAGFN             |
         END   ,                       OF Update paging function
*-
*- Add to list of swap control segments with unreclaimed frames
*-
         L     RS,PAGFRC               Count number of frames
         AH    RS,#SWPCNT              |
         ST    RS,PAGFRC               |
         LADD  PAGRSCB,LA:PGDSWAP,WR=RS
         LKREL PAGSWAPL
*-
*- Wake up any waiting for frames
*-
         LKOB  PAGFRAL
         IF    (('LT RS,PAGFTCNT',NZ),AND,(PAGFWCNT,NZ)),BEGIN
         SET   PAGFWFRA,MODE=LOCKED,REF=PAGFWAIT
         END   ,                       OF Notify any waiting
         LKREL PAGFRAL
         END   ,                       OF Swap in not requested
         PAGXIT ASYNC,#OSEPSWM,#OSELKF,WR=RS
         END   ,                       OF Addr to PGDSWAP
*-
*- Invalidate ASN
*-
         WITH  (ASBPCB,RPCB),BEGIN
*-
*- Notify dispatcher
*-
         IF    #OSEDISP,BEGIN          Notify dispatcher
*-
*- Tell dispatcher swap is done
*-
         PSET  @DISPSIOC
         PMOV  @DSIOASB,PCBASB
         VCALL DISPSIOC
         END   ,                       OF Notify dispatcher
         END   ,                       OF ASBPCB addr
         PEND  ,
         TITLE 'Advice for swapping'
*box
*
*  Make room (from logically swapped address spaces) for an
*  address space that is now eligible to come in
*
*  Input - @PAGSWADV
*
* Output - None
*
*
         SPACE
PAGSWADV PROC  @PAGSWADV,#LCLLOCK,SCOPE=GLOBAL
         PAGAD RPAG
         SLKOB PAGSWAPL,#LCLPSWM
*-
*- If this AS isn't out, or if it has already been notified
*- it is an error
*-
         L     RPCB,@ADVASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         IF    (^PCBFSOUT,OR,PCBFNOTE),BADADV
         SET   PCBFNOTE
*-
*- If this AS has has it's frames stolen, update the frames
*- waiting to come in, and if need be send someone else out to
*- make room.
*-
         LH    RJ,PCBSWFS              Number of stolen frames
         IF    (RJ,NZ),BEGIN           More frames waiting swap-in
         AL    RJ,PAGFWSI
         ST    RJ,PAGFWSI
         END   ,                       OF More frames waiting swap-in
         SLKRL PAGSWAPL,#LCLPSWM       Release swap lock
*-
*- See if we need to send anyone else out to make room for this
*- pending arrival
*-
         IF    (RJ,NZ),BEGIN           AS was out
         ACALL MAKEROOM
         END   ,                       OF AS was out
         PEND  ,
BADADV   ABORT PAGBADADVICE            Bad swap advice - not out or
*                                      already notified
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Request to swap an address space in'
*NEST,1
*box
*
*  Request to swap an address space in
*
*   Input - @PAGSWAP
*
*  Output - @PAGSWAP
*
*
#ISWAP   RECORD BEGIN
#ISCB    LHEAD PFX=#ISC                Swap CB queue
#ISFRAME LHEAD PFX=#ISF                Frame allocation Q
#ISREC   DS    A                       Reclaimed frame count
#ISPSWM  DS    X                       PSW mask for disabling
#ISLKFLG DS    X                       Locks for this PCB
         END   ,
         SPACE
PAGISWAP PROC  @PAGSWAP,#ISWAP,SCOPE=GLOBAL     Swap address space in
         PAGAD RPAG
         L     RPCB,@SWASB             Get PCB addr
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         PAGNTRY ASYNC,#ISPSWM,#ISLKFLG
*
         SET   @SWFINP                 Pre set as in progress
         INCR  RS,PAGMSIRN             | one more swap in requested
SWIVAL   BEGIN ,                       Swap-In OK
*-
*- The frames of swapped out address spaces are controlled by the
*- PAGSWAPL lock, and so therefore is the state of a swapped out
*- address space.  (logically swapped, un-reclaimed frames etc)
*- So we hold the lock when we decide if this AS is in or out.
*-
         LKOB  PAGSWAPL
*-
*- If the address space isn't currently swapped out it is an error.
*- If we weren't previously notified by the dispatcher that this
*- address space would be coming back in, then that is an error too.
*-
         IF    (NOT,(PCBFSOUT,AND,PCBFNOTE)),PAGISK
*-
*- Address space is no longer considered "out"
*-
         CLEAR PCBFSOUT
*box
*
*  Logical swap out
*
         IF    PCBFLOUT,BEGIN          Swap out was logical
*-
*- If the logically-swapped bit and the logical-in-progress bit
*- are both on, then this AS is in transition.  We simply
*- mark it as requested-for-swap-in, and it will be brought in
*- later.
*-
         IF    PCBFLIP,BEGIN           In state transition
         SET   PCBFRSIN                Set requested-for-swap-in
         LKREL PAGSWAPL
         SET   @SWFINP                 Return swap-in-progress
         END   ,                       OF In state transition
         ELSE  BEGIN                   Only logically swapped
         LREM  PAGLASB,LA:ASBPCB,WR=RS
         L     RS,PAGFLS               Fewer logically
         SH    RS,PCBSWCNT               swapped
         ST    RS,PAGFLS                   frames
         L     EPAR,MATPTR             Update paging function num
         WITH  (MAT,EPAR),BEGIN        |
         L     RS,MATPAGFN             |
         SH    RS,PCBSWCNT             |
         ST    RS,MATPAGFN             |
         END   ,                       OF Update paging function num
         LKREL PAGSWAPL
         PSET  @SWDONE                 Call swap completion rtn
         PMOV  @SWDPCB,LA:ASBPCB       |
         LCALL SWAPILOG                |
         SET   @SWFOK                  Swap done
         END   ,                       OF Only logically swapped
         END   ,                       OF Swap out was logical
*box
*
*  Swap out is not logical
*
         ELSE  BEGIN                   Swap out not logical
         WITH  (LHEAD,RB),BEGIN        Init list heads
         LA    RB,#ISCB                Local control block list
         ST    RB,LHFP
         ST    RB,LHBP
         CLEAR LHCNT
         LA    RB,#ISFRAME             Local frame list
         ST    RB,LHFP
         ST    RB,LHBP
         CLEAR LHCNT
         END   ,                       OF Init list heads
*-
*- Reclaim frames that have been swapped but haven't been stolen yet
*-
         L     RM,PCBSWCB              Swap control block
         LH    RN,PCBSWCBN              and number of CBs
         CLEAR RJ                        and frames represented
         LOOP  BEGIN                   Reclaim loop
         WITH  (PGDSWAP,RM)            Swap CB addr
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (#SWPDO,PGDSWP)
         IF    (^PGDSFLOUT,AND,PGDSFFALLO),BEGIN Out & not reclaimed
         IF    ^PGDSFSINP,BEGIN        Not in-progress
         LREM  PAGRSCB,LA:PGDSWAP,WR=RS
         LADD  #ISCB,LA:PGDSWAP,WR=RS
         AH    RJ,#SWPCNT
         END   ,                       OF Not in-progress
         END   ,                       OF Out & not reclaimed
         L     RM,PGDSWLNK             Next swap control block
         UNTIL (BCT,RN),END            OF Reclaim loop
*-
*- Adjust available frames count
*-
         ST    RJ,#ISREC               Reclaimed frame cnt
         L     RM,PAGFRC
         SLR   RM,RJ
         ST    RM,PAGFRC
         L     RM,PAGFTCNT
         LOOP  BEGIN
         LR    RN,RM
         SLR   RN,RJ
         CS    RM,RN,PAGFTCNT
         UNTIL EQUAL,END
*-
*- Take off of logical-in-progress queue, as if all was ok
*-
         IF    PCBFLIP,BEGIN
         LREM  PAGLIP,LA:ASBPCB,WR=RS
         END   ,
*-
*- Get the frames we need, adding them to a local list
*- (not on the PCB frame list just yet)
*-
         LH    RA,PCBSWFS
         IF    (RA,POS),BEGIN          Need more frames
         L     RN,PAGFWSI              Fewer frames
         SR    RN,RA                     waiting for
         ST    RN,PAGFWSI                  swap in
         LKREL PAGSWAPL
         FRAMEGET LA:ASBPCB,LA:ASBPCB,CNT=(RA),TYPE=LOCAL,LA:#ISFRAME
*-
*- Frames not available - return reclaimed swap segments and exit
*-
         IF    ^@FRAOK,BEGIN           Not enough frames avail
         LKOB  PAGSWAPL
         IF    PCBFLIP,BEGIN           Add back to in-progress Q
         LADD  PAGLIP,LA:ASBPCB,WR=RS
         END   ,                       OF Add back to in-progress Q
         L     RN,PAGFWSI              More frames
         AH    RN,PCBSWFS                waiting for
         ST    RN,PAGFWSI                  swap in
         LREMALL #ISCB,LAST=(RB),COUNT=(RN),WR=RS
         IF    ('LTR RA,RVR',NZ),BEGIN Segments to return
         LADD  PAGRSCB,(RA),(RB),(RN),WR=RS
*-
*- Re-Adjust available frames count
*-
         L     RJ,#ISREC               Reclaimed frame cnt
         L     RM,PAGFRC
         ALR   RM,RJ
         ST    RM,PAGFRC
         L     RM,PAGFTCNT
         LOOP  BEGIN
         LR    RN,RM
         ALR   RN,RJ
         CS    RM,RN,PAGFTCNT
         UNTIL EQUAL,END
         END   ,                       OF Segments to return
         SET   @SWFWAIT                Say we must wait to swap
         SET   PCBFSOUT                  and AS is still out
         LKREL PAGSWAPL
         EXIT  SWIVAL
         END   ,                       OF Not enough frames avail
         LKOB  PAGSWAPL
         END   ,                       OF Need more frames
*-
*- Make note that a swap in has been requested
*-
         SET   PCBFRSIN
         CLEAR PCBFLIP                 PCB not logical in-progress
*-
*- Move non-reclaimed segments to local PCB list
*-
         LREMALL #ISCB,LAST=(RB),COUNT=(RN),WR=RS
         IF    ('LTR RA,RVR',NZ),BEGIN Segments to return
         LADD  PCBSWIN,(RA),(RB),(RN),WR=RS
         END   ,                       OF Segments to return
*-
*- Read frames that have been stolen, and account for frames
*-
         L     RM,PCBSWCB              Swap control block
         LH    RN,PCBSWCBN              and number of CBs
         CLEAR RJ                        logical frames taken back
         LOOP  BEGIN                   Reclaim loop
         WITH  (PGDSWAP,RM)            Swap CB addr
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (#SWPDO,PGDSWP)
         IF    PGDSFLOUT,BEGIN         Segment is logically out
         AH    RJ,#SWPCNT
         END   ,                       OF Segment is logically out
*-
*- Read in segments that are really gone
*-
         ELSEIF ^PGDSFFALLO,BEGIN      No frames left
         LH    RK,#SWPCNT
         LREM  #ISFRAME,,LAST=(RB),(RK),WR=RS
         LTR   RA,RVR
         IF    ZERO,'ABORT PAGISFRAME'
         LADD  PGDSWFRA,(RA),(RB),(RK),WR=RS
         PSET  @SWAPIN
         PMOV  @SWICB,LA:PGDSWAP
         LCALL SWAPIN
         END   ,                       OF No frames left
         L     RM,PGDSWLNK             Next swap control block
         UNTIL (BCT,RN),END            OF Reclaim loop
*-
*- Adjust frame counts for this swap in
*-
         L     RM,PAGFLS               Logically swapped frames
         SLR   RM,RJ
         ST    RM,PAGFLS
         AL    RJ,#ISREC               Total of frames taken
         L     RN,MATPTR
         WITH  (MAT,RN),BEGIN          Addr to MAT
         L     RM,MATPAGFN             Paging function number
         SLR   RM,RJ
         ST    RM,MATPAGFN
         END   ,                       OF Addr to MAT
         LKREL PAGSWAPL
*-
*- If all of the swap CBs are on the local swapped-in Q, we're
*- done.
*-
         LH    RN,PCBSWCBN
         IF    (RN,EQ,PCBSICNT),BEGIN  All ready to go
         PSET  @SWDONE
         PMOV  @SWDPCB,LA:ASBPCB
         LCALL SWAPIDONE
         SET   @SWFOK                  Ready to go
         END   ,                       OF All ready to go
*-
*- Not quite ready yet.  Say the swap is in progress.
*-
         ELSE  BEGIN                   Swap is in progress
         SET   @SWFINP
         END   ,                       OF Swap is in progress
         END   ,                       OF Swap out not logical
         END   ,                       OF Swap-In OK
         PAGXIT ASYNC,#ISPSWM,#ISLKFLG,WR=RS
*-
*- Call the make-room routine when all locks are freed
*-
         ACALL MAKEROOM
         PEND  ,
*NEST,2
PAGISK   ABORT PAGISWAP                Swapping in before swapped out
         TITLE 'Do I/O to swap in segment'
*box
*
*   Do the I/O to swap in a segment that has been swapped out
*
*   Input -    @SWICB
*
*  Output -
*
*
@SWAPIN  RECORD BEGIN
@SWICB   DS    A                       Address of Swap CB
         END   ,
         SPACE ,
SWAPIN   PROC  @SWAPIN
         PAGAD RPAG
         L     RM,@SWICB
         WITH  (PGDSWAP,RM)
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (#SWPDO,PGDSWP)
         L     RPCB,PSCASB
         WITH  (ASB,RPCB)
*-
*- Put frame pointers in swap control blocks
*-
         LH    RN,#SWPCNT              Number of frames
         L     RK,PGDSWFP              First frame
         LA    RA,PGDSWEXT
         LOOP  BEGIN                   Put frame pointers in extents
         WITH  (PFTE,RK)
         WITH  (PGDSLIST,RA)
*-
*- Put frame pointers in this swap control block extent,
*- and set the keys of the page frames for I/O read
*-
        $LA    RAR,PFTE                Compute real addr
         SL    RAR,PAGPFTO             |
         SLL   RAR,L'PAGPAGM-PFTLOG    |
         ST    RAR,PGDSLAD             Save real addr
         LA    EPAR,CPAGIOKEY          Set Key
         SSKE  EPAR,RAR                |
         L     RK,PFTFP
         LA    RA,PGDSLNXT
         UNTIL (BCT,RN),END            OF Put frame pointers in extents
         SH    RA,=Y(L'PGDSLIST)
         WITH  (PGDSLIST,RA),'SET PGDSLAX'      Set as last frame
         EJECT ,
*-
*- DO THE SWAP IO
*-
         SET   PGDSFSINP               Swap in progress
         L     RA,PSCDEV               Get swap data set ID
         WITH  (DSDES,RA),BEGIN
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         L     RA,DSCHID
         END   ,
*-
*- Set parameters to do Swap-In I/O
*-
         PMOV  #SWPDCMD,=A(#SWCREAD)
         USING PZERO,R0
         PSET  @IOSDOIO                Call IO Supervisor
         PMOV  @IOSCHID,(RA)           | channel ID
         PMOV  @IOSCP,LA:#SWPDO        |
         PMOV  @IOSID,PSCIO            | I/O supervisor ID
         PMOV  @IOSPID,LA:ASB,LEFTADJ=YES
         PMOV  @IOSXID,LA:PAGISEND     | return addr
         PMOV  @IOSXPAR,LA:PGDSWAP     |
         PMOV  @IOSKEY,LA:CPAGIOKEY    | key of I/O
         SET   @IOSFAST                | fast path I/O
         VCALL IOSDOIO                 |
         DROP  R0
         IF    (RVR,NZ),PAGISK2
         PEND  ,
*
PAGISK2  ABORT PAGISIO                 I/O invalid
         TITLE 'Swap-in I/O completion routine'
*box
*
*  Swap in IO completion routine
*
*   Input - @IOTERM
*
*  Output -
*
*
         SPACE ,
PAGISEND PROC  @IOTERM,#PAGE           Swap in IO completion
         IF    ('LT RA,@IOTEND',NZ),'ABORT PAGSWIN'
         PAGAD RPAG
         L     RK,@IOTPARM
         WITH  (PGDSWAP,RK),BEGIN      Addr to swap CB
         WITH  (PSCPFX,PGDSWPFX)
         L     RPCB,PSCASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
*-
*- Gather stats
*-
         PSET  @IOSTIME
         PMOV  @IOSTID,PSCIO
         VCALL IOSTIME
*
         INCR  RS,PAGMSIN              One more swap in
         LM    RM,RN,@IOSIOTIME        Total time
         REGCH (RVR,R0),(RS,R1)
         LM    RVR,RS,PAGMSITM         |
         ADLR  RM,RVR                  |
         STM   RM,RN,PAGMSITM          |
*
         L     RJ,PSCDEV
         WITH  (DSDES,RJ),BEGIN        DSDES addr
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         INCR  RS,DSINCNT              Another swap in this device
         LM    RM,RN,@IOSIOTIME        Total time
         REGCH (RVR,R0),(RS,R1)
         LM    RVR,RS,DSINTIME         |
         ADLR  RM,RVR                  |
         STM   RM,RN,DSINTIME          |
         END   ,                       OF DSDES addr
*
         WITH  (#SWPDO,PGDSWP),BEGIN
         LH    RS,#SWPCNT              Count frames swapped in
         AL    RS,PAGMSIF              |
         ST    RS,PAGMSIF              |
         END   ,
*-
*- Add swap CB to Paging control block
*-
         SLKOB PAGSWAPL,#PAGPSWM
         CLEAR PGDSFSINP               No longer in progress
         LADD  PCBSWIN,LA:PGDSWAP,WR=RS
         CLEAR RA
         LH    RB,PCBSWCBN             Are all CBs in core?
         IF    (RB,EQ,PCBSICNT),'LA RA,1'
         SLKRL PAGSWAPL,#PAGPSWM
         IF    (RA,NZ),BEGIN           Call swap completed rtn
         PSET  @SWDONE
         PMOV  @SWDPCB,LA:ASBPCB
         LCALL SWAPIDONE
*-
*- Notify the dispatcher that this AS is now in core again
*-
         PSET  @DISPSIOC
         PMOV  @DSIOASB,PCBASB
         VCALL DISPSIOC
         END   ,                       OF Call swap completed rtn
         END   ,                       OF Addr to Swap CB
         PEND  ,
         TITLE 'Swap In I/Os completed'
*NEST,1
*box
*
*  Swap in I/Os all completed
*
*   Input - @SWDONE
*
*  Output -
*
*
         SPACE
#ISEND   RECORD BEGIN
#ISEVA   DS    A                       Virtual addr of work
#ISERA   DS    A                       | and real addr
#ISEEXT  DS    A                       Start of this swap des extent
#ISENXT  DS    A                       Next address in swap des
#ISEPAGF DS    2A                      First of page table frames
#ISEPAGX DS    A                       | page extent of swap cntl blk
#ISECNT  DS    A                       Loop counter
#ISELASP DS    D                       Old LASP parameters
#ISEPSWM DS    X                       PSW mask for disabling
#ISEASLK DS    X                       Save AS lock flags
         END   ,
         SPACE ,
@SWDONE  RECORD BEGIN
@SWDPCB  DS    A                       ASBPCB address
         END   ,
         SPACE
SWAPIDONE PROC @SWDONE,#ISEND          Swap in IO completion
         PAGAD RPAG
*-
*- One more user in memory
*-
         L     RA,PAGASIN
         LOOP  BEGIN
         LA    RB,@RA+1
         CS    RA,RB,PAGASIN
         UNTIL EQUAL,END
*
         L     RPCB,@SWDPCB            Addr to control block
         WITH  (PGDSWAP,RK),BEGIN      PGDSWAP addr
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (ASBPCB,RPCB)
         L     RK,PCBSWCB
         PMOV  #ISEEXT,LA:PGDSWAP
         LA    RB,PGDSWEXT
*-
*- Get paging lock for this AS
*-
         PAGNTRY ASYNC,#ISEPSWM,#ISEASLK
         EJECT
*-
*- Not in progress, request for swap in completed, notification
*- taken care of
*-
         CLEAR PCBFLOUT+PCBFISOUT+PCBFRSIN+PCBFNOTE
         IF    PGDSFDAT,BEGIN          We need to update seg tbl
*-
*- Validate segment table's virtual addresses, and set keys.
*-   Get start of page frame table
*-
         L     RM,PCBPSTO              VA of Segment Table Origin
         L     RJ,PAGCASB              | common ASB addr
         WITH  (ASB,RJ),'L RJ,ASBPAGB' |
*-
*- Get global lock
*-
         WITH  (ASBPCB,RJ),LABEL=COMM,BEGIN
         IF    ^PCBFGBL,BEGIN          Get global lock
         LKOB  COMM.PCBLOCK            | |
         SET   PCBFGBL                 |
         END   ,                       OF Get global lock
         L     RN,COMM.PCBRA           |
         WITH  (ASBPCB,RN),LABEL=REAL
*
         LA    RA,PGDSWEXT             First slot
         LR    RB,RA                   |
         AH    RB,PAGSWXL              | and virt slot
         LH    BRR,PAGSEGP             | num of pages in seg tables
         ST    BRR,#ISECNT             | |
         LOOP  BEGIN
         WITH  (PGDSLIST,RA)           Real addresses
         WITH  (PGDSVLST,RB)           Virtual addresses +
         LRA   RAR,@RM
         IF    ^PAGI,SEKAPSEG          Invalid page entry expected
         L     BRR,PGDSLAD             Real address
         N     BRR,=A(PAGSTOM)         |
*-
*- Fix seg table's VA tables in DAT-OFF
*-
         DATOFF COMM.PCBPSWM
         WITH  (PGTE,RAR),BEGIN        |
         SET   PGTFDEF                 | Set as defined again
         L     RVR,PGAD                |
         N     RVR,=A(PGTAIMSK)        | Clear RA & invalid
         OR    RVR,BRR                 | |
         ST    RVR,PGAD                |
         END   ,                       OF Validate seg table's addr
         DATON REAL.PCBPSWM
         IC    RVR,PGDSFKEY            Set seg table's storage key
         SSKE  RVR,BRR                 |
         SRL   BRR,L'PAGPAGM-PFTLOG    Put VA in frame table entry
         AL    BRR,PAGPFTO             | + page frame table offset
         WITH  (PFTE,BRR),BEGIN        |
         MVC   PFTVA,PGDSVA            | virtual addr + flags
         MVC   PFTASB,COMM.PCBASB      | and ASB
         MVC   PFTFIX,=Y(1)            | set fix count to 1
         MVI   PFTQ,PCBSFLH-ASBPCB     | set Q id
         END   ,                       OF Put VA in frame table entry
*
         LA    RA,PGDSLNXT             Next swap frame addr
         LA    RB,PGDSVNXT             | and virtual list
         AH    RM,=Y(PAGPAGEL)         Next page of segment tbls (VA)
         L     EPAR,#ISECNT            Check loop count
         BCT   EPAR,SELOOP
         EXIT
SELOOP   ST    EPAR,#ISECNT
         END   ,                       | and loop ...
         CLEAR PCBFGBL                 |
         LKREL COMM.PCBLOCK            |
         END   ,                       OF WITH (COMM.PCB,RJ)
         END   ,                       OF We need to update seg tbl
*-
*- Even if we don't update the segment table entries, we need to
*- update the pointers to point the portion of the swap control
*- blocks that contain page table information
*-
         ELSE  BEGIN                   Point at page tbl frames
         LA    RA,PGDSWEXT
         LR    RB,RA
         AH    RB,PAGSWXL
         LH    RS,PAGSEGP
         SLL   RS,PGDSLLOG
         ALR   RA,RS                   1st pg tbl frame slot
         SLL   RS,PGDSVLOG-PGDSLLOG
         ALR   RB,RS
         END   ,                       OF Point at page tbl frames
*-
*- Set up the first page table pointers
*-
         LRA   RA,@RA
         LRA   RB,@RB
         STM   RA,RB,#ISEPAGF
*
         STCTL 3,4,#ISELASP            Save old AS parameters
*
         PSET  @VALDASN                Validate and establish new AS
         L     RN,PCBASB               | set LASP parms
         WITH  (ASB,RN),BEGIN          |
         MVC   @VALASP,ASBLASP         |
         END   ,                       |
         L     RN,PCBPSTO              | Segment table real addr
         LRA   RN,@RN                  | |
         PMOV  @VAPSTO,(RN)            | |
         PMOV  @VALPARM,=X'04'         | insist on doing translation
         LCALL VALIDASN                |
         INCR  RS,PAGMSIVN             One more "virtual" swap I/O
         EJECT ,
*box
*
*  Validate page table addresses
*
         L     RK,#ISEEXT              Current swap control extent
         LRA   BRR,0(,RK)              |
         ST    BRR,#ISEPAGX            | extent of first page table
         LM    RA,RB,#ISEPAGF
         LH    RM,PCBSWPCT             | and number of pages swapped
*
         L     RN,PCBPSTO              Get real addr of seg tbl
         LRA   RN,@RN                  |
         L     RS,PCBRA                Go into DAT-OFF
         LRA   RPAG,PAGCB              |
         DATOFF PCBPSWM                |
         LR    RPCB,RS                 |
         IF    (RM,NZ),BEGIN           PTs to fix up
SESEGV   LOOP  BEGIN                   Set PT real addresses
         WITH  (PGDSWAP,BRR),LABEL=BASE
         WITH  (PGDSLIST,RA)           Real addresses
         WITH  (PGDSVLST,RB)           Virtual addresses +
         IF    (BRR,ZERO),SEKAPEXT     Ran out of extents
         IF    BASE:PGDSFDAT,BEGIN     Need update of DAT tables
         LH    RJ,PGDSFSEG             Segment of this PT
         N     RJ,=X'000007FF'         |  hardware max
         SLL   RJ,SGTLOG               | segment entry offset
         ALR   RJ,RN                   |
         WITH  (SGTE,RJ)               |
         L     RVR,SGTAD               Put in new RA of page table
         N     RVR,=A(SGPTLMSK)        | length mask
         L     RS,PGDSLAD              | frame RA
         OR    RVR,RS                  | put it in
         ST    RVR,SGTAD               |
*  NB - We set the segment as invalid now, so later a LRA on
*       the page table's virtual address will give us this
*       entry and real addr for the page table.  At that time
*       the segment table entry will will be set as valid.
         SET   SGTFINV                 |
         END   ,                       OF Need update of DAT tables
*
         IF    PGDSLAX,BEGIN           Last swap addr in this extent
         L     BRR,BASE.PGDSWLNK       Get next extent address
         LRA   BRR,BASE.PGDSWAP        |
         LA    RA,BASE.PGDSWEXT        |
         LH    RB,PAGSWXL              |
         ALR   RB,RA                   |
         END   ,                       OF Last swap addr in this ext
         ELSE  BEGIN                   Get next addr in this extent
         LA    RA,PGDSLNXT             Addr of next swap frame addr
         LA    RB,PGDSVNXT             |
         END   ,                       OF Get next addr in this ext
*
         UNTIL (BCT,RM),END            OF Set PT real addresses
         END   ,                       OF PTs to fix up
         EJECT
*box
*
*
*  Validate page addresses and set keys
*
*
         L     RM,PCBVA                Addr to PAGCB
         DATON PCBPSWM                 |
         PAGAD RPAG,BEGIN              |
         WITH  (#SWPDO,PGDSWP)
         WITH  (ASBPCB,RM),BEGIN
         LH    RS,PCBSWCNT             Number of non seg/page tbls
         SH    RS,PCBSWPCT             |
         END   ,
         SH    RS,PAGSEGP              |
         LRA   RPAG,0(,RPAG)           |
         WITH  (ASBPCB,RM),BEGIN       Back to DAT-OFF
         DATOFF PCBPSWM                |
         END   ,                       OF Back to DAT-OFF
         SPACE
         IF    (RS,NZ),BEGIN           Pages to fix up
         LOOP  BEGIN                   Set page real addresses
         WITH  (PGDSWAP,BRR),LABEL=BASE
         WITH  (PGDSLIST,RA)           Real addresses
         WITH  (PGDSVLST,RB)           Virtual addresses +
         IF    (BRR,ZERO),SEKAPEXT     Ran out of extents
         IF    BASE:PGDSFDAT,BEGIN     Need update of DAT tables
         L     RM,PGDSVA
*  NB - The load real address on this VA will return the segment
*       table entry for this VA's segment (since the seg table
*       entry is still marked invalid.)
         LRA   RJ,0(,RM)
         IF    ^SEGI,BEGIN             If not a seg fault
         LR    RJ,RM                   Get seg table entry
         SRL   RJ,L'PAGSGNM            |
         SLL   RJ,SGTLOG               |
         AL    RJ,PCBPSTO              | start of seg
         LRA   RJ,@RJ                  |
         IF    ^VAOK,SEKAPPAG          Seg table should be def
         END   ,                       OF If not a seg fault
         L     RJ,@RJ                  Page table address
         N     RJ,=A(SGTADMSK)         |
         N     RM,=A(PAGPGNM)          Page table entry (page num)
         SRL   RM,L'PAGPAGM-PGTLOG     | index
         ALR   RM,RJ                   |
         WITH  (PGTE,RM),BEGIN         |
         L     RVR,PGDSLAD             Real address
         N     RVR,=A(PAGPAGM)         |
         L     EPAR,PGAD               Clear out old RA
         N     EPAR,=A(PGTAIMSK)       |
         OR    EPAR,RVR                | and put in new RA
         ST    EPAR,PGAD               |
         END   ,                       OF Page table entry addr
         IC    RVR,PGDSFKEY            Set storage key
         SSKE  RVR,EPAR                |
*  NB - The next 2 instructions clear the low bits of the address
*       while computing the offset.
         SRL   EPAR,L'PAGPAGM          Set up page frame table entry
         SLL   EPAR,PFTLOG             | frame num * len of entries
         AL    EPAR,PAGPFTO            |
         LRA   EPAR,@EPAR              |
         WITH  (PFTE,EPAR),BEGIN       |
         MVC   PFTVA,PGDSVA            | set VA and flags
         MVC   PFTASB,PCBASB           |  and ASB
         MVC   PFTHIST(1),PGDSFHST     | move in one byte of history
         MVC   PFTSFIX,PGDSFFIX        |  and short fix count
         MVI   PFTQ,PCBUFLH-ASBPCB     |   and Q of this frame
         END   ,                       OF Set up page frame table ...
         END   ,                       OF Need update of DAT tables
         IF    PGDSLAX,BEGIN           Last swap addr in this extent
         L     BRR,BASE.PGDSWLNK       Get next extent address
         LRA   BRR,BASE.PGDSWAP        |
         LA    RA,BASE.PGDSWEXT        |
         LH    RB,PAGSWXL              |
         ALR   RB,RA                   |
         END   ,                       OF Last swap addr in this ext
         ELSE  BEGIN                   Get next addr in this extent
         LA    RA,PGDSLNXT             Addr of next swap frame addr
         LA    RB,PGDSVNXT             |
         END   ,                       OF Get next addr in this ext
         UNTIL (BCT,RS),END            OF Set page real addresses
         END   ,                       OF Pages to fix up
         EJECT
*box
*
*
*  Fix up entries for the virtual addresses of the page tables
*
*
         LH    RS,PCBSWPCT             Number of page tables
         L     RM,PCBVA                Go into DAT-ON briefly
         DATON PCBPSWM                 |
         LM    RA,RB,#ISEPAGF          First of page table frames
         L     BRR,#ISEPAGX            |
         WITH  (ASBPCB,RM),BEGIN       Back into DAT-OFF
         DATOFF PCBPSWM                |
         END   ,                       |
         IF    (RS,NZ),BEGIN           Fix up PTs
         LOOP  BEGIN                   Validate PT addresses
         WITH  (PGDSWAP,BRR),LABEL=BASE
         WITH  (PGDSLIST,RA)           Real addresses
         WITH  (PGDSVLST,RB)           Virtual addresses +
         IF    (BRR,ZERO),SEKAPEXT     Ran out of extents
         IF    BASE:PGDSFDAT,BEGIN     Need update of DAT tables
         LH    RM,PGDSFSEG
         N     RM,=X'000007FF'         | hardware limit
*-
*- NB - The load real address on this VA will return the segment
*-      table entry for this VA's segment (since the seg table
*-      entry is still marked invalid.)
*-
         SLL   RM,L'PAGSGNM            | seg number to address
         LRA   RJ,0(,RM)
         IF    ^SEGI,BEGIN             If not a seg fault
         LR    RJ,RM                   Get seg table entry
         SRL   RJ,L'PAGSGNM            |
         SLL   RJ,SGTLOG               |
         AL    RJ,PCBPSTO              | start of seg
         LRA   RJ,@RJ                  |
         IF    ^VAOK,SEKAPPAG          Seg table should be def
         END   ,                       OF If not a seg fault
         WITH  (SGTE,RJ),BEGIN         Get page table RA from seg
         CLEAR SGTFINV                 |
         L     RJ,SGTAD                |
         N     RJ,=A(PAGPAGM)          | align on page bndry
         END   ,                       OF Get page table RA from seg
         L     EPAR,PCBPSTO            Get virtual addr tables
         LRA   EPAR,@EPAR              | seg table start
         IF    ^VAOK,SEKAPPGT          | |
         L     RM,PGDSVA               | seg table entry
         N     RM,=A(PAGSGNM)          |
         SRL   RM,L'PAGSGNM-SGTLOG     |
         ALR   RM,EPAR                 |
         WITH  (SGTE,RM),'L RM,SGTAD'  | page table entry
         N     RM,=A(SGTADMSK)         |
         L     EPAR,PGDSVA             |
         N     EPAR,=A(PAGPGNM)        |
         SRL   EPAR,L'PAGPGNM-PGTLOG   |
         ALR   RM,EPAR                 |
         WITH  (PGTE,RM),BEGIN         Validate address
         L     RVR,PGDSLAD             Real address
         N     RVR,=A(PGTADMSK)        | masked for PGTE
         L     EPAR,PGAD               Clear out old RA
         N     EPAR,=A(PGTAIMSK)       |
         OR    EPAR,RVR                | and put in new RA
         ST    EPAR,PGAD               |
         END   ,                       OF Page table entry addr
         IC    RVR,PGDSFKEY            Set storage key
         SSKE  RVR,EPAR                |
         SRL   EPAR,L'PAGPAGM          Set up page frame table entry
         SLL   EPAR,PFTLOG             | frame num * len of entries
         AL    EPAR,PAGPFTO            |
         LRA   EPAR,@EPAR              |
         WITH  (PFTE,EPAR),BEGIN       |
         MVC   PFTVA,PGDSVA            Get VA
         LH    RVR,PGDSFSEG            | segment number
         N     RVR,=X'000007FF'        |  hardware max
         STH   RVR,PFTSEG              |
         MVC   PFTASB,PCBASB           |  and ASB
         LC    RVR,PGDSFPTF            | PT short term fixes
         INCR  RVR                     |  one more -> 1..256
         IF    PGDFNOF,'CLEAR RVR'     |   no fixes
         STH   RVR,PFTSFIX             |
         SET   PFTFPGT                 | It's a page table page
         MVI   PFTQ,PCBPFLH-ASBPCB     |  and it's on page table Q
         END   ,                       OF Set up page frame table ...
         END   ,                       OF Need update of DAT tables
         IF    PGDSLAX,BEGIN           Last swap addr in this extent
         L     BRR,BASE.PGDSWLNK       Get next extent address
         LRA   BRR,BASE.PGDSWAP        |
         LA    RA,BASE.PGDSWEXT        |
         LH    RB,PAGSWXL              |
         ALR   RB,RA                   |
         END   ,                       OF Last swap addr in this ext
         ELSE  BEGIN                   Get next addr in this extent
         LA    RA,PGDSLNXT             Addr of next swap frame addr
         LA    RB,PGDSVNXT             |
         END   ,                       OF Get next addr in this ext
         UNTIL (BCT,RS),END            OF Validate PT addresses
         END   ,                       OF Fix up PTs
         END   ,                       OF Addr to PAGCB
*-
*- Back to DAT-ON
*-
         L     RS,PCBVA                Back to DAT-ON
         DATON PCBPSWM                 |
         LR    RPCB,RS                 | PCB's VA
*
         PAGAD RPAG
         END   ,                       OF PGDSWAP addr
         WITH  (PAGCB,RPAG)
         WITH  (ASBPCB,RPCB)
*-
*- Put frame lists back on PCB anchors
*-
         PSET  @SIFRAME
         PMOV  @SIFPCB,LA:ASBPCB
         LCALL SIFRAME
*-
*- Handle page writes that completed while we were swapped out
*-
         L     RA,PCBWPEND
         IF    (RA,NZ),BEGIN           Frame writes to handle
         CLEAR PCBWPEND
         LOOP  BEGIN                   Loop through frames
         WITH  (PGDPAGE,RA)
         WITH  (PSCPFX,PGDPGPFX)
         WITH  (#PIODO,PGDPIO)
         PSET  @PAGPIOC
         PMOV  @PCIOCB,LA:PGDPAGE      I/O control block addr
         PMOV  @PCPCB,LA:ASBPCB          and PCB addr
         ACALL PAGPWC
*-
*- Free the paging I/O control block
*-
         L     RB,PSCFP                Get next CB on list
         CELLFREE LA:PGDPAGE,TYPE=PAGE Free CB
         LR    RA,RB
         UNTIL (RA,ZERO),END           OF Loop through frames
         END   ,                       OF Frame writes to handle
*-
*- Free control blocks and external frames
*-
         PSET  @SICBS
         PMOV  @SICBPCB,LA:ASBPCB
         LCALL SICBS
*-
*- Back to old AS
*-
         LASP  #ISELASP,CPAGLASP
         PAGXIT ASYNC,#ISEPSWM,#ISEASLK,WR=RS
         PEND  ,
         SPACE
         WITH  (SWAPIDONE,BR),BEGIN
SEKAPSEG LA    RVR,0                   Segment VA lookup
         B     SEKAP0
SEKAPEXT LA    RVR,1                   Ran out of extents
         B     SEKAP0
SEKAPASB LA    RVR,2                   Error in validating ASB
         B     SEKAP0
SEKAPPAG LA    RVR,3                   Should get Segment fault here
         B     SEKAP0
SEKAPPGT LA    RVR,4                   Error w/ page table VA
SEKAP0   ABORT PAGISEND
         END   ,
*NEST,2
         TITLE 'Logical swap in completed'
*box
*
*  Logical swap in routine
*
*   Input -  @SWAPILO
*
*  Output -  None
*
*
         SPACE
#SWAPILO RECORD BEGIN
#SILPSWM DS    X                       PSW mask for disabling
         END   ,
         SPACE
SWAPILOG PROC  @SWDONE,#SWAPILO        Logical swap in completion
         PAGAD RPAG
         L     RPCB,@SWDPCB
         WITH  (ASBPCB,RPCB)
*-
*- One more address space in core - reserve another frame
*- and count another virtual swap-in
*-
         L     RA,PAGASIN
         LOOP  BEGIN
         LA    RB,@RA+1
         CS    RA,RB,PAGASIN
         UNTIL EQUAL,END
         INCR  RS,PAGMSIVN             One more virtual swap-in
         SLKOB PCBLOCK,#SILPSWM
*-
*- Set the state of this PCB
*-
         CLEAR PCBFISOUT+PCBFRSIN+PCBFNOTE+PCBFLOUT
*-
*- Handle page writes that completed while we were swapped out
*-
         L     RA,PCBWPEND
         IF    (RA,NZ),BEGIN           Frame writes to handle
         CLEAR PCBWPEND
         LOOP  BEGIN                   Loop through frames
         WITH  (PGDPAGE,RA)
         WITH  (PSCPFX,PGDPGPFX)
         WITH  (#PIODO,PGDPIO)
         PSET  @PAGPIOC
         PMOV  @PCIOCB,LA:PGDPAGE      I/O control block addr
         PMOV  @PCPCB,LA:ASBPCB          and PCB addr
         ACALL PAGPWC
*-
*- Free the I/O control block
*-
         L     RB,PSCFP                Get next CB on list
         CELLFREE LA:PGDPAGE,TYPE=PAGE Free CB
         LR    RA,RB
         UNTIL (RA,ZERO),END           OF Loop through frames
         END   ,                       OF Frame writes to handle
*-
*- Put frames lists back on PCB headers
*-
         IF    ('LT RA,PCBSICNT',NZ),BEGIN      Frame lists to manage
         PSET  @SIFRAME
         PMOV  @SIFPCB,LA:ASBPCB
         LCALL SIFRAME
*-
*- Release swap control blocks and external frames
*-
         PSET  @SICBS
         PMOV  @SICBPCB,LA:ASBPCB
         LCALL SICBS
         END   ,                       OF Frame lists to manage
         SLKRL PCBLOCK,#SILPSWM
         PEND  ,
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Move frame lists from swap control blocks'
*box
*
*  Move frame lists from swap control blocks
*
*   Input - @SIFRAME
*             Local PCB lock held on entry
*
*  Output - None
*
*
@SIFRAME RECORD BEGIN
@SIFPCB  DS    A
         END   ,
         SPACE ,
SIFRAME  PROC  @SIFRAME
         PAGAD RPAG
         L     RPCB,@SIFPCB
         WITH  (ASBPCB,RPCB)
         L     RK,PCBSWCB
         WITH  (PGDSWAP,RK)
*-
*- Move first frames to segment table frame list
*-
         LH    RJ,PAGSEGP
         LREM  PGDSWFRA,,LAST=(RB),(RJ),WR=RS
         LR    RA,RVR
         LADD  PCBSFLH,(RA),(RB),(RJ),WR=RS
*-
*- Put next frames from swap control blocks on page table lists
*-
         LH    RM,PCBSWPCT
         WHILE (RM,NZ),BEGIN           Page table frame loop
         LR    RN,RM
         L     RB,PGDSWCNT
         IF    (RB,ZERO),BEGIN         Link to next extent
         L     RK,PGDSWLNK
         IF    (RK,ZERO),'ABORT SWAP_PGM'
         L     RB,PGDSWCNT
         END   ,                       OF Link to next extent
         STMIN RB,RN
         LREM  PGDSWFRA,,LAST=(RB),(RN),WR=RS
         LR    RA,RVR
         LADD  PCBPFLH,(RA),(RB),(RN),WR=RS
         SR    RM,RN
         END   ,                       OF Page table frame loop
*-
*- Put remainder of frames on PCB's unfixed frames list
*-
SDUFLOOP LOOP  BEGIN                   Unfixed frame loop
         L     RN,PGDSWCNT
         IF    (RN,ZERO),BEGIN         Link to next extent
         L     RK,PGDSWLNK
         IF    (RK,ZERO),EXIT,SDUFLOOP No more extents
         L     RN,PGDSWCNT
         END   ,                       OF Link to next extent
         LREMALL PGDSWFRA,LAST=(RB),COUNT=(RN),WR=RS
         LR    RA,RVR
         LADD  PCBUFLH,(RA),(RB),(RN),WR=RS
         END   ,                       OF Unfixed frame loop
         PEND  ,
         TITLE 'Free swap control blocks and external frames'
*box
*
*  Free swap control blocks and external frames
*
*   Input - @SICBS
*
*  Output - None
*
*
@SICBS   RECORD BEGIN
@SICBPCB DS    A
         END   ,
         SPACE ,
SICBS    PROC  @SICBS
         PAGAD RPAG
         L     RPCB,@SICBPCB
         WITH  (ASBPCB,RPCB)
*-
*- Free control blocks and external frames
*-
         LREMALL PCBSWIN,,LAST=(RJ),COUNT=(RA),WR=RS
         L     RB,PCBSWCB              Control block addr
         PMOV  (RA),PCBSWCBN           Number of swap CBs
         LOOP  BEGIN                   Loop through CBs
         WITH  (PGDSWAP,RB)
         WITH  (PSCPFX,PGDSWPFX)
         WITH  (#SWPDO,PGDSWP)
         PSET  @XPREL                  Release external frames
         PMOV  @XPRLBLK,#SWPBLK        | relative block
         PMOV  @XPRNUM,LA:1            |  number of clusters
         PMOV  @XPRCB,PSCDEV           |
         ACALL SWPREL                  |
         L     RJ,PGDSWLNK             Next extent
         CELLFREE LA:PGDSWAP,TYPE=SWAP
         LR    RB,RJ
         UNTIL (BCT,RA),END            OF Loop through CBs
         PEND  ,
         TITLE 'Validate an ASN'
*box
*
*  Sets an Address Space as valid and establishes it.
*
*  Input - @VALDASN
*
*  Output - @VAOK, RVR
*    IF @VAOK:
*      ASN first table entry was valid and ASN entry was validated
*      RVR contains the Segment Table Descriptor (STD)
*      Address space established
*    IF ^@ASNOK
*      Couldn't establish this address space
*        or
*      ASN second table was invalid - ASN entry not validated
*
*
         SPACE
@VALDASN RECORD BEGIN                  Sets ASN as valid
@VALASP  DS    0D                      LASP information
@VAPKM   DS    H                       |
@VASASN  DS    H                       |
@VAAX    DS    H                       |
@VAPASN  DS    H                       |
@VAPSTO  DS    A                       Seg table origin this ASB (RA)
@VALPARM DS    X                       LASP parm to be ORd in
@VAF1    FLAG  @VAOK                   |
         END   ,
         SPACE
VALIDASN PROC  @VALDASN,#LCLLOCK       Validate ASN entry
*        CLEAR @VAOK                   Should be cleared to start
         PAGAD RPAG
         LH    RA,@VAPASN              ASN to work from (AFX)
         LR    RB,RA                   | used for ASX
         N     RA,=A(PAGAFXM)          First table entry calc
         SRL   RA,L'PAGAFXM-AFTLOG     | index*4 is offset from AFTO
         AL    RA,PAGAFTO              |
*-
*- Get ASN lock
*-
         SLKOB PAGASNL,#LCLPSWM
         WITH  (AFTE,RA),BEGIN         |
         L     RA,AFTASTO              Second table origin
         END   ,                       OF First table entry calc
         IF    (RA,NEG),VALIDKAP       Error - 2nd table unavailable
         N     RA,=A(AFTASTM)          | mask em out
         RTOV  (RA)                    | to virtual (ret in RVR)
         N     RB,=A(PAGASXM)          Second table entry calc
         SLL   RB,ASTLOG               | index*16 is offset from ASTO
         ALR   RB,RVR                  |
         WITH  (ASTE,RB),BEGIN         |
         L     RVR,ASTSTD              Set seg table RA
         N     RVR,=A(ASTSTL)          | save old length
         O     RVR,@VAPSTO             | new RA
         ST    RVR,ASTSTD              |
         CLEAR ASTFINV                 Now it's valid
         END   ,
*-
*- Release ASN lock
*-
         SLKRL PAGASNL,#LCLPSWM
*-
*- Load address space parameters (local AS)
*-
         LC    RS,@VALPARM
         O     RS,=A(ASBLPARM)
         LASP  @VALASP,0(RS)
         IF    NZ,VALIDKAP
         SET   @VAOK                   Available AS
         PEND  ,
VALIDKAP ABORT VALIDASN                Not valid LASP
         TITLE 'Invalidate an ASN'
*box
*
*  Sets an Address Space as invalid.
*
*  Input - @NVLDASN
*
*  Output - @IAOK, RVR
*    IF @IAOK:
*      RVR contains the Segment Table Descriptor (STD) of the now
*      invalidated ASN entry
*    IF ^@IAOK
*      Either the ASN first or second table entry was already
*      marked as invalid
*
*
@NVLDASN RECORD BEGIN                  Sets ASN as invalid
@IAASB   DS    A                       Address Space Block addr
@IAF1    FLAG  @IAOK
         END   ,
         SPACE
NVALDASN PROC  @NVLDASN                Invalidate ASN entry
*        CLEAR @IAOK                   Should be cleared to start
         PAGAD RPAG
         L     RPCB,@IAASB             ASB addressability
         WITH  (ASB,RPCB)              |
         LH    RA,ASBPASN              ASN to work from (AFX)
         IF    (RA,ZERO),'ABORT ASN0INVALID'
         LR    RB,RA                   | used for ASX
         N     RA,=A(PAGAFXM)          First table entry calc
         SRL   RA,L'PAGAFXM-AFTLOG     | index*4 is offset from AFTO
         AL    RA,PAGAFTO              |
*-
*- Get ASN lock
*-
         LKOB  PAGASNL
NVASNOK  BEGIN ,                       ASN is currently OK
         WITH  (AFTE,RA),BEGIN         |
         L     RA,AFTASTO              Second table origin
         END   ,                       OF First table entry calc
         IF    (RA,NEG),EXIT,NVASNOK   EXIT - 2nd table unavailable
         N     RA,=A(AFTASTM)          | mask em out
         RTOV  (RA)                    | to virtual (ret in RVR)
         N     RB,=A(PAGASXM)          Second table entry calc
         SLL   RB,4                    | index*16 is offset from ASTO
         ALR   RB,RVR                  |
         WITH  (ASTE,RB),BEGIN         |
         IF    ASTFINV,EXIT,NVASNOK    EXIT - 2nd table entry unavail
         SET   ASTFINV                 Now it's invalid
         END   ,
         END   ,                       OF ASN is currently OK
*-
*- Release ASN lock
*-
         LKREL PAGASNL
         SET   @IAOK                   Available AS
         PEND  ,
         TITLE 'Do working set management for an address space'
*NEST,1
*box
*
*  Do working set management for an address space
*
*  Input - @PAGWSMA
*
* Output - @PAGWSMA
*
*
         SPACE
#PAGWSMA RECORD BEGIN
#WSPGD   DS    A                   ddf PGD save
#WSINT   DS    A                       Number of intervals passed
#WSNXTF  DS    A                       Next frame table ptr
#WSFLIST DS    A                       Current frame-list head
#WSNEED  DS    A                       Number needed to trim
#WSFLAG  FLAG  ,
         FLAG  #WSFTRIM
#WSFREF  EQU   X'04'                   ISKE ref bit
#WSFREFL EQU   5                       Ref bit is 5 from the MSB
#WSPSWM  DS    X                       PSW mask for disabling
#WSLKFLG DS    X                       Locks for this PCB
         END   ,
         SPACE
         SPACE
PAGWSMAN PROC  @PAGWSMA,#PAGWSMA,SCOPE=GLOBAL
         PAGAD RPAG
         CLEAR #PAGWSMA
         USING PZERO,R0
         L     RB,PZCURASB             ASB to manage
         DROP  R0
         WITH  (ASB,RB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         PAGNTRY ASYNC,#WSPSWM,#WSLKFLG
*-
*- If this is a request to manage global frames then we need
*- to get the global address space lock
*-
         IF    (@WSFGLOB,AND,^PCBFGBL),BEGIN    Manage global frames
         L     RJ,PAGCASB
         WITH  (ASB,RJ),'L RJ,ASBPAGB'
         WITH  (ASBPCB,RJ,),LABEL=COMM
         LKOB  COMM.PCBLOCK
         SET   PCBFGBL
*  Set global PCB as current
         LR    RPCB,RJ
         END   ,                       OF Manage global frames
WSLOCK   BEGIN ,                       Locked access code
         IF    PCBFTERM,EXIT           No frame mgmt - terminating
*-
*- Set up the upper limit of frames an address space can have, and
*- set up the history value for trimming.  The history value
*- determines how old a frame can be before it is tossed from the
*- working set.
*-
         L     RB,@WSLIMIT             Max frame limit
         ST    RB,PCBFLIMIT            Set our limit
         L     RK,@WSINT               Num of time intervals elapsed
         FLOOR RK,0
         CEIL  RK,63                   |
         ST    RK,#WSINT               |
         IF    (RK,POS),BEGIN          Intervals passed
         MVC   PCBWSHIST,PAGMNHST      Set new minimum history
         IF    @WSFGLOB,'MVC PCBWSHIST,PAGGMHST'        For global
         END   ,                       |
         ELSE  BEGIN                   No intervals passed
*-
*- Since no intervals have passed since the last call, if there
*- is nothing to trim, scram.  (The global address space
*- doesn't have a trim-limit.)
*- If there is something to trim, make a note of it.
*-
         IF    (@WSFGLOB,OR,                                           *
               (RB,ZERO)),EXIT,WSLOCK
         L     RA,PCBFCNT              Add frames together
         AL    RA,PCBPFCNT             | page tables
         AL    RA,PCBLFCNT             | long term fixed
         SR    RA,RB
         IF    NPOS,EXIT,WSLOCK        We're under the limit
         ST    RA,#WSNEED
         SET   #WSFTRIM
         END   ,                       OF No intervals passed
*-
*- Make sure we stay under maximum
*-
WSLIMIT  LOOP  BEGIN                   Stay under maximum
*-
*- Manage unfixed frames, then the page table frames
*-
         LA    RA,PCBUFLH
         LOOP  BEGIN
         WITH  (LHEAD,RA),BEGIN        List head addr
         ST    RA,#WSFLIST
         L     RS,LHCNT                Manage all frames in list
         L     RA,LHFP                 | 1st frame
         END   ,                       OF List head addr
         IF    (RS,POS),BEGIN          Process non-empty list
         LOOP  BEGIN                   |
         WITH  (PFTE,RA)
*-
*- Point to next unfixed frame.  After the I/O has started, the
*- next frame points to a fixed frame, because the frame is now
*- fixed for I/O.
*-
         MVC   #WSNXTF,PFTFP           Next unfixed frame
*-
*- Perform working set history calculations for frame
*-
         LCM   RJ,B'1100',PFTHIST      Get old history
         IF    ^#WSFTRIM,BEGIN         Calculate new history
         L     RK,#WSINT               Number of intervals
         SRL   RJ,@RK                  Shift history!
         LR    RB,RA                   Get change counts
         SL    RB,PAGPFTO              |
         SLL   RB,L'PAGPAGM-PFTLOG     | frame address
         RRBE  R0,RB                   |
         IF    REF,'O RJ,=X"80000000"' |
         STCM  RJ,B'1100',PFTHIST      |
         END   ,                       OF Calculate new history
         ELSEIF (RJ,POS),BEGIN         Check last interval reference
         LR    RB,RA                   Get reference value
         SL    RB,PAGPFTO              |
         SLL   RB,L'PAGPAGM-PFTLOG     |
         ISKE  RVR,RB                  |
         SLL   RVR,#WSFREFL+24         |
         IF    (RVR,NEG),BEGIN         Was referenced
         O     RJ,=X'80000000'         | set it
         STCM  RJ,B'1100',PFTHIST      |
         END   ,                       OF Was referenced
         END   ,
         SRL   RJ,16                   Move history to lower halfword
*-
*- We can trim any non-short fixed frames that have a sufficiently
*- under-utilized refrence history
*-
WSTRIM   IF    (('LTH RB,PFTSFIX',ZERO),AND,    Eligible for trimming  *
               ((RJ,LT,PCBWSHIST),OR,PFTFPGT)),BEGIN
         L     RJ,PFTVA                Get seg table addr
         N     RJ,=A(PAGSGNM)          |
         SRL   RJ,L'PAGSGNM-SGTLOG     |
         AL    RJ,PCBPSTO              |
         WITH  (SGTE,RJ),'L RJ,SGTAD'  |
         L     RVR,PFTVA               Invalidate page table entry
         IPTE  RJ,RVR                  |
*-
*-   If the frame has been changed, write it out.  We can only check
*- this for sure after the IPTE.
*-   Actually... if we're only letting a frame be defined in one
*- place at a time (in memory, on external page, or on external
*- swap, we have to write ALL of our trims.
*-
         LR    RB,RA                   Check for changed
         SL    RB,PAGPFTO              |
         SLL   RB,L'PAGPAGM-PFTLOG     |
         RRBE  R0,RB                   |
         IF    (CHG,OR,PAGXF1DEF),BEGIN         Write out page
*-
*- Set the page table entry as "in I/O"
*-
         N     RJ,=A(SGTADMSK)         Page table start
         L     RM,PFTVA                | compute entry
         N     RM,=A(PAGPGNM)          |
         LR    RN,RM                   |
         SRL   RM,L'PAGPGNM-PGTLOG     |
         ALR   RM,RJ                   |
         L     BRR,PCBRA               | DAT-Off
         DATOFF PCBPSWM                |
         BEGIN ,
         WITH  (PGTE,RM)
         SET   PGTFIO
*-
*- Get the external slot number from the shadow page table
*-
         SRL   RN,L'PAGPGNM-SPTLOG     Shadow page table entry
         LA    RN,@RN+PGTL             |
         ALR   RN,RJ                   |
         WITH  (SPTE,RN)
         L     RK,SPXSLOT
         IF    ^PGTFXDEF,BEGIN         Need to allocate ext frame
         WITH  (ASBPCB,BRR),'DATON PCBPSWM'
         XPGET ,
         IF    ^@XPOK,BEGIN            Alloc of ext page failed
         DATOFF PCBPSWM
         WITH  (PGTE,RM),BEGIN         PGTE addr
         CLEAR PGTFINV                 | not invalid
         CLEAR PGTFIO                  | and not in I/O
         END   ,                       OF PGTE addr
         WITH  (ASBPCB,BRR),'DATON PCBPSWM'
         EXIT  WSTRIM
         END   ,                       OF Alloc of ext page failed
         LR    RK,RVR
         DATOFF PCBPSWM
         WITH  (PGTE,RM),BEGIN         PGTE addr
         SET   PGTFXDEF                External page defined
         WITH  (SPTE,RN)
         ST    RK,SPXSLOT
         END   ,                       OF PGTE addr
         END   ,                       OF Need to allocate ext frame
         END   ,
         WITH  (ASBPCB,BRR),'DATON PCBPSWM'
*-
*- Write out this frame
*-
         PSET  @PAGOUT
         PMOV  @PGOSLOT,(RK)
         PMOV  @PGORA,(RB)
         SET   @PGOUFIX*@PGOREL        Unfix and release on complete
         ACALL PAGOUT
         IF    @PGOOK,BEGIN        ddf Could do page out
         MVC   #WSPGD,@PGOPGD      ddf Save PGD address
         END   ,                   ddf
         ELSE  BEGIN               ddf Couldn't do page out
*
*ddf     IF    ^@PGOOK,BEGIN           Couldn't do page out
         DATOFF PCBPSWM
         WITH  (PGTE,RM),BEGIN         PGTE addr
         CLEAR PGTFINV                 | not invalid
         CLEAR PGTFIO                  | and not in I/O
         END   ,                       OF PGTE addr
         WITH  (ASBPCB,BRR),'DATON PCBPSWM'
         EXIT  WSTRIM
         END   ,                       OF Couldn't do page out
         IF    PFTFPGT,BEGIN           Page table written out
         LH    RJ,PFTSEG               Set invalid segment
         LR    RB,RJ                   | set "in I/O" in shadow
         SLL   RB,SSTLOG               | |
         AH    RB,PAGSEGL              | |
         AL    RB,PCBPSTO              | |
         WITH  (SSTE,RB),BEGIN         | |
         SET   SSTFIO                  | |
         END   ,                       | |
         SLL   RJ,SGTLOG               |
         AL    RJ,PCBPSTO              |
         WITH  (SGTE,RJ),BEGIN         | SGTE addr
         SET   SGTFINV                 |
         VCALL DISPPTLB                |
         END   ,                       | OF SGTE addr
         END   ,                       |
         IF    ('LT R15,#WSPGD',NZ),BEGIN ddf
         WITH  (PGDPAGE,R15),'TS PGDIOF' ddf IO already done?
         IF    NZ,BEGIN            ddf Yes, that sure was fast!
         PSET  @IOTERM             ddf
         PMOV  @IOTPARM,(R15)      ddf PCB in control
         ACALL PAGTERM             ddf Do page IO termination now
         END   ,                   ddf
         CLEAR #WSPGD              ddf
         END   ,                   ddf
         END   ,                       OF Write out page
         EJECT ,
         ELSE  BEGIN                   Release unchanged frame
*box
*
*    Frame is not changed, so release it.  If it is a page table
*  frame, set the segment entry to the virtual address, and set
*  the page table entry to the segment number.
*
         IF    PFTFPGT,BEGIN           Page table frame
         L     RK,PFTVA                Virtual address
         N     RK,=A(PAGPAGM)          | page align
*-
*- Set seg table with PTs VA
*-
         LH    RJ,PFTSEG               Segment table addr
         SLL   RJ,SGTLOG               |
         AL    RJ,PCBPSTO              |
         WITH  (SGTE,RJ),BEGIN         |
         SET   SGTFINV                 Invalidate segment
         VCALL DISPPTLB                |
         L     RVR,SGTAD               Set seg entry w/ VA
         N     RVR,=A(SGTFLMSK)        |
         OR    RVR,RK                  | VA
         ST    RVR,SGTAD               |
         END   ,                       OF SGTE addr
*-
*- Set page table with segment number
*-
         LR    RJ,RK                   Copy VA => page tbl entry
         SRL   RJ,L'PAGSGNM            |
         IF    ('CH RJ,PFTSEG',NE),BEGIN        Doesn't map own addr
         SLL   RJ,SGTLOG
         AL    RJ,PCBPSTO
         WITH  (SGTE,RJ),BEGIN         SGTE addr
         IF    SGTFINV,WSSTI
         L     RJ,SGTAD
         END   ,                       OF SGTE addr
         N     RJ,=A(SGTADMSK)         Page table entry - start
         N     RK,=A(PAGPGNM)          | page number
         SRL   RK,L'PAGPGNM-PGTLOG     |
         ALR   RK,RJ                   | page table entry RA
         L     RM,PCBRA
         WITH  (ASBPCB,RM),LABEL=REAL
         LH    RB,PFTSEG               Get segment number for PT
         SLL   RB,L'PAGSGNM            |
         DATOFF PCBPSWM
         WITH  (PGTE,RK),BEGIN         PGTE addr
         L     RVR,PGAD
         N     RVR,=A(PGTFLMSK)
         OR    RVR,RB
         ST    RVR,PGAD
         END   ,                       OF PGTE addr
         DATON REAL.PCBPSWM
         END   ,                       OF Doesn't map own addr
         END   ,                       OF Page table frame
*-
*- One less short term fix for PT frame
*-
         L     RK,PFTVA                One less short fix - PT
         LRA   RK,@RK                  |
         IF    ^PAGI,WSPTI             | just made invalid
         QUSFIX (RK)                   |
*
         FRAMEREL LA:PFTE              |
         END   ,                       OF Release unchanged frame
         IF    #WSFTRIM,BEGIN          Have we trimmed enough?
         DECR  RA,#WSNEED
         IF    (RA,ZERO),EXIT,WSLIMIT
         END   ,                       OF Have we trimmed enough?
         END   ,                       OF Eligible for trimming
         L     RA,#WSNXTF              Next unfixed frame
         UNTIL (BCT,RS),END            OF Manage all frames in list
         END   ,                       OF Process non-empty list
*-
*- Move onto the next frame list
*-
         L     RA,#WSFLIST
         LA    RA,@RA+L'LHEAD
         LA    RS,PCBPFLH
         UNTIL (RA,GT,RS),END          OF manage normal then page tbl
*-
*- Check to see if we are under maximum
*-
         L     RA,PCBFCNT              Number of frames we have
         AL    RA,PCBPFCNT             | PT frames
         AL    RA,PCBLFCNT             | long term fixed
         IF    ('LT RB,@WSLIMIT',ZERO),EXIT
         SLR   RA,RB                   |
         IF    (RA,NPOS),EXIT          We are OK
         ST    RA,#WSNEED
         SET   #WSFTRIM
         L     RB,PCBWSHIST            Use smaller work set window
         SLL   RB,1                    |
* after 8 cycles through the list we can't do any more
         IF    (RB,GT,=A(PAGMXHST)),EXIT,WSLIMIT can't trim more
         ST    RB,PCBWSHIST            |
*
         END   ,                       OF Stay under maximum
         END   ,                       OF Locked access code
         USING PZERO,R0                Go back to PCB in control
         L     RPCB,PZCURASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         DROP  R0
         PAGXIT ASYNC,#WSPSWM,#WSLKFLG,WR=RS
         PEND  ,
*NEST,2
         SPACE
WSSTI    ABORT PAGWSSTI                Seg invalid - shouldn't be
         SPACE
WSPTI    ABORT PAGWSPTI                Should be page-invalid
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Fix frames in main store'
*box
*
*  Fix a range of virtual addresses in main store
*
*  Input - @PAGE
*
* Output - NONE
*
*
         FLAG  (@PAG2ND,@PAGLOC.X'80') 2ndary space address
         SPACE
PAGFIX   PROC  @PAGE,#PAGE,SCOPE=GLOBAL         Fix frames
         PAGAD RPAG
         USING PZERO,R0
         L     RPCB,PZCURASB           Get PCB address
         DROP  R0
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RA,@PAGLOC              Starting page
         LR    RB,RA                   Ending page
         AL    RB,@PAGLEN              |
         DECR  RB                      |
         L     RS,=A(PAGPAGM)          |
         NR    RA,RS                   |
         NR    RB,RS                   |
         SLR   RB,RA                   Number of pages
         SRL   RB,L'PAGPAGM            |
         INCR  RB                      |
*        IF    @PAG2ND,BEGIN           Secondary space fix
*        ABORT PAGFIX2                 Can't do now
*        O     RA,=X'80000000'
*        END   ,                       OF Secondary space fix
         SPACE ,
*box
*
*  Get lock
*
         PAGNTRY SYNC,#PAGPSWM,#PAGFLGS
         LOOP  BEGIN                   Fix pages
         PSET  @RESOLVE                Bring in page
         PMOV  @PRVA,(RA)              |
         PMOV  @PRPCB,LA:ASBPCB        |
         PMOV  @PRPSWM,#PAGPSWM        |
         ACALL PAGRESLV                |
         IF    ^@PRROK,PFABORT         |
         LR    RJ,RVR                  Fix this frame (RVR = real ad)
         PSET  @QFIX                   |
         PMOV  @QFIXRA,(RJ)            |
         ACALL QFIX                    |
*
         AL    RA,=A(PAGPAGEL)         Next page ...
         UNTIL (BCT,RB),END            OF Fix pages
         PAGXIT SYNC,#PAGPSWM,#PAGFLGS,WR=RS
         PEND  ,
         SPACE
PFABORT  ABORT PAGFIX                  Pages not defined
         TITLE 'Unfix a frame in main store'
*box
*
*  Unfix a range of virtual addresses in main store
*
*  Input - @PAGE
*
* Output - RVR =  0 if all went OK
*          RVR <> 0 if one of the pages was out.
*            RVR = the virtual address of the frame that was out
*
*
         SPACE
PAGUFIX  PROC  @PAGE,#PAGE,SCOPE=GLOBAL         Unfix frames
         PAGAD RPAG
         USING PZERO,R0
         L     RPCB,PZCURASB           Get PCB address
         DROP  R0
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RA,@PAGLOC              Starting page
         LR    RB,RA                   Ending page
         AL    RB,@PAGLEN              |
         DECR  RB                      |
         L     RS,=A(PAGPAGM)          |
         NR    RA,RS                   |
         NR    RB,RS                   |
         SLR   RB,RA                   Number of pages
         SRL   RB,L'PAGPAGM            |
         INCR  RB                      |
*        IF    @PAG2ND,BEGIN           Secondary space fix
*        ABORT PAGFIX2                 Can't do now
*        O     RA,=X'80000000'
*        END   ,                       OF Secondary space fix
         SPACE ,
*box
*
*  Get lock
*
         PAGNTRY SYNC,#PAGPSWM,#PAGFLGS
         CLEAR RK                      Set as OK
PAGUFOK  LOOP  BEGIN                   Unfix pages
         LRA   RJ,@RA
         IF    ^VAOK,'LR RK,RA; EXIT PAGUFOK'
         IF    ^PCBFGBL,BEGIN          Don't have global lock
         LR    RM,RJ
         SRL   RM,L'PAGPAGM
         SLL   RM,PFTLOG
         AL    RM,PAGPFTO
         WITH  (PFTE,RM),BEGIN         PFTE addr
         L     RN,PFTASB
         WITH  (ASB,RN),'L RN,ASBPAGB'
         WITH  (ASBPCB,RN),LABEL=COMM
         IF    COMM:PCBFGBLC,BEGIN     This is global memory
         LKOB  COMM.PCBLOCK            Get global lock
         SET   PCBFGBL                 | set as held
         END   ,                       OF This is global memory
         END   ,                       OF PFTE addr
         END   ,                       OF Don't have global lock
         PSET  @QUFIX                  | frame table entry
         PMOV  @QUFRA,(RJ)             |
         ACALL QUFIX                   |
         AL    RA,=A(PAGPAGEL)         Next page ...
         UNTIL (BCT,RB),END            OF Unfix pages
         PAGXIT SYNC,#PAGPSWM,#PAGFLGS,WR=RS
         LR    RVR,RK                  0 = all OK
         PEND  ,
         SPACE
         TITLE 'Short-term fix frames in main store'
*box
*
*  Short term fix a range of virtual addresses in main store
*
*  Input - @PAGE
*
* Output - NONE
*
*
PAGSFIX  PROC  @PAGE,#PAGE,SCOPE=GLOBAL         Short term fix
         PAGAD RPAG
         USING PZERO,R0
         L     RPCB,PZCURASB           Get PCB address
         DROP  R0
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RA,@PAGLOC              Starting page
         LR    RB,RA                   Ending page
         AL    RB,@PAGLEN              |
         DECR  RB                      |
         L     RS,=A(PAGPAGM)          |
         NR    RA,RS                   |
         NR    RB,RS                   |
         SLR   RB,RA                   Number of pages
         SRL   RB,L'PAGPAGM            |
         INCR  RB                      |
*        IF    @PAG2ND,BEGIN           Secondary space fix
*        ABORT PAGSFIX2                Can't do now
*        O     RA,=X'80000000'
*        END   ,                       OF Secondary space fix
         PAGNTRY SYNC,#PAGPSWM,#PAGFLGS
         LOOP  BEGIN                   Fix pages
         PSET  @RESOLVE                Bring in page
         PMOV  @PRVA,(RA)              |
         PMOV  @PRPCB,LA:ASBPCB        |
         PMOV  @PRPSWM,#PAGPSWM        |
         ACALL PAGRESLV                |
         IF    ^@PRROK,PFSABORT        |
         LR    RJ,RVR                  Fix this frame (RVR = real ad)
         QSFIX (RJ)                    |
*
         AL    RA,=A(PAGPAGEL)         Next page ...
         UNTIL (BCT,RB),END            OF Fix pages
         PAGXIT SYNC,#PAGPSWM,#PAGFLGS,WR=RS
         PEND  ,
         SPACE
PFSABORT ABORT PAGFIX                  Pages not defined
         TITLE 'Unfix a short term fixed frame'
*box
*
*  Unfix a range of virtual addresses - short term fixed
*
*  Input - @PAGE
*
* Output - RVR =  0 if all went OK
*          RVR <> 0 if one of the pages was out.
*            RVR = the virtual address of the frame that was out
*
*
         SPACE
PAGUSFIX PROC  @PAGE,#PAGE,SCOPE=GLOBAL         Unfix frames
         PAGAD RPAG
         USING PZERO,R0
         L     RPCB,PZCURASB           Get PCB address
         DROP  R0
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RA,@PAGLOC              Starting page
         LR    RB,RA                   Ending page
         AL    RB,@PAGLEN              |
         DECR  RB                      |
         L     RS,=A(PAGPAGM)          |
         NR    RA,RS                   |
         NR    RB,RS                   |
         SLR   RB,RA                   Number of pages
         SRL   RB,L'PAGPAGM            |
         INCR  RB                      |
*        IF    @PAG2ND,BEGIN           Secondary space fix
*        ABORT PAGFIX2                 Can't do now
*        O     RA,=X'80000000'
*        END   ,                       OF Secondary space fix
         SPACE ,
*box
*
*  Get lock
*
         PAGNTRY SYNC,#PAGPSWM,#PAGFLGS
         CLEAR RK                      Set as OK
PAGUSFOK LOOP  BEGIN                   Unfix pages
         LRA   RJ,@RA
         IF    ^VAOK,'LR RK,RA; EXIT PAGUSFOK'
         QUSFIX (RJ)
         AL    RA,=A(PAGPAGEL)         Next page ...
         UNTIL (BCT,RB),END            OF Unfix pages
         PAGXIT SYNC,#PAGPSWM,#PAGFLGS,WR=RS
         LR    RVR,RK                  0 = all OK
         PEND  ,
         TITLE 'Quickly fix a page in main store'
*box
*
*    Quickly fix a page in main store - page MUST be currently in
*  main store.
*
*   Input - @QFIX
*
*  Output - NONE
*
*
@QFIX    RECORD BEGIN
@QFIXRA  DS    A                       Real addr of frame to fix
         END   ,
         SPACE
QFIX     PROC  @QFIX                   Quickly fix a frame in core
         PAGAD RPAG
         L     RA,@QFIXRA              Get page frame table addr
         SRL   RA,L'PAGPAGM            |
         SLL   RA,PFTLOG               |
         AL    RA,PAGPFTO              |
         WITH  (PFTE,RA),BEGIN         Page frame table addr
         INCR  RS,PFTFIX               | one more fix
         IF    (RS,EQ,1),BEGIN         First fix - change lists
         L     RPCB,PFTASB             |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         LC    RB,PFTQ                 Remove from current list
         LA    RB,ASBPCB(RB)           |
         LREM  (RB),LA:PFTE,WR=RS      |
         LADD  PCBLFLH,LA:PFTE,WR=RS   |
         MVI   PFTQ,PCBLFLH-ASBPCB     | set new Q id
         END   ,                       OF First fix - change lists
         END   ,                       OF Page frame table addr
         PEND  ,
         TITLE 'Quickly unfix a frame in main store'
*box
*
*  Quickly unfix a fixed page
*
*   Input - @QUFIX
*
*  Output - NONE
*
*
         SPACE
@QUFIX   RECORD BEGIN                  Unfix frame in core
@QUFRA   DS    A                       Frame real addr
         END   ,
         SPACE
QUFIX    PROC  @QUFIX
         PAGAD RPAG
         L     RK,@QUFRA               RA => Frame table entry
         SRL   RK,L'PAGPAGM            |
         SLL   RK,PFTLOG               |
         AL    RK,PAGPFTO              |
         WITH  (PFTE,RK)               |
         L     RPCB,PFTASB             PCB that owns frame
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         LH    RA,PFTFIX               | one less fix
         DECR  RA                      |
         FLOOR RA,0                    |
         STH   RA,PFTFIX               |
         IF    (RA,ZERO),BEGIN         | totally unfixed
         LC    RB,PFTQ                 |
         LREM  ASBPCB(RB),LA:PFTE,WR=RS
         LA    RJ,PCBUFLH              Add to normal frames list
         IF    PFTFPGT,'LA RJ,PCBPFLH' | or page table frames
         LADD  (RJ),LA:PFTE,WR=RS      |
         SR    RJ,RPCB                 | put in Q id
         STC   RJ,PFTQ                 |
         END   ,                       | OF totally unfixed
         PEND  ,
         TITLE 'Set page table protection on range'
*box
*
*  Set page table protection on range of virtual addresses
*
*   Input - @PAGE
*
*  Output - RVR =  0 all pages were defined, and now are protected
*           RVR <> 0 a page not defined in range.
*             RVR = address of undefined page, and the remainder
*                   of the pages in the range are not protected
*
*
         SPACE
PAGPROT  PROC  @PAGE,SCOPE=GLOBAL
         PSET  $PAGE                   Call general rtn w/ code
         MVC   $PAGLOC(8),@PAGLOC
         MVC   $PAGCODE,=A($VPPROT)
         LCALL VPROTRAN                protection on range
         PEND  ,
         EJECT ,
PAGPROT2 PROC  @PAGE
         PAGAD RPAG
         L     RPCB,PAGCASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RJ,PCBPSTO
         LRA   RJ,@RJ
         IF    NZ,'ABORT BADSEGTEST'
         RTOV  (RJ)
         LR    RJ,RVR                  Seg table VA
         L     RA,@PAGLOC
         LR    RB,RA
         N     RA,=A(PAGSGNM)
         SRL   RA,L'PAGSGNM-SGTLOG
         ALR   RA,RJ
         WITH  (SGTE,RA),BEGIN
         L     RA,SGTAD
         END   ,
         N     RA,=A(SGTADMSK)
         RTOV  (RA)
         LR    RA,RVR                  Page table VA
         N     RB,=A(PAGPGNM)
         SRL   RB,L'PAGPGNM-PGTLOG
         ALR   RB,RA
         WITH  (PGTE,RB),BEGIN
         SET   PGTFPROT
         END   ,
         VCALL DISPPTLB
         PEND  ,
         EJECT ,
PAGUPROT2 PROC  @PAGE
         PAGAD RPAG
         L     RPCB,PAGCASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RJ,PCBPSTO
         LRA   RJ,@RJ
         IF    NZ,'ABORT BADSEGTEST'
         RTOV  (RJ)
         LR    RJ,RVR                  Seg table VA
         L     RA,@PAGLOC
         LR    RB,RA
         N     RA,=A(PAGSGNM)
         SRL   RA,L'PAGSGNM-SGTLOG
         ALR   RA,RJ
         WITH  (SGTE,RA),BEGIN
         L     RA,SGTAD
         END   ,
         N     RA,=A(SGTADMSK)
         RTOV  (RA)
         LR    RA,RVR                  Page table VA
         N     RB,=A(PAGPGNM)
         SRL   RB,L'PAGPGNM-PGTLOG
         ALR   RB,RA
         WITH  (PGTE,RB),BEGIN
         CLEAR PGTFPROT
         END   ,
         VCALL DISPPTLB
         PEND  ,
         TITLE 'Clear page table protection on range'
*box
*
*  Clear page table protection on range of virtual addresses
*
*   Input - @PAGE
*
*  Output - RVR =  0 all pages were defined, now are unprotected
*           RVR <> 0 a page not defined in range.
*             RVR = address of undefined page, and the remainder
*                   of the pages in the range are not protected
*
*
         SPACE
PAGUPROT PROC  @PAGE,SCOPE=GLOBAL
         PSET  $PAGE                   Call general rtn w/ code
         MVC   $PAGLOC(8),@PAGLOC
         MVC   $PAGCODE,=A($VPUPROT)
         LCALL VPROTRAN                clear protection on range
         LR    RA,RVR                  Save RC
         VCALL DISPPTLB
         LR    RVR,RA
         PEND  ,
         TITLE 'Test page table protection on range'
*box
*
*  Test page table protection on range
*
*   Input - @PAGE
*
*  Output - RVR =  0 at least one page was unprotected/undefined
*               <> 0 all pages in range were protected
*
*
         SPACE
PAGTPTP  PROC  @PAGE,SCOPE=GLOBAL      Test page table protection
         PSET  $PAGE                   Call general rtn w/ code
         MVC   $PAGLOC(8),@PAGLOC
         MVC   $PAGCODE,=A($VPTACC)
         LCALL VPROTRAN                test protection on range
         PEND  ,
         TITLE 'Test protection on range'
*box
*
*  Test protection on range
*
*   Input - @PAGE
*
*  Output - RVR =  0 can store and fetch range
*               =  1 fetch only
*               =  2 no fetching or storing
*               =  3 addressing exception
*
*
         SPACE
PAGTPROT PROC  @PAGE,SCOPE=GLOBAL
         PSET  $PAGE                   Call general rtn w/ code
         MVC   $PAGLOC(9),@PAGLOC
         MVC   $PAGCODE,=A($VPTPROT)
         LCALL VPROTRAN                test protection on range
         PEND  ,
         TITLE 'General protection routine'
*box
*
*  Do page protection actions
*
*   Input - $PAGE
*
*  Output - RVR depends on function type
*
*
$PAGE    RECORD BEGIN
$PAGLOC  DS    A                       Virtual Location
$PAGLEN  DS    A                       Virtual Length
$PAGCODE DS    A                       Request code
$PAGKEY  DS    X
$VPPROT  EQU   4                       Protect range
$VPUPROT EQU   8                       Unprotect a range
$VPTACC  EQU   12                      Test protection on range
$VPTPROT EQU   16                      Test access
*-
*- Definitions for $VPTPROT call returns
*-
$VPSTORE EQU   0                       Fetch & store allowed
$VPFETCH EQU   1                       Fetch allowed
$VPNOACC EQU   2                       No access allowed
$VPUNDEF EQU   3                       Undefined address
         END   ,
         SPACE
#VPROTRA RECORD BEGIN
#VPFLGS  DS    X
#VPPSWM  DS    X                       PSW mask for disabling
         VPPARM PFX=#VP
         END   ,
         SPACE
VPROTRAN PROC  $PAGE,#VPROTRA
         PAGAD RPAG
         USING PZERO,R0                Address of current PCB
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         L     RA,$PAGLOC              Page/number of pages
         L     RS,$PAGLEN              |
         ALR   RS,RA                   |
         DECR  RS                      |
         IF    ((RA,NEG),OR,(RS,LT,RA)),VPERR
         SRL   RS,L'PAGPAGM            | last page number
         SRL   RA,L'PAGPAGM            | 1st page number
         L     RB,PAGMEG               | last page in AS
         SLL   RB,L'PAGSGNM-L'PAGPGNM  | |
         DECR  RB                      | |
*
         IF    ((RS,GT,RB),OR,(RA,GT,RB)),BEGIN Error in range
VPERR    LABEL ,
         L     RB,$PAGCODE
VPERTAB  B     VPERTAB(RB)
         B     VPEPROT
         B     VPEUPROT
         B     VPETACC
*        B     VPETPROT
VPETPROT LABEL ,
         LA    RVR,$VPUNDEF            Undefined addr/len
         EXIT  VPROTRAN
         SPACE
VPETACC  CLEAR RVR                     At least one undefined
         EXIT  VPROTRAN
         SPACE
VPEPROT  LABEL
VPEUPROT LR    RVR,RA                  Address of undefined
         EXIT  VPROTRAN
         END   ,                       OF Error in range
*
         SLR   RS,RA                   |
         INCR  RS                      | number of pages
         SLL   RA,L'PAGPAGM            | 1st page address
*-
*- Get locks
*-
         PAGNTRY SYNC,#VPPSWM,#VPFLGS  Get flags - set up entry
         L     RJ,PCBPSTO              Check for seg table in core
         LRA   RJ,@RJ                  |
         IF    ^VAOK,VPABORT           | seg table not in
         PSET  @RESPT                  Bring in PT for VA
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#VPPSWM         |
         ACALL RESPT                   |
         LM    RJ,RK,@PTPGTE           Page/shadow page addr
*-
*- In this loop, RA is the page address to be protected, and RS is
*- the number of consecutive pages to protect
*-
         CLEAR RM                      Preset return
VPSEG    BEGIN ,                       Valid segments
VPLOOP   LOOP  BEGIN                   Loop through virtual addrs
         WITH  (PGTE,RJ)
         WITH  (SPTE,RK)
         IF    (RVR,NZ),BEGIN          Addr exception
         LR    RM,RA                   | address of undef page
         IF    ($PAGCODE,EQ,$VPTPROT),BEGIN     Test access call
         LA    RM,$VPUNDEF
         END   ,                       OF Test access call
         EXIT  VPSEG                   |
         END   ,                       OF Addr exception
         L     RB,$PAGCODE
VPTAB    B     VPTAB(RB)
         B     VPPROT
         B     VPUPROT
         B     VPTACC
*        B     VPTPROT
VPTPROT  LABEL ,
         IF    ^PGTFDEF,BEGIN          Undefined page
         LA    RM,$VPUNDEF
         EXIT  VPLOOP
         END   ,                       OF Undefined page
         IF    ^PGTFINV,BEGIN          If frame is in
         L     RN,PGAD                 Real addr of this addr
         N     RN,=A(PGTADMSK)         |
         IF    (ZERO),BEGIN            Check low address protection
         LC    RB,$PAGKEY
         TPROT @RA,@RB                 CC => integer 0..3
         IPM   RB                      |
         SRL   RB,28                   |
         STMAX RB,RM
         END   ,                       OF Check low addr protection
         END   ,                       OF If frame is in
*
         IF    PGTFPROT,BEGIN          Check page table protection
         LA    RB,$VPFETCH             |
         STMAX RB,RM                   |
         END   ,                       OF Check page table protection
*
         LC    EPAR,$PAGKEY            |
         N     EPAR,=X'000000F0'       |
         IF    ^ZERO,BEGIN             Bypass for key of 0
         LC    RVR,SPKEY               |
         N     RVR,=X'000000F0'        | keys
         IF    (RVR,NE,EPAR),BEGIN     Key mismatch
         LA    RB,$VPFETCH             Limit to fetch
         STMAX RB,RM
         IF    SPFPROT,BEGIN           Fetch protection
         LA    RB,$VPNOACC             No access
         STMAX RB,RM
         END   ,                       OF Fetch protection
         END   ,                       OF Key mismatch
         END   ,                       OF Bypass for key of 0
         B     VPNXT
         SPACE 2
VPTACC   LABEL ,
         IF    (^PGTFDEF,OR,^PGTFPROT),BEGIN
         CLEAR RM                      At least 1 undef/unprotect
         EXIT  VPLOOP                  |
         END   ,
         LA    RM,4                    Another protected page
         B     VPNXT
         SPACE 2
VPUPROT  LABEL ,
*-
*- If the page is defined, clear page protection
*-
         IF    ^PGTFDEF,BEGIN          Undefined page
         LR    RM,RA                   | address of undefined
         EXIT  VPLOOP                  |
         END   ,                       OF Undefined page
         CLEAR PGTFPROT                Clear page protection
         B     VPNXT
         SPACE 2
VPPROT   LABEL ,
*-
*- If the page is defined, set the protection bit
*-
         IF    ^PGTFDEF,BEGIN          Undefined page
         LR    RM,RA                   | address of undefined
         EXIT  VPLOOP                  |
         END   ,                       OF Undefined page
         SET   PGTFPROT                Set page as protected
         SPACE 2
VPNXT    LABEL ,
*-
*- Get the addresses of the page table entries, using a short cut
*- if it's in the same segment.
*-
         IF    (RS,GT,1),BEGIN         More to come
         AL    RA,=A(PAGPAGEL)         Is next in another segment?
         LR    RB,RA                   |
         N     RB,=A(PAGPGNM)          | (if page num 0, next seg)
         IF    NZ,BEGIN                Same segment
         LA    RJ,PGTNXT               |
         LA    RK,SPTNXT               |
         CLEAR RVR                     | (not addr error)
         END   ,                       OF Same segment
         ELSE  BEGIN                   Different segment
         LRA   RB,PGTE                 Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
*
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#VPPSWM         |
         ACALL RESPT                   |
         LM    RJ,RK,@PTPGTE
         END   ,                       OF Different segment
         END   ,                       OF More to come
         UNTIL (BCT,RS),END            OF Loop through virtual addrs
         LRA   RB,@RJ                  Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
         END   ,                       Valid segments
         PAGXIT SYNC,#VPPSWM,#VPFLGS,WR=RS
         LR    RVR,RM                  RVR = completion code
         PEND  ,
         SPACE
VPABORT  ABORT PAGPROT                 Page protection error
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Define pages'
*box
*
*  Define pages
*
*   Input - @PAGDEF
*           For global definitions
*             The common ASB is obtained from the PAGCB
*           For local definitions
*             PZCURASB defines the AS which is in control and
*             which will have this page defined
*
*  Output - NONE
*
*
         SPACE
#PAGDEF  RECORD BEGIN
#PDFLGS  DS    X                       Current flags held on entry
#PDPSWM  DS    X                       PSW mask for disabling
         END   ,
         SPACE
PAGDEF   PROC  @PAGDEF,#PAGDEF,SCOPE=GLOBAL     Define pages
         PAGAD RPAG
         USING PZERO,R0                Address of current PCB
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         L     RA,@PDADDR              Page/number of pages
         L     RS,@PDLEN               |
         ALR   RS,RA                   |
         DECR  RS                      |
         SRL   RS,L'PAGPAGM            | last page number
         SRL   RA,L'PAGPAGM            | 1st page number
         L     RB,PAGMEG               | last page in AS
         SLL   RB,L'PAGSGNM-L'PAGPGNM  | |
         DECR  RB                      | |
         IF    ((RS,GT,RB),OR,(RA,GT,RB)),PDABORT
         SLR   RS,RA                   |
         INCR  RS                      | number of segments
         SLL   RA,L'PAGPAGM            | 1st page address
         PAGNTRY SYNC,#PDPSWM,#PDFLGS  Get flags - set up entry
         IF    (@PDFGLOB,AND,^PCBFGBL),BEGIN    Get global lock
         L     RCPCB,PAGCASB
         WITH  (ASB,RCPCB),'L RCPCB,ASBPAGB'
         WITH  (ASBPCB,RCPCB),LABEL=COMM
         LKOB  COMM.PCBLOCK
         SET   PCBFGBL
         END   ,                       OF Get global lock
         L     RM,PCBPSTO              Check for seg table in core
         LRA   RM,@RM                  |
         IF    ^VAOK,PDABORT           | seg table not in
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PDPSWM         |
         ACALL RESPT                   |
         LM    RM,RN,@PTPGTE           |
*-
*- In this loop, RA is the page address to be defined, and RS is
*- the number of consecutive pages to define.  RM and RN are
*- addresses of the page/shadow page table entries.
*-
         LOOP  BEGIN                   Define pages
         IF    (RVR,NZ),PDABORT        Addr error on PT
         WITH  (PGTE,RM)
         WITH  (SPTE,RN)
         LR    RB,RA                   Segment addr
         SRL   RB,L'PAGSGNM            |
         SLL   RB,SGTLOG               |
         AL    RB,PCBPSTO              |
         WITH  (SGTE,RB),BEGIN         |
         IF    ((@PDFGLOB,AND,^SGTFCOMM),OR,                           *
               (^@PDFGLOB,AND,SGTFCOMM)),PDABORT
         END   ,
*-
*- Define the page attributes, and if not previously defined, get
*- an external frame for the page.
*-
         SPACE ,
*        MVC   SPINIT,@PDHASH          |
         MVC   SPKEY,@PDKEY            |
         IF    @PDFPROT,'SET PGTFPROT' |
         IF    @PDFGLOB,'SET PGTFCOMM' |
         SET   PGTFDEF                 |
*-
*- Get the addresses of the page table entries, using a short cut
*- if it's in the same segment.
*-
         IF    (RS,GT,1),BEGIN         More to come
         AL    RA,=A(PAGPAGEL)         Is next in another segment?
         LR    RB,RA                   |
         N     RB,=A(PAGPGNM)          | (0 page num = new segment)
         IF    NZ,BEGIN                Same segment
         LA    RM,PGTNXT               |
         LA    RN,SPTNXT               |
         CLEAR RVR                     | (no addr error on PT)
         END   ,                       OF Same segment
         ELSE  BEGIN                   Different segment
         LRA   RB,PGTE                 Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
*
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PDPSWM         |
         ACALL RESPT                   |
         LM    RM,RN,@PTPGTE           | get page/shadow entry addrs
         END   ,                       OF Different segment
         END   ,                       OF More to come
         UNTIL (BCT,RS),END            OF Define pages
         LRA   RB,@RM                  Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
         PAGXIT SYNC,#PDPSWM,#PDFLGS,WR=RS
         PEND  ,
PDABORT  ABORT PAGDEFN                 Page define error
         TITLE 'Undefine a page'
*NEST,1
*box
*
*  Undefine a page
*
*   Input - @PAGE
*
*  Output - RVR =  0  Range of pages is now undefined
*           RVR <> 0  At least one page was undefined, had a
*                     long-term fix on it, or did not match the
*                     Local/Global flag of the ASB.
*                       In this case RVR contains the address of
*                     the page which could not be undefined. The
*                     rest of the pages in the range are ignored.
*
*
         SPACE
#PAGUDEF RECORD BEGIN
#PUDFLGS DS    X                       Flags
#PUDPSWM DS    X                       PSW mask for diabling
         END   ,
         SPACE
PAGUDEF  PROC  @PAGE,#PAGUDEF,SCOPE=GLOBAL
         PAGAD RPAG
         USING PZERO,R0                Address of current PCB
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         L     RA,@PAGLOC              Page/number of pages
         L     RS,@PAGLEN              |
         ALR   RS,RA                   |
         DECR  RS                      |
         SRL   RS,L'PAGPAGM            | last page number
         SRL   RA,L'PAGPAGM            | 1st page number
         L     RB,PAGMEG               | last page in AS
         SLL   RB,L'PAGSGNM-L'PAGPGNM  | |
         DECR  RB                      | |
         IF    ((RS,GT,RB),OR,(RA,GT,RB)),PUDABORT
         SLR   RS,RA                   |
         INCR  RS                      | number of segments
         SLL   RA,L'PAGPAGM            | 1st page address
*-
*- Get locks
*-
         PAGNTRY SYNC,#PUDPSWM,#PUDFLGS
         L     RJ,PCBPSTO              Check for seg table in core
         LRA   RJ,@RJ                  |
         IF    ^VAOK,PUDABORT          | seg table not in
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PUDPSWM        |
         ACALL RESPT                   |
         LM    RJ,RK,@PTPGTE           |
*-
*- In this loop, RA is the page address to be undefined, and RS is
*- the number of consecutive pages to undefine. RJ and RK are
*- the addresses of the page/shadow page table entries.
*-
         CLEAR RM                      Preset return
PUDPTVAL BEGIN ,                       Current PT valid
PUDLOOP  LOOP  BEGIN                   Loop through virtual addrs
*-
*- If the page table is not defined, quit this loop, returning
*- the address of the first page represented by this page table
*-
         IF    (RVR,NZ),BEGIN          Addr exception for PT
         LR    RM,RA                   | address of undef page
         EXIT  PUDPTVAL                |
         END   ,                       OF Addr exception for PT
         WITH  (PGTE,RJ)
         WITH  (SPTE,RK)
         IF    (PGTFCOMM,AND,^PCBFGBL),BEGIN    Need global lock
         L     EPAR,PAGCASB
         WITH  (ASB,EPAR),'L EPAR,ASBPAGB'
         WITH  (ASBPCB,EPAR),LABEL=COMM
         LKOB  COMM.PCBLOCK
         SET   PCBFGBL                 Global lock held
         END   ,                       OF Need global lock
PUDACT   BEGIN ,                       Do appropriate undefine action
*-
*- For undefined pages, return address of undefined page
*-
         IF    ^PGTFDEF,BEGIN
         LR    RM,RA
         EXIT  PUDLOOP
         END   ,
*-
*-   If the page is a page table page, skip it.  It will have to
*- become undefined through a SEGUDEF call.
*-
         IF    PGTFPGT,EXIT,PUDACT
*-
*- If page is in main store, check for fixes, invalidate and free
*-
PUDAGAIN IF    (^PGTFINV),BEGIN        Page valid
         L     RB,PGAD                 Get frame addr
         SRL   RB,L'PAGPAGM            |
         SLL   RB,PFTLOG               |
         AL    RB,PAGPFTO              |
         WITH  (PFTE,RB),BEGIN         Frame table addr
*-
*- If page I/O is in progress, then mark the frame for release
*- when the I/O completes
*-
         IF    PGTFIO,BEGIN            Page I/O in progress
         SET   PFTFREL                 Release frame @ I/O complete
         SET   PCBFREL                 We're waiting for release
*-
*- Put ourselves on the list waiting for this I/O to complete
*-
         L     RB,PFTIOCB
         IF    (RB,ZERO),'ABORT PAGUDEFWAIT'
         WITH  (PGDPAGE,RB)
         L     RN,PGDPGWT              Get old head of chain
         PMOV  PGDPGWT,LA:ASBPCB        put ourselves there
         ST    RN,PCBWAIT                and point to old head
         PAGWT ,,LA:ASBPCB             -- Wait --
         B     PUDAGAIN
         END   ,                       OF Page I/O in progress
*-
*- Page I/O not in progress, release it if we can
*-
         IF    ('LTH RN,PFTFIX',NZ),BEGIN       Page is fixed
         LR    RM,RA                   Addr of bad page
         EXIT  PUDLOOP
         END   ,                       OF Page is fixed
*-
*- Invalidate page
*-
         LRA   RN,PGTE                 Invalidate page (PT real addr)
         N     RN,=A(PAGPAGM)          |
         IPTE  RN,RA                   |
*
         FRAMEREL LA:PFTE
*-
*- One less valid page is one less short term fix on the page table.
*-
         QUSFIX (RN)                   One unfix of page
         END   ,                       OF Frame table addr
         END   ,                       OF Page is valid
*-
*- Release external frame if it's still there
*-
         IF    PGTFXDEF,BEGIN
         XPREL SPXSLOT
         END   ,
*-
*- Reset page table entries
*-
         MVC   PGAD,=A(256*L'PGTFINV)  Clears flags too!
         CLEAR SPTE
         END   ,                       OF Do appropriate undefine act
*-
*- Get the addresses of the page table entries, using a short cut
*- if it's in the same segment.
*-
         IF    (RS,GT,1),BEGIN         More to come
         AL    RA,=A(PAGPAGEL)         Is next in another segment?
         LR    RB,RA                   |
         N     RB,=A(PAGPGNM)          | (0 page num = new segment)
         IF    NZ,BEGIN                Same segment
         LA    RJ,PGTNXT               |
         LA    RK,SPTNXT               |
         CLEAR RVR                     | (no addr error on PT)
         END   ,                       OF Same segment
         ELSE  BEGIN                   Different segment
         LRA   RB,PGTE                 Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
*
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PUDPSWM        |
         ACALL RESPT                   |
         LM    RJ,RK,@PTPGTE           | get page/shadow entry addrs
         END   ,                       OF Different segment
         END   ,                       OF More to come
         UNTIL (BCT,RS),END            OF Define pages
         LRA   RB,@RJ                  Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
         END   ,                       OF Current PT valid
         PAGXIT SYNC,#PUDPSWM,#PUDFLGS,WR=RS
         LR    RVR,RM                  RVR = completion code
         PEND  ,
         SPACE
PUDABORT ABORT PAGUDEF
*NEST,2
         TITLE 'Define a segment'
*box
*
*  Define a segment
*
*   Input - @PAGSEGD
*           For global definitions
*             The common ASB is obtained from the PAGCB
*           For local definitions
*             PZCURASB defines the AS which is in control and
*             which will have this page defined
*
*  Output - NONE
*
*
#PAGSEGD RECORD BEGIN
#SDFLGS  DS    X                       Flags for locks held on entry
#SDPSWM  DS    X                       PSW mask for disabling
#SDACFLG FLAG  ,
         FLAG  #SDFROOM                Call make-room routine
         END   ,
         SPACE
PAGSEGD  PROC  @PAGSEGD,#PAGSEGD,SCOPE=GLOBAL   Define a segment
         CLEAR #SDACFLG
         PAGAD RPAG
         USING PZERO,R0                Address of current PCB
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         LR    BRR,RPCB                PCB that owns the frames
         WITH  (ASBPCB,BRR),LABEL=OWN  |
         PAGNTRY SYNC,#SDPSWM,#SDFLGS  Synchronous entry
         IF    (@SDFGLOB,AND,^PCBFGBL),BEGIN    Get global lock
         L     RK,PAGCASB
         WITH  (ASB,RK),'L BRR,ASBPAGB'
         LKOB  OWN.PCBLOCK
         SET   PCBFGBL
         END   ,                       OF Get global lock
         L     RA,@SDADDR              Segment/number of segments
         L     RS,@SDLEN               |
         ALR   RS,RA                   |
         DECR  RS                      |
         N     RS,=A(PAGSGNM)          |
         N     RA,=A(PAGSGNM)          |
         L     RB,PAGMEG               |
         DECR  RB                      | 0..n
         SRL   RS,L'PAGSGNM            | last segment number
         CEIL  RS,RB                   | |
         SRL   RA,L'PAGSGNM            | 1st segment number
         CEIL  RA,RS                   | | no bigger than last
         SLR   RS,RA                   |
         INCR  RS                      | number of segments
         INCR  RB                      Shadow segment entry
         SLL   RB,SGTLOG               | shadow start
         LR    RJ,RA                   | offset in shadow
         SLL   RJ,SSTLOG               | |
         ALR   RB,RJ                   |
         L     RJ,PCBPSTO              |
         ALR   RB,RJ                   |
         SLL   RA,SGTLOG               Segment entry
         ALR   RA,RJ                   |
         LRA   RJ,@RJ                  Check for seg table in core
         IF    ^VAOK,SDABORT           | seg table not in
         LOOP  BEGIN                   Mark all segments as defined
         WITH  (SGTE,RA)
         WITH  (SSTE,RB)
         IF    (SSTFDEF,AND,((@SDFGLOB,AND,^SGTFCOMM),OR,              *
               (^@SDFGLOB,AND,SGTFCOMM))),SDABORT
*-
*- Define non-defined segments
*-
         IF    ^SSTFDEF,BEGIN
         PAGXIT SYNC,#SDPSWM,#SDFLGS,WR=RJ ,CPCB=BRR
         IF    ^@SDFGLOB,BEGIN
         VMGET LH:=Y(L'PAGTABLE),LOC=LOCSYS,PAGE=YES
         END   ,
         ELSE  BEGIN
         VMGET LH:=Y(L'PAGTABLE),LOC=GLOBHI,FIX=YES,PAGE=YES
         END   ,
         LR    RJ,RVR                  |
         N     RJ,=A(PAGPAGM)          |
         PAGNTRY SYNC,#SDPSWM,#SDFLGS  |
         IF    (@SDFGLOB,AND,^PCBFGBL),BEGIN    Get global lock
         LKOB  OWN.PCBLOCK
         SET   PCBFGBL
         END   ,                       OF Get global lock
         IF    ^@SDFGLOB,BEGIN         Local page table
*box
*
*    For local page table, we must allocate an external frame, a
*  real frame, and set the page table's virtual address as valid.
*
         XPGET LA:OWN.ASBPCB
         LR    RN,RVR                  External frame address
         FRAMEGET (RPCB),LA:OWN.ASBPCB,TYPE=PT
         IF    @FRAROOM,'SET #SDFROOM' Make note to call make-room
         LR       RK,RVR               Frame addr
         PSET  @RESPT                  Bring in PT for this VA
         PMOV  @PTVA,(RJ)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#SDPSWM         |
         ACALL RESPT
         IF    (RVR,NZ),SDABORT
         L     RM,@PTSPTE
         WITH  (SPTE,RM),BEGIN
         ST    RN,SPXSLOT              Save external address
         END   ,
         L     RM,@PTPGTE
         WITH  (PGTE,RM),BEGIN
         L     RVR,PGAD                Page no longer invalid
         N     RVR,=A(PGTAIMSK)        |
         OR    RVR,RK                  | this is RA + flags
         ST    RVR,PGAD                |
         SET   PGTFREF+PGTFXDEF        | now a referenced page
         END   ,                       OF Page table entry addr
*-
*- One more short term fix for page table that maps this VA
*-
         LRA   RK,@RM                  Real addr of PT
         QSFIX (RK)                    |
         LM    RM,RN,@PTPGTE
         END   ,                       OF Local page table
         ELSE  BEGIN                   Global page table
*-
*- Get page table entries for a global page table
*-
         VIRTABL (RJ),(RPCB)
         IF    ^@VPFOK,SDABORT
         LM    RM,RN,@VPPGTE
         END   ,                       OF Global page table
*box
*
*    For both global and local page tables the external pages
*  addresses must be set, and it must be indicated that
*  the virtual addresses of the page table is for a page table.
*    Then the page table is initialized to all undefined pages.
*
         WITH  (PGTE,RM)
         WITH  (SPTE,RN)
*-
*- Move in matching fields from shadow page to shadow segment tables
*-
         SET   PGTFPGT
         MVC   SSXSLOT,SPXSLOT
         MVC   SSKEY,SPKEY
*-
*- Init page table and put real address in segment table
*-
         PSET  @PAGPGIN                Do init
         PMOV  @PIVA,(RJ)              |
         ACALL PAGPGINI                |
         LRA   RK,@RJ                  Set seg table address
         O     RK,=A((256/16)-1)       | + full length
         ST    RK,SGTAD                |
         IF    @SDFGLOB,BEGIN          Global/common segment
         SET   SGTFCOMM
         SET   SSTFCOMM
         END   ,                       OF Global/common segment
         SET   SSTFDEF                 Defined segment
*-
*- Indicate that this is a page table in the frame table
*-
         SRL   RK,L'PAGPAGM            Compute page frame entry addr
         SLL   RK,PFTLOG               |
         AL    RK,PAGPFTO              |
         WITH  (PFTE,RK),BEGIN         |
         SET   PFTFPGT                 It's a page table
         ST    RJ,PFTVA                Set the virtual addr of frame
         LR    EPAR,RA                 Convert seg offset to seg #
         SL    EPAR,PCBPSTO            |
         SRL   EPAR,SGTLOG             |
         STH   EPAR,PFTSEG             |
*-
*- Unfix page table for local segment
*-
         IF    ^@SDFGLOB,BEGIN         Local segment
         LRA   RK,PGTE                 Unfix page table for this VA
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RK)             |
         ACALL QUFIX                   |
         END   ,                       OF Local segment
         END   ,                       OF PFTE addr
         END   ,                       OF Define undefined
         MVC   SSINIT,@SDHASH          Set hash byte for segment
         LA    RA,SGTNXT               Next segment table entry
         LA    RB,SSTNXT               | and shadow
         UNTIL (BCT,RS),END            OF Mark all segs as defined
         PAGXIT SYNC,#SDPSWM,#SDFLGS,WR=RS
*-
*- If we need to, call the make-room routine when all locks are freed
*-
         IF    #SDFROOM,BEGIN
         ACALL MAKEROOM
         END   ,
         PEND  ,
SDABORT  ABORT PAGSEGD                 Seg define error
         TITLE 'Un-Reference a page'
*NEST,1
*box
*
*  Un-Reference a page
*
*   Input - @PAGE
*
*  Output - RVR =  0  Range of pages is now un-referenced
*           RVR <> 0  At least one page was undefined, had a
*                     long-term fix on it, or did not match the
*                     Local/Global flag of the ASB.
*                       In this case RVR contains the address of
*                     the page which could not be unreferenced.
*                     The rest of the pages in the range are
*                     ignored.
*
*
         SPACE
#PAGUREF RECORD BEGIN
#PURFLGS DS    X                       Flags
#PURPSWM DS    X                       PSW mask for diabling
         END   ,
         SPACE
PAGUREF  PROC  @PAGE,#PAGUREF,SCOPE=GLOBAL
         PAGAD RPAG
         USING PZERO,R0                Address of current PCB
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         L     RA,@PAGLOC              Page/number of pages
         L     RS,@PAGLEN              |
         ALR   RS,RA                   |
         DECR  RS                      |
         SRL   RS,L'PAGPAGM            | last page number
         SRL   RA,L'PAGPAGM            | 1st page number
         L     RB,PAGMEG               | last page in AS
         SLL   RB,L'PAGSGNM-L'PAGPGNM  | |
         DECR  RB                      | |
         IF    ((RS,GT,RB),OR,(RA,GT,RB)),PURABORT
         SLR   RS,RA                   |
         INCR  RS                      | number of segments
         SLL   RA,L'PAGPAGM            | 1st page address
*-
*- Get locks
*-
         PAGNTRY SYNC,#PURPSWM,#PURFLGS
         L     RJ,PCBPSTO              Check for seg table in core
         LRA   RJ,@RJ                  |
         IF    ^VAOK,PURABORT          | seg table not in
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PURPSWM        |
         ACALL RESPT                   |
         LM    RJ,RK,@PTPGTE           |
*-
*- In this loop, RA is the page address to be undefined, and RS is
*- the number of consecutive pages to undefine. RJ and RK are
*- the addresses of the page/shadow page table entries.
*-
         CLEAR RM                      Preset return
PURPTVAL BEGIN ,                       Current PT valid
PURLOOP  LOOP  BEGIN                   Loop through virtual addrs
*-
*- If the page table is not defined, quit this loop, returning
*- the address of the first page represented by this page table
*-
         IF    (RVR,NZ),BEGIN          Addr exception for PT
         LR    RM,RA                   | address of undef page
         EXIT  PURPTVAL                |
         END   ,                       OF Addr exception for PT
         WITH  (PGTE,RJ)
         WITH  (SPTE,RK)
PURACT   BEGIN ,                       Do appropriate undefine action
*-
*- For undefined pages, return address of undefined page
*-
         IF    ^PGTFDEF,BEGIN
         LR    RM,RA
         EXIT  PURLOOP
         END   ,
*-
*-   If the page is a page table page, skip it.  It will have to
*- become undefined through a SEGUDEF call.
*-
         IF    PGTFPGT,EXIT,PURACT
*-
*- If page is in main store, check for fixes, invalidate and free
*-
PURAGAIN IF    (^PGTFINV),BEGIN        Page valid
         L     RB,PGAD                 Get frame addr
         SRL   RB,L'PAGPAGM            |
         SLL   RB,PFTLOG               |
         AL    RB,PAGPFTO              |
         WITH  (PFTE,RB),BEGIN         Frame table addr
*-
*- If page I/O is in progress, then mark the frame for release
*- when the I/O completes
*-
         IF    PGTFIO,BEGIN            Page I/O in progress
         SET   PFTFREL                 Release frame @ I/O complete
         SET   PCBFREL                 We're waiting for release
*-
*- Put ourselves on the list waiting for this I/O to complete
*-
         L     RB,PFTIOCB
         IF    (RB,ZERO),'ABORT PAGUREFWAIT'
         WITH  (PGDPAGE,RB)
         L     RN,PGDPGWT              Get old head of chain
         PMOV  PGDPGWT,LA:ASBPCB        put ourselves there
         ST    RN,PCBWAIT                and point to old head
         PAGWT ,,LA:ASBPCB             -- Wait --
         B     PURAGAIN
         END   ,                       OF Page I/O in progress
*-
*- Page I/O not in progress, release it if we can
*-
         IF    ('LTH RN,PFTFIX',NZ),BEGIN       Page is fixed
         LR    RM,RA                   Addr of bad page
         EXIT  PURLOOP
         END   ,                       OF Page is fixed
*-
*- Invalidate page
*-
         LRA   RN,PGTE                 Invalidate page (PT real addr)
         N     RN,=A(PAGPAGM)          |
         IPTE  RN,RA                   |
*
         FRAMEREL LA:PFTE
*-
*- One less valid page is one less short term fix on the page table.
*-
         QUSFIX (RN)                   One unfix of page
         END   ,                       OF Frame table addr
         END   ,                       OF Page is valid
*-
*- Set as not referenced
*-
         CLEAR PGTFREF
*-
*- If we are releasing external frames on "un-reference" operations,
*- do it here.  Clear flag and release external core
*-
         IF    (PAGXFUREL,AND,PGTFXDEF),BEGIN   Do free of ext frame
         CLEAR PGTFXDEF                External page not defined
         XPREL SPXSLOT                 Free external slot
         CLEAR SPXSLOT                 |
         END   ,                       OF Do free of ext frame
         END   ,                       OF Do appropriate undefine act
*-
*- Get the addresses of the page table entries, using a short cut
*- if it's in the same segment.
*-
         IF    (RS,GT,1),BEGIN         More to come
         AL    RA,=A(PAGPAGEL)         Is next in another segment?
         LR    RB,RA                   |
         N     RB,=A(PAGPGNM)          | (0 page num = new segment)
         IF    NZ,BEGIN                Same segment
         LA    RJ,PGTNXT               |
         LA    RK,SPTNXT               |
         CLEAR RVR                     | (no addr error on PT)
         END   ,                       OF Same segment
         ELSE  BEGIN                   Different segment
         LRA   RB,PGTE                 Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
*
         PSET  @RESPT                  Bring in PT
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PURPSWM        |
         ACALL RESPT                   |
         LM    RJ,RK,@PTPGTE           | get page/shadow entry addrs
         END   ,                       OF Different segment
         END   ,                       OF More to come
         UNTIL (BCT,RS),END            OF Define pages
         LRA   RB,@RJ                  Unfix last PT
         PSET  @QUFIX                  |
         PMOV  @QUFRA,(RB)             |
         ACALL QUFIX                   |
         END   ,                       OF Current PT valid
         PAGXIT SYNC,#PURPSWM,#PURFLGS,WR=RS
         LR    RVR,RM                  RVR = completion code
         PEND  ,
         SPACE
PURABORT ABORT PAGUREF
*NEST,2
         TITLE 'Set page hash value for a segment'
*box
*
*  Set page hash value for a segment
*
*   Input - @PAGE
*
*  Output - RVR =  0  Range of segments now have new hash value
*           RVR <> 0  At least one segment was undefined, or not
*                     local.
*                       In this case RVR contains the address of
*                     the segment in error, and the
*                     rest of the segments in the range are
*                     ignored.
*
*
         SPACE
#PAGHASH RECORD BEGIN
#PHFLGS  DS    X                       Flags
#PHPSWM  DS    X                       PSW mask for disabling
         END   ,
         SPACE
PAGHASH  PROC  @PAGE,#PAGHASH,SCOPE=GLOBAL      Set seg hash value
         PAGAD RPAG
         USING PZERO,R0                Address of current PCB
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         PAGNTRY SYNC,#PHPSWM,#PHFLGS  Synchronous entry
         L     RA,@PAGLOC              Segment/number of segments
         L     RS,@PAGLEN              |
         ALR   RS,RA                   |
         DECR  RS                      |
         N     RS,=A(PAGSGNM)          |
         N     RA,=A(PAGSGNM)          |
         L     RB,PAGMEG               |
         DECR  RB                      | 0..n
         SRL   RS,L'PAGSGNM            | last segment number
         CEIL  RS,RB                   | |
         SRL   RA,L'PAGSGNM            | 1st segment number
         CEIL  RA,RS                   | | no bigger than last
         SLR   RS,RA                   |
         INCR  RS                      | number of segments
         INCR  RB                      Shadow segment entry
         SLL   RB,SGTLOG               | shadow start
         LR    RJ,RA                   | offset in shadow
         SLL   RJ,SSTLOG               | |
         ALR   RB,RJ                   |
         L     RJ,PCBPSTO              |
         ALR   RB,RJ                   |
         LR    RK,RA                   Segment addr
         SLL   RK,L'PAGSGNM            |
         SLL   RA,SGTLOG               Segment entry
         ALR   RA,RJ                   |
         LRA   RJ,@RJ                  Check for seg table in core
         IF    ^VAOK,SHABORT           | seg table not in
         CLEAR RM                      Pre-set return
SHLOOP   LOOP  BEGIN                   Set hash for all segments
         WITH  (SGTE,RA)
         WITH  (SSTE,RB)
         IF    (^SSTFDEF,OR,SGTFCOMM),BEGIN
         LR    RM,RK                   Return segment addr
         EXIT  SHLOOP
         END   ,
         MVC   SSINIT,@PAGHASH         Set hash byte for segment
         AL    RK,=X'00100000'         Set next segment VA
         LA    RA,SGTNXT               Next segment table entry
         LA    RB,SSTNXT               | and shadow
         UNTIL (BCT,RS),END            OF Set hash for all segments
         PAGXIT SYNC,#PHPSWM,#PHFLGS,WR=RS
         LR    RVR,RM                  Set RC
         PEND  ,
SHABORT  ABORT PAGHASHAS               AS not in
         TITLE 'Accounting init function (@ logon)'
*box
*
*  Return the pointer for the page fault count for the currently
*  established address space
*
*   Input - None
*
*  Output - None
*
*
PAGPIOA  PROC  SCOPE=GLOBAL
         USING PZERO,R0
         L     RPCB,PZCURASB
         DROP  R0
         WITH  (ASB,RPCB)
         L     RPCB,ASBPAGB            Pointer to page fault count
         WITH  (ASBPCB,RPCB)
         LA    RVR,PCBMPFR
         PEND  ,
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Address space creation'
*box
*
*  Allocate initial paging control block, and chain it off of the
*  ASB
*
*   Input - @PAGASC1
*
*  Output - NONE
*
*
         SPACE ,
PAGASC1  PROC  @PAGASC1,SCOPE=GLOBAL
         PAGAD RPAG
*
         L     RA,@ASCASB
         WITH  (ASB,RA)
*-
*- Do allocate and init of new PCB
*-
         PSET  @PCBINIT                Init PCB for this AS
         PMOV  @PCIASB,(RA)            |
         ACALL PCBINIT                 |
*
         LR    RPCB,RVR
         WITH  (ASBPCB,RPCB)
         MVC   PCBFLIMIT,@ASCWSLM      limit frames
         ST    RPCB,ASBPAGB            |
         PEND  ,
         EJECT
*box
*
*  Address space creation - log on a user
*
*   Input - @PAGASC2
*             The ASB of the AS being created is in PZERO
*
*  Output - NONE
*
*
#PAGASC  RECORD BEGIN
#ASCSLOT DS    A                       External slot of 1st page tbl
#ASCFLGS DS    X                       Current flags held on entry
         END   ,
         SPACE
PAGASC2  PROC  @PAGASC2,#PAGASC,SCOPE=GLOBAL    Log on a user
         PAGAD RPAG
*-
*- One more user in memory
*-
         L     RA,PAGASIN
         LOOP  BEGIN
         LA    RB,@RA+1
         CS    RA,RB,PAGASIN
         UNTIL EQUAL,END
*-
*- Keep track of max ever logged on
*-
         AL    RB,PAGMSOVN
         SL    RB,PAGMSIVN
         STMAX RB,PAGMASMX
*
         USING PZERO,R0                New PCB address
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),BEGIN        |
         L     RPCB,ASBPAGB            |
         END   ,                       |
         WITH  (ASBPCB,RPCB)           |
         WITH  (ASBPCB,RPCB),LABEL=LOCAL,BEGIN
*-
*- Point at global segment table
*-
         L     RB,PAGCASB
         WITH  (ASB,RB),'L RB,ASBPAGB'
         WITH  (ASBPCB,RB),LABEL=GLOBAL
         MVC   LOCAL.PCBPSTO,GLOBAL.PCBPSTO
         END   ,
*
         SET   PCBFSYNC
*-
*- Get ASN and fill in ASTE
*- NB - The authority index and linkage table descriptors for now
*-      default to zero.
*-      Set PASN and SASN as the same now
*-
         L     RB,PAGMEG               Segment table length
         SRL   RB,4                    | now in multiples of 16
         DECR  RB                      |
         STC   RB,PCBPSTL              |
         PSET  @ASNGET                 Allocate and fill in ASN
         PMOV  @AGSTD,(RB)             | only len of seg table
         PMOV  @AGATO,PAGATO           | authority location & len
         PMOV  @AGATL,PAGATL           |
         SET   @AGFINV                 | invalid, although allocated
         PMOV  @AGPCB,LA:ASBPCB        | set PCB addr
         ACALL ASNGET                  |
         STH   RVR,PCBPASN             Save this ASN
*-
*- Get segment table
*-
         L     RB,PAGMEG               Get Segment table
         MH    RB,=Y(L'SGTE+L'SSTE)    |
         LA    RB,@RB+4095             | round up to page bndry
         N     RB,=A(PAGPAGM)          |
         VMGET (RB),LOC=GLOBHI,FIX=YES,PAGE=YES
         ST    RVR,PCBPSTO
*-
*- Init this seg table to be the same as the global seg table
*-
         LR    RA,RVR                  Copy from global seg table
         L     RM,PAGCASB              |
         WITH  (ASB,RM),'L RM,ASBPAGB'
         WITH  (ASBPCB,RM),LABEL=GBL,BEGIN      Gbl PCB addr
         L     RJ,GBL.PCBPSTO
         LR    RK,RB                   | equal length
         MVCL  RA,RJ                   |
*-
*- Put frames for seg table on local list
*-
         LH    RK,PAGSEGP
         L     RJ,PCBPSTO              PFTE addr
         LRA   RJ,@RJ
         SRL   RJ,L'PAGPAGM-PFTLOG       for seg
         AL    RJ,PAGPFTO                  frame
         WITH  (PFTE,RJ)
         SLKOB GBL.PCBLOCK,PCBPSWM
         LOOP  BEGIN                   Take Seg tbl frames
         LREM  GBL.PCBLFLH,LA:PFTE,WR=RS
         LADD  PCBSFLH,LA:PFTE,WR=RS
         MVC   PFTASB,PCBASB           Set ASB of owner
         MVI   PFTQ,PCBSFLH-ASBPCB       and queue id
         LA    RJ,PFTNXT
         UNTIL (BCT,RK),END            OF Take Seg tbl frames
         SLKRL GBL.PCBLOCK,PCBPSWM
         END   ,                       OF Gbl PCB addr
*-
*- Get frame for page table
*-
         PSET  @FRAMGET
         PMOV  @FRAPCBC,LA:ASBPCB      PCB in control
         PMOV  @FRAPCB,LA:ASBPCB       PCB to own frame
         PMOV  @FRANUM,LA:1            Number of frames
         SET   (@FRAFPT,EQ)            Get page table frame
         PMOV  @FRALIST,LA:PCBPFLH
         IF    PCBFGBLC,BEGIN          Global frame - put on fix Q
         SET   (@FRAFIX,EQ)
         PMOV  @FRALIST,LA:PCBLFLH
         END   ,                       OF Global frame - put on fix Q
         LCALL FRAMEGET
         LR    RJ,RVR                  | real addr (1 fix)
         L     RK,@FRA1ST              Put VA in frame
         IF    @FRAROOM,BEGIN          Make more room for paging
         ACALL MAKEROOM
         DROP  SPR
         END   ,                       OF Make more room for paging
*-
*- Initialize page frame table for this page table page.
*-   One short term fix, on page; no long term fixes; it's a page tbl
*-
         WITH  (PFTE,RK),BEGIN
         NC    @ASCVA,=A(PAGPAGM)      Align VA on page boundary
         L     RA,@ASCVA               Virtual addr of PT
         ST    RA,PFTVA                |
         SRL   RA,L'PAGSGNM            Segment number of PT
         STH   RA,PFTSEG               |
         SET   PFTFPGT                 Page table frame
         MVC   PFTSFIX,=Y(1)           One short term fix
         END   ,
*-
*- Initialize seg table entries for the first page table's VA
*-
         L     RS,PAGMEG               Get segment table offsets
         SLL   RS,SGTLOG               | shadow start
         L     RA,@ASCVA               |
         N     RA,=A(PAGSGNM)          |
         SRL   RA,L'PAGSGNM-SSTLOG     |
         LR    RB,RA                   | shadow seg offset
         ALR   RB,RS                   | |
         SRL   RA,SSTLOG-SGTLOG        | segment offset
         L     RS,PCBPSTO              |
         ALR   RA,RS                   | seg table entry
         ALR   RB,RS                   | shadow seg entry
         WITH  (SGTE,RA),BEGIN
         WITH  (SSTE,RB),BEGIN
         IF    SSTFDEF,ASCABORT        Shouldn't be defined yet
         LR    RS,RJ                   Set real address
         O     RS,=A((256/16)-1)       |
         ST    RS,SGTAD                |
         XPGET (RPCB)                  Get external frame for page
         ST    RVR,SSXSLOT             |
         ST    RVR,#ASCSLOT            | save for shadow page
         SET   SSTFDEF                 Defined
         IC    RS,@ASCKEY              Set key of frame
         SSKE  RS,RJ                   |
         STC   RS,SSKEY                |
         END   ,                       OF Shadow Seg addr
         END   ,                       OF Seg addr
*-
*- Init page table in DAT-OFF
*-
         L     RA,PCBRA                DAT-OFF
         DATOFF PCBPSWM                |
         LR    RVR,RJ                  Clear whole frame
         LH    RS,=Y(PAGPAGEL)         |
         CLEAR RB                      |
         REGCH (RVR,R0),(RS,R1)        |
         MVCL  RVR,RA                  |
         LR    RK,RJ
         LA    RS,256                  | number of pages/page table
         LOOP  BEGIN                   Init all entries
         WITH  (PGTE,RK)               |
         MVC   PGTE,=A(256*L'PGTFINV)  Invalid hardware page entry
         LA    RK,PGTNXT
         UNTIL (BCT,RS),END            OF Init all entries
         WITH  (ASBPCB,RA),BEGIN       DAT-ON
         DATON PCBPSWM                 |
         END   ,                       |
*-
*- Init this first page table entry
*-
         L     RB,@ASCVA
         N     RB,=A(PAGPGNM)
         LR    RA,RB
         SRL   RB,L'PAGPGNM-SSTLOG
         LA    RB,@RB+PGTL
         SRL   RA,L'PAGPGNM-SGTLOG
         LR    RS,RA                   PT entry - RA
         ALR   RS,RJ                   |
         L     RK,PCBRA                Set page table RA in DAT-OFF
         DATOFF PCBPSWM                |
         WITH  (PGTE,RS),BEGIN
         ST    RJ,PGAD
*  Page table page (defined,ref,defined externally)
         SET   PGTFDEF+PGTFREF+PGTFPGT+PGTFXDEF
         END   ,
         WITH  (ASBPCB,RK),BEGIN       |
         DATON PCBPSWM                 |
         END   ,                       |
*-
*- Establish this AS (disable while we do it)
*-
         STNSM PCBPSWM,DISABLE         Disable for a while
         VCALL CPLOCK                    and get the CPU lock
         L     RK,PCBASB               Set ASNs
         WITH  (ASB,RK),BEGIN          | Local ASB addr
         PSET  @VALDASN                Validate this ASN
         L     RJ,PCBASB               | set LASP parms
         WITH  (ASB,RJ),BEGIN          |
         MVC   @VALASP,ASBLASP         |
         LH    RN,PCBPASN              |
         STH   RN,@VAPASN              |
         STH   RN,@VASASN              |
         END   ,                       |
         L     RJ,PCBPSTO              |
         LRA   RJ,@RJ                  |
         PMOV  @VAPSTO,(RJ)            | set seg tbl origin
         PMOV  @VALPARM,=X'04'         | insist on translation
         ACALL VALIDASN                |
*-
*- Set ASB's ASNs (primary and secondary)
*-
         STH   RN,ASBPASN
         STH   RN,ASBSASN
         END   ,                       | OF Local ASB addr
*
         VCALL CPULOCK                 Free the CPU lock
         SSM   PCBPSWM                   and re-enable
*-
*- Set up page table entries
*-
         AL    RA,@ASCVA               PT entry - VA
         AL    RB,@ASCVA               SPT entry - VA
         WITH  (PGTE,RA),BEGIN
         WITH  (SPTE,RB),BEGIN
         MVC   SPXSLOT,#ASCSLOT        External slot
         MVC   SPKEY,@ASCKEY           Key
         SET   PGTFDEF+PGTFREF+PGTFPGT Defined, Referenced, Page tbl
         END   ,                       OF Shadow page table addr
         END   ,                       OF Page table addr
*-
*- Allocate swap cell
*-
         ACALL CELLALL
*
         CLEAR PCBFSYNC
*
         PEND  ,
         SPACE
ASCABORT ABORT ASCSEGD                 Segment defined
         TITLE 'Address space termination'
*box
*
*  Bring in all page tables for termination
*
*   Input - None
*             PZCURASB has the ASB of the address space being
*             terminated
*
*  Output - None
*
*
         SPACE
PAGAST1  PROC  ,#PAGE,SCOPE=GLOBAL
         PAGAD RPAG
         USING PZERO,R0
         L     RN,PZCURASB
         DROP  R0
         WITH  (ASB,RN)
         L     RPCB,ASBPAGB
         WITH  (ASBPCB,RPCB),BEGIN     ASBPCB address
*
         PAGNTRY SYNC,#PAGPSWM,#PAGFLGS
         L     RJ,PCBPSTO              Loop through seg table
         L     RK,PAGMEG               |
         LH    RM,PAGSEGL              | start of shadow seg
         ALR   RM,RJ                   |
         LOOP  BEGIN                   |
         WITH  (SGTE,RJ)
         WITH  (SSTE,RM)
         IF    (^SGTFCOMM,AND,SSTFDEF),BEGIN    Local defined segment
         LR    RA,RJ                   VA in segment
         SL    RA,PCBPSTO              |
         SLL   RA,L'PAGSGNM-SGTLOG     |
         PSET  @RESPT                  Make sure PT is in & stays in
         PMOV  @PTVA,(RA)              |
         PMOV  @PTPCB,LA:ASBPCB        |
         PMOV  @PTPSWM,#PAGPSWM        |
         ACALL RESPT                   |
         END   ,                       OF Local defined segment
         LA    RJ,SGTNXT
         LA    RM,SSTNXT
         UNTIL (BCT,RK),END            OF Loop through seg table
         PAGXIT SYNC,#PAGPSWM,#PAGFLGS,WR=RS
         END   ,                       OF PCB addr
         PEND  ,
         TITLE 'Address space termination - 2nd phase'
*box
*
*  Release the real memory resources associated with an ASB
*
*   Input - None
*
*  Output - None
*             The ASB has the LASP parameters set to the GLOBAL
*           ASN, and that ASN is established
*
*
         SPACE
PAGAST2  PROC  ,#PAGE,SCOPE=GLOBAL
         PAGAD RPAG
         USING PZERO,R0
         L     RN,PZCURASB
         DROP  R0
         WITH  (ASB,RN)
         L     RPCB,ASBPAGB
         WITH  (ASBPCB,RPCB),BEGIN     ASBPCB address
*
         PAGNTRY SYNC,#PAGPSWM,#PAGFLGS
         SET   PCBFTERM                No frame mgmt from here on
         L     RA,PCBWCNT              Page writes outstanding
         PAGXIT SYNC,#PAGPSWM,#PAGFLGS,WR=RS
*-
*- Wait for page writes to finish
*-
         IF    (RA,POS),BEGIN
         AWAIT PCBWECB,TYPE=AS
         END   ,
         L     RCPCB,PAGCASB
         WITH  (ASB,RCPCB),LABEL=GLOBAL
         L     RM,GLOBAL.ASBPAGB
         WITH  (ASBPCB,RM),LABEL=GBL,BEGIN      Gbl PCB addr
*-
*- Put frames for seg table on global list
*-
         LH    RB,PAGSEGP
         L     RA,PCBPSTO              PFTE addr
         LRA   RA,@RA
         SRL   RA,L'PAGPAGM-PFTLOG       for seg
         AL    RA,PAGPFTO                  frame
         WITH  (PFTE,RA)
         SLKOB GBL.PCBLOCK,PCBPSWM
         LOOP  BEGIN                   Take Seg tbl frames
         LREM  PCBSFLH,LA:PFTE,WR=RS
         LADD  GBL.PCBLFLH,LA:PFTE,WR=RS
         MVC   PFTASB,GBL.PCBASB       Set ASB of owner
         MVI   PFTQ,PCBLFLH-ASBPCB       and queue id
         LA    RA,PFTNXT
         UNTIL (BCT,RB),END            OF Take Seg tbl frames
         SLKRL GBL.PCBLOCK,PCBPSWM
         END   ,                       OF Gbl PCB addr
*-
*- Release real memory resources, and backing store
*-
         PSET  @FRAMTERM
         PMOV  @FTPCB,LA:ASBPCB
         LCALL FRAMTERM
*
         ACALL CELLDALL
*-
*- Set ASN to be same as global, and establish that ASN
*-
         MVC   ASBPAGB,GLOBAL.ASBPAGB  Set PCB to global
         LH    RB,ASBPASN              Save primary ASN
         MVC   ASBLASP,GLOBAL.ASBLASP  Copy global ASNs
         LA    RS,X'04'                Lasp parm - insist on xlate
         O     RS,=A(ASBLPARM)
         LASP  ASBLASP,0(RS)
*-
*- Free ASN
*-
         PSET  @ASNFREE
         PMOV  @ASNFASN,(RB)
         ACALL ASNFREE
*-
*- Free real memory lock for this ASB
*-
         PSET  @LOCKS
         PMOV  @LOCKID,PCBLOCK
         VCALL LKDEL
         CLEAR PCBLOCK
         L     RA,PCBPSTO              Save segment table origin
*-
*- Free PAGING control block
*-
         VMFREE L'ASBPCB,A=LA:ASBPCB,LOC=GLOBHI,FIX=YES
         END   ,                       OF PCB addr
*-
*- Free global memory for segment table
*-
         LH    RB,PAGSEGP              Number of pages for seg tbl
         SLL   RB,12                   |
         VMFREE (RB),A=(RA),LOC=GLOBHI,FIX=YES
*-
*- One less user in memory
*-
         L     RA,PAGASIN
         LOOP  BEGIN
         LR    RB,RA
         DECR  RB
         CS    RA,RB,PAGASIN
         UNTIL EQUAL,END
         PEND  ,
         TITLE 'Remove an address space''s memory'
*NEST,1
*box
*
*  Remove the vitrual memory backing and real memory for an ASB
*    Address space lock held on entry
*
*   Input - @FRAMTERM
*
*  Output - None
*
*
#FRAMTERM RECORD BEGIN
#FTSGTN  DS    D                       Segment entry, count left
#FTPSWM  DS    X                       PSW mask for disable
         END   ,
         SPACE ,
@FRAMTERM RECORD BEGIN
@FTPCB   DS    A
         END   ,
         SPACE ,
FRAMTERM PROC  @FRAMTERM,#FRAMTERM
         PAGAD RPAG
         STNSM #FTPSWM,DISABLE
         L     RPCB,@FTPCB
         WITH  (ASBPCB,RPCB)
         L     RJ,PCBPSTO              Start of seg tbl
         L     RK,PAGMEG               | number of entries
         STM   RJ,RK,#FTSGTN           |
         LH    BRR,PAGSEGL             | start of shadow seg
         ALR   BRR,RJ                  |
         LOOP  BEGIN
         WITH  (SGTE,RJ)
         WITH  (SSTE,BRR)
         IF    (^SGTFCOMM,AND,SSTFDEF),BEGIN    Local segment
         IF    SGTFINV,BEGIN           All page tables should be in
         ABORT PAGTERMPT
         END   ,                       OF All page tables should be in
*box
*
*  Undefine pages in PT
*
         L     RM,SGTAD                Get VA of page table
         N     RM,=A(SGTADMSK)         |
         RTOV  (RM)                    |
         LR    RM,RVR                  |
         WITH  (PGTE,RM),BEGIN         Addr to page table
         WITH  (PAGTABLE,RM),'LA RN,SPGT'
         WITH  (SPTE,RN)
         LA    RS,256                  Loop through all PT entries
         LOOP  BEGIN                   |
         IF    (PGTFDEF,AND,^PGTFPGT),BEGIN     Undefine normal def
*-
*- Free frame if it is a valid page table entry
*-
         IF    ^PGTFINV,BEGIN          Free frame if it is in
         L     RA,PGAD                 PFTE addr
         SRL   RA,L'PAGPAGM            |
         SLL   RA,PFTLOG               |
         AL    RA,PAGPFTO              |
         WITH  (PFTE,RA),BEGIN         |
         IF    ('LTH RB,PFTFIX',NZ),BEGIN
         ABORT PAGTERMFIX
         END   ,
*-
*- Invalidate virtual addr
*-
         LRA   RB,PGTE
         N     RB,=A(PAGPAGM)
         L     EPAR,PFTVA
         IPTE  RB,EPAR
*-
*- Release frame
*-
         FRAMEREL LA:PFTE              Release frame
*
*        QUSFIX (RN)
         END   ,                       OF PFTE addr
         END   ,                       OF Free frame if it is in
*-
*- Release external frame
*-
         IF    PGTFXDEF,BEGIN          Release if defined
         XPREL SPXSLOT
         END   ,                       OF Release if defined
*-
*- Reset page table entries
*-
         MVC   PGAD,=A(256*L'PGTFINV)
         CLEAR SPTE
         END   ,                       OF Undefine normal defined pg
         LA    RM,PGTNXT
         LA    RN,SPTNXT
         UNTIL (BCT,RS),END            OF Loop through all PT entries
         END   ,                       OF Addr to page table
         END   ,                       OF Local segment
         LA    RJ,SGTNXT
         LA    BRR,SSTNXT
         UNTIL (BCT,RK),END
         EJECT ,
*box
*
*  Invalidate page table virtual addresses
*
         LM    RJ,RK,#FTSGTN
         LH    BRR,PAGSEGL
         ALR   BRR,RJ
         LOOP  BEGIN                   Undefine page table VAs
         WITH  (SGTE,RJ)
         WITH  (SSTE,BRR)
         IF    (^SGTFCOMM,AND,SSTFDEF),BEGIN    Local defined seg
         IF    SGTFINV,BEGIN
         ABORT PAGTERMPT
         END   ,
*-
*- Invalidate PTs VA
*-
         L     RA,SGTAD                PFTE addr
         SRL   RA,L'PAGPAGM            |
         SLL   RA,PFTLOG               |
         AL    RA,PAGPFTO              |
         WITH  (PFTE,RA),BEGIN         |
         L     RB,PFTVA                VA of page table
         LR    EPAR,RB                 Get real addr of PT that maps
         SRL   EPAR,L'PAGSGNM          |
         SLL   EPAR,SGTLOG             |
         AL    EPAR,PCBPSTO            |
         WITH  (SGTE,EPAR),'L EPAR,SGTAD'
         N     EPAR,=A(PAGPAGM)        |
         IPTE  EPAR,RB                 |
         END   ,                       OF PFTE addr
*-
*- Release external frame for page table
*-
         XPREL SSXSLOT
         END   ,                       OF Local defined seg
         LA    RJ,SGTNXT
         LA    BRR,SSTNXT
         UNTIL (BCT,RK),END            OF Undefine page table VAs
         EJECT ,
*box
*
*  Release page table frames
*
         LM    RJ,RK,#FTSGTN
         LH    BRR,PAGSEGL
         ALR   BRR,RJ
         LOOP  BEGIN                   Undefine page table VAs
         WITH  (SGTE,RJ)
         WITH  (SSTE,BRR)
         IF    (^SGTFCOMM,AND,SSTFDEF),BEGIN    Local defined seg
         L     RA,SGTAD                PFTE addr
         SRL   RA,L'PAGPAGM            |
         SLL   RA,PFTLOG               |
         AL    RA,PAGPFTO              |
         WITH  (PFTE,RA),BEGIN         |
         FRAMEREL LA:PFTE
         END   ,                       OF PFTE addr
*
         MVC   SGTAD,=A(L'SGTFINV)     Set seg as invalid
         CLEAR SSTE                    Clear shadow entry
         END   ,                       OF Local defined seg
         LA    RJ,SGTNXT
         LA    BRR,SSTNXT
         UNTIL (BCT,RK),END            OF Release page table frames
*-
*- Check to make sure all frames released
*-
         IF    (('LT RS,PCBFCNT',NZ),OR,('LT RS,PCBPFCNT',NZ),OR,      *
               ('LT RS,PCBSFCNT',NZ),OR,('LT RS,PCBLFCNT',NZ)),BEGIN
         ABORT PAGTERMFRAME
         END   ,                       OF Missed a frame
         SSM   #FTPSWM
         PEND  ,
*NEST,2
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Allocate a page frame'
*box
*
*  Allocate one or more page frames
*
*   Input - @FRAMGET
*
*  Output - @FRAMGET and RVR
*             RVR contains the real address of the frame
*             For synchronous operations the procedure does not
*           return until the required number of frames are
*           allocated.
*             For asynchronous operations the procedure will return
*           with @FRAOK set if the allocation was successful.
*
*
#FRAMEGET RECORD BEGIN
#FGLIST  LHEAD PFX=#FG                 Temp frame list
#FGCBS   LHEAD PFX=#FGC                Temp swap CB list
#FGNEED  DS    A                       Needed frames count
#FGPSWM  DS    X                       PSW mask for disabling
#FGFLAG  FLAG  ,
         FLAG  #FGPTLB                 We need to do a PTLB
         END   ,
         SPACE
FRAMEGET PROC  @FRAMGET,#FRAMEGET      Allocate a page frame
*        CLEAR @FRAOK                  Not OK
         PAGAD RPAG
         SLKOB PAGFRAL,#FGPSWM         Get free frames lock
*-
*- Wait for enough free frames if not available (and wait mode)
*-
         L     RPCB,@FRAPCBC
FRAMWAIT LOOP  BEGIN
         WITH  (ASBPCB,RPCB)
         L     RJ,@FRANUM
         S     RJ,PAGFCNT
         S     RJ,PAGFRC
         IF    NPOS,EXIT               Enough free frames already
*-
*- Figure how many more frames we should try for
*-
         S     RJ,PAGFLS               Subtract logically swapped
         IF    POS,BEGIN               Try for more frames (# in RJ)
*-
*- See if we can get more frames for paging
*-
         L     RK,PAGMAXFR             More frames to fix ?
         S     RK,PAGFIXCNT            |
         IF    NPOS,EXIT               | no, exit
         CEIL  RK,PAGUFCNT             Number available to fix
         IF    (RK,GT,RJ),'LR RK,RJ'   |
         IF    (RK,NPOS),EXIT          | none, exit
*-
*- Take frames from unfixed list
*-
         LREM  PAGUFHD,,(RK),LAST=(RJ),WR=RS
         LR    RM,RVR                  Save first frame
         LKREL PAGFRAL
*box
*
*  If we must long term fix frames, we might have to wait.  First
*  free the lock so other frame management can go on.
*
         LR    RA,RM                   First frame
         LR    RS,RK                   Count of frames
         LOOP  BEGIN                   Fix frames
         WITH  (PFTE,RA)
        $LA    RB,PFTE                 Frame addr
         SL    RB,PAGPFTO              |
         SLL   RB,L'PAGPAGM-PFTLOG     |
         SYSCTL (RB),TYPE=PAGE         | and fix it
         SET   PFTPAGING               We can page on this one
         L     RA,PFTFP                next frame
         UNTIL (BCT,RS),END            OF Fix frames
*--------------                        UNLOCKED CODE 
         LKOB  PAGFRAL                 Re-obtain frame lock
*  Add frames to LT fixed free list
         LR    RA,RM                   First frame
         LADD  PAGFHEAD,(RA),(RJ),(RK),WR=RS
*-
*- Update counts of available frames
*-
         L     RJ,PAGFIXCNT            More fixed frames
         ALR   RJ,RK                   |
         ST    RJ,PAGFIXCNT            |
         L     EPAR,PAGFTCNT           More frames available
         LOOP  BEGIN                   |
         LR    RJ,EPAR                 |
         ALR   RJ,RK                   |
         CS    EPAR,RJ,PAGFTCNT        |
         UNTIL EQUAL,END               |
         L     EPAR,MATPTR             |
         WITH  (MAT,EPAR),BEGIN        Update paging function
         AL    RK,MATPAGFN             |
         ST    RK,MATPAGFN             |
         END   ,                       OF Update paging function
         IF    (RJ,GE,@FRANUM),EXIT,FRAMWAIT
         END   ,                       OF Try for more frames
*
         SLKRL PAGFRAL,#FGPSWM         Release frame lock
*-
*- Make note of possible need for more paging room
*-
         SET   @FRAROOM
*-
*- Wait for frames if need be (and we can)
*-
         IF    ^PCBFSYNC,EXIT,FRAMEGET Don't wait on asynchronous op
         PMOV  PCBAMT,@FRANUM          Number waiting for
         PAGWT PAGFWT,,LA:ASBPCB
         SLKOB PAGFRAL,#FGPSWM
         END   ,
*-
*- There are enough free frames now, but some may belong to
*- a swapped ASB.  If need be, take the frames from these swapped
*- ASBs.
*-
         CLEAR #FGPTLB
         WITH  (LHEAD,RS),BEGIN        LHEAD addr
         LA    RS,#FGLIST              Init temp frame list
         ST    RS,LHFP                 |
         ST    RS,LHBP                 |
         CLEAR LHCNT                   |
         LA    RS,#FGCBS               Init temp CB list
         ST    RS,LHFP                 |
         ST    RS,LHBP                 |
         CLEAR LHCNT                   |
         END   ,                       OF LHEAD addr
         L     RA,@FRANUM              Frames needed
         S     RA,PAGFCNT              |
         IF    POS,BEGIN               Need to reclaim frames
         ST    RA,#FGNEED              | amt needed
         LKREL PAGFRAL
         LKOB  PAGSWAPL
         LOOP  BEGIN                   Get needed frames
         LREM  PAGRSCB,WR=RS           Take frames from this ASB
         IF    ('LTR RK,RVR',ZERO),EXIT
         WITH  (PGDSWAP,RK),BEGIN      PGDSWAP addr
         WITH  (#SWPDO,PGDSWP)
         WITH  (PSCPFX,PGDSWPFX)
         IF    PGDSFSGT,BEGIN          This swap block has seg tbl
         SET   #FGPTLB                 Purge TLB (stealing seg tbl)
         LADD  #FGCBS,LA:PGDSWAP,WR=RS
         END   ,                       OF This swap block has seg tbl
         L     RPCB,PSCASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         CLEAR PGDSFFALLO              Frames not allocated
         SET   PGDSFDAT                DAT needs updating
         LREMALL PGDSWFRA,LAST=(RN),COUNT=(BRR),WR=RS
         IF    ('LTR RM,RVR',ZERO),'ABORT FRAMSTEAL'
         LADD  #FGLIST,(RM),(RN),(BRR),WR=RS    add to free frames
*-
*- We have taken the frames from this swap control block
*-
         L     RB,PAGFRC               Fewer unreclaimed frames
         SLR   RB,BRR                  |
         ST    RB,PAGFRC               |
         LH    RJ,PCBSWFS              More frames stolen
         ALR   RJ,BRR                  |
         STH   RJ,PCBSWFS              |
         L     RJ,#FGNEED              Update needed frames
         SLR   RJ,BRR                  |
         ST    RJ,#FGNEED              |
         IF    PCBFNOTE,BEGIN          This AS already notified
         AL    BRR,PAGFWSI
         ST    BRR,PAGFWSI
         END   ,                       OF This AS already notified
         END   ,                       OF PGDSWAP addr
         UNTIL (RJ,NPOS),END           OF Get needed frames
         LKREL PAGSWAPL
*-
*- If we stole segment frames, we must invalidate their global
*- virtual addresses
*-
         IF    ('LT RK,#FGCCNT',NZ),BEGIN       Invalidate seg tbls
         L     RM,PAGCASB
         WITH  (ASB,RM),'L RM,ASBPAGB'
         WITH  (ASBPCB,RM),LABEL=GBL
         LKOB  GBL.PCBLOCK
         LOOP  BEGIN                   Loop through CBs
         LREM  #FGCBS,,WR=RS
         LTR   RN,RVR
         IF    ZERO,EXIT               No more control blocksf
         WITH  (PGDSWAP,RN)
         WITH  (PSCPFX,PGDSWPFX)
         L     RPCB,PSCASB
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RA,PCBPSTO              Addr of local seg table
         LH    RS,PAGSEGP              | num of pages for seg table
         LOOP  BEGIN                   Do invalidations
         LR    RJ,RA                   Invalidate addr
         SRL   RJ,L'PAGSGNM            |
         SLL   RJ,SGTLOG               |
         AL    RJ,GBL.PCBPSTO          |
         WITH  (SGTE,RJ),BEGIN         |
         L     RJ,SGTAD                |
         END   ,                       | OF SGTE addr
         IPTE  RJ,RA                   |
*-
*- Set addresses of SEG/shadow SEG as undefined
*-
         SRL   RJ,L'SGTADMSK           Even PT align
         SLL   RJ,L'SGTADMSK           |
         LR    RVR,RA                  Get page table offset
         N     RVR,=A(PAGPGNM)         |
         SRL   RVR,L'PAGPGNM-PGTLOG    |
         ALR   RJ,RVR                  |
         RTOV  (RJ)                    | virtual address of PT entry
         LR    RJ,RVR                  | |
         WITH  (PGTE,RJ),BEGIN         PGTE addr
         CLEAR PGTFDEF                 UNDEFINED
         END   ,                       OF PGTE addr
*
         AH    RA,=Y(PAGPAGEL)         Next page VA of seg table
         UNTIL (BCT,RS),END            | do all seg table pages
         END   ,                       OF Loop through CBs
         LKREL GBL.PCBLOCK
         END   ,                       OF Invalidate seg tbls
         EJECT ,
         LKOB  PAGFRAL
         END   ,                       OF Need to reclaim frames
*-
*- We stole a segment table and page tables, so we need to purge
*- the TLB before we can safely use them
*-
         IF    #FGPTLB,BEGIN
         VCALL DISPPTLB
         END   ,
         EJECT
*-
*- Put stolen frames on available list
*-
         LREMALL #FGLIST,LAST=(RB),COUNT=(RJ),WR=RS
         IF    ('LTR RA,RVR',NZ),BEGIN
         LADD  PAGFHEAD,(RA),(RB),(RJ),WR=RS
         END   ,
*box
*
*  Allocate frames
*
         L     RJ,@FRANUM              Alloc frames
         LREM  PAGFHEAD,,LAST=(RB),(RJ),WR=RS
         IF    ('LTR RA,RVR',ZERO),FRAMWAIT
*-
*- Update frame counts
*-
         L     RS,PAGFTCNT             Update total count
         LOOP  BEGIN                   |
         LR    EPAR,RS                 |
         SLR   EPAR,RJ                 |
         CS    RS,EPAR,PAGFTCNT        |
         UNTIL EQUAL,END               |
         L     EPAR,MATPTR             Update paging function
         WITH  (MAT,EPAR),BEGIN        |
         L     RS,MATPAGFN             |
         SLR   RS,RJ                   |
         ST    RS,MATPAGFN             |
         END   ,                       OF Update paging function
*
         SLKRL PAGFRAL,#FGPSWM         Release frame lock
*-
*- Make note of possible need for more paging room
*-
         SET   @FRAROOM
*
         L     RPCB,@FRAPCB            PCB that owns frames
         WITH  (ASBPCB,RPCB),BEGIN     Add to this PCB
         L     RK,@FRALIST             Address of list to add to
         LADD  (RK),(RA),(RB),(RJ),WR=RS
         SR    RK,RPCB                 | offset of PCB lists
         ST    RA,@FRA1ST              |
         LR    RS,RA                   |
         LOOP  BEGIN                   Set fix counts to 1 on alloc
         WITH  (PFTE,RS),BEGIN         | PFTE addr
         IF    ^PFTPAGING,BEGIN        Should be LT fixed
         ABORT PAGNOTPAGING            |
         END   ,                       OF Should be LT fixed
         XC    PFTVA(PFTFLG2-PFTVA),PFTVA
         MVC   PFTASB,PCBASB           | owning PCB
         STC   RK,PFTQ                 | queue it's on
         MVC   PFTHIST,=AL2(PAGHINIT)  | set history
         IF    @FRAFIX,'MVC PFTFIX,=Y(1)'
         IF    @FRAFPT,'SET PFTFPGT'
         L     RS,PFTFP                | next frame
         END   ,                       | OF PFTE addr
         UNTIL (BCT,RJ),END            OF Set fix cnts to 1 on alloc
         END   ,                       OF Add to this PCB
         LR    RVR,RA                  Return real addr of frame
         SL    RVR,PAGPFTO             |
         SLL   RVR,L'PAGPAGM-PFTLOG    |
         SET   @FRAOK                  Allocation OK
         PEND  ,
         TITLE 'Release a page frame'
*box
*
*  Release a page frame
*
*   Input - @FRAMREL
*
*  Output - NONE
*             PCBs waiting for frames (if any) are awakened if this
*           release will satisfy their request.
*
*
FRAMEREL PROC  @FRAMREL                Release a page frame
         PAGAD RPAG
         L     RB,@FRARFRA             1st frame to be released
         WITH  (PFTE,RB)
         L     RPCB,PFTASB             Get PCB that owns frame(s)
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
*-
*- Take from the proper frame list.  A frame is either a normal
*- unfixed frame, or a page table frame, or a fixed frame.
*-
         LC    RA,PFTQ                 Which queue
         LA    RA,ASBPCB(RA)
         WITH  (LHEAD,RA),BEGIN        Remove frame from list
*
         LREM  LHEAD,LA:PFTE,WR=RS
         END   ,                       OF Remove frame from list
*-
*- Add to free frames
*-
         LKOB  PAGFRAL
         CLEAR PFTASB                  Clear ownership of frame
         IF    PFTPAGING,BEGIN         We can page on this one
         LADD  PAGFHEAD,LA:PFTE,WR=RS
         L     EPAR,PAGFTCNT           One more available
         LOOP  BEGIN                   |
         LA    RK,1                    |
         ALR   RK,EPAR                 |
         CS    EPAR,RK,PAGFTCNT        |
         UNTIL EQUAL,END               |
         L     EPAR,MATPTR
         WITH  (MAT,EPAR),BEGIN        Update paging function
         LA    RVR,1                   |
         AL    RVR,MATPAGFN            |
         ST    RVR,MATPAGFN            |
         END   ,                       OF Update paging function
*
         IF    ('LT RS,PAGFWCNT',NZ),BEGIN      Notify any waiting
         SET   PAGFWFRA,MODE=LOCKED,REF=PAGFWAIT
         END   ,                       OF Notify any waiting
         END   ,                       OF We can page on this one
         ELSE  BEGIN                   Put on non LT-fix list
         LADD  PAGUFHD,LA:PFTE,WR=RS
         END   ,                       OF Put on non LT-fix list
         LKREL PAGFRAL
         PEND  ,
FRABORT  ABORT PAGFRR                  Page frame release
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'External page allocation'
*box
*
*  Allocate an external page
*
*   Input - @XPGET
*             For asynchronous routines, @XPPCB doesn't need to be
*           filled in.
*
*  Output - IF @XPOK set
*             RVR contains the external page block number
*             @XPGET contains DSID and relative block number
*
*
         SPACE
XPGET    PROC  @XPGET,#LCLLOCK         Allocate external pages
         PAGAD RPAG
         SLKOB PAGXPL,#LCLPSWM         Lock on resource
XPGLOOP  LH    RS,PAGXPN               Number of data sets
         L     RB,PAGXPCUR             Data set descriptors
         LA    RA,1                    Number of frames requested
XPGSRCH  BEGIN ,                       Look for blocks
         LOOP  BEGIN                   Look through necessary DSs
         LR    RJ,RB
         WITH  (DSDES,RJ)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         PSET  @BMALLOC                Look for external frames
         PMOV  @BMACB,LA:DSDES         | control block
         PMOV  @BMANUM,(RA)            | number of frames desired
         LCALL BMALLOC                 |
         L     RB,DSCHAIN              Next data set...
         IF    @BMAOK,BEGIN            Allocation OK
         L     RK,PAGXPRCNT            Update total available
         SLR   RK,RA                   |
         ST    RK,PAGXPRCNT            |
         LR    RK,RVR                  Get block number
         ST    RK,@XPRBLK              | | relative
         PMOV  @XPDSDES,LA:DSDES       | Data set descriptor
         AL    RK,DSOFFSET             | absolute block number
         ST    RB,PAGXPCUR             Alloc from next DS next time
         SET   @XPOK
         SLKRL PAGXPL,#LCLPSWM         Release resource
         LR    RVR,RK                  Return block number
         EXIT  XPGSRCH
         END   ,                       OF Allocation OK
         UNTIL (BCT,RS),END            OF Look through ...
         L     RPCB,@XPPCB
         WITH  (ASBPCB,RPCB),BEGIN
         IF    ((RPCB,NZ),AND,PCBFSYNC),BEGIN   Synchronous request
         PMOV  PCBAMT,(RA)             Amount waiting for
         PAGWT PAGXPWT,PAGXPL,LA:ASBPCB
         B     XPGLOOP
         END   ,                       OF Synchronous request
         ELSE  BEGIN                   Async request
         SLKRL PAGXPL,#LCLPSWM
         END   ,                       OF Async request
         END   ,                       OF PCB addr
         END   ,                       OF Look for blocks
         PEND  ,
         TITLE 'External swap page allocation'
*box
*
*  Allocate an external swap set
*
*   Input - @XPGET
*
*  Output - If @XPOK
*             RVR contains the external page block number
*                relative to the start of the dataset
*             @XPGET contains DSID and relative block number
*           Else
*             Couldn't allocate the external pages
*
*
         SPACE
SWPGET   PROC  @XPGET,#LCLLOCK         Allocate external swap pages
         PAGAD RPAG
         SLKOB PAGXSL,#LCLPSWM         Lock on resource
XSWLOOP  LH    RS,PAGXSN               Number of data sets
         L     RB,PAGXSCUR             Data set descriptors
         L     RA,@XPCNT               Number of clusters requested
XSWSRCH  BEGIN ,                       Look for clusters
         LOOP  BEGIN                   Look through necessary DSs
         LR    RJ,RB
         WITH  (DSDES,RJ)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
*
         PSET  @BMALLOC                Look for external frames
         PMOV  @BMACB,LA:DSDES         | control block
         PMOV  @BMANUM,(RA)            | number of frames desired
         LCALL BMALLOC                 |
         L     RB,DSCHAIN              Next data set...
         IF    @BMAOK,BEGIN            Allocation OK
         L     RK,PAGXSRCNT            Update total clusters avail
         SLR   RK,RA                   |
         ST    RK,PAGXSRCNT            |
         LR    RK,RVR                  Get block number
         MH    RK,PAGSWXN
         ST    RK,@XPRBLK              | | relative
         PMOV  @XPDSDES,LA:DSDES       | Data set descriptor
         ST    RB,PAGXSCUR             Alloc from next DS next time
         SET   @XPOK
         SLKRL PAGXSL,#LCLPSWM         Release resource
         LR    RVR,RK                  Return relative block number
         EXIT  XSWSRCH
         END   ,                       OF Allocation OK
         UNTIL (BCT,RS),END            OF Look through ...
*        ABORT NOXSWAP
         SLKRL PAGXSL,#LCLPSWM
         END   ,                       OF Look for blocks
         PEND  ,
         TITLE 'Release block from external page device'
*box
*
*  Release block from external page device
*
*   Input - @XPREL
*             only uses block number
*
*  Output - none
*
*
@XPREL   RECORD BEGIN
@XPRLBLK DS    A                       Block address
@XPRNUM  DS    A                       | count of consecutive blocks
@XPRCB   DS    A                       Control block
         END   ,
         SPACE
XPREL    PROC  @XPREL                  Release external blocks
         PAGAD RPAG
         LKOB  PAGXPL                  Get resource lock
         BLKDSID @XPRLBLK              Compute DSID/rel block
         L     RA,@BLKRNUM             RA = DSID/rel blk num
         L     RB,@BLKBCB              | individual bit map CB
         PSET  @BMFREE                 Release blocks
         PMOV  @BMFADD,(RA)            | relative blk number
         PMOV  @BMFCB,(RB)             | individual bit map ctl block
         LA    RK,1
         PMOV  @BMFNUM,(RK)            |
         LCALL BMFREE                  |
         IF    ^@BMFOK,BEGIN
         ABORT PAGBMFREE
         END   ,
         AL    RK,PAGXPRCNT            Update available count
         ST    RK,PAGXPRCNT            |
         IF    ('LT RS,PAGXPCNT',NZ),BEGIN      Notify any waiting
         SET   PAGFWXP,MODE=LOCKED,REF=PAGFWAIT
         END   ,                       OF Notify any waiting
         LKREL PAGXPL
         PEND  ,
         TITLE 'Release block from external swap device'
*box
*
*  Release block from external swap device
*
*   Input - @XPREL
*
*  Output - none
*
*
         SPACE
SWPREL   PROC  @XPREL,#LCLLOCK         Release external blocks
         PAGAD RPAG
         SLKOB PAGXSL,#LCLPSWM         Get resource lock
         PSET  @BMFREE                 Release blocks
         LH    RA,PAGSWXN              |   cluster size
         L     RK,@XPRLBLK             Starting cluster
         CLEAR RJ                      | from starting block
         DR    RJ,RA                   |
         PMOV  @BMFADD,(RK)            |
         PMOV  @BMFNUM,@XPRNUM         | number of clusters
         PMOV  @BMFCB,@XPRCB           | individual bit map ctl block
         LCALL BMFREE                  |
         IF    ^@BMFOK,BEGIN
         ABORT PAGBMFREE
         END   ,
         L     RK,PAGXSRCNT            Update available count
         AL    RK,@XPRNUM              |
         ST    RK,PAGXSRCNT            |
         SLKRL PAGXSL,#LCLPSWM         Free resource
         PEND  ,
         TITLE 'Convert paging block number to DSID/block number'
*box
*
*  Convert paging block number to DSID/block number
*
*   Input - @BLKDSID
*
*  Output - RVR contains DSID
*           @BLKDSID also has relative block number
*
@BLKDSID RECORD BEGIN
@BLKNUM  DS    A                       Absolute block number
* -- Return info starts here --
@BLKID   DS    A                       Data set ID
@BLKRNUM DS    A                       Relative blk number for DSID
@BLKBCB  DS    A                       Individual bit map CB addr
         END   ,
         SPACE
BLKDSID  PROC  @BLKDSID                Block # to DSID/block
         PAGAD RPAG
         L     RA,@BLKNUM              Absolute block number
         L     RB,PAGXPDS              First DS in block
         LH    RS,PAGXPN               | number of DSs
BLKSRCH  BEGIN ,                       Look for right DS
         LOOP  BEGIN                   Loop through DSs
         WITH  (DSDES,RB)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         IF    (RA,LLT,DSCOUNT),EXIT,BLKSRCH
         SL    RA,DSCOUNT
         L     RB,DSCHAIN
         UNTIL (BCT,RS),END            OF Loop through DSs
         ABORT PAGXPNUM                Invalid block number
         END   ,                       OF Look for right DS
         WITH  (DSDES,RB),BEGIN        BM addressability
         ST    RB,@BLKBCB              This bit map CB
         ST    RA,@BLKRNUM             Relative block number
         L     RVR,DSCHID              Channel ID
         ST    RVR,@BLKID              |
         END   ,                       OF BM addressability
         PEND  ,
         TITLE 'Bitmap allocation'
*box
*
*  Allocate a unit of resource represented by a bitmap.
*
*  Input  - @BMALLOC
*
*  Output - @BMAOK, RVR
*    IF @BMAOK:
*      RVR contains the bit address of the resource quantity
*        allocated
*    IF ^@BMAOK
*      no pages available
*
*
         SPACE
         SPACE
BMALLOC  PROC  @BMALLOC                Bitmap allocation
         L     RM,@BMACB               Addr to control block
         WITH  (DSDES,RM)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
*
*        CLEAR @BMAOK                  Set alloc not OK
         IF    (@BMANUM,GT,DSAVAIL),EXIT,BMALLOC        Not enough
         L     RLOC,DSLOC              Compute first available byte
         L     RLEN,DSLEN              | and remaining length
         CLEAR (RY)                    |  search for not all 0s
         CLCL  RLOC,RX                 |
         IF    EQUAL,EXIT,BMALLOC      | no bytes available
BMALOOP  BEGIN ,                       Allocation loop - search & set
BMALOOK  BEGIN ,                       Allocation search
         LR    RADD,RLOC               Bit address of 1st avail byte
         SL    RADD,DSLOC              |
         SLL   RADD,3                  |
         LTR   RX,RLEN                 Fix mask and load BM section
         IF    ZERO,EXIT,BMALOOP       | failed allocation
         CEIL  RX,4                    |
         IC    RS,=X'080C0E0F'-1(RX)   | ICM mask
         EX    RS,'ICM RMAP,0,@RLOC'   |
         ALR   RLOC,RX                 Address of next byte in map
         SLR   RLEN,RX                 | and remaining length
         SLL   RX,3                    | number of bits inserted
         ALR   RADD,RX                 Bit Address of next segment
         CLEAR (RCNT)
         L     RWANT,@BMANUM
BMAINWRD BEGIN ,                       Allocate from within word
         IF    (RCNT,EQ,RWANT),EXIT,BMAINWRD
         LA    RCNT,@RCNT+1
         IF    (RMAP,NNEG),BEGIN       This bit allocated
         CLEAR (RCNT)                  | clear consecutive counts
         END   ,
         SLL   RMAP,1
         BCT   RX,BMAINWRD
         END   ,                       OF Allocate from within word
         LR    RS,RADD                 Compute start address
         SR    RS,RCNT                 |
         SR    RS,RX                   |
         ST    RS,@BMAADD              |
         AL    RS,@BMANUM
         IF    (RS,GT,DSCOUNT),EXIT,BMALLOC     Failed allocate
         IF    (RCNT,ZERO),BMALOOK     Try again
         IF    (RCNT,EQ,RWANT),EXIT,BMALOOK     Have all we want
         LOOP  BEGIN                   Consecutive bit search
         SLR   RWANT,RCNT              Remaining desired
         IF    (RWANT,NPOS),'ABORT PAGBITNEG'
         A     RCNT,@BMALEFT           Total so far
         ST    RCNT,@BMALEFT           |
         LR    RX,RLEN                 Fix mask and load BM section
         CEIL  RX,4                    |
         IC    RS,=X'080C0E0F'-1(RX)   | ICM mask
         EX    RS,'ICM RMAP,0,@RLOC'   Check for all 1s on right
         L     RMAPL,=A(X'FFFFFFFF')   |
         LR    RCNT,RX                 |
         SLL   RCNT,3                  |
         CEIL  RCNT,RWANT              |
         SLDL  RMAPL,@RCNT             | if avail will be all ones
         IF    (RMAPL,NE,=A(X'FFFFFFFF')),BEGIN
         CLEAR @BMALEFT
         B     BMALOOK                 Start again
         END   ,                       OF Check on right failed
         ALR   RLOC,RX                 Address of next byte in map
         SLR   RLEN,RX                 | and remaining length
         UNTIL (RWANT,EQ,RCNT),END     |
         END   ,                       OF Allocation search
         L     RLOC,@BMAADD            Bit start address => byte
         LR    RX,RLOC                 |
         SRL   RLOC,3                  |
         L     RLEN,DSLEN              | Remaining length
         SLR   RLEN,RLOC               | |
         AL    RLOC,DSLOC              | Byte address
         N     RX,=A(X'00000007')      |  bit w/in byte
         L     RWANT,@BMANUM           Desired number of units
         LOOP  BEGIN                   Allocate the bits from the map
         LR    RCNT,RWANT              | number for this pass
         ALR   RCNT,RX                 | | max this pass
         CEIL  RCNT,32                 | | including leading bits
         SLR   RCNT,RX                 | |
         L     RMAP,=A(X'FFFFFFFF')    | ... Life time supply of 1s
         SLDL  RMAPL,@RX               | Leading 1s
         SLL   RMAPL,@RCNT             | Mask 0s
         SLR   RWANT,RCNT              | Ending 1s (# left to alloc)
         ALR   RCNT,RX                 | |
         LCR   RCNT,RCNT               | |
         LA    RCNT,@RCNT+32           | |
         SLDL  RMAPL,@RCNT             | |
         LR    RX,RLEN                 Fix mask and load BM section
         CEIL  RX,4                    |
         IC    RS,=X'080C0E0F'-1(RX)   | ICM mask
         EX    RS,'ICM RMAP,0,@RLOC '  Get map
         LR    RY,RMAP
         NR    RMAP,RMAPL              ALLOCATE BITS
         OR    RMAPL,RY
         IF    (RMAPL,NE,=A(X'FFFFFFFF')),'ABORT BADBITALLOC'
         EX    RS,'STCM RMAP,0,@RLOC ' Put map back
         ALR   RLOC,RX                 Address of next byte in map
         SLR   RLEN,RX                 | and remaining length
         CLEAR (RX)                    | & no more leading pad bits
         UNTIL (RWANT,ZERO),END
         SET   @BMAOK                  Allocation successful
         L     RS,DSAVAIL              Decrement available number
         SL    RS,@BMANUM              |
         ST    RS,DSAVAIL              |
         END   ,                       OF Allocation loop
         L     RVR,@BMAADD             Allocation starts here
*
         PEND
         TITLE 'Bitmap deallocation'
*box
*
*  Free an external page/set of pages using an external page
*    bitmap
*  Input  - @BMFREE
*
*  Output - @XFROK, RVR
*    IF @XFROK:
*      page successfully deallocated
*    IF ^@XFROK
*      page was not previously allocated
*
*
         SPACE
BMFREE   PROC  @BMFREE                 Bitmap resource free
         L     RM,@BMFCB               Addr to control block
         WITH  (DSDES,RM)
         IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
         L     RLOC,@BMFADD            Bit start address => byte
         L     RS,@BMFNUM              | check boundarys
         AR    RS,RLOC                 | |
         IF    ((RLOC,NEG),OR,(RS,GT,DSCOUNT)),EXIT,BMFREE
         LR    RX,RLOC                 |
         SRL   RLOC,3                  |
         L     RLEN,DSLEN              | Remaining length
         SLR   RLEN,RLOC               | |
         AL    RLOC,DSLOC              | Byte address
         N     RX,=A(X'00000007')      |  bit w/in byte
         L     RWANT,@BMFNUM           Desired number of units
         LOOP  BEGIN                   Allocate the bits from the map
         LR    RCNT,RWANT              | number for this pass
         ALR   RCNT,RX                 | | including leading pad bits
         CEIL  RCNT,32                 | |
         SLR   RCNT,RX                 | |
         L     RMAP,=A(X'FFFFFFFF')    | ... Life time supply of 1s
         CLEAR RMAPL                   | Leading 0s
         SLDL  RMAPL,@RCNT             | Mask 1s
         SLR   RWANT,RCNT              | Ending 0s (# still to free)
         ALR   RCNT,RX                 | |
         LCR   RCNT,RCNT               | |
         LA    RCNT,@RCNT+32           | |
         SLL   RMAPL,@RCNT             | |
         LR    RX,RLEN                 Fix mask and load BM section
         CEIL  RX,4                    |
         IC    RS,=X'080C0E0F'-1(RX)   | ICM mask
         EX    RS,'ICM RMAP,0,@RLOC '  Get map
         LR    RY,RMAP                 | save for check
         OR    RMAP,RMAPL              DEALLOCATE BITS
         NR    RY,RMAPL                | check for already dealloc
         IF    NZ,BEGIN                ERROR! Bits previously free
         ABORT PAGBITFR                |
         END   ,                       OF ERROR! Bits previously free
         EX    RS,'STCM RMAP,0,@RLOC ' Put map back
         ALR   RLOC,RX                 Address of next byte in map
         SLR   RLEN,RX                 | and remaining length
         CLEAR (RX)                    | & no more leading pad bits
         UNTIL (RWANT,ZERO),END
         L     RS,DSAVAIL              Add free blocks to available
         AL    RS,@BMFNUM              |
         ST    RS,DSAVAIL              |
         SET   @BMFOK                  Free went ok
*
         PEND
         TITLE 'Allocate a new ASN'
*box
*
*  Allocate a new ASN
*
*   Input - @ASNGET
*
*  Output - RVR is the new ASN, and the ASN 2nd table entry is
*           filled in
*             For now, if there aren't enough ASNs, this routine
*           will ABORT.
*
*
ASNAFTN  EQU   1024                    Number of first table entries
ASNAFTLG EQU   10                      | Log of number of entries
ASNASTN  EQU   64                      Number of 2nd table entries
ASNASTLG EQU   6                       | Log of number of entries
ASNAFT   EQU   L'AFTE*ASNAFTN          Length of ASN first table
ASNAST   EQU   L'ASTE*ASNASTN          Length of ASN second table
         SPACE
#ASNGET  RECORD BEGIN
#AGPSWM  DS    X                       PSW mask for DAT
#AGLKPSWM DS   X                       PSW mask for Spin Lock
         END   ,
         SPACE
         REGCH (RPAG,RX)
         SPACE
ASNGET   PROC  @ASNGET,#ASNGET
         PAGAD RPAG
         SLKOB PAGASNL,#AGLKPSWM       Get lock and disable
         LH    RJ,PAG1ASN              Lowest possibly available ASN
NASLOOP  LOOP  BEGIN                   Allocation loop
         LR    RK,RJ                   |
         N     RK,=A(PAGAFXM)          ASN first table
         SRL   RK,L'PAGAFXM-AFTLOG     | index * 4
         AL    RK,PAGAFTO              |
         WITH  (AFTE,RK),BEGIN         |
NASCHK   IF    AFTFINV,BEGIN           Need new 2nd tables
         IF    PAGFASNL,BEGIN          ASN table being updated
*-
*- Do wait if someone else is allocating a new 2nd table
*-
         L     RN,@AGPCB
         WITH  (ASBPCB,RN)
         PMOV  PCBAMT,LA:1
         PAGWT PAGASNW,PAGASNL,LA:ASBPCB
*-
*- Reset the pointers/counters after we have waited
*-
         LH    RJ,PAG1ASN
         LR    RK,RJ                   |
         N     RK,=A(PAGAFXM)          ASN first table
         SRL   RK,L'PAGAFXM-AFTLOG     | index * 4
         AL    RK,PAGAFTO              |
         B     NASCHK                  and try again
         END   ,                       OF ASN table being updated
*-
*- We need to do the allocation of an ASN 2nd table
*-
         SET   PAGFASNL                We're allocating another table
         SLKRL PAGASNL,#AGLKPSWM
         PSET  @PAGASTI                Allocate and init ASN 2nd tbl
         PMOV  @ASI1ST,(RK)            |
         ACALL PAGASTI                 |
         SLKOB PAGASNL,#AGLKPSWM
         CLEAR PAGFASNL
*
         L     RS,=A(PAGPAGEL/L'ASTE)  Add to total count
         LR    RB,RS                   | total number
         AH    RB,PAGTASN              |
         STH   RB,PAGTASN              |
         A     RS,PAGAVASN             | avail number
         ST    RS,PAGAVASN             |
         LR    RB,RVR                  | real addr
         END   ELSE,BEGIN              Table exists
         L     RB,AFTASTO              Get real addr
         END   ,                       |
         END   ,                       OF ASN first table
*-
*- RS is the virtual address of the local work area during the
*- DATOFF/DATON switching of this loop.
*-
         LR    RS,WAR                  Go into DATOFF
         DATOFF #AGPSWM                |
         LRA   WAR,0(,WAR)             |
*
         LR    RK,RJ                   ASN second table
         N     RK,=A(PAGASXM)          |
         SLL   RK,ASTLOG               | entry length of 16
         ALR   RK,RB                   |
         LA    RB,@RB+ASNAST-L'ASTE    Limit reg
         LA    RA,L'ASTE               | increment
NAS2LOOP LABEL ,                       Look through ASN 2nd table
         WITH  (ASTE,RK),BEGIN         |
         IF    (ASTATO,EQ,X'80000000'),EXIT,NASLOOP
         INCR  RJ                      | next ASN
         END   ,                       OF WITH ASTE
         BXLE  RK,RA,NAS2LOOP          END OF Look through ASN 2nd
         IF    (RJ,GE,=A(ASNAFTN*ASNASTN)),BEGIN
         ABORT PAGASN                  Not enough ASNs
         END   ,
         DATON #AGPSWM                 Back to DATON
         LR    WAR,RS                  | local work area scratch
         END   ,                       OF Alloc loop - start again
*-
*- Come here if we found a free ASN
*-
         DATON #AGPSWM                 Back to DAT-On
         LR    WAR,RS                  |
         RTOV  (RK)                    Get VA of second table entry
         LR    RK,RVR                  |
         WITH  (ASTE,RK),BEGIN         Put in new entry
         MVC   ASTE,@AGSASTE
         END   ,                       OF Put in new entry
         STH   RJ,PAG1ASN              This is the new ASN
*-
*- Wake up those waiting (for when we allocate new tables)
*-
         DECR  RA,PAGAVASN             One less entry available
         IF    ('LT RS,PAGASNCNT',NZ),BEGIN     Notify any waiting
         SET   PAGFWASN,MODE=LOCKED,REF=PAGFWAIT
         END   ,                       OF Notify any waiting
         LKREL PAGASNL                 Lock resource
         SSM   #AGLKPSWM               Enable
         LR    RVR,RJ                  Return ASN
         PEND  ,
         TITLE 'Release an ASN'
*box
*
*  Release an ASN
*
*   Input - @ASNFREE
*
*  Output - None
*
*
@ASNFREE RECORD BEGIN
@ASNFASN DS    H                       ASN number to free
         END   ,
         SPACE
ASNFREE  PROC  @ASNFREE,#LCLLOCK
         PAGAD RPAG
         SLKOB PAGASNL,#LCLPSWM
         LH    RB,@ASNFASN             Index to ASN 1st table
         N     RB,=A(PAGAFXM)          |
         SRL   RB,L'PAGAFXM-AFTLOG     |
         AL    RB,PAGAFTO              |
         WITH  (AFTE,RB),BEGIN         |
         IF    AFTFINV,'ABORT ASNFRE1ST'
         L     RA,AFTASTO
         N     RA,=A(AFTASTM)
         END   ,                       OF Index to ASN 1st table
         RTOV  (RA)                    Index to ASN 2nd table
         LR    RA,RVR                  |
         LH    RB,@ASNFASN
         N     RB,=A(PAGASXM)          |
         SLL   RB,ASTLOG               |
         ALR   RA,RB                   |
         WITH  (ASTE,RA),BEGIN         |
         IF    (ASTATO,EQ,X'80000000'),'ABORT ASNFRE2ND'
         MVC   ASTATO,=X'80000000'
         END   ,                       OF Index to ASN 2nd table
*-
*- Set 1st ASN
*-
         LH    RA,@ASNFASN             Set first possible avail ASN
         LH    RB,PAG1ASN
         STMIN RA,RB
         STH   RB,PAG1ASN
*-
*- Wake up those waiting
*-
         INCR  RA,PAGAVASN             One less entry available
         IF    ('LT RS,PAGASNCNT',NZ),BEGIN     Notify any waiting
         SET   PAGFWASN,MODE=LOCKED,REF=PAGFWAIT
         END   ,                       OF Notify any waiting
         LKREL PAGASNL                 Lock resource
         SSM   #LCLPSWM                Enable
*
         PEND  ,
         TITLE 'Cell Allocation'
*box
*
*
*  Cell allocation
*
*   Input - @CELLGET
*
*  Output - RVR contains the address of the cell
*             For immediate return calls, if RVR = 0, the request
*           could not be satisfied
*
*
CELLGET  PROC  @CELLGET,#LCLLOCK
         PAGAD RPAG
*
         USING PZERO,R0                Get AS control block addr
         L     RPCB,PZCURASB           |
         DROP  R0                      |
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)           |
         L     RM,@CGTYP               | Specific cell w/ in cb
         WITH  (PAGCEL,RM)             |
         L     RK,@CGAMT               Number of cells wanted
         SLKOB PAGCELLK,#LCLPSWM       Get lock
         IF    (PAGCELAMT,LT,RK),BEGIN None available
         SLKRL PAGCELLK,#LCLPSWM
         CLEAR RVR                     | none available
         EXIT  CELLGET                 |
         END   ,                       OF None available
         LCR   RA,RK                   Subtract used cells
         AL    RA,PAGCELAMT            |
         ST    RA,PAGCELAMT            |
*
         L     RA,PAGCELHD             Get cells
         LR    RB,RA                   | first cell
         LOOP  BEGIN                   |
         WITH  (PSCPFX,RB)             |
         LR    RJ,RB                   | last
         L     RB,PSCFP                | next
         UNTIL (BCT,RK),END            OF Get cells
         ST    RB,PAGCELHD             | point to next cell
         SLKRL PAGCELLK,#LCLPSWM
         ST    RJ,@CGLAST              Last cell allocated
         LR    RVR,RA                  Return addr of cell
         PEND  ,
         TITLE 'Cell Release'
*box
*
*
*  Cell release
*
*   Input - @CELLFREE
*
*  Output - NONE
*
*
         SPACE
CELLFREE PROC  @CELLFREE,#LCLLOCK
         PAGAD RPAG
*
         L     RY,@CFTYP               |
         WITH  (PAGCEL,RY)
         SLKOB PAGCELLK,#LCLPSWM       Get lock
         L     RA,PAGCELAMT            Increment counts
         AL    RA,@CFAMT               |
         ST    RA,PAGCELAMT            |
         L     RB,@CFLAST              Last being added
         WITH  (PSCPFX,RB),BEGIN       | point to old first
         MVC   PSCFP,PAGCELHD          |
         END   ,
         MVC   PAGCELHD,@CFLOC         First being added
         IF    ('LT RS,PAGCELCNT',NZ),BEGIN    Notify any waiting
         CLEAR RM
         ICM   RM,X'08',PAGCELBIT      Mask for wait flags
         L     RJ,PAGFWAIT
         LOOP  BEGIN
         LR    RK,RJ
         OR    RK,RM
         CS    RJ,RK,PAGFWAIT
         UNTIL EQUAL,END
*        SET   PAGFWIOP,MODE=LOCKED,REF=PAGFWAIT
         END   ,                       OF Notify any waiting
         LKREL PAGCELLK
         SSM   #LCLPSWM
         PEND  ,
         TITLE 'Swap cell allocation'
*box
*
*  Allocate and add new swap cells to pool of I/O cells
*
*   Input - None
*
*  Output - None
*
*
#CELLALL RECORD BEGIN
#CAFIRST DS    A                       First allocated cell
#CALAST  DS    A                       Last allocated cell
#CAPSWM  DS    X                       PSW mask for disabled code
         END   ,
         SPACE ,
CELLALL  PROC  ,#CELLALL
         PAGAD RPAG
         WITH  (PAGCEL,PAGSWCEL)       Swap cell
*-
*- Allocate extra cells for this AS, using extra ones if there
*-
*- Number of cells needed
*-
         LH    RA,PAGSWXN              Average size/number per cell
         LH    RK,PAGSWAVG             |
         ALR   RK,RA                   |
         DECR  RK                      |
         CLEAR RJ                      |
         DR    RJ,RA                   |
*
         L     RS,PAGCELXTR
         LOOP  BEGIN                   One less cell
         LR    RA,RS
         SLR   RA,RK
         CS    RS,RA,PAGCELXTR
         UNTIL EQUAL,END               OF One less cell
*   Need to allocate more cells
         WHILE (RA,NPOS),BEGIN         Need more cells
         L     RK,=A(4096)             Get another page
         VMGET (RK),LOC=GLOBHI,FIX=YES,PAGE=YES
         LR    RA,RVR                  Starting address
         LR    RB,RK                   Clear memory
         REGCH (RS,R1),(RVR,R0)        |
         CLEAR RS                      |
         MVCL  RA,RVR                  |
         LR    RA,RVR                  Start add - not changed in RVR
         LH    RS,PAGCELLEN            Length of control block
         CLEAR (RJ)                    | Number of cells/page
         DR    RJ,RS                   |
*-
*- Link all I/O cells for this device type
*-  RVR,RA = addr of first cell on page, RK = number of cells on page
*-
         ST    RA,#CALAST
         LR    RB,RK                   Number of cells in page
         LOOP  BEGIN                   Link together cells on a page
         WITH  (PSCPFX,RA)
         PMOV  PSCFP,#CAFIRST          Point to old head
         PMOV  #CAFIRST,LA:PSCPFX      |
         PMOV  PSCID,PAGCELID          | set ID
         PSET  @IOSIDGET               Save I/O id in this cell
         SET   @IOSFWAIT               |
         VCALL IOSIDGET                |
         ST    RVR,PSCIO               |
         AH    RA,PAGCELLEN            Next cell in page
         UNTIL (BCT,RB),END            OF Link together cells on page
         SLKOB PAGCELLK,#CAPSWM
         LR    EPAR,RK                 Add cells (RK = num)
         AL    EPAR,PAGCELAMT          |
         ST    EPAR,PAGCELAMT          |
         L     RA,#CALAST
         WITH  (PSCPFX,RA),BEGIN       Link in new cells
         MVC   PSCFP,PAGCELHD          Last points to old head
         END   ,
         MVC   PAGCELHD,#CAFIRST       Head points to new first
         SLKRL PAGCELLK,#CAPSWM
         L     RS,PAGCELXTR
         LOOP  BEGIN                   Update number of cells
         LR    RA,RS
         ALR   RA,RK                   Number of extra cells now
         CS    RS,RA,PAGCELXTR
         UNTIL EQUAL,END               OF Update number of cells
         END   ,                       OF Need more cells
         PEND  ,
         TITLE 'Swap cell deallocation'
*box
*
*  Deallocate a swap cell - make it available
*
*   Input - None
*
*  Output - None
*
*
CELLDALL PROC  ,
         PAGAD RPAG
         WITH  (PAGCEL,PAGSWCEL)
*-
*- Mark cells as available to a class of I/O cells
*-
         L     RS,PAGCELXTR
*-
*- Number of cells to free
*-
         LH    RA,PAGSWXN              Average size/number per cell
         LH    RK,PAGSWAVG             |
         ALR   RK,RA                   |
         DECR  RK                      |
         CLEAR RJ                      |
         DR    RJ,RA                   |
         LOOP  BEGIN                   Increment free cell count
         LR    RA,RS
         ALR   RA,RK
         CS    RS,RA,PAGCELXTR
         UNTIL EQUAL,END               OF Increment free cell count
         PEND  ,
         AGO   .NOASSTD
         TITLE 'ASN to STD conversion'
*box
*
*  Returns the Segment Table Origin/Length (STD) for a given
*    ASN
*  Input - @PAGASSTD
*
*  Output - @ASNOK, RVR
*    IF @ASNOK:
*      RVR contains the STD for this ASN
*    IF ^@ASNOK
*      address space number invalid
*
*
@PAGASSTD RECORD BEGIN                 ASN to STD conversion
@ASASN   DS    H                       Address Space Number for trans
@ASSF1   FLAG  @ASNOK                  Address space is valid
         END   ,
         SPACE
PAGASSTD PROC  @PAGASSTD               ASN to STD conversion
         PAGAD RM
         LH    RA,@ASASN               ASN to work from (AFX)
         LR    RB,RA                   | used for ASX
         N     RA,=A(PAGAFXM)          First table entry calc
         SRL   RA,L'PAGAFXM-AFTLOG     | index*4 is offset from AFTO
         AL    RA,PAGAFTO              |
         WITH  (AFTE,RA),BEGIN         |
         L     RA,AFTASTO              Second table origin
         END   ,                       OF First table entry calc
         IF    (RA,NEG),EXIT,PAGASSTD  EXIT - 2nd table unavailable
         N     RA,=A(AFTASTM)          | mask em out
         RTOV  (RA)                    | to virtual (ret in RVR)
         N     RB,=A(PAGASXM)          Second table entry calc
         SLL   RB,4                    | index*16 is offset from ASTO
         ALR   RB,RVR                  |
         WITH  (ASTE,RB),BEGIN         |
         IF    ASTFINV,EXIT,PAGASSTD   EXIT - this AS unavailable
         L     RVR,ASTSTD              Return the STD
         END   ,
         SET   @ASNOK                  Available AS
         PEND  ,
.NOASSTD ANOP  ,
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Wait on an event'
*box
*
*  Wait on an event
*
*   Input - @PAGWAIT
*
*  Output - NONE
*
*
         SPACE
@PAGWAIT RECORD BEGIN
@WTHEAD  DS    A                       Head of waiting PCBs
@WTLOCK  DS    A                       Specific lock word
@WTPCB   DS    A                       PCB in control
         END   ,
#PAGWAIT RECORD BEGIN                  Flags for locks
#WTLOCKF FLAG  (#WTFGBL,PCBFGBL)       Global lock
         FLAG  (#WTFLCL,PCBFLCL)       Local lock
         END   ,
         SPACE
PAGWAIT  PROC  @PAGWAIT,#PAGWAIT
         PAGAD RPAG
         L     RPCB,@WTPCB             PCB addr
         WITH  (ASBPCB,RPCB)           |
*-
*- Add to wait list if there is one
*-
         L     RA,@WTHEAD              Add to list if required
         IF    (RA,^ZERO),BEGIN        |
         LADD  (RA),LA:ASBPCB,WR=RS    |
         END   ,                       |
*-
*-   Free locks before we wait
*- Spin locks can be obtained more than once by a task.  Before
*- a task can wait, it must be free of all spin locks.  Therefore
*- this routine calls the lock release routine until the return
*- indicates that the lock is completely free (RVR=0).  When this
*- task is resumed, this routine will obtain the locks such that
*- the lock is in the same condition as on entry to this routine.
*-
         L     RB,@WTLOCK
         IF    (RB,^ZERO),BEGIN        Free specific lock
         LKREL (RB)                    |
         END   ,                       OF Free specific lock
         MVC   #WTLOCKF,PCBLOCKF       Save locks held
         IF    PCBFGBL,BEGIN           Free global lock
         CLEAR PCBFGBL                 |
         L     RM,PAGCASB              |
         WITH  (ASB,RM),'L RM,ASBPAGB'
         WITH  (ASBPCB,RM),LABEL=GBL
         L     RS,GBL.PCBLOCK
         LKREL (RS)
         LR    RJ,RVR                  Remaining lock obtain count
         WHILE (RVR,NZ),BEGIN
         LKREL (RS)
         END   ,
         END   ,                       OF Free global lock
         IF    PCBFLCL,BEGIN           Free local lock
         CLEAR PCBFLCL                 |
         L     RS,PCBLOCK
         LKREL (RS)
         LR    RK,RVR                  Remaining lock obtain count
         WHILE (RVR,NZ),BEGIN          Free lock completely
         LKREL (RS)
         END   ,
         END   ,                       OF Free local lock
*-
*- Wait whole address space
*-
         AWAIT PCBECB,TYPE=AS          Put AS in wait
*-
*- Get locks that we had before waiting
*-
         IF    #WTFLCL,BEGIN           Get local lock
         L     RS,PCBLOCK
         INCR  RK
         LOOP  BEGIN
         LKOB  (RS)
         UNTIL (BCT,RK),END
         SET   PCBFLCL
         END   ,                       OF Get local lock
         IF    #WTFGBL,BEGIN           Get global lock
         WITH  (ASBPCB,RM),LABEL=GBL
         L     RS,GBL.PCBLOCK
         INCR  RJ
         LOOP  BEGIN
         LKOB  (RS)
         UNTIL (BCT,RJ),END
         SET   PCBFGBL
         END   ,                       OF Get global lock
         IF    (RB,NZ),BEGIN           Get specific lock again
         LKOB  (RB)                    |
         END   ,                       OF Get specific lock again
         SET   PCBFSYNC                Set flags - we have locks
         PEND  ,
         TITLE 'Check for tasks needing wake up calls'
*box
*
*  Check for tasks needing wake up calls
*
*   Input - NONE
*
*  Output - NONE
*             RESWAKE called for resources that require it
*
*
         SPACE
WAKELOOK PROC  ,#LCLLOCK
         PAGAD RPAG
         IF    (PAGFWAIT,ZERO),EXIT
         L     RA,=X'80000000'         Initialize flag mask
         CLEAR RS                        and count
*-
*- Check all resource flags
*-
         LOOP  BEGIN                   Check all flags
         LR    RB,RA
         N     RB,PAGFWAIT
         IF    NZ,BEGIN                Flag is set
*-
*- Turn off bit in flag
*-
         X     RB,=X'FFFFFFFF'         One's compliment
         L     RJ,PAGFWAIT
         LOOP  BEGIN                   Turn off this flag
         LR    RK,RJ
         NR    RK,RB
         CS    RJ,RK,PAGFWAIT
         UNTIL EQUAL,END               OF Turn off this flag
*-
*- Form index (RN), and load parameters for this resource
*-
         LR    RN,RS                   Form table pointer
         MH    RN,=Y(WKLLEN)
         LA    RN,RFRAME(RN)
*
         LR    RM,RPAG                 Lock location
         AH    RM,@RN
         LR    RK,RPAG                 Queue location
         AH    RK,@RN+2
         LR    RJ,RPAG                 Resource count
         AH    RJ,@RN+4
*-
*- Get lock and call wake up routine
*-
         STNSM #LCLPSWM,DISABLE        Disable for spin lock
         L     RM,@RM
         LKOB  (RM)                    Get lock
         PSET  @RESWAKE                Do wake up call
         IF    ('LT RJ,@RJ',NZ),BEGIN  Some resource available
         PMOV  @RESFREE,(RJ)
         PMOV  @RESWAIT,(RK)
         PMOV  @RESLOCK,(RM)
         LCALL RESWAKE
         END   ,                       OF Some resource available
         IF    ^@RESFLKRL,BEGIN        Free lock
         LKREL (RM)
         END   ,                       OF Free lock
         SSM   #LCLPSWM                Set PSW mask back
         END   ,                       OF Flag is set
*-
*- Set up for next pass of loop
*-
         INCR  RS                      Increment count
         SRL   RA,1                    Shift flag mask
         UNTIL (RS,GE,WKLCOUNT),END    OF Check all flags
         PEND  ,
         SPACE ,
         ASSERT (L'PAGFWFRA,2*L'PAGFWXP)        Verify flag order
         ASSERT (L'PAGFWXP,2*L'PAGFWIOP)        Verify flag order
         ASSERT (L'PAGFWIOP,2*L'PAGFWIOS)       Verify flag order
         ASSERT (L'PAGFWIOS,2*L'PAGFWASN)       Verify flag order
RFRAME   DC    Y(PAGFRAL-PAGCB)        Lock location
         DC    Y(PAGFWT-PAGCB)         Queue location
         DC    Y(PAGFTCNT-PAGCB)       Availability location
WKLLEN   EQU   *-RFRAME
RXPAGE   DC    Y(PAGXPL-PAGCB)         Lock location
         DC    Y(PAGXPWT-PAGCB)        Queue location
         DC    Y(PAGXPRCNT-PAGCB)      Availability location
RIOP     DC    Y(PAGCELLK-PAGCB)       Lock location
         DC    Y((PAGCELAS-PAGCEL)+(PAGPGCEL-PAGCB))    Queue loc
         DC    Y((PAGCELAMT-PAGCEL)+(PAGPGCEL-PAGCB))   Avail loc
RIOS     DC    Y(PAGCELLK-PAGCB)       Lock location
         DC    Y((PAGCELAS-PAGCEL)+(PAGSWCEL-PAGCB))    Queue loc
         DC    Y((PAGCELAMT-PAGCEL)+(PAGSWCEL-PAGCB))   Avail loc
RASN     DC    Y(PAGASNL-PAGCB)        Lock location
         DC    Y(PAGASNW-PAGCB)        Queue location
         DC    Y(PAGAVASN-PAGCB)       Availability location
WKLCOUNT EQU   (*-RFRAME)/WKLLEN
         TITLE 'Wake up tasks waiting on a resource'
*box
*
*  Wake up tasks waiting on a resource
*
*   Input - @RESWAKE
*
*  Output - NONE
*           PCBs that can be satisfied by the amount of resource
*           available are awakened.
*
*
         SPACE
RESWAKE  PROC  @RESWAKE
         L     RB,@RESFREE
         L     RA,@RESWAIT
         WITH  (LHEAD,RA)
         L     RJ,LHFP                 First PCB on list
         CLEAR RK                      | number of PCBs to wake up
         WHILE ((RB,POS),AND,(RK,LT,LHCNT)),BEGIN       Count wake up
         WITH  (ASBPCB,RJ)
         S     RB,PCBAMT               Can this PCB be satisfied?
         IF    POS,BEGIN               |
         INCR  RK
         END   ,                       OF Can this PCB be satisfied?
         L     RJ,PCBPCFP              Next in line
         END   ,                       OF Count wake up
         IF    (RK,POS),BEGIN          Wake these PCBs up
         PAGAD RPAG
         LREM  LHEAD,,(RK),LAST=(RB),WR=RS
         LR    RA,RVR                  |
         LKREL @RESLOCK                Release lock
         SET   @RESFLKRL               | set as released
         LOOP  BEGIN                   Loop through PCBs
         WITH  (LELEM,RA)
         LR    RPCB,RA                 Current PCB
         L     RA,LFP                  Next PCB
         WITH  (ASBPCB,RPCB)
         SIGNL PCBECB,TYPE=AS          Address space resume
         UNTIL (BCT,RK),END            OF Loop through PCBs
         END   ,                       OF Wake these PCBs up
         PEND  ,
         TITLE 'Initialize an ASB PCB'
*box
*
*  Initialize an ASB sub-control block, the PCB
*
*   Input - @PCBINIT
*
*  Output - RVR contains the PCB address, and the ASB also has a
*           pointer to this PCB filled in
*
*
@PCBINIT RECORD BEGIN
@PCIASB  DS    A                       ASB of this PCB
         END   ,
         SPACE
PCBINIT  PROC  @PCBINIT
         PAGAD RPAG
*-
*- Get a PCB and point to this ASB, but don't have ASB point to
*- this PCB just yet.
*-
         VMGET L'ASBPCB,LOC=GLOBHI,FIX=YES,ONEPAGE=YES
         LR    RPCB,RVR                PCB addr
         WITH  (ASBPCB,RPCB),BEGIN     |
         L     RJ,@PCIASB              ASB addr
         WITH  (ASB,RJ)
         CLEAR ASBPCB                  Clear control block
         MVC   ASBPCBID,=CL4'PCB'      | and set ID
         ST    RJ,PCBASB               ASB addr
         ST    RPCB,PCBVA              This PCB's VA
         LRA   RS,ASBPCB               This PCB's RA
         ST    RS,PCBRA                |
         LKCRE PCBLOCK,TYPE=SPIN       Get PCB lock
         ST    RVR,PCBLOCK             |
*-
*- Set up the working set history value
*-
         MVC   PCBWSHIST,PAGMNHST
*-
*- Init the PCB frame lists
*-
         WITH  (LHEAD,RA),BEGIN
         LA    RA,PCBUFLH              Normal user frames
         ST    RA,LHFP
         ST    RA,LHBP
         LA    RA,PCBPFLH              Page table frames
         ST    RA,LHFP
         ST    RA,LHBP
         LA    RA,PCBSFLH              Segment table frames
         ST    RA,LHFP
         ST    RA,LHBP
         LA    RA,PCBLFLH              Locked frames
         ST    RA,LHFP
         ST    RA,LHBP
*-
*- Init swap control block lists
*-
         LA    RA,PCBSWIN              CBs w/ frames in core
         ST    RA,LHFP
         ST    RA,LHBP
         END   ,
         END   ,                       OF PCB addr
         LR    RVR,RPCB                Return PCB addr
         PEND  ,
         TITLE 'Initialize segment table'
*box
*
*  Initialize segment table
*
*   Input - @PAGSGIN
*
*  Output - none
*
*
@PAGSGIN RECORD BEGIN
@SIVA    DS    A                       Virtual addr of segment table
         END   ,
         SPACE
         REGCH (RPAG,RX)
PAGSGINI PROC  @PAGSGIN                Init segment table
         PAGAD RPAG
         L     RY,@SIVA                Virtual addr of seg table
         WITH  (SGTE,RY)               |
         L     RK,PAGMEG               Shadow seg table addr
         LR    RJ,RK                   | number of segments
         SLL   RK,SGTLOG               | offset from start of seg tbl
         ALR   RK,RY                   |
         WITH  (SSTE,RK)               |
         L     RA,=A(L'SGTFINV)        Invalid hardware seg entry
         REGCH (RVR,R0),(RS,R1)
         CLEAR (RVR),(RS)              Clear shadow entries
         LOOP  BEGIN                   Init all entries
         ST    RA,SGTE                 Hardware
         STM   RVR,RS,SSTE             Shadow segment table
         LA    RY,SGTNXT
         LA    RK,SSTNXT
         UNTIL (BCT,RJ),END            OF Init all entries
         PEND  ,
         TITLE 'Initialize page table'
*box
*
*  Initialize page table
*
*   Input - @PAGPGIN
*
*  Output - none
*
*
@PAGPGIN RECORD BEGIN
@PIVA    DS    A                       Virtual addr of page table
         END   ,
         SPACE
PAGPGINI PROC  @PAGPGIN                Init page table
         L     RY,@PIVA                Virtual addr of page table
         WITH  (PAGTABLE,RY),'LA RX,SPGT'
         WITH  (PGTE,RY)               |
         WITH  (SPTE,RX)               |
         LA    RJ,256                  | number of pages/page table
         L     RA,=A(256*L'PGTFINV)    Invalid hardware page entry
         REGCH (RVR,R0),(RS,R1)
         CLEAR (RVR),(RS)              Clear shadow entries
         LOOP  BEGIN                   Init all entries
         ST    RA,PGTE                 Hardware
         STM   RVR,RS,SPTE             Shadow segment table
         LA    RY,PGTNXT
         LA    RX,SPTNXT
         UNTIL (BCT,RJ),END            OF Init all entries
         PEND  ,
         TITLE 'Initialize ASN allocation mechanism'
*box
*
*  Initialize ASN allocation mechanism
*
*   Input - NONE
*
*  Output - PAGCB points to ASN first table origin (VA), and the
*           first available ASN is set
*
*
         SPACE
#ASNINIT RECORD BEGIN
#ASIAFTO DS    A                       AFTO from CR14
#ASIAFTM EQU   X'FFF00000'             AFTO mask for CR14
#ASIAUTH EQU   X'00080000'             ASN authority bit
         END   ,
         SPACE
ASNINIT  PROC  ,#ASNINIT
         PAGAD RPAG
         LKCRE PAGASN,TYPE=SPIN        Init this lock
         ST    RVR,PAGASNL             |
         CLEAR PAG1ASN                 1st available ASN is zero
* Get space for ASN first table
         VMGET L:=A(ASNAFT),LOC=GLOBHI,FIX=YES,PAGE=YES
         ST    RVR,PAGAFTO             AFT address
         LR    RY,RVR                  |
         WITH  (AFTE,RY),BEGIN         |
         LR    RK,RVR                  | save it
         LA    RS,ASNAFTN              Init AFT entries
         L     RA,=X'80000000'         | invalid entries
         LOOP  BEGIN                   |
         ST    RA,AFTASTO              | Invalidate this one
         LA    RY,AFTNXT               | on to next
         UNTIL (BCT,RS),END            OF Init AFT addresses
         END   ,                       OF AFT address
         PSET  @PAGASTI                Allocate and init ASN 2nd tbls
         PMOV  @ASI1ST,(RK)            |
         LCALL PAGASTI                 |
         L     RS,=A(PAGPAGEL/L'ASTE)  Add to total count
         LR    RA,RS                   | total
         AH    RA,PAGTASN              |
         STH   RA,PAGTASN              |
         A     RS,PAGAVASN             | avail
         ST    RS,PAGAVASN             |
         LRA   RS,@RK                  Real addr of AFTO
         SRL   RS,L'PAGPAGM            | just page number
         O     RS,=A(#ASIAUTH)         | allow authority for ASN tran
         STCTL R14,R14,#ASIAFTO        | current CR14
         NC    #ASIAFTO,=A(#ASIAFTM)   |
         O     RS,#ASIAFTO             |
         ST    RS,#ASIAFTO             |
         LCTL  R14,R14,#ASIAFTO        | set AFTO in hardware
*-
*- Get Authorization table
*-
         VMGET LA:4,LOC=GLOBHI,FIX=YES
         LR    RA,RVR                  Init Authorization table
         MVC   @RA(4),=X'AAAAAAAA'     | no secondary spaces
         LRA   RS,@RA                  |
         ST    RS,PAGATO               Save for ASN allocation
         CLEAR PAGATL                  | minimum length
         PEND  ,
         TITLE 'Initialize an ASN second table'
*box
*
*  Initialize an ASN second table
*
*   Input - NONE
*
*  Output - RVR contains the RA of the new ASN second table
*
*
@PAGASTI RECORD BEGIN
@ASI1ST  DS    A                       Address of first table entry
         END   ,
         SPACE
PAGASTI  PROC  @PAGASTI                Init ASN second table
         L     RK,@ASI1ST              First table entry
         VMGET L:=A(4096),LOC=GLOBHI,FIX=YES,PAGE=YES
         LR    RB,RVR                  1st AST address
         LRA   RVR,@RB                 | save for return
         L     RA,=X'80000000'         Value for invalidating
         LA    RJ,4096/ASNAST          Init all ASTs, number of them
         LOOP  BEGIN                   |
         WITH  (AFTE,RK),BEGIN         Save pointer to this 2nd table
         LRA   RAR,@RB                 |
         ST    RAR,AFTASTO             |
         LA    RK,AFTNXT               |
         END   ,                       OF Save pointer to 2nd table
         WITH  (ASTE,RB),BEGIN         |
         LA    RS,ASNASTN              Init AST entries
         LOOP  BEGIN                   |
         CLEAR ASTE
         ST    RA,ASTATO               Invalidate this one
         LA    RB,ASTNXT               on to next
         UNTIL (BCT,RS),END            OF Init AST entries
         END   ,                       OF AST address
         UNTIL (BCT,RJ),END            OF Init all ASTs
*                                      RVR = Real addr of 1st AST
         PEND  ,
         TITLE 'Paging interval management'
*box
*
*  The following functions need to be monitored on a real time
*  interval.  This routine is entered on that regular interval
*
*    Number of long term fixed frames
*
*   Input - @PAGINTV
*             If the parameter is zero, then longer term parameters
*           will be adjusted.
*
*  Output - none
*
*
#PAGINTV RECORD BEGIN
#INTFLT0 DS    D                       Save for float reg 0
#INTFLT2 DS    D                       Save for float reg 2
#INTTIM  DS    D                       Real time elapse
#INTFLTW DS    D                       Floating point work area
#INTFRAM DS    E                       Frames swapped in interval
#INTPSWM DS    X                       PSW mask for disabling
         END   ,
*
PAGINTV  PROC  @PAGINTV,#PAGINTV,SCOPE=GLOBAL
         STD   R0,#INTFLT0             Save FPR0
         STD   R2,#INTFLT2             Save FPR2
         PAGAD RPAG
*-
*- Reset the upper limit on the number of frames we should have
*-
         L     RA,@PAGINT
         IF    (RA,NPOS),BEGIN
         SYSCTL RA,TYPE=MAXREAL
         CEIL  RA,PAGFRAN
         ST    RA,PAGMAXFR         Save maximum number of frames
         CEIL  RB,RA               Min can't be greater than max
         ST    RB,PAGMINFR         Save minimum number of frames
         END
*-
*- Compute the elapsed seconds
*-
         LM    RJ,RK,PAGLTRT           TOD at last cycle
         STCK  PAGLTRT
         LM    RA,RB,PAGLTRT
         SDLR  RA,RJ
         SRDL  RA,8                    Convert TOD to float
         STM   RA,RB,#INTTIM           |
         MVI   #INTTIM,X'50'           |
         LD    R0,#INTTIM              |
         DD    R0,=D'4096E6'           | seconds
*-
*- Compute frames/second over the last interval
*-
         L     RA,PAGLTCNT             Frame count over interval
         L     RB,PAGMSIF              |
         ST    RB,PAGLTCNT             |
         SLR   RB,RA                   |
         ST    RB,#INTFRAM             Convert frames to float
         MVI   #INTFRAM,X'46'          |
         LE    R2,#INTFRAM             |
         ME    R2,=E'1'                | extend to double
         DDR   R2,R0                   Frames/second
*-
*- Compute exponential average of frames/second
*-
         IF    ('CE R2,PAGSRAVG',LT),BEGIN      Take highest of rates
         LE    R0,=E'1'                Mul current rate by (1-factor)
         SE    R0,PAGSRATE             |
         ME    R0,=E'1'                | extend to double
         MDR   R2,R0                   |
         LE    R0,PAGSRAVG             Mul past rate by factor
         ME    R0,PAGSRATE             |
         ADR   R2,R0                   Add two together for exp avg
         END   ,                       OF Take highest of rates
         LRER  R2,R2                    get short form
         STE   R2,PAGSRAVG               and save it
*-
*- Compute the number of frames we need to have in reserve due to
*-    the current swap-in rate.
*-
         LER   R0,R2                   Current swap frames/sec
         SE    R0,PAGRESX0              - offset
         ME    R0,PAGRESM                * slope
         SDR   R2,R2
         LE    R2,PAGRESB
         ADR   R0,R2                      + intercept
         AW    R0,FLTZERO
         STD   R0,#INTFLTW
         L     RK,#INTFLTW+4
         CEIL  RK,PAGRESMX
         FLOOR RK,PAGRESMN
         ST    RK,PAGRESAMT            Save the reserve count
*
         LE    R2,PAGSRAVG
         LER   R0,R2                   copy frame/s avg
FRAMEADJ BEGIN ,                       Adjust real frame usage
*box
*
*  See if we need to allocate any long term fixed frames
*
         SPACE ,
*-
*- Compute the number of additional frames we should have
*-
         CLEAR RK                      Preset to zero
         SE    R2,PAGSRHI              Compare with high rate
         IF    POS,BEGIN               Compute frames to get
         ME    R2,PAGSRMHI
         AU    R2,FLTSZERO
         STE   R2,#INTFRAM
         MVI   #INTFRAM,0
         L     RK,#INTFRAM
         END   ,                       OF Compute frames to get
*-
*- Now compute the minimum number of frames we need to breathe.
*-
         L     RJ,PAGRESAMT            Reserve due to swap-in rate
         AL    RJ,PAGFRES                and other reserves
         AL    RJ,PAGMSMAX                 plus max swap size
*-
*- Figure how many more we need
*-
         SL    RJ,PAGFTCNT             Number needed - what we have
         SL    RJ,PAGFLS
*
         STMAX RJ,RK                   Max of two methods
         L     RJ,PAGMAXFR             Number avail for fixing
         SL    RJ,PAGFIXCNT            |
         STMIN RJ,RK                   Limit the most we can get
         IF    (RK,POS),BEGIN          Do long term fixes
         SLKOB PAGFRAL,#INTPSWM
         CEIL  RK,PAGUFCNT             Limit to total number of avail
         IF    (RK,POS),BEGIN          There are frames to fix
*-
*- Take frames from unfixed list
*-
         LREM  PAGUFHD,,(RK),LAST=(RJ),WR=RS
         LR    RM,RVR                  Save first frame
         SLKRL PAGFRAL,#INTPSWM
*box
*
*  If we must long term fix frames, we might have to wait.  First
*  free the lock so other frame management can go on.
*
         LR    RA,RM                   First frame
         LR    RS,RK                   Count of frames
         LOOP  BEGIN                   Fix frames
         WITH  (PFTE,RA)
        $LA    RB,PFTE                 Frame addr
         SL    RB,PAGPFTO              |
         SLL   RB,L'PAGPAGM-PFTLOG     |
         SYSCTL (RB),TYPE=PAGE         | and fix it
         SET   PFTPAGING               We can page on this one
         L     RA,PFTFP                next frame
         UNTIL (BCT,RS),END            OF Fix frames
*--------------                        UNLOCKED CODE 
         SLKOB PAGFRAL,#INTPSWM        Re-obtain frame lock
*  Add frames to LT fixed free list
         LR    RA,RM                   First frame
         LADD  PAGFHEAD,(RA),(RJ),(RK),WR=RS
*-
*- Update counts of available frames
*-
         L     RJ,PAGFIXCNT            More fixed frames
         ALR   RJ,RK                   |
         ST    RJ,PAGFIXCNT            |
         L     RJ,PAGFTCNT             More frames available
         LOOP  BEGIN                   |
         LR    EPAR,RJ                 |
         ALR   EPAR,RK                 |
         CS    RJ,EPAR,PAGFTCNT        |
         UNTIL EQUAL,END               |
         L     EPAR,MATPTR             |
         WITH  (MAT,EPAR),BEGIN        Update paging function
         L     RJ,MATPAGFN             |
         ALR   RJ,RK                   |
         ST    RJ,MATPAGFN             |
         END   ,                       OF Update paging function
         END   ,                       OF There are frames to fix
         SLKRL PAGFRAL,#INTPSWM
         EXIT  FRAMEADJ                Just got frames, don't release
         END   ,                       OF Do long term fixes
         EJECT ,
*box
*
*  See if we should release any long term fixed frames
*
         L     RB,@PAGINT              Number of intervals left
         IF    (RB,NPOS),BEGIN         Need to reset the page max
*-
*- See if we can release any long term fixed frames
*-   We will try to free frames if 1) we are over the limit of
*- maximum suggested use, or 2) our swap rate is too low
*-
*- Compute the number of frames we should release
*-
         CLEAR RK                      Preset to zero
         LE    R2,PAGSRLO
         SER   R2,R0                   Compare with low rate
         IF    POS,BEGIN               Compute frames to free
         ME    R2,PAGSRMLO
         AU    R2,FLTSZERO
         STE   R2,#INTFRAM
         MVI   #INTFRAM,0
         L     RK,#INTFRAM
         END   ,                       OF Compute frames to free
*-
*- Now compute the most we can free and still breathe
*-
         L     RJ,PAGRESAMT            Reserve due to swap-in rate
         AL    RJ,PAGFRES                and other reserves
         AL    RJ,PAGMSMAX                 plus max swap size
*-
*- Figure how many we don't need
*-
         SL    RJ,PAGFTCNT             Number needed - what we have
         SL    RJ,PAGFLS
         LCR   RJ,RJ                   | most we can free and breathe
         STMIN RJ,RK                   |
*-
*-       Don't ever go below minimum.
*-
         L     RJ,PAGFIXCNT        Total frames
         SL    RJ,PAGMINFR         Calc max frames we can free
         STMIN RJ,RK               Don't go below minimum size
*-
*- Compute the number of frames we should free by virtue of
*- the maximum suggested amount
*-
         L     RJ,PAGFIXCNT
         SL    RJ,PAGMAXFR
*
         STMAX RJ,RK
         CEIL  RK,PAGFTCNT             limit by free memory now
         IF    (RK,LT,PAGSRTHR),'CLEAR RK'
*
         IF    (RK,NPOS),EXIT,FRAMEADJ No frames to free
         SLKOB PAGFRAL,#INTPSWM
         CEIL  RK,PAGFCNT
         IF    (RK,POS),BEGIN          Do long term release
         LREM  PAGFHEAD,,(RK),LAST=(RJ),WR=RS
         LR    RM,RVR                  Save first frame
         LR    RA,RM                   First frame
         LR    RS,RK                   Count of frames
         LOOP  BEGIN                   Un-Fix frames
         WITH  (PFTE,RA)
        $LA    RB,PFTE                 Frame addr
         SL    RB,PAGPFTO              |
         SLL   RB,L'PAGPAGM-PFTLOG     |
         SYSCTL (RB),TYPE=NOPAGE       | and un-fix it
         CLEAR PFTPAGING               We can page on this one
         L     RA,PFTFP                next frame
         UNTIL (BCT,RS),END            OF Un-Fix frames
*  Add frames to unfixed frame list
         LR    RA,RM                   First frame
         LADD  PAGUFHD,(RA),(RJ),(RK),WR=RS
*-
*- Update counts of available frames
*-
         L     RJ,PAGFIXCNT            More fixed frames
         SLR   RJ,RK                   |
         ST    RJ,PAGFIXCNT            |
         L     RJ,PAGFTCNT             More frames available
         LOOP  BEGIN                   |
         LR    EPAR,RJ                 |
         SLR   EPAR,RK                 |
         CS    RJ,EPAR,PAGFTCNT        |
         UNTIL EQUAL,END               |
         L     EPAR,MATPTR             |
         WITH  (MAT,EPAR),BEGIN        Update paging function
         L     RJ,MATPAGFN             |
         SLR   RJ,RK                   |
         ST    RJ,MATPAGFN             |
         END   ,                       OF Update paging function
         END   ,                       OF Do long term release
         SLKRL PAGFRAL,#INTPSWM
*
         END   ,                       OF Need to reset the page max
         END   ,                       OF adjust real frame usage
*-
*- See if we need more room
*-
         ACALL MAKEROOM
*-
*- Call the routine to wake up those who were waiting for a
*- resource
*-
         ACALL WAKELOOK
*
         LD    R0,#INTFLT0             Restore FPR0
         LD    R2,#INTFLT2             Restore FPR2
         PEND  ,
         DS    0D
FLTZERO  DC    X'4E00000000000000'     Unnormalized floating pt zero
FLTSZERO DC    X'46000000'             Short flt pt zero
         TITLE 'Paging system SMF routine'
*box
*
*  Write System Management Facilities record
*
*   Input - none
*
*  Output - none
*
*
#PAGSMF  RECORD BEGIN
#SMFTIME DS    D                       TOD of this interval
         END   ,
         SPACE
PAGSMF   PROC  ,#PAGSMF,SCOPE=GLOBAL
         PAGAD RPAG
         VMGET L'SMFPAGE,LOC=GLOBHI
         LR    RK,RVR
         WITH  (SMFPAGE,RK)
         WITH  (SMFPFX,SMFPPFX)
         CLEAR SMFPAGE
         L     RJ,MATPTR
         WITH  (MAT,RJ),BEGIN
         MVC   SMFSYSTM,MATSNAME       Say who we are
         END   ,
         MVC   SMFCAT,=CL4'ORVP'       Paging record
         MVC   SMFNSEG,=A(3)           General, Paging, Swapping segs
*-
*- Set offsets and lengths of segments
*-
         MVC   SMFPGLOC,=A(SMFPGEN-SMFPAGE)
         MVC   SMFPGLEN,=A(L'SMFPGEN)
         MVC   SMFPLOC,=A(SMFPPAGE-SMFPAGE)
         MVC   SMFPLEN,=A(L'SMFPPAGE)
         MVC   SMFSLOC,=A(SMFPSWAP-SMFPAGE)
         MVC   SMFSLEN,=A(L'SMFPSWAP)
*-
*- Elapsed real time
*-
         MVC   #SMFTIME,PAGMTIME
         STCK  PAGMTIME
         LM    RA,RB,PAGMTIME          Store 2 middle bytes of elapse
         LM    RM,RN,#SMFTIME          |
         SLR   RB,RN                   |
         IF    NEG,'DECR RA'           |
         SLR   RA,RM                   |
         SRDL  RA,16                   |
         ST    RB,SMFPTIME             |
*
         MVC   SMFFRAME,PAGFIXCNT      Number of frames
*-
*- Loop through paging data sets
*-
         SPACE ,
*        CLEAR RM,RN,RA,RB,RVR         Total, avail, I/O times, I/Os
*        L     RJ,PAGXPDS              Count external frames
*        LH    RS,PAGXPN               | number of data sets
*        LOOP  BEGIN                   |
*        WITH  (DSDES,RJ)
*        IF    (DSAID,NE,=CL4'BMCB'),'ABORT BADBMID'
*        AL    RM,DSCOUNT              Total
*        AL    RN,DSAVAIL              Available
*        L     RJ,DSCHAIN
*        UNTIL (BCT,RS),END            OF Count external frames
         L     RM,PAGMXPG              Number of external frames
         ST    RM,SMFXPT
         SL    RM,PAGXPRCNT            Number alloc
         ST    RM,SMFXPAGE             |
         STMAX RM,PAGMXPMX             Maximum observedalloc
         MVC   SMFXPMX,PAGMXPMX        |
*-
*- Number of swap slots
*-
         L     RM,PAGMXSW              Max observed alloc swap slots
         SL    RM,PAGXSRCNT            |
         STMAX RM,PAGMXSMX             |
*-
*- Fill in paging section
*-
         L     RA,PAGMPON              Number of I/Os
         AL    RA,PAGMPIN              |
         ST    RA,SMFPGDAT             |
         LM    RA,RB,PAGMPOT           Time of I/Os
         LM    RM,RN,PAGMPIT           |
         ADLR  RA,RM                   |
         SRDL  RA,16                   |
         ST    RB,SMFPGDAT+4           | 2 middle bytes of TOD
*-
*- Fill in swapping section
*-
         L     RA,PAGMSON              Number of swaps
         AL    RA,PAGMSIN              |
         ST    RA,SMFSWDAT             |
         L     RA,PAGMSOF              Number of frames swapped
         AL    RA,PAGMSIF              |
         ST    RA,SMFSCNT              |
         LM    RA,RB,PAGMSOTM          Time of I/Os
         LM    RM,RN,PAGMSITM          |
         ADLR  RA,RM                   |
         SRDL  RA,16                   |
         ST    RB,SMFSWDAT+4           | 2 middle bytes of TOD
*-
*- Write SMF record
*-
         LA    RA,SMFPAGE              Location
         LA    RB,L'SMFPAGE            Length
         ICM   RB,8,=AL1(SMFNUM)       SMF number
         SYSCTL RA,RB,TYPE=SMF
*-
*- Free buffer
*-
         VMFREE A=LA:SMFPAGE,L'SMFPAGE,LOC=GLOBHI
         PEND  ,
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Initialize page frame resource'
*NEST,1
*box
*
*  Initialize the page frame resource
*
*
#PFINIT  RECORD BEGIN
#PFISTO  DS    A                       Segment table origin
#PFIUSED LHEAD PFX=#PFI                Temporary frames list
#PFISEGE DS    A                       Segment entry
#PFISEG# DS    A                       | number of entries
#PFIPAGE DS    A                       Page entry
#PFIPAG# DS    A                       | number of entries
#PFIPTVA DS    A                       Virtual address of PTs
#PFIXP#  DS    A                       Number of cur external page
#PFILOOP DS    2A                      Doubleword for loop vars
         END   ,
         SPACE
PFINIT   PROC  ,#PFINIT
         CLEAR #PFIXP#                 External frame alloc init
         PAGAD RPAG
*
         SYSCTL RA,TYPE=MAXREAL    Max frames to use (sets RA & RB)
         ST    RB,PAGMINFR         Save min number of frames allowed
         LR    RB,RA               RB = max number of frames
*
         SYSCTL RA,TYPE=MEMSIZE    Number of frames in machine
         ST    RA,PAGFRAN          RA = number of frames in machine
*
         CEIL  RB,RA                   |
         ST    RB,PAGMAXFR             |
         SLL   RA,PFTLOG               Get page frame table
         VMGET (RA),LOC=GLOBHI,FIX=YES
         ST    RVR,PAGPFTO             |
         LR    RS,RA                   | Clear page frame table
         CLEAR RB                      |
         REGCH (RVR,R0),(RS,R1)        |
         MVCL  RVR,RA                  |
*  Link frame table entries together
         L     RA,PAGPFTO              First entry
         LA    RB,PAGFHEAD             Previous entry
         L     RS,PAGFRAN              Number of entries
         ST    RS,PAGFCNT              |
         LOOP  BEGIN                   Link together
         WITH  (LELEM,RB),'ST RA,LFP'  | point fwd
         WITH  (LELEM,RA),'ST RB,LBP'  | point back
         LR    RB,RA                   | advance pointer
         WITH  (PFTE,RA),'LA RA,PFTNXT'
         UNTIL (BCT,RS),END            OF Link together
         LA    RA,PAGFHEAD             Close circular list
         WITH  (LELEM,RB),'ST RA,LFP'  | point fwd
         WITH  (LELEM,RA),'ST RB,LBP'  | point back
*box
*
*  Figure which frames are already allocated
*
         STCTL R1,R1,#PFISTO           Seg table origin/len
         L     RA,#PFISTO              |
         LR    RB,RA                   |
         N     RA,=A(PAGSTOM)          | origin
         N     RB,=A(PAGSTLM)          | number of entries
         INCR  RB                      | |
         SLL   RB,4                    | |
         L     RJ,PAGMEG               Num of extra meg in hardware
         LCR   RJ,RJ                   |
         ALR   RJ,RB                   |
         CEIL  RB,PAGMEG               |
         STM   RA,RB,#PFISEGE          Seg entry/number of entries
         LH    EPAR,PAGSEGP            Number of pages/seg table
         L     RPCB,PAGCASB            PCB address
         WITH  (ASB,RPCB),'L RPCB,ASBPAGB'
         WITH  (ASBPCB,RPCB)
         L     RS,PCBRA                DAT-OFF
         DATOFF PCBPSWM                |
*  Count frames used by page and segment tables.  EPAR has number of
* frames needed for segment table.
         LOOP  BEGIN                   Count
         WITH  (SGTE,RA)
         IF    ^SGTFINV,BEGIN          Valid segment
         INCR  EPAR                    | one more
         END   ,
         LA    RA,SGTNXT               Next seg table entry
         UNTIL (BCT,RB),END            OF Count
*
         IF    (RJ,POS),BEGIN          Check for segs beyond max
         LOOP  BEGIN                   Check entries beyond max
         WITH  (SGTE,RA)
         IF    ^SGTFINV,BEGIN
         ABORT PAGSEGINIT
         END   ,
         LA    RA,SGTNXT
         UNTIL (BCT,RJ),END            OF Check entries beyond max
         END   ,                       OF Check for segs beyond max
         WITH  (ASBPCB,RS),BEGIN       PCB addr - RA
         DATON PCBPSWM                 DAT-ON
         END   ,                       OF PCB addr
*
         SLL   EPAR,L'PAGPAGM          Get page/seg tables from VM
         LR    RS,EPAR                 |
         VMGET (RS),LOC=GLOBHI,FIX=YES,PAGE=YES
         ST    RVR,PCBPSTO             New PSTO that we will build
         REGCH (RVR,R0),(RS,R1)        | clear seg/page memory tbls
         CLEAR RB                      |
         MVCL  RVR,RA                  |
*box
*
*  Take used frames off of the free frames list, hardware segment
*  tables frames first.
*
         LA    RS,#PFIUSED             Init used frames list
         ST    RS,#PFIFP               |
         ST    RS,#PFIBP               |
         CLEAR #PFICNT                 |
*-
*- NB - This assumes that hardware segment tables have a maximum
*-      length of 4K and start on a 4K boundary.
*-
         L     RA,#PFISEGE             Seg table RA => PFT entry
         SRL   RA,L'PAGPAGM-PFTLOG     |
         AL    RA,PAGPFTO              |
         WITH  (PFTE,RA),BEGIN         |
         LREM  PAGFHEAD,LA:PFTE,WR=RS  Seg table frame off free list
         LADD  #PFIUSED,LA:PFTE,WR=RS  |
         END   ,                       OF PFTE addr
*box
*
*  Loop through segment table
*
         LM    RA,RB,#PFISEGE          Seg entry, num of entries
         L     RS,PCBRA                DAT-OFF
         DATOFF PCBPSWM                |
         LR    RPCB,RS                 | RA
         LOOP  BEGIN                   Look @ all entries in seg tbl
         WITH  (SGTE,RA)
         IF    ^SGTFINV,BEGIN          Valid segment
         REGCH (RAR,R14),(EPAR,R15)
         L     RAR,SGTAD               Compute page table address/len
         L     RS,PCBVA                | DAT-ON
         DATON PCBPSWM                 | |
         LR    RPCB,RS                 | | VA
         LR    EPAR,RAR                | num of page table entries
         N     EPAR,=A(SGPTLMSK)       |
         INCR  EPAR                    |
         SLL   EPAR,4                  |
         N     RAR,=A(SGTADMSK)        | address mask
         STM   RAR,EPAR,#PFIPAGE       PT addr/num entries
         LR    RJ,RAR                  Remove from free frames
         SRL   RJ,L'PAGPAGM-PFTLOG     |
         AL    RJ,PAGPFTO              |
         WITH  (PFTE,RJ),BEGIN         |
         LREM  PAGFHEAD,LA:PFTE,WR=RS  |
         LADD  #PFIUSED,LA:PFTE,WR=RS  |
         END   ,                       OF PFTE addr
         EJECT
*box
*
*  Loop through page table
*
         LM    RAR,EPAR,#PFIPAGE       Page entries, # left
         L     RS,PCBRA                DAT-OFF
         DATOFF PCBPSWM                |
         LR    RPCB,RS                 | RA
         LOOP  BEGIN                   Loop through page table
         WITH  (PGTE,RAR)
         IF    ^PGTFINV,BEGIN          Valid page
         L     RJ,PGAD                 Page real address
         L     RVR,PCBVA               | DAT-ON
         DATON PCBPSWM                 | |
         LR    RPCB,RVR                | | VA
         STM   RAR,EPAR,#PFIPAGE       Save page table counters
         N     RJ,=A(PGTADMSK)         Remove from free frames
         SRL   RJ,L'PAGPAGM-PFTLOG     |
         AL    RJ,PAGPFTO              |
         WITH  (PFTE,RJ),BEGIN         |
         LREM  PAGFHEAD,LA:PFTE,WR=RS  |
         LADD  PCBLFLH,LA:PFTE,WR=RS   | add to PCBs fixed frames
         MVI   PFTQ,PCBLFLH-ASBPCB     | set Q id
*  NB - This assumes hardware seg tables are a max of 4K in length
*       and page tables start on a 4K boundary.
         LR    RAR,RA                  Compute VA - from entry addrs
         N     RAR,=A((1024*L'SGTE)-1) | starting page in segment
         SLL   RAR,8-SGTLOG            |
         L     EPAR,#PFIPAGE           | starting page in PT
         N     EPAR,=A((256*L'PGTE)-1) |
         SRL   EPAR,PGTLOG             |
         ALR   RAR,EPAR                |
         SLL   RAR,L'PAGPAGM           This is the VA
         ST    RAR,PFTVA               | VA
         MVC   PFTASB,PCBASB           | ASB
         MVC   PFTFIX,=Y(1)            | one fix here
         END   ,                       OF PFTE addr
         LM    RAR,EPAR,#PFIPAGE       Page table counters
         L     RVR,PCBRA               DAT-OFF
         DATOFF PCBPSWM                |
         LR    RPCB,RVR                | RA
         END   ,                       OF Valid page
         LA    RAR,PGTNXT
         UNTIL (BCT,EPAR),END          OF Loop through page table
         END   ,                       OF Valid segment
         LA    RA,SGTNXT               next seg tbl entry
         UNTIL (BCT,RB),END            OF Look @ all entries in seg
         L     RVR,PCBVA               DAT-ON
         DATON PCBPSWM                 |
         LR    RPCB,RVR                | VA
         EJECT
*box
*
*  Copy over segment and page tables to virtual memory
*
         PSET  @PAGSGIN                Init memory for segment tbl
         PMOV  @SIVA,PCBPSTO           |
         ACALL PAGSGINI                |
         LH    RA,PAGSEGP              Compute next PT VA origin
         MH    RA,=Y(PAGPAGEL)         |
         AL    RA,PCBPSTO              |
         ST    RA,#PFIPTVA             |
         LM    RA,RB,#PFISEGE          Copy seg table - seg start
         CEIL  RB,PAGMEG               | limit number of meg to copy
         ST    RB,#PFISEG#             |
         SLL   RB,SGTLOG               | | length of seg tbl
         L     RS,PCBPSTO              | virt start
         REGCH (RVR,R0),(RS,R1)
         LRA   RVR,@RS                 |
         LR    RS,RB                   |
         L     EPAR,PCBRA              Copy seg table - DAT-OFF
         DATOFF PCBPSWM                |
         MVCL  RVR,RA                  |
         WITH  (ASBPCB,EPAR),BEGIN     | DAT-ON again
         DATON PCBPSWM                 |
         END   ,                       |
*  Loop through new seg table
         L     RA,PCBPSTO              New seg table start
         ST    RA,#PFISEGE             |
         L     RB,#PFISEG#             | num of entries
         L     RK,PAGMEG               | shadow seg table start
         MH    RK,=Y(L'SGTE)           |
         ALR   RK,RA                   |
         LOOP  BEGIN                   Loop through seg tbl
         WITH  (SGTE,RA)
         WITH  (SSTE,RK)
         IF    ^SGTFINV,BEGIN          Valid segment entry
         SET   SGTFCOMM                These are all common segments
         SET   SSTFDEF+SSTFCOMM        | defined & referenced
         MVI   SSINIT,X'BD'
*box
*
*  Init page table
*
         L     RJ,#PFIPTVA             Init PT
         PSET  @PAGPGIN                |
         PMOV  @PIVA,(RJ)              |
         ACALL PAGPGINI                |
*
         LRA   RJ,@RJ                  Set storage key - RA of PT
         ISKE  RS,RJ                   |
         STC   RS,SSKEY                |
         L     RAR,SGTAD               Page table address/length
         LR    EPAR,RAR                |
         N     RAR,=A(SGTADMSK)        | addr
         N     EPAR,=A(SGPTLMSK)       | len
         INCR  EPAR                    |
         SLL   EPAR,4                  | num of entries (mult of 16)
         REGCH (RAR,R14),(EPAR,R15)
         STM   RAR,EPAR,#PFIPAGE       PT loc/len
         SLL   EPAR,PGTLOG             |
         LR    RVR,RJ                  | virtual PT's RA
         LR    RS,EPAR                 |
         L     RJ,PCBRA                Copy page table - DAT-OFF
         DATOFF PCBPSWM                |
         MVCL  RVR,RAR                 |
         WITH  (ASBPCB,RJ),BEGIN       | DAT-ON again
         DATON PCBPSWM                 |
         END   ,                       |
         N     RVR,=A(PAGPAGM)         Set RA for PT in seg table
         LR    RM,RVR                  | back to start of page
         O     RVR,=A((256/16)-1+L'SGTFCOMM)    | const len + common
         ST    RVR,SGTAD               |
         SRL   RM,L'PAGPAGM-PFTLOG     |
         AL    RM,PAGPFTO              |
         WITH  (PFTE,RM),BEGIN         |
         SET   PFTFPGT                 | page table page
         LR    RAR,RA                  Compute segment number for PT
         N     RAR,=A(PAGOFFM)         | just seg num
         SRL   RAR,SGTLOG              |
         STH   RAR,PFTSEG              |
         END   ,                       OF Set PFT for this page tbl
         L     RAR,#PFIPTVA            PT loc/num entries
         L     EPAR,#PFIPAG#           |
         LR    RS,RAR                  | update for next PT VA
         AL    RS,=A(PAGPAGEL)         |
         ST    RS,#PFIPTVA             |
         WITH  (PAGTABLE,RAR),'LA RJ,SPGT'
         LOOP  BEGIN                   Loop through PT
         WITH  (PFTE,RM)
         WITH  (PGTE,RAR)
         WITH  (SPTE,RJ)
         IF    ^PGTFINV,BEGIN          Valid page found
*-
*- A valid page causes 1 more short term fix for the page table
*-
         INCR  RS,PFTSFIX              One more valid page in segment
         CLEAR PGTFLG2                 Clear all software flags
         SET   PGTFDEF+PGTFREF+PGTFCOMM+PGTFXDEF
         STM   RAR,EPAR,#PFIPAGE
         XPGET (RPCB)                  Get slot for page
         LM    RAR,EPAR,#PFIPAGE
         ST    RVR,SPXSLOT             Fill in external page slot
         L     RS,PGAD                 Get key of page
         N     RS,=A(PGTADMSK)         |
         ISKE  RVR,RS                  |
         STC   RVR,SPKEY               |
*        MVI   SPINIT,X'BD'
         END   ,                       OF Valid page found
         LA    RAR,PGTNXT              Next entry
         LA    RJ,SPTNXT               |
         UNTIL (BCT,EPAR),END          OF Loop through PT
         END   ,                       OF Valid segment entry
         LA    RA,SGTNXT               Next entry
         LA    RK,SSTNXT               |
         UNTIL (BCT,RB),END            OF Loop through seg tbl
*box
*
*  Now deal with the VAs of new page tables
*
         L     RA,PCBPSTO              Get first page table VA
         LH    RB,PAGSEGP              |
         MH    RB,=Y(PAGPAGEL)         |
         ALR   RA,RB                   |
         L     RB,#PFICNT              Number of PTs
         DECR  RB                      | minus 1 for original seg tbl
         LOOP  BEGIN                   Mark page tables' VAs
*-
*- Indicate that this is a page table page.  Set the external slot
*- in the shadow segment table entry that this page table represents
*- to be the same as the shadow page slot for the virtual address of
*- this page table.
*-
         STM   RA,RB,#PFILOOP
         L     RJ,PCBPSTO              Segment table origin
         LC    RS,PCBPSTL              | last entry
         SLL   RS,4                    |  *16
         LA    RS,@RS+16-1             |
         N     RJ,=A(PCBSTM)           Clean up segment start
         LR    RK,RJ                   |  save for shadow offset
*-
*- Get segment table entry/page table address
*-
         N     RA,=A(PAGPAGM)          | remove high bit/offset
         CLEAR (RB)
         SRDL  RA,L'PAGSGNM            | RA = seg number
         SRL   RB,24                   | RB = pg number
         LR    RM,RA                   Use RM as seg table index
         SLL   RM,SGTLOG               | seg table offset (4 bytes ea)
         LA    RJ,@RJ(RM)              |
         SLL   RM,SSTLOG-SGTLOG        Shadow table offset
         L     RN,PAGMEG               Shadow seg table entry addr
         SLL   RN,SGTLOG               |
         LA    RK,@RK(RN)              |
         LA    RK,@RK(RM)              |
         IF    (RA,GT,RS),PFIKAP       | and exit if so
         WITH  (SGTE,RJ),BEGIN         Segment table entry addr
         IF    SGTFINV,PFIKAP          | and exit if so
         L     RJ,SGTAD                Page table addr
         END   ,                       OF Segment table entry addr
         LR    RK,RJ                   | length
         N     RK,=A(SGPTLMSK)         | |
         SLL   RK,4                    | |
         LA    RK,@RK+16-1             | | last entry
         N     RJ,=A(SGTADMSK)         |
         IF    (RB,GT,RK),PFIKAP       | and exit if so
*-
*- Get page table entry addr
*-
         RTOV  (RJ)                    Convert real addr to virt
         LR    RJ,RVR                  |
         WITH  (PAGTABLE,RJ),'LA RK,SPGT '      Shadow Page table add
         LR    RA,RB                   | entry
         SLL   RB,SPTLOG               |
         LA    RK,@RK(RB)              |
         SLL   RA,PGTLOG               Page table entry address
         LA    RJ,@RJ(RA)              |
*-
*-  RJ = page table addr, RK = shadow page table addr
*-
         WITH  (PGTE,RJ),BEGIN         |
         IF    PGTFINV,PFIKAP          | exit if not valid
         SET   PGTFPGT                 Page table page
         L     RJ,PGAD                 Real address of page table
         END   ,                       OF Page table entry address
         WITH  (SPTE,RK),BEGIN         Shadow page addr
         L     RS,SPXSLOT              External slot
         END   ,                       OF Shadow page addr
*-
*- Compute shadow segment table entry for the segment this PT
*- represents
*-
         N     RJ,=A(PGTADMSK)         Page frame entry
         SRL   RJ,L'PAGPAGM-PFTLOG     |
         AL    RJ,PAGPFTO              |
         WITH  (PFTE,RJ),BEGIN         |
         LH    RJ,PFTSEG               | segment num in frame entry
         END   ,                       | OF Page frame table addr
         L     RK,PCBPSTO              Compute shadow table entry
         N     RK,=A(PCBSTM)           |
         AH    RK,PAGSEGL              | shadow seg start
         SLL   RJ,SSTLOG               | offset from shadow seg start
         ALR   RK,RJ                   | shadow seg entry
         WITH  (SSTE,RK),'ST RS,SSXSLOT'
*-
*-  Get back virtual addr/number of PTs to go
*-
         LM    RA,RB,#PFILOOP
*
         AL    RA,=A(PAGPAGEL)         Next virtual page
         UNTIL (BCT,RB),END            OF Mark page tables' VAs
         EJECT
*box
*
*   Put old hardware segment/page tables back on free frames list,
*  mark all frames as PAGEABLE, and set new PSTO
*
*  Add all to list
*
         LADD  PAGFHEAD,#PFIFP,#PFIBP,#PFICNT,WR=RS
*
         L     RS,#PFICNT              Clear certain fields
         L     RA,#PFIFP               |
         CLEAR RVR                     |
         LOOP  BEGIN                   |
         WITH  (PFTE,RA)               |
         ST    RVR,PFTASB              |
         STC   RVR,PFTQ                |
         UNTIL (BCT,RS),END            OF Clear certain fields
*-
*- Only fix a certain amount
*-
         L     RJ,PAGFCNT              Number we could fix
         L     RB,PAGMAXFR              over the max
         IF    ('SR RJ,RB',POS),BEGIN    will be removed
         LREM  PAGFHEAD,,(RJ),LAST=(RB),WR=RS
         LR    RA,RVR
         LADD  PAGUFHD,(RA),(RB),(RJ),WR=RS
         END   ,                       OF will be removed
         L     RS,PAGFCNT              Mark all frames as PAGEABLE
         ST    RS,PAGFIXCNT            | number of fixed frames
         ST    RS,PAGFTCNT             | Total of available
         L     RB,MATPTR               Set MAT paging function
         WITH  (MAT,RB),BEGIN          |
         LR    RVR,RS                  |
         SL    RVR,PAGASIN             | save 1 frame/AS in core
         ST    RVR,MATPAGFN            |
         END   ,                       OF Set MAT paging function
         L     RA,PAGFFP               | 1st frame
         L     RJ,PAGPFTO              | start of page frame table
         LOOP  BEGIN                   |
         LR    RB,RA                   Compute frame addr
         SR    RB,RJ                   |
         SLL   RB,L'PAGPAGM-PFTLOG     |
         SYSCTL (RB),TYPE=PAGE         |
         WITH  (PFTE,RA),BEGIN
         SET   PFTPAGING               Can use for paging
         L     RA,PFTFP                Next frame
         END   ,
         UNTIL (BCT,RS),END            OF Mark all frames as PAGEABLE
*
         L     RK,PCBPSTO              Set new seg table origin
         LRA   RK,@RK                  |
         L     RJ,PCBASB
         WITH  (ASB,RJ),BEGIN          ASB addr
         LH    RA,ASBPASN              ASN to work from (AFX)
         LR    RB,RA                   | used for ASX
         N     RA,=A(PAGAFXM)          First table entry calc
         SRL   RA,L'PAGAFXM-AFTLOG     | index*4 is offset from AFTO
         AL    RA,PAGAFTO              |
*
         WITH  (AFTE,RA),BEGIN         |
         L     RA,AFTASTO              Second table origin
         END   ,                       OF First table entry calc
         IF    (RA,NEG),PFIKAP2        Error - 2nd table unavailable
         N     RA,=A(AFTASTM)          | mask em out
         RTOV  (RA)                    | to virtual (ret in RVR)
         N     RB,=A(PAGASXM)          Second table entry calc
         SLL   RB,ASTLOG               | index*16 is offset from ASTO
         ALR   RB,RVR                  |
         WITH  (ASTE,RB),BEGIN         |
         L     RVR,ASTSTD              Set seg table RA
         N     RVR,=A(ASTSTL)          | save old length
         OR    RVR,RK                  | new RA
         ST    RVR,ASTSTD              |
         CLEAR ASTFINV                 Now it's valid
         END   ,
*-
*- Load address space parameters (local AS)
*-
         LA    RS,X'04'                Lasp parm - insist on xlate
         O     RS,=A(ASBLPARM)
         LASP  ASBLASP,0(RS)
         IF    NZ,PFIKAP2
         END   ,                       OF ASB addr
         PTLB  ,                       |
*-
*- Init number of address spaces
*-
         MVC   PAGASIN,=A(1)           Number of address spaces
*-
*- We can take page defines now
*-
         VCALL VMDEFSET
*
         PEND  ,
         SPACE
PFIKAP   ABORT PFINIT                  Page frame initialization
         SPACE
PFIKAP2  ABORT PFINITAS                ASN error
*NEST,2
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Global initialization'
*box
*
*
*
*
*
*
#PAGINIT RECORD BEGIN
#PIFLT0  DS    D                       Save area for floating point
#PIFLT2  DS    D
#PIFLTW  DS    D                       Work area
#PIPARM  DS    F                       PAGIPARM pointer save
         END   ,
         SPACE
PAGINIT  PROC  @PAGINIT,#PAGINIT,SCOPE=GLOBAL   Global initialization
         USING PZERO,R0                CVT address
         L     RA,PZMATP               |
         DROP  R0                      |
*-
*- Initalize paging control block
*-
         WITH  (MAT,RA),BEGIN          Save PAGCB address
         VMGET L'PAGCB,LOC=GLOBHI,FIX=YES,ONEPAGE=YES
         ST    RVR,MATPAGCB
         END   ,
         LR    RPAG,RVR                Paging CB addr
         WITH  (PAGCB,RPAG)
         WITH  (PAGCEL,PAGPGCEL),LABEL=PC
         WITH  (PAGCEL,PAGSWCEL),LABEL=SC
         CLEAR PAGCB                   Set to zero
         MVC   PAGCBID,=CL8'PAGCB'     | and put in tag
*-
*- Set up lock routines as dummys for initialization
*-
         LA    EPAR,LOCKDUMMY          Dummy EPs for init
         ST    EPAR,PAGLKOB            |
         ST    EPAR,PAGLKREL           |
*-
*- Set up internal resolve routine for init
*-
         MVC   PAGRESLV,=A(INITRESLV)  Resolve routine for init
*
         MVI   PAGSKEY,CPAGIOKEY       Key for paging reads
         L     RA,@PAGIMEG             Number of meg in VA space
         AL    RA,=A(PAGOFFM+PAGPGNM)  | round up to next meg
         SRL   RA,L'PAGSGNM            |
         LA    RA,@RA+16-1             | rounded up to next 16
         N     RA,=A(-16)              |
         ST    RA,PAGMEG               |
         LR    RB,RA                   | length of hardware seg tbl
         SLL   RB,SGTLOG               |
         STH   RB,PAGSEGL              |
         MH    RA,=Y(L'SGTE+L'SSTE)    | length of seg table
         AL    RA,=A(PAGPAGEL-1)       |
         N     RA,=A(-PAGPAGEL)        |
         SRL   RA,L'PAGPAGM            |
         STH   RA,PAGSEGP              | pages/segment table
*  Get various locks
         LKCRE PAGFRAME,TYPE=SPIN      Free frame lock
         ST    RVR,PAGFRAL             |
         LKCRE PAGESWAP,TYPE=SPIN      Swap control lock
         ST    RVR,PAGSWAPL            |
*  Init lists
         WITH  (LHEAD,RB),BEGIN        LHEAD addr
         LA    RB,PAGFHEAD             Init free frames pool
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGFWT               | waiting for free frames
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGUFHD              Init list of un-LT-fixed frame
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGLASB              Init logical swaps list
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGLIP               Init logical/in-progess list
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGRSCB              Init non-reclaimed swap CBs
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGXPWT              Init lists for ext pag res
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PC.PAGCELAS          Init lists for paging cells
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,SC.PAGCELAS          Init lists for swapping cells
         ST    RB,LHFP
         ST    RB,LHBP
         LA    RB,PAGASNW              Init waiting for ASN list
         ST    RB,LHFP
         ST    RB,LHBP
         END   ,                       OF LHEAD addr
         L     RPCB,@PAGIASB           Common ASB address
         ST    RPCB,PAGCASB            |
*  Init info pointers
         LA    RB,PAGSTATS             |
         ST    RB,PAGSTPTR             |
         LA    RB,PAGXPN               |
         ST    RB,PTRXPN               |
         LA    RB,PAGXPDS              |
         ST    RB,PTRXPDS              |
         LA    RB,PAGXPRCNT            |
         ST    RB,PTRXPRCNT            |
         LA    RB,PAGXSRCNT            |
         ST    RB,PTRXSRCNT            |
         LA    RB,PAGXSN               |
         ST    RB,PTRXSN               |
         LA    RB,PAGXSDS              |
         ST    RB,PTRXSDS              |
         LA    RB,PAGFIXCNT            |
         ST    RB,PTRFRAN              |
         LA    RB,PAGASIN              |
         ST    RB,PTRASIN              |
         LA    RB,PAGLCNT              |
         ST    RB,PTRLOUT              |
         LA    RB,PAGFRAL              |
         ST    RB,PTRFRAME             |
         EJECT
*-
*- Init ASN allocation mechanism
*-
         ACALL ASNINIT
*-
*- Common ASB/PCB init
*-
         PSET  @PCBINIT                Init global PCB
         PMOV  @PCIASB,(RPCB)          |
         ACALL PCBINIT                 |
         LR    RA,RVR                  PCB addr
         WITH  (ASBPCB,RA),BEGIN       |
         WITH  (ASB,RPCB),BEGIN        ASB addr
         ST    RA,ASBPAGB              Point at this PCB
         SET   ASBFGBLC                Set global flag
         SET   PCBFGBLC                Common PCB
         END   ,                       OF ASB addr
         END   ,                       OF PCB addr
         LR    RPCB,RA                 set PCB register
*-
*- Get ASN and fill in ASTE
*- NB - The authority index and linkage table descriptors for now
*-      default to zero.
*-      Set PASN and SASN as the same now
*-
         L     RJ,PAGAFTO              Get first AST table RA
         WITH  (AFTE,RJ),'L RJ,AFTASTO'
         N     RJ,=A(AFTASTM)          |
*-
*- Fill in slot for ASN 0, the global address space's ASN
*-   Use DAT-OFF
*-
         WITH  (ASBPCB,RPCB),BEGIN
         LRA   RK,PAGCB
         L     RS,PCBRA                DAT-Off
         DATOFF PCBPSWM                |
         WITH  (PAGCB,RK),BEGIN        Addr of PAGCB in DAT-OFF
         WITH  (ASTE,RJ)
         L     RA,PAGMEG               Segment table length
         SRL   RA,4                    | now in multiples of 16
         DECR  RA                      |
         ST    RA,ASTSTD               | only len of seg table
         MVC   ASTATO,PAGATO           | authority location & len
         MVC   ASTATL,PAGATL           |
         SET   ASTFINV                 | invalid, although allocated
         CLEAR PAG1ASN                 Lowest possible available ASN
         DECR  RN,PAGAVASN             One less ASN entry available
         END   ,                       OF addr of PAGCB in DAT-OFF
         WITH  (ASBPCB,RS),'DATON PCBPSWM'      DAT-On
*-
*- Set results in global ASB and PCB
*-
         STC   RA,PCBPSTL              Set segment table len
         CLEAR PCBPASN                 Save this ASN
         L     RK,PCBASB               |
         WITH  (ASB,RK),BEGIN          | Local ASB addr
         CLEAR ASBPASN                 |
         CLEAR ASBSASN                 |
         END   ,                       | OF Local ASB addr
         END   ,                       OF PCB addressability
         EJECT
         WITH  (PAGCEL,PAGPGCEL),LABEL=PC
         WITH  (PAGCEL,PAGSWCEL),LABEL=SC
*-
*- External frame init - paging
*-   Data set has not been allocated yet.  PAGINIT2 will allocate
*- the datasets and map the external frames allocated in the first
*- pass to a real paging dataset.
*-
         LKCRE PAGEXPAG,TYPE=SPIN      External pages lock
         ST    RVR,PAGXPL              |
         MVC   PAGXPN,=Y(1)            Only one bitmap for init
         VMGET L'DSDES,LOC=GLOBHI,FIX=YES,ONEPAGE=YES
         ST    RVR,PAGXPDS
         ST    RVR,PAGXPCUR
         LR    RJ,RVR                  Init control block
*-
*- Allocate bitmap and initialize it
*-
         WITH  (DSDES,RJ),BEGIN
         CLEAR DSDES
         MVC   DSAID,=CL4'BMCB'        Set ID
         L     RB,=A(4096)             | number of blocks for init
         ST    RB,DSCOUNT              |
         ST    RB,DSAVAIL              |
         ST    RB,PAGXPRCNT            Total blocks in PAGE DSs
         LA    RB,@RB+7                Bytes required for map
         SRL   RB,3                    |
         VMGET (RB),LOC=GLOBHI,FIX=YES
         ST    RVR,DSLOC               Bitmap location
         ST    RB,DSLEN                | and len
         REGCH (RAR,R14),(EPAR,R15)
         LR    RAR,RVR                 Init bit map - location
         LR    EPAR,RB                 | and len
         LCM   RB,8,=X'FF'             | fill w/ ones
         MVCL  RAR,RA                  |
*-
*- Point to self w/ only one dummy bitmap
*-
         ST    RJ,DSCHAIN
         END   ,                       OF allocate bitmap and init it
         EJECT
*-
*- Get initialization parameters
*-
         VMGET L'PAGIPARM,LOC=GLOBHI,FIX=YES
         LR    RM,RVR
         ST    RM,#PIPARM          Save pointer
         WITH  (PAGIPARM,RM),BEGIN
         WITH  (PARMIN,PAGITYPE)
         REGCH (RVR,R0),(RS,R1),(RAR,R14),(EPAR,R15)
*  Paging I/O cells
         GETPARM2 KEY=(PAGING,PAGE_CNT),REGS=(RVR,RAR)
         LA    RB,CPAGCEL              Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,20                   Minimum
         END   ,
         ST    RB,PC.PAGCELAMT
*  Swapping I/O cells
         GETPARM2 KEY=(,SWAP_CNT),REGS=(RVR,RAR)
         LA    RB,CSWPCEL              Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,10                   Minimum
         END   ,
         ST    RB,SC.PAGCELAMT
*  Average size of working set
         GETPARM2 KEY=(,AVG_WS),REGS=(RVR,RAR)
         LA    RB,CSWPAVG              Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,20                   Minimum
         END   ,
         STH   RB,PAGSWAVG
*  Number of cycles before page is thrown out of working set
         GETPARM2 KEY=(,WS_CYCLE),REGS=(RVR,RAR)
         LA    RB,8                    Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,1                    Minimum
         CEIL  RB,8                    Maximum
         END   ,
         L     RA,=A(PAGMXHST)         Set up history value
         SRL   RA,@RB                   shifting one bit/cycle
         ST    RA,PAGMNHST
*  Number of cycles before global page is thrown out of working set
         GETPARM2 KEY=(,GWS_CYCLE),REGS=(RVR,RAR)
         LA    RB,8                    Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,1                    Minimum
         CEIL  RB,8                    Maximum
         END   ,
         L     RA,=A(PAGMXHST)         Set up history value
         SRL   RA,@RB                   shifting one bit/cycle
         ST    RA,PAGGMHST
*
         STD   R0,#PIFLT0              Save old float 0
*-
*- Get the exponential average parameter for swaps/sec
*-  values closer to 1.00 weigh more heavily to past history
*-
         GETPARM2 KEY=(,RM_ALPHA),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'.55'              Default (.55)
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         IF    ('LTER R0,R0',NPOS),'SER R0,R0'          Minimum
         IF    ('CE R0,=E".99"',GT),'LE R0,=E".99"'     Maximum
         END   ,
         STE   R0,PAGSRATE
*-
*- Swap parameter for long term frame management
*-   If swap rate is lower than the lower suggested rate,
*-   this number is multiplied by the difference between the
*-   actual swap rate and the boundary swap rate.  The resulting
*-   number is the count of frames that we will try to long
*-   term release.
*-
         GETPARM2 KEY=(,RM_LOW),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'1'                Default
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         IF    ('LTER R0,R0',NPOS),'SER R0,R0'          Minimum
         END   ,
         STE   R0,PAGSRMLO
*-
*- Swap parameter for long term frame management
*-   If swap rate is higher than the high suggested rate,
*-   this number is multiplied by the difference between the
*-   actual swap rate and the boundary swap rate.  The resulting
*-   number is the count of frames that we will try to long
*-   term fix.
*-
         GETPARM2 KEY=(,RM_HIGH),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'1'                Default
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         IF    ('LTER R0,R0',NPOS),'SER R0,R0'          Minimum
         END   ,
         STE   R0,PAGSRMHI
*-
*- Get the high swap/sec parameter
*-  above this we try to get more frames
*-
         GETPARM2 KEY=(,SWAP_HI),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'60'               Default (60/sec)
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         IF    ('CE R0,=E"1"',LT),'LE R0,=E"1"'         Minimum /sec
         IF    ('CE R0,=E"1000"',GT),'LE R0,=E"1000"'   Maximum /sec
         END   ,
         STE   R0,PAGSRHI
*-
*- Get the low swap/sec parameter
*-  below this we try to free frames
*-
         GETPARM2 KEY=(,SWAP_LOW),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'20'               Default /sec
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         END   ,
         IF    ('CE R0,=E".1"',LT),'LE R0,=E".1"'       Minimum /sec
         IF    ('CE R0,PAGSRHI',GT),'LE R0,PAGSRHI'     Maximum /sec
         STE   R0,PAGSRLO
*-
*- Long term fixing/releasing threshold - below this number we don't
*-   bother unfixing a frame.
*-
         GETPARM2 KEY=(,RM_THRSH),REGS=(RVR,RAR)
         LE    R0,PAGSRLO              Minimum threshold can't be
         ME    R0,PAGSRMLO              more than 1/2 of
         MD    R0,=D'0.5'                low_rate * low_multiplier
         LRER  R0,R0
         AU    R0,=X'46000000'
         STE   R0,PAGSRTHR
         MVI   PAGSRTHR,0
         L     RA,PAGSRTHR             Top value for threshold
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,0                    Minimum
         IF    (RB,LT,RA),'LR RA,RB'   RA = maximum
         END   ,
         ST    RA,PAGSRTHR             Set threshold
*-
*- Get the page frame reserve parameters
*- Reserved frames = SLOPE * (SWAP-IN-RATE - X_OFF) + INTERCPT
*-   the values MAX and MIN are also supplied as boundaries
*-
*- First on the list is the SLOPE parameter
*-
         GETPARM2 KEY=(,RESERVE,SLOPE),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'0'                Default
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         END   ,
         IF    ('CE R0,=E"0"',LT),'LE R0,=E"0"'         Minimum
         IF    ('CE R0,=E"100"',GT),'LE R0,=E"100"'     Maximum
         STE   R0,PAGRESM              Slope of (y=m(x-x0)+b)
*-
*- Get the X offset
*-
         GETPARM2 KEY=(,,X_OFF),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'0'                Default
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         END   ,
         IF    ('CE R0,=E"-100"',LT),'LE R0,=E"-100"'   Minimum
         IF    ('CE R0,=E"100"',GT),'LE R0,=E"100"'     Maximum
         STE   R0,PAGRESX0             x0 of (y=m(x-x0)+b)
*-
*- Get the intercept
*-
         GETPARM2 KEY=(,,INTERCPT),TYPE=FLOAT,REGS=(RVR,RAR)
         LE    R0,=E'0'                Default
         IF    ZERO,BEGIN
         ST    RVR,PAGIOUT
         LE    R0,PAGIOUT
         END   ,
         IF    ('CE R0,=E"-100"',LT),'LE R0,=E"-100"'   Minimum
         IF    ('CE R0,=E"100"',GT),'LE R0,=E"100"'     Maximum
         STE   R0,PAGRESB              b of (y=m(x-x0)+b)
*-
*- Get the maximum
*-
         GETPARM2 KEY=(,,MAX),REGS=(RVR,RAR)
         LA    RB,100                  Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         END   ,
         CEIL  RB,=Y(32767)            32K-1
         FLOOR RB,10
         STH   RB,PAGRESMX             Maximum reserve
*-
*- Get the minimum
*-
         GETPARM2 KEY=(,,MIN),REGS=(RVR,RAR)
         LA    RB,10                   Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         END   ,
         CEIL  RB,PAGRESMX
         FLOOR RB,0
         STH   RB,PAGRESMN             Minimum reserve
*
         LD    R0,#PIFLT0              Restore old float 0
*-
*- Size of swap cell
*-
         GETPARM2 KEY=(,SWAP_EXT),REGS=(RVR,RAR)
         LA    RB,PGDSWNUM             Default
         IF    ZERO,BEGIN
         LR    RB,RVR
         FLOOR RB,12                   Minimum
         CEIL  RB,255                  Max (hardware CCW limit)
         END   ,
         STH   RB,PAGSWXN              Number of frames/extent
         LR    RA,RB                   | length of extent
         SLL   RA,PGDSLLOG             |
         STH   RA,PAGSWXL              |
         SLL   RB,PGDSVLOG             Length of swap cell
         ALR   RB,RA                   |
         STH   RB,PAGSWXTL             | total extent length
         LA    RB,@RB+L'PGDSWAP+7      |
         N     RB,=A(-8)               | Double word align
         STH   RB,SC.PAGCELLEN         |
*-
*- Should we provide backing store for non-referenced frames?
*-
         GETPARM2 PAGIOUT,KEY=(,EXTERNAL,BAKEMPTY),TYPE=YESNO,         *
               REGS=(RVR,RAR)
         IF    ZERO,BEGIN
         IF    (PAGIOUT,EQ,'N'),BEGIN
         SET   PAGXFUREL               Set flag to do releases
         END   ,
         END   ,
*-
*- Should pages be defined in only 1 place (in memory, on external
*- paging store, or on external swapping store)?
*-
         GETPARM2 PAGIOUT,KEY=(,,MULTDEF),TYPE=YESNO,                  *
               REGS=(RVR,RAR)
         IF    ZERO,BEGIN
         IF    ((PAGIOUT,EQ,'N'),AND,PAGXFUREL),BEGIN
         SET   PAGXF1DEF               Set flag for one definition
         END   ,
         END   ,
*         VMFREE L'PAGIPARM,A=LA:PAGIPARM,LOC=GLOBHI,FIX=YES
         END   ,                       OF Parameter address
*-
*- Init global cells
*-
         LKCRE PAGCELL,TYPE=SPIN
         ST    RVR,PAGCELLK
*
         MVC   PC.PAGCELLEN,=Y(L'PGDPAGE) Length of paging cell
         MVC   PC.PAGCELID,=CL4'PGIO'  | cell ID
         MVI   PC.PAGCELBIT,L'PAGFWIOP | wait/post bit
         MVC   SC.PAGCELID,=CL4'SWIO'  | cell ID
         MVI   SC.PAGCELBIT,L'PAGFWIOS | wait/post bit
*
         LA    RS,2                    Page and swap cells
         LA    RY,PAGCEL1
         LOOP  BEGIN                   Init all dev type pools
         WITH  (PAGCEL,RY)
         LA    RB,1                    Init as one extra
         ST    RB,PAGCELXTR            |
         LA    RB,PAGCELAS             Init ASB list to empty
         ST    RB,PAGCELFP             |
         ST    RB,PAGCELBP             |
*-
*- Initialize cell pool for this device type
*-
         LH    RK,=Y(4096)             Number of cells/page
         CLEAR RJ                      |
         LH    EPAR,PAGCELLEN          |
         DR    RJ,EPAR                 |
         LR    EPAR,RK                 Number of pages
         L     RK,PAGCELAMT            |
         CLEAR RJ                      |
         DR    RJ,EPAR                 |
         IF    (RJ,NZ),'INCR RK'       | round up
         SLL   RK,12                   | pages to bytes
         LR    RJ,EPAR                 | cells/page
         VMGET (RK),LOC=GLOBHI,FIX=YES,PAGE=YES
         LR    RM,RVR                  Clear pages
         LR    RN,RK                   |
         CLEAR RB                      |
         MVCL  RM,RA                   |
         SRL   RK,12                   Number of pages
*-
*- Link all I/O cells for this device type
*-
         CLEAR PAGCELAMT               Init to zero
         LR    RM,RVR                  Starting address
         LOOP  BEGIN                   Link together all pages
         LR    RB,RJ
         LR    EPAR,RJ                 Add cells for this page
         AL    EPAR,PAGCELAMT          |
         ST    EPAR,PAGCELAMT          |
         LOOP  BEGIN                   Link together cells on a page
         WITH  (PSCPFX,RM)
         MVC   PSCFP,PAGCELHD          Point to old head
         MVC   PSCID,PAGCELID          | ID
         ST    RM,PAGCELHD             |
         PSET  @IOSIDGET               Save I/O id in this cell
         SET   @IOSFWAIT               |
         VCALL IOSIDGET                |
         ST    RVR,PSCIO               |
         AH    RM,PAGCELLEN            Next cell in page
         UNTIL (BCT,RB),END            OF Link together cells on page
         AH    RM,PAGCELLEN
         N     RM,=X'7FFFF000'
         UNTIL (BCT,RK),END            OF Link together all pages
         LA    RY,PAGCELNXT            Next cell descriptor block
         UNTIL (BCT,RS),END            OF Init all dev type pools
         EJECT
*box
*
*  Init page frame resource
*
         ACALL PFINIT                  Init page frame resource
         VMFREE L'PAGIPARM,A=L:#PIPARM,LOC=GLOBHI,FIX=YES
         PEND  ,
         SPACE
LOCKDUMMY PROC
         PEND
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Internal resolve for initizliation'
*box
*
*
*
INITRESLV PROC @RESOLVE
         PAGAD RPAG                    |
         L     RPCB,@PRPCB             Get PCB address
         WITH  (ASBPCB,RPCB)           |
         SET   @PRROK                  Assume ok to start
         L     RA,@PRVA                Get virtual addr to resolve
         LRA   RVR,@RA                 |
*-
*- If page is not in - bring it in
*-
         IF    (NOT,VAOK),BEGIN        Page not in - get frame
*-
*- Page invalid is only valid return
*-
         IF    ^PAGI,BEGIN
         BAS   RAR,INITRESAB
         END   ,
*
         VIRTABL @PRVA,(RPCB)          Page/Seg table ptrs
         L     RCPCB,@VPFPCB           | PCB to own frame
*-
*- Page invalid is the only acceptable return
*-
         IF    (NOT,@VPFPEI),BEGIN
         BAS   RAR,INITRESAB
         END   ,
         LM    RM,RN,@VPPGTE
         WITH  (PGTE,RM)
         WITH  (SPTE,RN)
         L     RJ,@VPSSTE
         WITH  (SSTE,RJ)
*-
*- Should only get "defined, not referenced" entries
*-
         IF    (^PGTFDEF,OR,PGTFREF),BEGIN
         BAS   RAR,INITRESAB
         END   ,
*-
*- Get frame, resolve address, and set page to hash value
*-
         FRAMEGET (RPCB),(RCPCB),TYPE=FIX
         L     RB,@FRA1ST
         WITH  (PFTE,RB),BEGIN         PFTE addr
         MVC   PFTVA,@PRVA
         SET   PFTFUFIX
         END   ,                       OF PFTE addr
         LR    RB,RVR                  | Frame addr
         PAGPRC (RB),(RCPCB),LA:ASBPCB Page read complete
         L     RA,@PRVA                Get virtual address
         N     RA,=A(PAGPAGM)          | start of page
         LH    RB,=Y(PAGPAGEL)         |
         REGCH (RVR,R0),(RS,R1)
         LCM   RS,B'1000',SSINIT       | Initialization value
         MVCL  RA,RVR                  |
*
         L     RA,@PRVA                Check the virtual addr
         LRA   RVR,@RA                 |
         IF    ^VAOK,BEGIN             |
INITRESAB ABORT PAGINITRES             |
         END   ,                       |
         END   ,                       OF Page not in - get frame
         PEND  ,
         TITLE 'Second stage of global initialization'
*box
*
*
*
PAGIPARM RECORD BEGIN
PAGITYPE DS    XL(L'PARMIN)
PAGIKEYS DS    3CL8                    Room for three keys
PAGIOUT  DS    CL(L'@DSDSN)            Room for output area
         END   ,
         SPACE
#PAGINI2 RECORD BEGIN
#PAGI2DS1 DS   A                       Addr 1st paging DS descriptor
#PAGI2DSL DS   A                       Last paging DS descriptor
#PAGI2CNT DS   A                       Data set count
#PAGI2SEG DS   XL(L'SEGCBD)            Seg control block
#PAGI2WTO DS   CL64                    WTO buffer
         END   ,
         SPACE
PAGINIT2 PROC  SCOPE=GLOBAL
         PAGAD RPAG
         WITH  (PAGCEL,PAGPGCEL),LABEL=PC
         WITH  (PAGCEL,PAGSWCEL),LABEL=SC
         VMGET L'PAGIPARM,LOC=GLOBHI   Get memory for parameters
         LR    RN,RVR                  |
         WITH  (PAGIPARM,RN)
*-
*- Get memory for dynamic allocs
*-
         VMGET L'PGDDAL,LOC=GLOBHI,FIX=YES,PAGE=YES
         LR    RM,RVR
         WITH  (PGDDAL,RM)
*-
*- Get I/O id
*-
         PSET  @IOSIDGET
         SET   @IOSFWAIT
         VCALL IOSIDGET
         LR    RA,RVR
         SPACE 2
*-
*- Open up page datasets
*-
         PSET  @OPENDS
         PMOV  @OPNPARM,LA:PAGIPARM
         PMOV  @OPNDAL,LA:PGDDAL
         PMOV  @OPNID,(RA)
         LCALL PAGOPEN
*-
*- Open up swap datasets
*-
         LCALL SWPOPEN
*-
*- Free I/O id
*-
         PSET  @IOSIDFRE               Free I/O id
         PMOV  @IOSFID,(RA)            |
         VCALL IOSIDFRE                |
*-
*- Free memory for dynamic allocs
*-
         VMFREE A=LA:PGDDAL,L'PGDDAL,LOC=GLOBHI,FIX=YES
*-
*- Free memory for parameter area
*-
         VMFREE A=LA:PAGIPARM,L'PAGIPARM,LOC=GLOBHI
*-
*- Set up lock manager routines for real
*-
         MVC   PAGLKOB,=V(LKOB)
         MVC   PAGLKREL,=V(LKREL)
*-
*- Set up real page fault resolution routine
*-
         MVC   PAGRESLV,=A(RESOLVE)
*-
*- Now set up swap address space
*-
         PSET  @ACREATE
         MVC   @ACRPSW(4),=X'070C0000'
         MVC   @ACRPSW+4(4),=A(X'80000000'+PAGESWAP)
         VCALL ACREATE
         PEND  ,
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Open paging datasets'
@OPENDS  RECORD BEGIN
@OPNPARM DS    A                       Address of parameter work area
@OPNDAL  DS    A                       Dynamic Alloc area
@OPNID   DS    A                       I/O id for our init
         END   ,
         SPACE ,
PAGOPEN  PROC  @OPENDS,#PAGINI2
         PAGAD RPAG
         L     RN,@OPNPARM
         WITH  (PAGIPARM,RN)
         WITH  (PARMIN,PAGITYPE)
         CLEAR PARMIN
         L     RM,@OPNDAL
         WITH  (PGDDAL,RM)             Addr to PGDDAL
         WITH  (#PIOOPEN,DALPDAT)
         WITH  (#PIRESET,DALPRSET)
         WITH  (#SWPOPEN,DALSDAT)
         WITH  (#SWPRSET,DALSRSET)
         WITH  (@DSALLO,DALAINFO)
         WITH  (#PFINFO,DALOINFO)
*-
*- Set up to get paging data set names
*-
         REGCH (RVR,R0),(RS,R1),(RAR,R14),(EPAR,R15)
         SET   PARMFSTR                String type parameters
         MVC   PAGIKEYS,=CL8'PAGING'   Keywords
         MVC   PAGIKEYS+8(8),=CL8'PAGE'
*
         CLEAR #PAGI2CNT,#PAGI2DSL
         CLEAR (RA),(RB)
OPENPG   LOOP  BEGIN                   Open all paging datasets
         L     RY,#PAGI2DSL            Last DS descriptor
         GETPARM2 PAGIOUT,,2,TYPE=STRING,REGS=(RJ,RAR)
         IF    ^ZERO,EXIT,OPENPG       No parameter found
*-
*- Allocate data set descriptor block
*-
         LR    RB,RY
         VMGET L'DSDES,LOC=GLOBHI,FIX=YES,ONEPAGE=YES
         LR    RY,RVR
         IF    (RB,ZERO),BEGIN         First dataset
         ST    RY,#PAGI2DS1
         END   ,
         ELSE  BEGIN                   Not first dataset
         WITH  (DSDES,RB)
         ST    RY,DSCHAIN
         END   ,                       OF Not first dataset
         WITH  (DSDES,RY)
         CLEAR DSDES
         MVC   DSAID,=CL4'BMCB'        Set ID
         ST    RA,DSOFFSET             DS starts w/ this block
*-
*- Clear fields
*-
         CLEAR #PIOOPEN                Clear channel prog
         CLEAR #PFINFO                 | and info area
         CLEAR @DSALLO                 Clear DS info
         LA    RVR,@DSDSN              Get DSN
         LA    RS,L'@DSDSN             | blank area 1st
         LCM   EPAR,8,=C' '            | |
         MVCL  RVR,RAR                 |
         CEIL  RK,=Y(L'@DSDSN)         | move in name (len)
         DEX   RK,'MVC @DSDSN(0),@RJ'  | location
*
         MVC   #PIOOCMD,=A(#PCOPEN)
         LRA   RB,@DSALLO              Allocation parms
         ST    RB,#PIOALLO             |
         LRA   RB,#PFINFO              Open info - return
         ST    RB,#PIOINFO             |
*-
*- Get a channel ID
*-
         LA    RB,#IOUPAGE             Device type
         SYSCTL (RB),TYPE=ALLOC
         IF    (RB,ZERO),'ABORT NOPAGCHID'
         ST    RB,DSCHID               Save channel ID
*-
*- Do the I/O
*-
         USING PZERO,R0
         PSET  @IOSDOIO
         PMOV  @IOSCHID,(RB)           Channel ID
         PMOV  @IOSID,@OPNID           I/O ID
         PMOV  @IOSPID,PZCURPID        This process ID
         PMOV  @IOSCP,LA:#PIOOPEN      Channel program
         LR    RB,RA                   Use PSW key - save RA
         REGCH (RA,R2)                 | hardware uses R2
         IPK   ,                       |
         STC   RA,@IOSKEY              |
         LR    RA,RB                   |
         SET   @IOSFSYNC               Do it as synchronous I/O
         VCALL IOSDOIO                 | Do DASD allocation
         DROP  R0                      |
         IF    (RVR,NZ),BEGIN          Paging DS open error
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEGB  'Page dataset open failed'
         SEGHEX @DSRTN
         SEGHEX @DSERR
         SEGHEX @DSRSN
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         SEGCLR ,
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   @DSDSN
         SEG   ' on '
         SEG   @DSVOL
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write DSN
         VMFREE L'DSDES,A=LA:DSDES,LOC=GLOBHI,FIX=YES
         NEXT  OPENPG
         END   ,                       OF Paging DS open error
         L     RB,#PFIBKS              Number of blocks in DS
         ST    RB,DSCOUNT              |
         ST    RB,DSAVAIL              |
*-
*- Reset paging device
*-
         CLEAR #PIRESET
         PMOV  #PIOTCMD,LA:#PCRESET
         USING PZERO,R0
         PSET  @IOSDOIO
         PMOV  @IOSCHID,DSCHID         Channel ID
         PMOV  @IOSID,@OPNID           I/O ID
         PMOV  @IOSPID,PZCURPID        This process ID
         PMOV  @IOSCP,LA:#PIRESET      Channel program
         LR    RB,RA                   Use PSW key - save RA
         REGCH (RA,R2)                 | hardware uses R2
         IPK   ,                       |
         STC   RA,@IOSKEY              |
         LR    RA,RB                   |
         SET   @IOSFSYNC               Do it as synchronous I/O
         VCALL IOSDOIO                 | Do DASD allocation
         DROP  R0                      |
         IF    (RVR,NZ),BEGIN          Failed reset of page device
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEGB  'Page dataset initialization failed'
         SEGHEX @DSRTN
         SEGHEX @DSERR
         SEGHEX @DSRSN
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         SEGCLR ,
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   @DSDSN
         SEG   ' on '
         SEG   @DSVOL
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write DSN
         VMFREE L'DSDES,A=LA:DSDES,LOC=GLOBHI,FIX=YES
         NEXT  OPENPG
         END   ,                       OF Failed reset of page device
*-
*- Successful open and init.  Set this as last DS
*-
         PMOV  #PAGI2DSL,LA:DSDES
*-
*- Allocate bitmap and initialize it
*-
         L     RB,DSCOUNT              Bytes required for map
         ALR   RA,RB                   Total number so far
         LA    RB,@RB+7                |
         SRL   RB,3                    |
         VMGET (RB),LOC=GLOBHI,FIX=YES
         ST    RVR,DSLOC               Bitmap location
         ST    RB,DSLEN                | and length
         REGCH (RAR,R14),(EPAR,R15)
         LR    RAR,RVR                 Init bit map - location
         LR    EPAR,RB                 | and len
         LCM   RB,8,=X'FF'             | fill w/ ones
         MVCL  RAR,RA                  |
*
         INCR  RS,#PAGI2CNT            One more dataset
         END   ,                       OF Open all paging datasets
*
         WITH  (DSDES,RY),BEGIN        Complete circular chain
         IF    (RY,NZ),BEGIN
         MVC   DSCHAIN,#PAGI2DS1
         END   ,
         END   ,                       OF Complete circular chain
         ST    RA,PAGXPRCNT            Total avail in PAGE DSs
         ST    RA,PAGMXPG               and save the total there
*-
*- Check to see if we have enough external frames
*-
         GETPARM2 KEY=(PAGING,XPAG_MIN),REGS=(RVR,RAR)
         LA    RB,1000
         IF    ZERO,'LR RB,RVR'
         IF    (RA,LT,RB),BEGIN
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   'External page frame shortage'
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         ABORT PAGNOXPG
         END   ,
*-
*- Move initial external page frame bitmap to first real dataset
*- bitmap.
*-
         L     RA,PAGXPDS
         WITH  (DSDES,RA),LABEL=OLD,BEGIN
         L     RB,#PAGI2DS1
         WITH  (DSDES,RB),LABEL=NEW
         ST    RB,PAGXPDS              First external paging DS
         ST    RB,PAGXPCUR             | and current
         L     RK,#PAGI2CNT            Number of paging DSs
         STH   RK,PAGXPN               |
         L     RK,OLD.DSCOUNT          Number allocated
         SL    RK,OLD.DSAVAIL          |
         LCR   RJ,RK                   | negative
         A     RJ,NEW.DSCOUNT          |
         IF    NEG,PI2ABORT            | too many for 1st DS
         ST    RJ,NEW.DSAVAIL          |
         LCR   RJ,RK                   | adjust total available
         A     RJ,PAGXPRCNT            |
         ST    RJ,PAGXPRCNT            |
*-
*- Copy bitmap
*-
         L     RK,OLD.DSLEN
         S     RK,NEW.DSLEN
         IF    (RK,POS),BEGIN          Old bitmap is longer
         L     RJ,OLD.DSLOC            Make sure extra is all free
         AL    RJ,NEW.DSLEN            | start of extra, RK = len
         CLEAR RS                      |
         LCM   RS,8,=X'FF'             |
         CLCL  RJ,RVR                  |
         IF    NE,PI2ABORT
         END   ,                       OF Old bitmap is longer
         L     RK,OLD.DSLEN            Len of copy
         L     RJ,NEW.DSLEN            |
         CEIL  RK,RJ                   | Don't copy more than new len
         L     RJ,OLD.DSLOC            Source
         L     RVR,NEW.DSLOC           Dest
         LR    RS,RK                   | len
         MVCL  RVR,RJ                  |
*-
*- Free old BM and associated control block
*-
         VMFREE L:OLD.DSLEN,A=L:OLD.DSLOC,LOC=GLOBHI,FIX=YES
         VMFREE L'DSDES,A=LA:OLD.DSDES,LOC=GLOBHI,FIX=YES
         END   ,                       OF Labeled DSDES usings
         PEND  ,
         SPACE
PI2ABORT ABORT PAG2INIT                1st paging DS to small
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
         LTORG ,
         TITLE 'Open swap datasets'
SWPOPEN  PROC  @OPENDS,#PAGINI2
         PAGAD RPAG
         L     RN,@OPNPARM
         WITH  (PAGIPARM,RN)
         WITH  (PARMIN,PAGITYPE)
         CLEAR PARMIN
         L     RM,@OPNDAL
         WITH  (PGDDAL,RM)             Addr to PGDDAL
         WITH  (#PIOOPEN,DALPDAT)
         WITH  (#PIRESET,DALPRSET)
         WITH  (#SWPOPEN,DALSDAT)
         WITH  (#SWPRSET,DALSRSET)
         WITH  (@DSALLO,DALAINFO)
         WITH  (#PFINFO,DALOINFO)
*box
*
*  External frame init - swapping
*
         LKCRE PAGXSWP,TYPE=SPIN       External swapping lock
         ST    RVR,PAGXSL              |
*
         CLEAR RA                      No blocks yet
         CLEAR RB                      First DS block
*-
*- Set up to get swap data set names
*-
         REGCH (RVR,R0),(RS,R1),(RAR,R14),(EPAR,R15)
         MVC   PAGIKEYS,=CL8'PAGING'   Keywords
         MVC   PAGIKEYS+8(8),=CL8'SWAP'
*
         CLEAR #PAGI2CNT,#PAGI2DSL     Count datasets
OPENSWP  LOOP  BEGIN                   Open all swapping datasets
         L     RY,#PAGI2DSL
         GETPARM2 PAGIOUT,,2,TYPE=STRING,REGS=(RJ,RAR)
         IF    ^ZERO,BEGIN             No parameter found
         EXIT  OPENSWP
         END   ,                       OF No parameter found
*-
*- Allocate data set descriptor block
*-
         LR    RB,RY
         VMGET L'DSDES,LOC=GLOBHI,FIX=YES,ONEPAGE=YES
         LR    RY,RVR
         IF    (RB,ZERO),BEGIN         First dataset
         ST    RY,PAGXSDS              External paging DSs
         ST    RY,PAGXSCUR             | current in round robin
         END   ,
         ELSE  BEGIN                   Not first dataset
         WITH  (DSDES,RB)
         ST    RY,DSCHAIN
         END   ,                       OF Not first dataset
         WITH  (DSDES,RY)
         CLEAR DSDES
         MVC   DSAID,=CL4'BMCB'        Set ID
*-
*- Clear fields
*-
         CLEAR #SWPOPEN                Clear channel prog
         CLEAR #PFINFO                 | and info area
         CLEAR @DSALLO                 Clear DS info
         LA    RVR,@DSDSN              Get DSN
         LA    RS,L'@DSDSN             | blank area 1st
         LCM   EPAR,8,=C' '            | |
         MVCL  RVR,RAR                 |
         CEIL  RK,=Y(L'@DSDSN)         | move in name (len)
         DEX   RK,'MVC @DSDSN(0),@RJ'
*
         MVC   #SWPOCMD,=A(#SWCOPEN)
         LRA   RB,@DSALLO              Allocation parms
         ST    RB,#SWPALLO             |
         LRA   RB,#PFINFO              Open info - return
         ST    RB,#SWPINFO             |
*-
*- Get a channel ID
*-
         LA    RB,#IOUSWAP             Device type
         SYSCTL (RB),TYPE=ALLOC
         IF    (RB,ZERO),'ABORT NOSWPCHID'
         ST    RB,DSCHID               Save channel ID
*-
*- Do the I/O
*-
         USING PZERO,R0
         PSET  @IOSDOIO
         PMOV  @IOSCHID,(RB)           Channel ID
         PMOV  @IOSID,@OPNID           I/O ID
         PMOV  @IOSPID,PZCURPID        This process ID
         PMOV  @IOSCP,LA:#SWPOPEN      Channel program
         REGCH (RA,R2)                 | hardware uses R2
         IPK   ,                       |
         STC   RA,@IOSKEY              |
         SET   @IOSFSYNC               Do it as synchronous I/O
         VCALL IOSDOIO                 | Do DASD allocation
         DROP  R0                      |
*
         IF    (RVR,NZ),BEGIN
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEGB  'Swap dataset open failed'
         SEGHEX @DSRTN
         SEGHEX @DSERR
         SEGHEX @DSRSN
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         SEGCLR ,
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   @DSDSN
         SEG   ' on '
         SEG   @DSVOL
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write DSN
         VMFREE L'DSDES,A=LA:DSDES,LOC=GLOBHI,FIX=YES
         NEXT  OPENSWP
         END   ,
*  Swap DSs must be one extent
         IF    (NOT,#PFOCNTG),BEGIN
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   'Swap dataset format error'
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         SEGCLR ,
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   @DSDSN
         SEG   ' on '
         SEG   @DSVOL
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write DSN
         VMFREE L'DSDES,A=LA:DSDES,LOC=GLOBHI,FIX=YES
         NEXT  OPENSWP
         END   ,
         PMOV  DSCOUNT,#PFIBKS         Save number of blocks in DS
*-
*- Reset swapping device
*-
         CLEAR #SWPRSET
         PMOV  #SWPRCMD,LA:#SWCRSET
         USING PZERO,R0
         PSET  @IOSDOIO
         PMOV  @IOSCHID,DSCHID         Channel ID
         PMOV  @IOSID,@OPNID           I/O ID
         PMOV  @IOSPID,PZCURPID        This process ID
         PMOV  @IOSCP,LA:#SWPRSET      Channel program
         REGCH (RA,R2)                 | hardware uses R2
         IPK   ,                       |
         STC   RA,@IOSKEY              |
         SET   @IOSFSYNC               Do it as synchronous I/O
         VCALL IOSDOIO                 | Do DASD allocation
         DROP  R0                      |
         IF    (RVR,NZ),BEGIN
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEGB  'Swap dataset initialization failed'
         SEGHEX @DSRTN
         SEGHEX @DSERR
         SEGHEX @DSRSN
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         SEGCLR ,
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   @DSDSN
         SEG   ' on '
         SEG   @DSVOL
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write DSN
         VMFREE L'DSDES,A=LA:DSDES,LOC=GLOBHI,FIX=YES
         NEXT  OPENSWP
         END   ,
*-
*- Allocate bitmap and initialize it
*-
         L     RB,DSCOUNT
         REGCH (RAR,R14),(EPAR,R15)
         LR    EPAR,RB                 How many clusters?
         CLEAR RAR                     |
         LH    RVR,PAGSWXN             |
         DR    RAR,RVR                 |
         ST    EPAR,DSCOUNT            | these clusters
         ST    EPAR,DSAVAIL            | all available
         L     RAR,PAGXSRCNT           Total number of clusters avail
         ALR   RAR,EPAR                |
         ST    RAR,PAGXSRCNT           |
         ST    RAR,PAGMXSW             and save the total there
         LA    RB,@EPAR+7              Bytes required for map
         SRL   RB,3                    |
         VMGET (RB),LOC=GLOBHI,FIX=YES
         ST    RVR,DSLOC               Bitmap location
         ST    RB,DSLEN                | and len
         REGCH (RAR,R14),(EPAR,R15)
         LR    RAR,RVR                 Init bit map - location
         LR    EPAR,RB                 | and len
         LCM   RB,8,=X'FF'             | fill w/ ones
         MVCL  RAR,RA                  |
*
         INCR  RS,#PAGI2CNT            One more dataset
         PMOV  #PAGI2DSL,LA:DSDES      Set most recent DS descriptor
         END   ,                       OF Open all swapping datasets
         WITH  (DSDES,RY),BEGIN        Complete circular chain
         IF    (RY,NZ),BEGIN
         MVC   DSCHAIN,PAGXSDS
         END   ,
         END   ,                       OF Complete circular chain
*-
*- Check to see that we have enough swap room
*-
         L     RA,PAGXSRCNT            Number of swap blocks
         MH    RA,PAGSWXN              |
         GETPARM2 KEY=(PAGING,XSWP_MIN),REGS=(RVR,RAR)
         LA    RB,1000
         IF    ZERO,'LR RB,RVR'
         IF    (RA,LT,RB),BEGIN
         WITH  (SEGCBD,#PAGI2SEG)
         SEGDEF LA:SEGCBD
         SEGINIT #PAGI2WTO
         L     RJ,MATPTR
         WITH  (MAT,RJ),'SEGB MATSNAME'
         SEG   'External swap frame shortage'
         ORVWTO L:SEGADD,LH:SEGCNT,DELETE=NO    Write descriptive msg
         ABORT PAGNOXSWAP
         END   ,
*
         L     RS,#PAGI2CNT            Count of datasets
         STH   RS,PAGXSN               |
         PEND  ,
         TITLE 'MP-ORVYL Real Memory / Paging Manager Services'
*-
*- Some initialization defaults
*-
         SPACE
PAGMXHST EQU   X'00010000'             Must be greater than this to
*                                      stay in core - (LSB of 1st
*                                      byte)
CPAGLASP EQU   X'03'                   Do LASP if different, use
*                                      LASP area AX, do secondary
CPAGIOKEY EQU  X'F0'                   Default key for swap IO
CPAGCEL  EQU   256                     Number of paging cells
CSWPCEL  EQU   25                      Number of swapping cells
CSWPAVG  EQU   80                      Average size of swap cell
PFRESLIM EQU   40                      Limit the amount of core
*                                      we reserve per address space
*                                      in core
         EJECT
         XTRCDATA ,
         END   .
