TERMINAL TITLE 'Orvyl Terminal Manager'
         COPY  HEADER
         EJECT ,
TERMINAL MODULE TRCNUM=2
         TITLE 'Global Control Blocks'
         COPY  PZERO
         USING (PZERO,R0)
         EJECT ,
         COPY  MAT
         EJECT ,
         COPY  ASB
         EJECT ,
         COPY  ACCTPARM
         EJECT ,
         COPY  DISPPARM
         EJECT ,
         COPY  LOCKPARM
         EJECT ,
         COPY  IOSPARM
         EJECT ,
         COPY  TIMEPARM
         EJECT ,
         COPY  VMPARM
         EJECT ,
         COPY  VMIPARM
         EJECT ,
         COPY  PAGEPARM
         EJECT ,
         COPY  XITPARM
         EJECT ,
         COPY  TERMPARM
         EJECT
         COPY  PARMPARM
         EJECT ,
         COPY  SCOMPARM
SCOMPLEN EQU   L'#SCSR+20*8            Room for 20 Segments
         TITLE 'Local Macros'
         MACRO
&L       FIX   &LOC,&LEN
&L       PSET  @PAGE
         PMOV  @PAGLOC,&LOC,OP=LA
         PMOV  @PAGLEN,&LEN,OP=LA
         VCALL PAGFIX
         MEND
         SPACE 2
         MACRO
&L       UNFIX &LOC,&LEN
&L       PSET  @PAGE
         PMOV  @PAGLOC,&LOC,OP=LA
         PMOV  @PAGLEN,&LEN,OP=LA
         VCALL PAGUFIX
         MEND
         SPACE 2
         MACRO
&L       ADDSG &LOC,&LEN,&PARM
&L       PSET  @ADDSEG,CLEAR=NO
         PMOV  @ADDSLOC,&LOC,OP=LA
         PMOV  @ADDSLEN,&LEN,OP=LA
         PMOV  @ADDSPA,&PARM,OP=LA
         ACALL ADDSEG
         MEND  ,
         SPACE 2
         MACRO
&L       FREEB &TBUF
&L       PSET  @FRTBUF
         PMOV  @FRTBLOC,&TBUF,OP=LA
         ACALL FREETBUF
         MEND  ,
         EJECT ,
         MACRO
&L       VALBUF &LOC,&LEN,&KEY,&TYPE
&L       PSET  @VALBUF
         PMOV  @VALBLOC,&LOC,OP=L
         PMOV  @VALBLEN,&LEN,OP=LH
         PMOV  @VALBKEY,&KEY,OP=IC
         AIF   ('&TYPE' NE 'W').NOWRT
         SET   @VALBWRT
.NOWRT   ANOP
         ACALL VALBUF
         MEND
         TITLE 'Local Control Blocks'
*****************************************************************
*                                                               *
*    GTCT  --  Global Terminal Control Table.  This is the main *
*              terminal control block for the system.  It is    *
*              pointed to by the MAT.                           *
*                                                               *
*****************************************************************
         SPACE 2
GTCT     RECORD BEGIN
         DC    C'GTCT'       Control block ID
GTCTLOCK DS    A             Lock ID for GTCT related resources
*
* Terminal buffer information
*
GTCTTBSZ DS    H             Total size of the TBUFs (incl. header)
GTCTTBTC DS    A             Total count of TBUFs obtained
GTCTTBFC DS    A             Count of the TBUFs on the free queue
         DS    0D
GTCTTBFL DS    A             Free list of the TBUFs
         DS    A             Control word for the Free list
*
* Terminal device specific control blocks
*
GTCTMILC DS    A             Address of the MILTEN control block
*
* Terminal Driver Address space IDs
*
GTMILAS  DS    A             Address of the MILTEN driver ASB
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    TBUF  --  Terminal I/O buffer.                             *
*                                                               *
*****************************************************************
         SPACE 2
TBUF     RECORD BEGIN
         DC    C'TBUF'       Control block ID
TBUFNEXT DS    A             Next TBUF in the list
TBUFMAXL DS    H             Maximum length of the data
TBUFLEN  DS    H             Actual length of the data
TBUFDATA DS    0D            Start of the data
         END   ,
         TITLE 'MILTEN Terminal Control Blocks'
*****************************************************************
*                                                               *
*   MILCB  --  MILTEN control block. This area contains info    *
*              about the state of the MILTEN terminal           *
*              interface.                                       *
*                                                               *
*****************************************************************
         SPACE 2
MILCB    RECORD BEGIN
         DC    C'MILC'       Control block ID
MILMAXLN DS    H             Maximum MILTEN line number
MILCLTAB DS    A             Address of the line table
*
* Milten Subsystem identification
*
MILONAM  DS    CL8           Our name to Milten
MILMNAM  DS    CL8           His name to us
MILWNAM  DS    CL8           Wylbur's name to us
MILPASS  DS    CL4           Password for the path
*
* Path I/O information
*
MILCIOCB DS    A             Addr of I/O control block
MILCIOPA DS    A             I/O parameter area
MILCPATH DS    A             Device ID of the Milten path
*
* Full Queue information
*
MILCFQCB DS    A             Addr of Full queue control block
*
* Path status
*
MILCFLG  FLAG  ,             Path status flags (same as PATHFL)
         FLAG  CLOSED          The path closed
         FLAG  FULLQE          His full queue emptied
         FLAG  NEWINFO         New information pending
         FLAG  DISCPOST        Discretionary post
         FLAG  OPENED          The partner opened his end
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    FQCB  --  Full Queue control block.  This block lives in   *
*              global storage and acts as an anchor for the     *
*              MFQEs.                                           *
*                                                               *
*****************************************************************
         SPACE 2
FQCB     RECORD BEGIN
         DC    C'FQCB'       Control block ID
FQCBCNT  DS    A             Count of the full Q's
FQCBLOCK DS    A             Lock ID of chain lock
FQCBHEAD DS    A             Address of the oldest MFQE
FQCBTAIL DS    A             Address of the newest MFQE
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*     MIB  --  Milten terminal initialization block.  This is   *
*              allocated from global storage and pointed to by  *
*              the ASB until initialization is finished.        *
*                                                               *
*****************************************************************
         SPACE 2
MIB      RECORD BEGIN
         DC    C'MIB '       Control block ID
MIBTBUF  DS    A             Address of the logon PDB TBUF
MIBPATH  DS    A             Device ID of the MILTEN path
MIBFQCB  DS    A             Address of the Full Queue control block
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    MTCB  --  MILTEN Terminal Control block.  This area        *
*              lives in local storage and contains much of the  *
*              device specific information neede for MILTEN     *
*              terminals.                                       *
*                                                               *
*****************************************************************
         SPACE 2
MTCB     RECORD BEGIN
         DC    C'MTCB'       Control block ID
MTCBLINE DS    H             Milten line number
MTCBWYLN DS    CL8           Wylbur's name
MTCBPATH DS    A             Device ID for the Milten path
MTCBFQCB DS    A             Address of the FQCB
MTCBPDB  DS    A             PDB for I/O
MTCBSIB  DS    A             Address of our copy of the Milten SIB
MTCBIOPA DS    A             Address of the SCOM I/O parm area
MTCBWMW  DS    A             Current Wylbur mode word
MTCBFLGS FLAG  ,             Milten flags
         FLAG  MTFLFRED        First read edit done
         FLAG  MTFLSLOW        The current I/O is a slow one
         FLAG  MTFLWATN        Signal an attn to WYLBUR
         FLAG  MTFLWCME        Signal command error to WYLBUR
         FLAG  MTFLLGOF        Logging off
*
MTCBTBUF DS    A             Return buffer from Milten
MTCBTKID DS    D             ID of task to wake upon milten response
MTCBIOCP DS    A             Exit request ID for I/O complete
MTCBATTN DS    A             Exit request ID for Attention
MTCBTIMO DS    A             Exit request ID for timeout
MTCBLGOF DS    A             Exit request ID for logoff
*
* Mode 1 terminal I/O information
*
MT1RQTK  DS    A             Task ID of requesting task
MT1RQID  DS    A             Current Request ID
MT1WR01  DS    A             Wait return for R1
MT1WR14  DS    A             Wait return for R14
MT1WR15  DS    A             Wait return from R15
*
MT1IBLOC DS    A             Location of the input (read) buffer
MT1IBLEN DS    H             Length of the input buffer
MT1TIMO  DS    A             Timeout value
MT1TIMER DS    A             Real-time timer ID
*
MT1ATSK  DS    A             Task Id of task handling attentions
MT1IACT  DS    X             Count of Idle ATTNs since last read
*
MT1CNTL  DS    X             Control number
MT1RKEY  DS    X             PSW key of user issuing request
*
MT1CFLG  FLAG  ,             Terminal control flags
         FLAG  MT1FCC         Write lines have CC in col 1
         FLAG  MT1FNWNL       Write lines not ended by NL
         FLAG  MT1FREWR       Write data on a Read edit
         FLAG  MT1FCIO        Control I/O started in main task
*
* Program info passed around in the PDB's (maps the area in the PDB)
*
         DS    0A
MT1PGM   DS    CL8           Program name
MT1CPUT  DS    F             CPU time used (timer units)
MT1PFLG  FLAG  ,             Program name flags
         FLAG  MT1PRUN         Program is running (not session break)
         FLAG  MT1PAUTH        Program is authorized
MT1DIOCT DS    AL3           Count of orvyl disk I/Os
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    MFQE  --  Milten Full queue entry.  This control block     *
*              represents a send on the milten path that got a  *
*              full queue and could not continue.               *
*                                                               *
*****************************************************************
         SPACE 2
MFQE     RECORD BEGIN
         DC    C'MFQE'       Control block ID
MFQENEXT DS    A             Next in the list
MFQEASB  DS    A             ASB address of waiting Address space
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*     PDB  --  Passed Data Block.  This control block specifies *
*              the format of the messages passed between MILTEN *
*              and ORVYL on the SCOM path.  It is also passed   *
*              between WYLBUR and ORVYL via MILTEN and so some  *
*              of the WYLBUR/ORVYL communication protocol is    *
*              also specified here.                             *
*                                                               *
*****************************************************************
         SPACE 2
XPDB     RECORD BEGIN
         PDB   TYPE=ALL
PDB      EQU   PDBLIN#,PDBTEXT-PDBLIN#,C'X'      Real PDB area
         EJECT ,
*
*    W Y L B U R   C O M M U N I C A T I O N   A R E A S
*
         COPY  FORVCMDS
         COPY  FWYLRTNS
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*     SIB  --  Session Information Block.  This is a MILTEN     *
*              control block containing session information of  *
*              interest to ORVYL and WYLBUR.  The contents of   *
*              this can be requested from MILTEN and may also   *
*              be sent to MILTEN for updating its copy.  The    *
*              update count determins whether an update is      *
*              needed or not.  The current value of the update  *
*              count is passed in each PDB from MILTEN.         *
*                                                               *
*****************************************************************
         SPACE 2
         RECORD 'SIB'
         TITLE 'Initialization'
*****************************************************************
*                                                               *
* TERMINIT --  This is entered from global initialization       *
*              as a subroutine of the initialization task.  It  *
*              starts up any address spaces that are needed to  *
*              act as servers for the different types of        *
*              terminals.                                       *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TERMINIT PROC  SCOPE=GLOBAL
         L     RM,MATPTR               Get the MAT pointer
         WITH  (MAT,RM)
*
* First allocate our global control block
*
         VMGET L'GTCT,LOC=GLOBHI,FIX=YES
         LR    RY,RVR                  Copy the address
         WITH  (GTCT,RY)
         CLEAR GTCT                    Zero it out
         MVC   GTCT(4),=C'GTCT'        Move in the control block ID
         MVC   GTCTTBSZ,=Y(8192+L'PDB+L'TBUF)    Allow for 8K xfers
         LKCRE GTCTLOCK                Get a lock
         ST    RVR,GTCTLOCK            Save the lock ID
         ST    RY,MATGTCT              Save the GTCT address
*
* Start up the MILTEN terminal server address space
*
         PSET  @ACREATE
         MVC   @ACRPSW(4),=X'070C0000' Default location
         OC    @ACRPSW+1(1),MATSKEY    System Key
         MVC   @ACRPSW+4(4),=A(X'80000000'+MILTERM)
*        L     RS,=V(ASMTASK)          Get the address
*        O     RS,=X'80000000'         Set 31 bit mode
*        ST    RS,@ACRPSW+4            Save in the PSW
*        MVC   @ACRPARM,=A(X'80000000'+MILTERM)
         VCALL ACREATE                 Create the address space
         ST    RVR,GTMILAS             Save the ASB address
*
* Start up other terminal servers
*
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* TERMINAS --  This is called from a new address space when it  *
*              starts up to initialize terminal communications  *
*              for that address space.                          *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TERMINAS PROC  SCOPE=GLOBAL
*
* Make sure that the Central Terminal routines have had time to
* place the terminal communications control block address in the ASB
*
         L     RM,PZMATP               Get the MAT pointer
         WITH  (MAT,RM),'L RM,MATGTCT' Get the GTCT pointer
         IF    (RM,Z),EXIT             No GTCT yet
         WITH  (GTCT,RM),BEGIN
         LKOB  GTCTLOCK                Obtain the Terminal lock
         LKREL GTCTLOCK                Now it can be freed
         END   ,
*
* Get the terminal control block
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the TCCB address
         IF    (RX,Z),EXIT             No terminal for this AS
*
* Call the proper initialization routine, depending on the
* terminal type.
*
         IF    (@RX,EQ,'M'),BEGIN      Milten Terminal
         ACALL MILIAS                  Go set up the milten terminal
         EXIT  TERMINAS
         END   ,
         ABORT BADTCCB                 What kind is it?
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* TERMINUI --  This is called from a new address space when it  *
*              is able to wait.  It sets up user information    *
*              for that address space.                          *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TERMINUI PROC  SCOPE=GLOBAL
*
* Get the terminal control block
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the TCCB address
         IF    (RX,Z),EXIT             No terminal for this AS
*
* Call the proper initialization routine, depending on the
* terminal type.
*
         IF    (@RX,EQ,'M'),BEGIN      Milten Terminal
         ACALL MILIUSI                 Get user info from Milten
         EXIT  TERMINUI
         END   ,
         ABORT BADTCCB                 What kind is it?
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* TERMLGOF --  This is called from a when an address space is   *
*              terminating.  It frees up any control blocks or  *
*              devices that are held by that address space with *
*              regard to terminals.                             *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TERMLGOF PROC  SCOPE=GLOBAL
*
* Get the terminal control block
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the TCCB address
         IF    (RX,Z),EXIT             No terminal for this AS
*
* Call the proper termination routine, depending on the
* terminal type.
*
         IF    (@RX,EQ,'M'),BEGIN      Milten Terminal
         ACALL MILLGOF                 Go logoff the milten terminal
         EXIT  TERMLGOF
         END   ,
         ABORT BADTCCB                 What kind is it?
         PEND  ,
         EJECT ,
         TITLE 'Terminal Information request'
*****************************************************************
*                                                               *
*  TERUINF -  Returns descriptive terminal information          *
*                                                               *
*   Input  --  @TERUINF                                         *
*                                                               *
*  Output  --  @TERUINF                                         *
*                                                               *
*****************************************************************
TERUINF  PROC  @TERUINF,SCOPE=GLOBAL
         L     RX,PZCURASB             Current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get TCCB addr
         IF    (RX,Z),EXIT             No terminal this AS
         IF    (@RX,EQ,'M'),BEGIN      Milten style terminal
         PSET  @MILUINF
         PMOV  @MILUPTR,LA:@TERUINF
         ACALL MILUINF
         EXIT  TERUINF
         END   ,                       OF Miltem style terminal
         ABORT BADTCCB                 What type is it?
         PEND  ,
         LTORG ,
         TITLE 'MILTEN Terminal Control - Central'
*****************************************************************
*                                                               *
*  MILTERM --  This is the main entry point for MILTEN terminal *
*              control.  It initializes the MILTEN interface    *
*              and routes input from the path to the correct    *
*              address spaces.                                  *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TIPARMS  RECORD BEGIN                  Terminal init parms
TITYPE   DS    XL(L'PARMIN)            Parameter request type
TIKEY1   DS    CL8                     Keyword 1
TIKEY2   DS    CL8                     | 2
TIKEY3   DS    CL8                     | 3
TIOUT    DS    CL12                    Output string area
         END   ,
         SPACE ,
MILTERM  PROC  SCOPE=LOCAL
         L     RM,MATPTR               Get the MAT pointer
         WITH  (MAT,RM),'L RM,MATGTCT' Address of the global CB
         WITH  (GTCT,RM)
         VCALL DISPSHLD                Make us non-swapable
*
*  Give this address space system-AS priority
*
         VCALL ASSYSTSK
*
* Allocate our Milten Control block
*
         VMGET L'MILCB,LOC=LOCSYS,FIX=YES
         LR    RN,RVR
         ST    RN,GTCTMILC             Save the address in the GTCT
         WITH  (MILCB,RN)
         CLEAR MILCB                   Clear it out
         MVC   MILCB(4),=C'MILC'       Control block id
*
* Fill in default info
*
         L     RS,PZMATP               Get the MAT address
         WITH  (MAT,RS),BEGIN
         MVC   MILONAM,MATSNAME        Our name
         END   ,
         MVC   MILMNAM,=CL8'MILTEN'
         MVC   MILPASS,=CL4'PSUB'
         MVC   MILMAXLN,=Y(1024)       Number of milten lines
*
* Check for specified parameters
*
         VMGET L'TIPARMS,LOC=LOCSYS
         LR    RX,RVR
         WITH  (TIPARMS,RX),BEGIN
         WITH  (PARMIN,TITYPE)
         CLEAR TIPARMS
*
*  Milten name
*
         GETPARM2 TIOUT,L'MILMNAM,KEY=(TERMINAL,MILNAME),              *
               TYPE=STRING,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         MVC   MILMNAM,=CL8' '
         DEX   RB,'MVC MILMNAM(0),@RA' Move the data
         END   ,
*
*  Milten password
*
         GETPARM2 TIOUT,L'MILPASS,KEY=(,MILPASS),                      *
               TYPE=STRING,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         MVC   MILPASS,=CL8' '
         DEX   RB,'MVC MILPASS(0),@RA' Move the data
         END   ,
*
*  Maximum number of Milten lines
*
         GETPARM2 KEY=(,MILLINES),TYPE=INT,REGS=(RA,RJ)
         IF    ZERO,BEGIN              It was specified
         CEIL  RA,=Y(32767)            Thats a lot of terminals
         STH   RA,MILMAXLN             Set value
         END   ,
*
* Free parameter work area
*
         VMFREE L'TIPARMS,A=LA:TIPARMS,LOC=LOCSYS
         END   ,
*
* Allocate the line table
*
         LH    RA,MILMAXLN             Get the number of lines
         SLL   RA,2                    4 bytes per line
         VMGET (RA),LOC=LOCSYS,FIX=YES  Get the memory
         LR    RB,RVR                  Copy the address
         ST    RB,MILCLTAB             Save the location
         ZOT   @RB,(RA)                Clear it to zero
*
* Setup the Full queue control block
*
         VMGET L'FQCB,LOC=GLOBHI       Get it from global memory
         LR    RA,RVR
         WITH  (FQCB,RA),BEGIN
         CLEAR FQCB                    Clear it out
         MVC   FQCB(4),=C'FQCB'        Move in the ID
         LKCRE FQCBLOCK                Get a suspend lock
         ST    RVR,FQCBLOCK            Save the lock ID
         END   ,
         ST    RA,MILCFQCB             Save the FQCB address
*
* Allocate our I/O control blocks
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait for it
         VCALL IOSIDGET
         ST    RVR,MILCIOCB            Save the I/O ID
*
         VMGET SCOMPLEN,LOC=LOCSYS,FIX=YES,ONEPAGE=YES
         ST    RVR,MILCIOPA            Save the parm area address
*
* Open the path
*
MOPEN    LCALL MILOPEN
         EJECT
*
*    M I L T E N   M A I N   L O O P
*
MMLOOP   LABEL ,
*
* If there is new information for us, we take that in
*
         IF    NEWINFO,'LCALL MILREAD' Read from the path
*
* If we have received a discretionary post, we ignore it
*
         IF    DISCPOST,'CLEAR DISCPOST'
*
* If a previous full queue emptied, we wake up those address
* spaces which were suspended for it
*
         IF    FULLQE,'LCALL MILFQE'   Wake up the unfortunate
*
* If the path has been closed, we have to logoff all the current
* users, and start back at the beginning.
*
         IF    CLOSED,BEGIN
         LCALL MILCLOSE                Close down the unfortunate
         B     MOPEN                   Then take it from the top
         END   ,
*
* Wait until something happens
*
         LCALL MILNOTFY                Wait for something to happen
         B     MMLOOP                  Then start the loop up
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MILOPEN --  This routine opens up the path to MILTEN and     *
*              signs us on as a subsystem.                      *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILOPEN  PROC  SCOPE=LOCAL
         L     RN,MATPTR               Get the MAT address
         WITH  (MAT,RN),'L RN,MATGTCT' Get the GTCT address
         WITH  (GTCT,RN)
         L     RM,GTCTMILC             Get the MILCB address
         WITH  (MILCB,RM)
*
* Allocate a path device
*
         LA    RS,#IOUSCOM             SCOM device
         SYSCTL RS,TYPE=ALLOC          Do the device allocation
         ST    RS,MILCPATH             Save it as the path ID
*
* Open the path to Milten
*
         L     RY,MILCIOPA             Get an IO parm area
         WITH  (#SCOPEN,RY),BEGIN
         CLEAR #SCOPEN
         WITH  (#SCOMCMD,RY),'MVC #SCCMD,=A(#SCCOPEN)'
         MVC   #SCOME,MILONAM          Move in our name
         MVC   #SCOYOU,MILMNAM         MILTEN's name
         MVC   #SCOPASS,MILPASS        And the password
         MVC   #SCOBUFL,=A(64*1024)    64k outstanding at one time
*
* Go ahead and do the I/O
*
         PSET  @IOSDOIO                Setup for the Call
         MVC   @IOSPID,PZCURPID
         PMOV  @IOSCP,LA:#SCOPEN       Channel program
         PMOV  @IOSCHID,MILCPATH       Device ID of the path
         PMOV  @IOSID,MILCIOCB
         SET   @IOSFSYNC               Synchronous I/O
         VCALL IOSDOIO                 Do the OPEN
         IF    (RVR,NZ),'ABORT BADOPEN'
         END   ,
*
* Our side is open.  Wait for the other side.
*
         LCALL MILNOTFY                Wait for something to happen
         IF    ^OPENED,'ABORT PATHSEQ' Sequence error
*
* Both sides are open now, we have to send Milten our initialization
* request.
*
         VMGET L'PDB,LOC=LOCSYS,FIX=YES,ONEPAGE=YES
         LR    RK,RVR                  Get the PDB address
         WITH  (PDB,RK)
         CLEAR PDB
         MVI   PDBCMD,TMILINIT         Move in the init command
         MVC   PDBSYSNM,MILONAM        Move in our name
*
* Format the I/O request
*
         L     RJ,MILCIOPA             Get a parameter location
         WITH  (#SCSR,RJ)
         CLEAR #SCSR
         WITH  (#SCOMCMD,RJ),'MVC #SCCMD,=A(#SCCSEND)'
         ADDSG PDB,L'PDB,#SCSR         Add the segment
*
* Send it off to milten
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSID,MILCIOCB         I/O control block
         ST    RJ,@IOSCP               Channel program (I/O parm)
         MVC   @IOSCHID,MILCPATH       Path device ID
         SET   @IOSFSYNC               Synchronous I/O
         VCALL IOSDOIO                 Go to it
         IF    (RVR,NZ),'ABORT MILINIT'
         VMFREE L'PDB,A=(RK),LOC=LOCSYS,FIX=YES
*
* We handle the return from this just like any other from milten,
* in the main loop of the milten terminal control.
*
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MILREAD --  This routine milks the path for all the queued   *
*              buffers and sends them where they belong.        *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILREAD  PROC  SCOPE=LOCAL
         L     RN,MATPTR               Get the MAT address
         WITH  (MAT,RN),'L RN,MATGTCT' Get the GTCT pointer
         WITH  (GTCT,RN)
         L     RM,GTCTMILC             Get the MILCB address
         WITH  (MILCB,RM)
*
* Loop through, receiving buffers and handling each, until there
* are no more to do.
*
RCVLOOP  WHILE NEWINFO,BEGIN           Loop until we're done
*
* Get a transaction from MILTEN
*
         LCALL MILRECV                 Get one
         LTR   RY,RVR                  Copy the TBUF location
         IF    Z,EXIT                  No buffer received
         WITH  (TBUF,RY)
*
* We have received a PDB.  If it is one of the commands we take
* care of, we do so.  If not, we ship it off to the proper address
* space where it can be processed.
*
         WITH  (PDB,TBUFDATA)          Address the PDB (no RDW)
*
* See if it's one that we just pass on.
*
         IF    ((PDBCMD,GT,FMILSOS),AND,(PDBCMD,LT,FMILASYN)),BEGIN
         LH    RS,PDBLIN#              Get the line number
         IF    (RS,GE,MILMAXLN),BEGIN
         ORVSNAP 'MILSYNCLIN#',MODE=WTL
         ORVSNAP TBUF,255
         FREEB TBUF                    Free the TBUF
         B     RCVLOOP
         END   ,
         SLL   RS,2                    Size of line table entry
         A     RS,MILCLTAB             Offset to the entry
         LT    RX,@RS                  Get the ASB address
         IF    Z,BEGIN
         ORVSNAP 'MILSYNCLIN#',MODE=WTL
         ORVSNAP TBUF,255
         FREEB TBUF                    Free the TBUF
         B     RCVLOOP
         END   ,
*
* Now go pass that info to the interested address space
*
         PSET  @SYSRNEW
         VCALL SYSRNEW                 Get a new SYSR ID
         LR    RA,RVR                  Copy the ID
         PSET  @SYSRDO
         ST    RA,@SYSRID              SYSR request ID
         ST    RX,@SYSRASB             ASB pointer
         MVC   @SYSRLOC,=A(MILSYSR)    Location for it
         WITH  (@MSPARM,@SYSRPRM)
         ST    RA,@MSPSYSR             Pass Him the SYSR ID
         ST    RY,@MSPTBUF             Address of the TBUF
         VCALL SYSRDO                  Schedule the routine
*
*  If we can't schedule the SYSR here, we just free the SYSR id
*  and ignore the event.
*
         IF    (RVR,NZ),BEGIN          'ABORT MILASYSR'
*  Remove the SYSR id
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,(RA)           Move in the ID
         VCALL SYSRDEL                 Then remove it
         ORVSNAP 'MILSYSR',MODE=WTL
         ORVSNAP TBUF,255
         FREEB TBUF                    Free the TBUF
         END   ,
         NEXT  RCVLOOP                 Go on to the next message
         END   ,
         EJECT ,
*
* It must be a command code that we handle here.
*
         IF    (PDBCMD,EQ,FMILINIT),BEGIN        Init completion
*         IF    PDBCPLA.CPLASNIU,'ABORT TWO-ORVS'
         FREEB TBUF                    Free the TBUF
         NEXT  RCVLOOP                 Get the next one
         END   ,
*
* If it is an error, or any other global command, we die
*
         IF    (PDBCMD,EQ,FMILSTOP),BEGIN
         ORVSNAP 'MILSTOP',MODE=LOG
         ABORT MILSTOP
         END
         IF    (PDBCMD,LE,FMILDUMP),'ABORT MILERR'
         EJECT ,
*
*           A S Y N C H R O N O U S   S T A T U S
*
* If we receive asyncronous status from milten, we just send it
* to the proper address space via a SYSR
*
         IF    (PDBCMD,EQ,FMILASYN),BEGIN
*
* Find out who it is for
*
         LH    RS,PDBLIN#              Get the line number
         IF    (RS,GE,MILMAXLN),BEGIN
         ORVSNAP 'MILASYNLIN#',MODE=WTL
         ORVSNAP TBUF,255
         B     ASYNIGNORE
         END   ,
         SLL   RS,2                    Size of line table entry
         A     RS,MILCLTAB             Offset to the entry
         LT    RX,@RS                  Get the ASB address
         IF    Z,BEGIN
         ORVSNAP 'MILASYNLIN#',MODE=WTL
         ORVSNAP TBUF,255
         B     ASYNIGNORE
         END   ,
*
* Get a new SYSR ID
*
         PSET  @SYSRNEW
         VCALL SYSRNEW                 Get a new SYSR ID
         LR    RA,RVR
*
* Schedule the SYSR
*
         PSET  @SYSRDO
         ST    RA,@SYSRID              ID of the SYSR
         ST    RX,@SYSRASB             ASB pointer
         MVC   @SYSRLOC,=A(MILASYN)    SYSR location
         WITH  (@MAPARM,@SYSRPRM)
         ST    RA,@MAPSYSR             SYSR ID so it can be deleted
         MVC   @MAPCPLB,PDBCPLB        Completion flags
         VCALL SYSRDO                  Go to it
*
*  If we can't schedule the SYSR here, we just free the SYSR id
*  and ignore the asynchronous event.
*  It probably can't be scheduled because this AS has logged off.
*
         IF    (RVR,NZ),BEGIN          'ABORT MILASYSR'
*  Remove the SYSR id
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,(RA)           Move in the ID
         VCALL SYSRDEL                 Then remove it
         ORVSNAP 'MILASYNSYSR',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
* Finish up
*
ASYNIGNORE DS  0H
         FREEB TBUF                    Release the buffer
         NEXT  RCVLOOP                 Continue in our quest
         END   ,
         EJECT ,
*
*           L O G O N   R E Q U E S T
*
* For a logon, we allocate a MIB, then create the address space.
*
         IF    (PDBCMD,EQ,FMILSOS),BEGIN
*
*  Make sure the line number is in range
*
         LH    RS,PDBLIN#              Get the line number
         IF    (RS,GE,MILMAXLN),BEGIN
         ORVSNAP 'MILLOGONLIN#',MODE=WTL
         ORVSNAP TBUF,255
         FREEB TBUF                    Free the TBUF
         B     RCVLOOP
         END   ,
*
* Get and initialize a MIB
*
         VMGET L'MIB,LOC=GLOBHI        Get global memory
         LR    RK,RVR                  Copy the address
*
* Fill in the MIB
*
         WITH  (MIB,RK)
         CLEAR MIB
         MVC   MIB(4),=CL4'MIB'        Move in the Control block ID
         MVC   MIBPATH,MILCPATH        MILTEN path device ID
         MVC   MIBFQCB,MILCFQCB        Address of FullQ control block
         ST    RY,MIBTBUF              Save the logon PDB TBUF
*
* Create the address space
*
         LKOB  GTCTLOCK                Get terminal function lock
         PSET  @ACREATE
         MVC   @ACRPSW(4),=X'070C0000' Enabled, Key 0
*        L     RS,=V(ASMTASK)          Get the address
         L     RS,=V(M1LOGON)          Get the address
         O     RS,=X'80000000'         Set 31 bit mode
         ST    RS,@ACRPSW+4            Save in the PSW
*        MVC   @ACRPARM,=V(M1LOGON)
         VCALL ACREATE                 Create the address space
         LR    RX,RVR                  Get the ASB Address
         WITH  (ASB,RX),'ST RK,ASBTCCB' Save the MIB pointer
*
* Save the ASB address in the line table
*
         LH    RS,PDBLIN#              Get the line number
         SLL   RS,2
         A     RS,MILCLTAB             Get the offset of the entry
         ST    RX,@RS                  Save the ASB pointer
         LKREL GTCTLOCK                Free the terminal lock
         NEXT  RCVLOOP                 Get the next one
         END   ,
*
* An un-identifiable PDB
*
         ORVSNAP 'MILPDBCMD',MODE=WTL
         ORVSNAP TBUF,255
         FREEB TBUF                    Release the buffer
*
         END   ,                       Of the receive loop
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   MILFQE --  This routine handles the full queue emptied      *
*              response from SCOM, it wakes up those address    *
*              spaces and tasks that are waiting on a fullq.    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILFQE   PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RM,MATPTR               Get the MAT address
         WITH  (MAT,RM),'L RM,MATGTCT' Get the GTCT address
         WITH  (GTCT,RM),'L RM,GTCTMILC' Get the MILCB location
         WITH  (MILCB,RM)
         CLEAR FULLQE                  Clear the flag
*
* Find the FQCB
*
         L     RY,MILCFQCB             Get the address
         WITH  (FQCB,RY)
*
         L     RB,FQCBCNT              Get the count of fullqueues
         WHILE ((RB,EQ,FQCBCNT),AND,(FQCBHEAD,NZ)),BEGIN
*
* Take care of one element
*
         LKOB  FQCBLOCK                Get the fullqueue lock
         L     RJ,FQCBHEAD             Get the first in the list
         WITH  (MFQE,RJ)
         MVC   FQCBHEAD,MFQENEXT       Remove it from the list
         IF    (RJ,EQ,FQCBTAIL),'CLEAR FQCBTAIL' Last on in the list
         LKREL FQCBLOCK                Free the lock
         PSET  @RESUME
         PMOV  @RESUNIT,MFQEASB        ASB to wake
         VCALL RESUMAS                 And go wake it
         VMFREE L'MFQE,A=(RJ),LOC=GLOBHI   Free the element
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* MILCLOSE --  This routine handles the close of the MILTEN     *
*              path and the cleanup attendant thereto.          *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILCLOSE PROC  SCOPE=LOCAL
         L     RN,MATPTR               Get the MAT address
         WITH  (MAT,RN),'L RN,MATGTCT' Get the GTCT address
         WITH  (GTCT,RN)
         L     RM,GTCTMILC             Get the MILCB address
         WITH  (MILCB,RM)
         ORVSNAP 'MILGONE',MODE=LOG
         ABORT MILGONE
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* MILNOTFY --  This routine does a notify to get the current    *
*              SCOM flags, and if no condition is pending, to   *
*              wait.  It updates the flags in the MILCB.        *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILNOTFY PROC  SCOPE=LOCAL
         L     RN,MATPTR               Get the MAT address
         WITH  (MAT,RN),'L RN,MATGTCT' Get the GTCT address
         WITH  (GTCT,RN),'L RN,GTCTMILC'
         WITH  (MILCB,RN)
*
* Get the notify parameter area  (already fixed)
*
         L     RX,MILCIOPA             Get the parameter area
         WITH  (#SCNOTE,RX)
         WITH  (#SCOMCMD,RX),'MVC #SCCMD,=A(#SCCNOTE)'
*
* The parm area is filled in, do the I/O
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,MILCPATH       Device ID
         MVC   @IOSID,MILCIOCB         Move in the request ID
         ST    RX,@IOSCP               Channel program
         SET   @IOSFSYNC               Synchronous style
         VCALL IOSDOIO                 Do the I/O
         STC   RVR,MILCFLG             Ending status is the flags
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MILRECV --  This routine retrieves one transaction from the  *
*              milten path and returns a TBUF pointer in RVR.   *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains TBUF address                        *
*                                                               *
*****************************************************************
         SPACE 2
MILRECV  PROC  SCOPE=LOCAL
         L     RM,MATPTR               Get the MAT address
         WITH  (MAT,RM)
         L     RN,MATGTCT              Get the GTCT address
         WITH  (GTCT,RN),'L RN,GTCTMILC'
         WITH  (MILCB,RN)
         CLEAR NEWINFO                 Pre-clear the flag
*
* Get an I/O buffer
*
         LCALL GETTBUF                 Get an I/O buffer
         LR    RY,RVR                  Pointer to the buffer
         WITH  (TBUF,RY)
         FIX   TBUFDATA,LH:TBUFMAXL    Fix the data area
*
* Set up the Read parameter area (already fixed)
*
         L     RX,MILCIOPA             Get the parm area
         WITH  (#SCSR,RX)
         CLEAR #SCSR                   Clear it out first
         WITH  (#SCOMCMD,RX),'MVC #SCCMD,=A(#SCCRECV)'
         ADDSG TBUFDATA,LH:TBUFMAXL,#SCSR  Add the data description
*
* The parm area is filled in, do the I/O
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,MILCPATH       Device ID
         MVC   @IOSID,MILCIOCB         Move in the request ID
         ST    RX,@IOSCP               Channel program
         SET   @IOSFSYNC               Synchronous style
         MVC   @IOSKEY,MATSKEY         Read in system key
         VCALL IOSDOIO                 Do the I/O
*
* Check the ending status
*
         LR    RA,RVR                  Copy the ending status
         UNFIX TBUF,LH:TBUFMAXL        Unfix the data area
*
* Normal return
*
         IF    ((RA,EQ,#SCESOK),OR,(RA,EQ,#SCESBS)),BEGIN
         L     RS,#SCSRRLN             Get the length retrieved
         STH   RS,TBUFLEN              Save it in the TBUF
         IF    (RS,Z),BEGIN            Zero length, means no buffer
         FREEB TBUF                    Free the buffer
         CLEAR RY                      We have it no longer
         END   ,
         ELSE  'SET NEWINFO'           Assume there is more data
         LR    RVR,RY                  Copy the TBUF address
         EXIT  MILRECV                 Return to the caller
         END   ,
*
* No Partner
*
         IF    (RA,EQ,#SCESNP),BEGIN   No partner
         FREEB TBUF                    Free the buffer
         CLEAR RVR                     Return value
         END   ELSE,BEGIN              Some other bad return
         ABORT PATHREAD                Arrrghhhh.....
         END   ,
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'MILTEN Terminal Control - Global'
*****************************************************************
*                                                               *
*  GETTBUF --  This routine obtains a terminal I/O buffer.  If  *
*              there is already one on the free queue, it is    *
*              used, otherwize a new one is allocated.          *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR points at the allocated TBUF                 *
*                                                               *
*****************************************************************
         SPACE 2
GETTBUF  PROC  SCOPE=LOCAL
         L     RM,MATPTR               Get the MAT location
         WITH  (MAT,RM),'L RM,MATGTCT' Get the GTCT address
         WITH  (GTCT,RM)               Address it
*
* Get a free one if it exists
*
         LM    RJ,RK,GTCTTBFL          Get Free pointer
         WITH  (TBUF,RJ)
         LOOP  BEGIN
         IF    (RJ,Z),EXIT             No free ones
         L     RA,TBUFNEXT             Address of the next
         LA    RB,@RK+1                Increment the control count
         CDS   RJ,RA,GTCTTBFL          Try to remove it
         UNTIL Z,END                   Keep on trying
*
* If we got it, we decrease the free count
*
         IF    (RJ,NZ),BEGIN
         L     RA,GTCTTBFC             Get the Free count
         LOOP  BEGIN
         LR    RB,RA                   Copy the count
         DECR  RB                      Decrement it
         CS    RA,RB,GTCTTBFC          Update the count
         UNTIL Z,END                   Keep trying
         END   ELSE,BEGIN
*
* If we didn't get one, we allocate a new one
*
         VMGET LH:GTCTTBSZ,LOC=GLOBHI
         IF    (RVR,Z),'ABORT NOGLOB'
         LR    RJ,RVR                  Move it to the right spot
*
* And we count it
*
         L     RA,GTCTTBTC             Get the Total count
         LOOP  BEGIN
         LA    RB,@RA+1                Increment the count
         CS    RA,RB,GTCTTBTC          Update the count
         UNTIL Z,END                   Keep trying
         END   ,
*
* Format the buffer the way we want
*
         CLEAR TBUF                    Clear the header
         MVC   TBUF(4),=C'TBUF'        Move in the ID
         LH    RS,GTCTTBSZ             Get the total buffer size
         SH    RS,=Y(L'TBUF)           Less the header size
         STH   RS,TBUFMAXL             Save maximum data length
         LR    RVR,RJ                  Return the location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* FREETBUF --  This routine releases a terminal I/O buffer.  If *
*              there are already enough on the free queue, then *
*              this one is de-allocated, otherwize it is put on *
*              the free queue.                                  *
*                                                               *
*   Input  --  @FRTBUF                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@FRTBUF  RECORD BEGIN
@FRTBLOC DS    A             Location of the buffer to free
         END   ,
         SPACE 2
FREETBUF PROC  @FRTBUF,SCOPE=LOCAL
         L     RM,MATPTR               Get the MAT location
         WITH  (MAT,RM),'L RM,MATGTCT' Get the GTCT address
         WITH  (GTCT,RM)               Address it
         L     RA,@FRTBLOC             Get the TBUF location
         WITH  (TBUF,RA)
         IF    (TBUF,NE,'TBUF'),'ABORT BADTBUF'
         MVI   TBUF+3,C'f'
*
* Check on the free status
*
         L     RS,GTCTTBTC             Get the total count
         SRL   RS,1                    Divide by 2
         IF    (RS,GE,GTCTTBFC),BEGIN  Less than half are free
         LM    RJ,RK,GTCTTBFL          Get Free pointer
         LOOP  BEGIN
         ST    RJ,TBUFNEXT             Address of the next
         LR    RB,RK                   Copy the control count
         CDS   RJ,RA,GTCTTBFL          Try to add it
         UNTIL Z,END                   Keep on trying
*
* If we added it to the free queue, we update the count
*
         L     RS,GTCTTBFC             Get the Free count
         LOOP  BEGIN
         LA    RB,@RS+1                Increment the count
         CS    RS,RB,GTCTTBFC          Update the count
         UNTIL Z,END                   Keep trying
         END   ELSE,BEGIN
*
* If too many were free, we de-allocate this one
*
         VMFREE LH:GTCTTBSZ,A=(RA),LOC=GLOBHI
         IF    (RVR,NZ),'ABORT BADFTBUF'
*
* And have to update the count of terminal buffers out there
*
         L     RS,GTCTTBTC             Get the Total count
         LOOP  BEGIN
         LR    RB,RS                   Copyt the count
         DECR  RB                      Decrement the count
         CS    RS,RB,GTCTTBTC          Update the count
         UNTIL Z,END                   Keep trying
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   ADDSEG --  This routine adds information about an area of   *
*              virtual memory to the list in a path send/recv   *
*              request parameter area.  It updates the count    *
*              and length values in the parm area.              *
*                                                               *
*   Input  --  @ADDSEG                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@ADDSEG  RECORD BEGIN
@ADDSPA  DS    A             Address of the parameter area
@ADDSLOC DS    A             Location of the data to add
@ADDSLEN DS    H             Length of the data to add
         END   ,
         SPACE 2
ADDSEG   PROC  @ADDSEG,SCOPE=LOCAL
         L     RX,@ADDSPA    Get the parameter area
         WITH  (#SCSR,RX)
*
* Get our starting point for this data
*
         L     RJ,#SCSRCT              Get current count
         SLL   RJ,3                    Size of each segment
         LA    RJ,#SCSRSEG(RJ)         Location of new segment ptrs
         L     RA,@ADDSLOC             Starting location
         LH    RB,@ADDSLEN             And total length
*
* Loop through the data area, adding a segment to the parm area for
* each page or fraction thereof.
*
         WHILE (RB,NZ),BEGIN           Through the info
*
* Fill in the location for the current part of the data area
*
         LRA   RS,@RA                  Real address of current bit
         IF    NZ,'ABORT BADFIX'       What?
         ST    RS,@RJ                  Save the real address
*
* Figure out how long to the next page boundary
*
         LR    RS,RA                   Copy the current address
         AH    RS,=Y(4096)             Get to the next page
         N     RS,=X'7FFFF000'         Address of the next page
         SR    RS,RA                   Length to the page boundary
         CEIL  RS,RB                   Max is the buffer length
         ST    RS,@RJ+4                Save the segment length
*
* Adjust the pointers for the next pass through
*
         AR    RA,RS                   Get to the next segment
         SR    RB,RS                   Length is less this segment
         LA    RJ,@RJ+8                Location for next entry
         END   ,
*
* Update the count of segments
*
         LA    RS,#SCSRSEG             Starting location
         SR    RJ,RS                   Length in bytes
         SRL   RJ,3                    Length in entries
         ST    RJ,#SCSRCT              Save the count
*
* Update the overall length
*
         L     RS,#SCSRLEN             Get the previous length
         AH    RS,@ADDSLEN             Add what we just put in
         ST    RS,#SCSRLEN             Update the length
         PEND  ,
         TITLE 'MILTEN Terminal Control - Local'
*****************************************************************
*                                                               *
*   MILSX  --  This routine sends a request to MILTEN.  It      *
*              takes care of all the stuff that has to be done  *
*              in the case of a full queue reply from the path  *
*              and other return codes as well.  It assumes that *
*              MTCBIOPA contains the address of the parm area   *
*              to be used in the PATH I/O.                      *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILSX    PROC  SCOPE=LOCAL
*
* Find the MTCB
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Get the I/O parm area
*
         L     RY,MTCBIOPA             Get the I/O parm area
         WITH  (#SCSR,RY)
         WITH  (#SCOMCMD,#SCSR)
         MVC   #SCCMD,=A(#SCCSEND)     Move in the command code
*
* Get an IOS ID
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait
         VCALL IOSIDGET                Go get us an ID
         LR    RK,RVR                  Copy the ID
         FIX   #SCSR,SCOMPLEN          Fix the parm area
*
* Send the parm area out on the path
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,MTCBPATH       Path ID
         ST    RK,@IOSID               I/O ID
         PMOV  @IOSCP,LA:#SCSR         Parm area address
         SET   @IOSFSYNC               Syncronous
         VCALL IOSDOIO                 Do the I/O
         LR    RB,RVR                  Copy the ending status
*
* Check the ending status of the write
*
         IF    (RB,EQ,#SCESOK),MXRDONE  Finish up
         IF    (RB,NE,#SCESFQ),'ABORT BADMXS'    Bad send
         EJECT ,
*
*        F U L L   Q U E U E
*
* If we got a full queue response, we have to try and re-send the
* buffer while we're holding the fullqueue lock.  If we still get
* fullqueue, then we queue an element to the MILCB and go into
* a wait.
*
         L     RA,MTCBFQCB             Get the FQCB address
         WITH  (FQCB,RA),BEGIN
FQL      LKOB  FQCBLOCK                Get the fullqueue lock
*
* Send the parm area out on the path
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,MTCBPATH       Path ID
         ST    RK,@IOSID               I/O ID
         PMOV  @IOSCP,LA:#SCSR         Parm area address
         SET   @IOSFSYNC               Syncronous
         VCALL IOSDOIO                 Do the I/O
         LR    RB,RVR                  Copy the ending status
*
* Check the ending status
*
         IF    (RB,EQ,#SCESOK),BEGIN   It went ok this time
         LKREL FQCBLOCK                Free the lock
         B     MXRDONE                 Then finish up
         END   ,
         IF    (RB,NE,#SCESFQ),'ABORT BADMXS'    Now something wrong
*
* We got another fullqueue.  Count it and queue an elem on the FQCB.
*
         INCR  RS,FQCBCNT              Count of full queues
         VCALL ASLOCK
         VMGET L'MFQE,LOC=GLOBHI       Get an element
         LR    RS,RVR
         WITH  (MFQE,RS),BEGIN
         CLEAR MFQE
         MVC   MFQE(4),=C'MFQE'
         MVC   MFQEASB,PZCURASB        Current Address space
         END   ,
         LT    RB,FQCBTAIL             Get the last in the list
         IF    Z,BEGIN                 Only one in the list
         ST    RS,FQCBTAIL             It is the last
         ST    RS,FQCBHEAD             And the first too
         END   ELSE,BEGIN              Not the only one
         WITH  (MFQE,RB)               Address the last
         ST    RS,MFQENEXT             Point the last at the new one
         ST    RS,FQCBTAIL             And point tail a the next one
         END   ,
*
* Suspend the address space
*
         PSET  @SUSPEND
         SET   @SUSPAS                 Do the whole address space
         VCALL SUSPEND                 Mark us suspended
*
* Free the fullqueue lock, so we can be awakened
*
         LKREL FQCBLOCK
         VCALL ASULOCK                 Release the local lock
         VCALL DISPRD                  Do the actual suspend
         B     FQL                     When we wake, try again
         END   ,
         EJECT ,
*
* We are done with the send, unfix the area and free the IOS ID
*
MXRDONE  UNFIX #SCSR,SCOMPLEN          Free the Parm area
         PSET  @IOSIDFRE
         ST    RK,@IOSFID
         VCALL IOSIDFRE                Free the IOS ID
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   MILRX  --  This routine receives the transaction back from  *
*              MILTEN.  The data has been received by the       *
*              Milten central address space and is (will be)    *
*              pointed to in our MTCB when the SYSR from the    *
*              central task runs.  We wait for it if it isn't   *
*              here yet.                                        *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR has the address of the received TBUF         *
*                                                               *
*****************************************************************
         SPACE 2
MILRX    PROC  SCOPE=LOCAL
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Wait for the buffer to show up
*
UPWT     VCALL ASLOCK                  Get the local lock
         LT    RJ,MTCBTBUF             Get a TBUF
         IF    NEG,'ABORT WAIT2BUF'    We have waited for it
*
* If it's not back yet, we have to wait for it
*
         IF    Z,BEGIN                 We have to wait for it
         PSET  @SUSPEND                We will suspend
         IF    MTFLSLOW,BEGIN          We can expect to wait a while
         SET   @SUSPLNG                So do a long wait
         CLEAR MTFLSLOW                Clear the slow flag
         END   ,
         VCALL SUSPEND                 Etc
         MVC   MTCBTBUF,=X'80000000'   Tell the SYSR we're waiting
         MVC   MTCBTKID,@SUSPCTL       Save info needed to wake
         VCALL ASULOCK                 Free the lock
         VCALL DISPRD                  Return to the dispatcher
         B     UPWT                    Try again
         END   ,
*
* We have the return buffer from Milten
*
         CLEAR MTCBTBUF                Clear out the buffer address
         VCALL ASULOCK                 Release the local Lock
         LR    RVR,RJ                  Copy the TBUF location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   CURSIB --  This routine sends a request to milten to get    *
*              the current information about the current line.  *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CURSIB   PROC  SCOPE=LOCAL
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Fill in the PDB how we like it
*
         L     RA,MTCBPDB
         WITH  (PDB,RA),BEGIN
         CLEAR PDB
         MVC   PDBLIN#,MTCBLINE        Put in the line number
         MVI   PDBCMD,MILCNTL          Command is a control
         MVI   PDBCNO,CTLSNSI          Sense session info
         END   ,
*
* Make sure it stays put
*
         FIX   (RA),L'PDB              Fix the PDB
*
* Set up the parm area
*
         L     RB,MTCBIOPA             Get the address of the area
         WITH  (#SCSR,RB),BEGIN
         CLEAR #SCSR
         ADDSG (RA),L'PDB,#SCSR        Add the segment
         END   ,
         ACALL MILSX                   Send the Transation
         UNFIX (RA),L'PDB              Free the PDB
*
* Now we wait to see what we got back from this
*
         ACALL MILRX                   Get the rebound
         LR    RJ,RVR                  Get the TBUF address
         WITH  (TBUF,RJ),BEGIN
         WITH  (PDB,TBUFDATA)          It should be a PDB
*
* Check to make sure it is the one we want
*
         IF    ((PDBCMD,NE,MILCNTL),OR,(PDBCRET,NZ)),'ABORT CURSIB?'
         L     RK,MTCBSIB              Get the SIB area address
         WITH  (SIB,RK)
         MVC   SIB,PDBTEXT             Move in the SIB
         FREEB TBUF                    Then free our buffer
         END   ,
*
* Update global information
*
         LCALL SIBDO
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   NEWSIB --  This routine sends a request to have MILTEN      *
*              update its version of the SIB to be like ours.   *
*              If we can't update it because we don't have a    *
*              current copy, we return RVR not equal to zero    *
*              and update out copy of the SIB.                  *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR = 0 if it went ok.                           *
*                                                               *
*****************************************************************
         SPACE 2
NEWSIB   PROC  SCOPE=LOCAL
*
* Find out where we are
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Increment the update count in the SIB
*
         L     RK,MTCBSIB              Get the SIB address
         WITH  (SIB,RK)
         INCR  RS,SIBUC                Bump the update count
*
* Get the parm area and PDB
*
         L     RY,MTCBPDB              Get a PDB
         WITH  (PDB,RY),BEGIN
         CLEAR PDB                     Clean that up too
         L     RM,MTCBIOPA             Get a parm location
         WITH  (#SCSR,RM)
         CLEAR #SCSR
*
* Fill in the PDB
*
         MVC   PDBLIN#,MTCBLINE        Move in the line number
         MVI   PDBCMD,MILCNTL          Milten control command
         MVI   PDBCNO,CTLSETI          Set Session info
         MVC   PDBVINFO,MT1PGM         And the program info
         LA    RA,L'SIBOPT             Get the SIB updateable length
         STH   RA,PDBWC                Fill in the write count
         LA    RS,@RA+6
         STH   RS,PDBOUTCT             And the milten count
         FIX   PDB,L'PDB
         ADDSG PDB,L'PDB,#SCSR         Send the PDB
         FIX   SIBOPT,L'SIBOPT         Fix the SIB too
         ADDSG SIBOPT,L'SIBOPT,#SCSR   And add it
         ACALL MILSX                   Send it off
         UNFIX SIBOPT,L'SIBOPT         Unfix the SIB
         UNFIX PDB,L'PDB               Unfix the PDB
         END   ,
*
* Now we wait to see what we got back from this
*
         ACALL MILRX                   Get the rebound
         LR    RY,RVR                  Get the TBUF address
         WITH  (TBUF,RY)
         WITH  (PDB,TBUFDATA)          It should be a PDB
*
* Check to make sure it is the one we want
*
NEWSIBOK BEGIN ,                       Return not in error
         IF    ((PDBCMD,NE,MILCNTL),OR,         'ABORT *SEQERR'        *
               (PDBCRET,NZ)),BEGIN              'ABORT *NEWSIB'
         ORVSNAP 'NEWSIB',MODE=WTL
         ORVSNAP TBUF,255
         LA    RA,4
         EXIT  NEWSIBOK
         END   ,                       OF Return not OK
*
* We know that milten liked our message.  If the update was
* successful, we just give a good return.  If not, milten returns
* the current SIB in the PDB.
*
         IF    (PDBCMOD,Z),BEGIN       The update was sucessful
         LCALL SIBDO                   Take the info out of the SIB
         CLEAR RA                      Signal good return
         END   ELSE,BEGIN              The update didn't take
         MVC   SIB,PDBTEXT             Update our copy
         LCALL SIBDO                   Distribute the info
         LA    RA,4                    Tell them it was NG
         END   ,
         END   ,                       OF Return not in error
*
* Free the buffer and return
*
         FREEB TBUF
         LR    RVR,RA                  Return code
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   SIBDO  --  This routine takes the data from the SIB and     *
*              moves it to the proper control blocks.           *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
SIBDO    PROC  SCOPE=LOCAL
*
* Find all the control blocks
*
         L     RY,PZCURASB             Get the current ASB
         WITH  (ASB,RY)
         L     RX,ASBTCCB              Get the MTCB Address
         WITH  (MTCB,RX)
         L     RK,MTCBSIB              Get the SIB address
         WITH  (SIB,RK)
*
* Update global information
*
         PSET  @ACLOGON
         MVC   @ACLASB,PZCURASB        Always for us
         MVC   @ACLUID(L'SIBACCT),SIBACCT
         MVC   @ACLUPR+3(1),SIBKIFL    Milten privs
         MVC   @ACLLOT,SIBLCLCK        Logon time
         PMOV  @ACLTID,SIBNO           Terminal ID
         VCALL ACLOGON                 Go do the logon
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   MILIAS --  This routine is called when an address space     *
*              using a milten terminal is started up.           *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILIAS   PROC  SCOPE=LOCAL
         L     RM,PZCURASB             Get the current ASB address
         WITH  (ASB,RM)
         L     RY,ASBTCCB              Get the MIB address
         WITH  (MIB,RY)
*
* Allocate an MTCB for the terminal
*
         VMGET L'MTCB,LOC=LOCSYS,FIX=YES
         LR    RX,RVR
         WITH  (MTCB,RX)
         CLEAR MTCB
         MVC   MTCB(4),=C'MTCB'        Control block ID
         ST    RX,ASBTCCB              Save the address
*
* Save information from the MIB
*
         MVC   MTCBPATH,MIBPATH        Save the PATH ID
         MVC   MTCBFQCB,MIBFQCB        FQCB address
*
* Get information from the logon PDB
*
         L     RK,MIBTBUF              Get the logon buffer
         WITH  (TBUF,RK),BEGIN
         WITH  (PDB,TBUFDATA)          Address the PDB
*        IF    (PDBCMD,NE,FMILSOS),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILSOS),BEGIN
         ORVSNAP 'MILIAS',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
         MVC   MTCBLINE,PDBLIN#        Milten line number
         MVC   MTCBWYLN,PDBSYSNM       Who XCTL'd to us
         FREEB TBUF                    Free the TBUF
         END   ,
*
* Allocate some of the things we need
*
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,MTCBATTN            Save the Attention Xit id
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,MTCBIOCP            And the I/O complete xit id
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,MTCBTIMO            And the Timer xit id
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,MTCBLGOF            And the logoff xit id
*
* Get some local data areas
*
         VMGET SCOMPLEN,LOC=LOCSYS,ONEPAGE=YES  Get an I/O parm area
         ST    RVR,MTCBIOPA            Save the address
         VMGET L'PDB,LOC=LOCSYS        Get a PDB
         ST    RVR,MTCBPDB             Save the location
         VMGET L'SIB,LOC=LOCSYS        Get a SIB buffer
         ST    RVR,MTCBSIB             Save the location
*
* We are done with the MIB now, we can free it
*
         VMFREE L'MIB,A=LA:MIB,LOC=GLOBHI
         PEND
         EJECT ,
*****************************************************************
*                                                               *
*   MILIUSI --  This routine is called to obtain the initial    *
*               user information from Milten.                   *
*                                                               *
*   Input   --  none                                            *
*                                                               *
*  Output   --  none                                            *
*                                                               *
*****************************************************************
         SPACE 2
MILIUSI  PROC  SCOPE=LOCAL
         L     RM,PZCURASB             Get the current ASB address
         WITH  (ASB,RM)
         L     RY,ASBTCCB              Get the MIB address
         WITH  (MTCB,RY)
*
* Find out about the user
*
         ACALL CURSIB                  Update the SIB
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   MILUINF --  This routine is called to obtain user terminal  *
*               information from Milten                         *
*                                                               *
*   Input   --  @MILUINF                                        *
*                                                               *
*  Output   --  parm area pointed to by @MILUINF                *
*                                                               *
*****************************************************************
         SPACE 2
@MILUINF RECORD BEGIN
@MILUPTR DS    A
         END   ,
         SPACE 2
MILUINF  PROC  @MILUINF
         L     RM,PZCURASB             Get the current ASB address
         WITH  (ASB,RM)
         L     RY,ASBTCCB              Get the MIB address
         WITH  (MTCB,RY)
         L     RX,@MILUPTR             Pointer to return parm area
         WITH  (@TERUINF,RX)
         L     RK,MTCBSIB
         WITH  (SIB,RK)
*
*  For now we just return terminal type
*
         MVC   @TERUTYP,SIBTID
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MILLGOF --  This routine loggs the terminal off.             *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MILLGOF  PROC  SCOPE=LOCAL
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Fill in the PDB with the EOS
*
         L     RA,MTCBPDB
         WITH  (PDB,RA),BEGIN          PDB addr
         CLEAR PDB
         MVC   PDBLIN#,MTCBLINE        Put in the line number
         MVI   PDBCMD,TMILEOS          Logoff this user
*
*  Get accounting information
*
         ACALL GETCHGS                 Get data
         MVC   PDBVCPU,MT1CPUT         Move CPU time to PDB
         MVC   PDBVDIO,MT1DIOCT         and I/O count
*
* Make sure it stays put
*
         FIX   PDB,L'PDB               Fix the PDB
*
* Set up the parm area
*
         L     RB,MTCBIOPA             Get the address of the area
         WITH  (#SCSR,RB),BEGIN
         CLEAR #SCSR
         ADDSG PDB,L'PDB,#SCSR         Add the segment
         END   ,
         ACALL MILSX                   Send the Transation
         UNFIX PDB,L'PDB               Free the PDB
         END   ,                       OF PDB addr
*
* There is no return from milten on this so we're done
*
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MILSYSR --  This routine is run as a SYSR under the address  *
*              space where a message recevied in the milten     *
*              main address space is destined.  It saves the    *
*              address of the buffer and wakes up the task that *
*              was waiting for it.                              *
*                                                               *
*   Input  --  @SYSRTN                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@MSPARM  RECORD BEGIN        Mapping of the SYSR parm area
@MSPSYSR DS    A             ID of the SYSR
@MSPTBUF DS    A             Address of the recevied buffer
         END   ,
         SPACE 2
MILSYSR  PROC  @SYSRTN,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Address
         WITH  (MTCB,RX)
         WITH  (@MSPARM,@SYSPARS)
*
* Free the SYSR
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,@MSPSYSR       Move in the ID
         VCALL SYSRDEL                 Then remove it
*
* Get the TBUF sent by the central processing
*
         L     RA,@MSPTBUF             And the TBUF addres
*
* See if there is someone waiting for this
*
         L     RS,MTCBTBUF             Get the current value
         IF    (RS,POS),'ABORT MILSEQ' Some kind of sequence error
         ST    RA,MTCBTBUF             Save this buffer address
         IF    (RS,NEG),BEGIN          Someone is waiting
         PSET  @RESUME
         MVC   @RESCTL,MTCBTKID        Move in the info
         VCALL RESUMTS                 Resume the waiting task
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MILASYN --  This routine is run as a SYSR under the address  *
*              space whose terminal has received asynchronous   *
*              status from MILTEN.  It takes care of the status *
*              and frees the SYSR ID.                           *
*                                                               *
*   Input  --  @SYSRTN                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@MAPARM  RECORD BEGIN        Mapping of the SYSR parm area
@MAPSYSR DS    A             ID of the current SYSR
@MAPCPLB DS    X             Asynchronous completion flags
         END   ,
         SPACE 2
MILASYN  PROC  @SYSRTN,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
         WITH  (@MAPARM,@SYSPARS)
*
* Free the current SYSR
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,@MAPSYSR       Move in the ID
         VCALL SYSRDEL                 Delete that SYSR
*
* Take care of the completion status
*
         IF    @MAPCPLB.CPLBIA,BEGIN   Idle attention
         INCR  RS,MT1IACT              Update the count
         ACALL M1ATTN                  Call the mode 1 Attn handler
         END   ,
         IF    @MAPCPLB.CPLBLGF,BEGIN  Hangup
         ACALL M1LOGOFF
         END   ,
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Mode 1 Control Blocks (MILTEN)'
*
*   M1IO -- Parm area for the Mode 1 I/O requests
*
         SPACE ,
@M1IO    RECORD BEGIN
@M1IOR01 DS    A             Register 1
@M1IOR14 DS    A             Register 14
@M1IOR15 DS    A             Register 15
@M1IOFLG FLAG  ,             Mode flags
         FLAG  @M1IODIS       Display mode for terminal
         FLAG  @M1IOM31       User wants 31 bit mode
         END   ,
         SPACE 2
*
* Parm are for Validating addresses
*
         SPACE ,
@VALBUF  RECORD BEGIN
@VALBLOC DS    A             Location of the buffer
@VALBLEN DS    H             Length of the buffer
@VALBKEY DS    X             Key under which to check buffers
@VALBFL  FLAG  ,
         FLAG  @VALBWRT      Need write access to the buffer
         END   ,
         SPACE 2
         TITLE 'Mode 1 Terminal Interface (MILTEN)'
*****************************************************************
*                                                               *
*   M1TERM --  This is the main entry point for the MODE 1      *
*              terminal interface.  It is called directly from  *
*              the SVC handler.  It shedules another task to    *
*              do part of the I/O if it cannot be done right    *
*              away.                                            *
*                                                               *
*   Input  --  @M1TERM                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
M1TERM   PROC  @M1TERM,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         IF    (@RX,NE,'MTCB'),'ABORT M1NOTMIL'
         WITH  (MTCB,RX)
*
* Save the program information
*
         MVC   MT1ATSK,PZCURTSK        Save the Attention task
         MVC   MT1PGM,@M1TPGM          Program name
         MVC   MT1PFLG,@M1TFLG         Move in the flags
         ACALL GETCHGS                 Get the session charges
*
* Save info for the returns
*
         MVC   MT1RQTK,PZCURTSK        Copy the Task information
         MVC   MT1RKEY,@M1TPKEY        Protection key of requestor
         MVC   MT1RQID,@M1TRQID        Copy the request ID
         MVC   MT1WR01,=X'80000000'    Default the return value
         MVC   MT1WR14,=X'80000000'    Default the return value
         MVC   MT1WR15,=X'80000000'    Default the return value
*
* Figure out what we have and who to call do handle the request
*
         IF    @M1TCNTL,BEGIN          It is a control function
         PSET  @M1IO
         IF    @M1TFM31,'SET @M1IOM31'
         MVC   @M1IOR01(3*4),@M1TR01   Copy the registers
         ACALL CNTRL                   Do the control operation
         B     M1TDONE                 Then return to the caller
         END
*
* Halt
*
         IF    @M1THALT,BEGIN
         ACALL HALT                    Do the halt
         B     M1TDONE                 Return to caller
         END   ,
         EJECT ,
*
* Read
*
         IF    @M1TREAD,BEGIN
         PSET  @M1IO                   All routines take this parm
         IF    @M1TFM31,'SET @M1IOM31'
         LM    RS,RB,@M1TR01           Get all the registers
         IF    (RS,NEG),BEGIN          It must be a read text
         LCR   RS,RS                   Fix the value
         IF    ((RA,NEG),OR,(RB,NEG)),M1TSPEC
         STM   RS,RB,@M1IOR01          Save the registers
         ACALL RDTEXT                  Go do a read text
         B     M1TDONE                 Then return to the caller
         END   ,
*
* Not a read text, check for read edit
*
         IF    (RB,NEG),BEGIN          Read edit (R15 Neg)
         LCR   RB,RB                   Fix the register up
         IF    (RA,NEG),M1TSPEC        Spec erorr for bad mode
         STM   RS,RB,@M1IOR01          Save the registers
         ACALL RDEDIT                  Do a read edit
         B     M1TDONE                 Then return
         END   ,
*
* It must be a read terminal
*
         IF    (RA,NEG),BEGIN          Check R14
         SET   @M1IODIS                Set display mode
         LCR   RA,RA
         END   ,
         STM   RS,RB,@M1IOR01          Save the registers
         ACALL RDTERM                  Then read from the terminal
         B     M1TDONE                 Then return to the caller
         END   ,
         EJECT ,
*
* Write
*
         IF    @M1TWRIT,BEGIN
         PSET  @M1IO                   All routines take this parm
         IF    @M1TFM31,'SET @M1IOM31'
         LM    RS,RB,@M1TR01           Get all the registers
*
* Check for mode text
*
         IF    ((RS,M),AND,(RB,NM)),BEGIN        Write text
         LCR   RS,RS                   Fix up the Register
         STM   RS,RB,@M1IOR01          Save the registers
         ACALL WRTEXT                  Do the write text
         B     M1TDONE                 all done here
         END   ,
*
* Check for mode edit
*
         IF    ((RS,NM),AND,(RB,M)),BEGIN        Write edit
         LCR   RB,RB                   Fix up the register
         STM   RS,RB,@M1IOR01          Save the registers
         ACALL WREDIT                  Go write edit
         B     M1TDONE                 Then return
         END   ,
*
* It must be a terminal write
*
         IF    (RS,M),BEGIN
         SET   @M1IODIS                Set the display mode bit
         LCR   RS,RS                   Fixup the registers
         LCR   RB,RB
         END   ,
         STM   RS,RB,@M1IOR01          Save the registers
         ACALL WRTERM                  Go write on the terminal
         B     M1TDONE                 Then we're done here
         END   ,
*
* If anything bad is found at this early stage we signal a spec error
*
M1TSPEC  LA    RVR,6                   Signal a SPEC error
*
* R15 is always zero on SVC return
*
M1TDONE  CLEAR @M1TR15                 Clear that register
         PEND
         EJECT ,
*****************************************************************
*                                                               *
*   RDTERM --  Do a Mode 1 terminal I/O.                        *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RTWA     RECORD BEGIN
RTOLOC   DS    A             Location of the output buffer
RTILOC   DS    A             Location of the input buffer
RTOLEN   DS    H             Length of the output buffer
RTWLEN   DS    H             Length of the write data in the OBUF
RTFLGS   DS    X             Write flags (display mode)
         END   ,
         SPACE 2
RDTERM   PROC  @M1IO,RTWA,SCOPE=LOCAL
*
* Find our control blocks
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
         CLEAR RTWA                    Zero the local work area
*
* Enforce 24 bit addressing
*
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR01,0              Clear high byte
         MVI   @M1IOR14,0              Ditto
         END   ,
*
* Validate the input buffer
*
         L     RJ,@M1IOR01             Get the input buffer
         LH    RK,@M1IOR15+2           And the input length
         IF    (RK,NP),RDTSPEC         Bad length
*oldlim: IF    @M1IODIS,BEGIN          Display mode length check
         IF    (RK,GT,8192),RDTSPEC    Must be less than 8192
*oldlim: END   ELSE,'CEIL RK,256'      Maximum line input size
         VALBUF (RJ),(RK),MT1RKEY,W    Check out the input buffer
         IF    (RVR,NZ),EXIT           Some access exception
         ST    RJ,MT1IBLOC             Save the buffer location
         STH   RK,MT1IBLEN             And the length
*
* Check out the timeout value
*
         LH    RS,@M1IOR15             Get the timeout value
         IF    ((RS,M),OR,(RS,GT,6000)),RDTSPEC  Bad timeout value
         ST    RS,MT1TIMO              Save the timeout value
*
* Check out the output buffer
*
         L     RJ,@M1IOR14             Get the output buffer location
*
* Display mode buffer...
*
         IF    @M1IODIS,BEGIN          Display mode
         IF    (RJ,Z),RDTSPEC          Must have flags at least
         VALBUF (RJ),LA:4,MT1RKEY      See if we can read it
         IF    (RVR,NZ),EXIT,RDTERM    Some access exception
         MVC   RTFLGS,@RJ+1            Move in the flags
         LH    RS,@RJ+2                Get the length
         IF    (RS,GT,8192),RDTSPEC    Maximum length
         STH   RS,RTOLEN               Save the length
*
* If there is some output data, we ensure that we can read it
*
         IF    (RS,NZ),BEGIN           There is some there
         IF    (RS,LT,6),RDTSPEC       Must be at least 6 bytes
         LA    RJ,@RJ+4                Point at the buffer
         ST    RJ,RTOLOC               Save the output buffer address
         VALBUF (RJ),(RS),MT1RKEY      Can we read it?
         IF    (RVR,NZ),EXIT,RDTERM    Some access exception
         END   ,
         END   ELSE,BEGIN
*
* Non-display mode output buffer...
*
         IF    (RJ,Z),BEGIN            No output data at all
         CLEAR RTWLEN                  Zero write length
         CLEAR RTOLEN                  And the total output length
         END   ELSE,BEGIN
         VALBUF (RJ),LA:4,MT1RKEY      We check the count bytes
         IF    (RVR,NZ),EXIT,RDTERM    Some access exception
         LH    RS,@RJ                  Get the write count
         IF    (RS,NEG),RDTSPEC        Can't be negative
         STH   RS,RTWLEN               Save the write length
         LH    RS,@RJ+2                Get the prompt count
         IF    (RS,NEG),RDTSPEC        Can't be negative either
         AH    RS,RTWLEN               Add the write count
         STH   RS,RTOLEN               Save the total output length
         IF    (RS,GT,251),RDTSPEC     Too long
         IF    (RS,NZ),BEGIN
         LA    RJ,@RJ+4                Get the address of the obuf
         ST    RJ,RTOLOC               Save the address
         VALBUF (RJ),(RS),MT1RKEY      Make sure we can read it
         IF    (RVR,NZ),EXIT,RDTERM    Some access exception
         END   ,
         END   ,
         END   ,
*
* Now we know where all the data is, send it off to milten
*
         CLEAR MT1IACT                 Since it's ok, clear IA count
         L     RM,MTCBIOPA             Get the IO parm address
         WITH  (#SCSR,RM)              Address it
         CLEAR #SCSR                   Clear it
         L     RY,MTCBPDB              Get a PDB to use
         WITH  (PDB,RY)
         CLEAR PDB
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Put in the line number
         MVI   PDBCMD,TMILREAD         It is a terminal read
         MVC   PDBINCT,MT1IBLEN        Length of the input
         MVC   PDBVINFO,MT1PGM         Move in the program info
*
* Save the output counts, this is strange due to the way milten
* expects the fields to be set up. (because of previous ORVYLs)
*
         LH    RS,RTOLEN               Get our output length
*
* Display mode ...
*
         IF    @M1IODIS,BEGIN          Display mode is different
         IF    (RS,NZ),BEGIN           Some data to write
         STH   RS,PDBOUTCT             Set the total length
         L     RA,RTOLOC               Get the output buffer location
         MVC   PDBWC(6),@RA            Move in WC,PC,RC
         AH    RA,=Y(6)                Point past the counts
         ST    RA,RTOLOC               Update the output pointer
         SH    RS,=Y(6)                Length is 6 bytes less
         STH   RS,RTOLEN               Update the length
         END   ,
         END   ELSE,BEGIN
*
* Line mode ...
*
         IF    (RTWLEN,NZ),'LA RS,@RS+1' Account for the NL char
         STH   RS,PDBPC                Save the output char count
         AH    RS,=Y(6)                Milten requirement
         STH   RS,PDBOUTCT             Total length
         END   ,
*
* Handle the mode flags
*
         SET   PDBMODD.MODDNPT         Don't allow page pause text
         IF    @M1IODIS,BEGIN          Display mode
         SET   PDBMODC.MODCDSPL        Set display mode
         IF    RTFLGS.X'04','SET PDBMODC.MODCSTIB'   Suppress blanks
         SET   PDBMODA.MODACL          Clean
         SET   PDBMODB.MODBSLOL        Slow list (don't expand tabs)
         SET   PDBMODB.MODBUPLO        Uplow
         SET   PDBMODB.MODBUFMT        Unformatted
         SET   PDBMODD.MODDNPAU        Nopause
         END   ,
         ELSE  'SET  PDBMODC.MODCSTOB' Suppress trailing blanks
         FIX   PDB,L'PDB               Fix it in storage
         ADDSG PDB,L'PDB,#SCSR         We will send it first
*
* Handle the output
*
         L     RJ,RTOLOC               Get the output buffer location
         LH    RK,RTOLEN               Get the output count
         IF    (RK,NZ),BEGIN           If there is any
         FIX   (RJ),(RK)               Fix it
         LH    RA,RTWLEN               Get the write length
         IF    (RA,NZ),BEGIN           There is some write text
         ADDSG (RJ),(RA),#SCSR         Move in the write text
         ADDSG =X'15',1,#SCSR          A newline
         AR    RJ,RA                   New location
         SR    RK,RA                   New length
         END   ,
         IF    (RK,NZ),BEGIN           Some amount of prompt
         ADDSG (RJ),(RK),#SCSR         Move in the prompt text
         END   ,
         END   ,                       No write text
*
* Send it off to Milten, then unfix the fixed areas
*
         ACALL MILSX                   Send the transaction to milten
         UNFIX PDB,L'PDB               First the PDB
         L     RJ,RTOLOC               Output location
         LH    RK,RTOLEN               Output length
         IF    (RK,NZ),BEGIN
         UNFIX (RJ),(RK)               Unfix the output buffer
         END   ,
*
* Schedule the task that will wait for and process the I/O completion
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+RDTERMX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
*
* We are done with the SVC inline stuff, return to the caller
*
         CLEAR RVR                     Good return
         B     RDTDONE
*
RDTSPEC  LA    RVR,6                   Cause a Specification error
RDTDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  RDTERMX --  This is the Mode 1 terminal Read completion      *
*              task.  It retrieves the response from milten and *
*              handles the incoming data.                       *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RDTERMX  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Setup for the timeout if that is required
*
         IF    (MT1TIMO,NZ),BEGIN
*
* Define the Exit routine
*
         PSET  @EXRADD
         WITH  (XITMSKD,@EXRTYPE)
         SET   XITMRTC                 Real time clock only
         MVC   @EXRPSW(4),=X'070C0000'
         MVC   @EXRPSW+4(4),=A(X'80000000'+RTTO)
         ST    RX,@EXRPARM             Save the MTCB address
         SET   @EXRAFS                 Enter it with a Stack
         VCALL EXRADD                  Add the Exit routine
*
* Enable the Exit
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMRTC                 Real time-timer
         SET   @XITMSO                 Or it in
         VCALL XITMASK                 Set the mask
*
* Start up the timer
*
         PSET  @RTSET
         MVC   @RTSXIT,MTCBTIMO        Tell him the exit ID
         SET   @RTSFINT                Interval timer
         CLEAR RA
         L     RB,MT1TIMO              Get the interval (S)
         M     RA,=A(1000000)          Turn it into uS
         SLDL  RA,12                   Turn it into TOD
         STM   RA,RB,@RTSCLK           Set the clock
         VCALL RTSET                   Set the time
         ST    RVR,MT1TIMER            Save the value
         END   ,
*
* Wait for the buffer to come back from milten
*
         L     RS,MTCBSIB              Get the SIB pointer
         WITH  (SIB,RS),BEGIN
         IF    ^SIBTVIRT,'SET MTFLSLOW'
         END   ,
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
*
* If the timer has not expired, we have to cancel it
*
         IF    (MT1TIMO,NZ),BEGIN      Only if an outstanding timer
         VCALL ASLOCK                  Get the local lock
         IF    (MT1TIMER,NZ),BEGIN     The timer is outstanding
         PSET  @RTCNCK
         MVC   @RTCID,MT1TIMER         Move in the timer ID
         CLEAR MT1TIMER                Clear the timer ID
         VCALL RTCAN                   Cancel the timer
         END   ,
         VCALL ASULOCK
         END   ,
         EJECT ,
*
* See if we got the response we wanted.
*
         IF    (PDBCMD,EQ,FMILXCTL),BEGIN
*
* Some kinds of requests go out as a read and are converted by milten
* to an XCTL to WYLBUR.  Under certain circumstances, Milten converts
* these back into read responses, but sometimes it doesn't.  That
* is what this section of code is for.
*
         MVI   PDBCMD,FMILREAD         Convert it back to a read
         CLI   PDBORV,PDBVRCTL         Test for a control
         IF    NE,EXIT                 If not, fixup not needed
         LH    RVR,PDBWC               Get the text length
         STH   RVR,PDBRC               Make it the read count
         CLEAR PDBWC                   Clear out the write count
         END   ,
*        IF    (PDBCMD,NE,FMILREAD),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILREAD),BEGIN
         ORVSNAP 'RDTERMX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
         IF    PDBCPLB.CPLBLGF,'ACALL M1LOGOFF'
*
* Move in the data, after re-checking the input buffer
*
         CLEAR MT1WR15                 Default zero return
         CLEAR MT1WR01                 Default length return
         VCALL ASLOCK                  No interference
         L     RJ,MT1IBLOC             Get the location
         LH    RK,MT1IBLEN             And the length
         VALBUF (RJ),(RK),MT1RKEY,W    Check it out
         IF    (RVR,NZ),BEGIN          Now it's no good
         MVC   MT1WR15,=A(-4)          Signal I/O error
         VCALL ASULOCK                 Unlock the address space
         B     RDTXDONE                Finish up the read
         END   ,
         LA    RA,PDBTEXT              Get the start of data
         AH    RA,PDBPC                Skip over the prompt
         LH    RB,PDBRC                Get the read+prompt count
         SH    RB,PDBPC                Reduce to the read count
         CEIL  RK,RB                   Buffer no bigger than data
         ST    RK,MT1WR01              Save the length
         MVCL  RJ,RA                   Move the data in
         VCALL ASULOCK                 Unlock the address space
*
* Check the return status, first check for illegal terminal
*
         IF    PDBCPLB.CPLBILT,BEGIN
         MVC   MT1WR15,=A(-12)         Illegal terminal return code
         B     RDTXDONE                Don't do any
         END   ,
*
* Check for unset tabs
*
         IF    PDBCPLA.CPLAUST,BEGIN   They typed an unset tab
         MVC   MT1WR15,=A(-8)          Move in that return code
         B     RDTXDONE                Then finish up
         END   ,
*
* Check for a break (timeout)
*
         IF    PDBCPLA.CPLABRK,BEGIN   Killed by a break
         MVC   MT1WR15,=A(8)           Timout code
         B     RDTXDONE                Finish up
         END   ,
*
* Check for I/O error
*
         IF    PDBCPLA.CPLAIOE,BEGIN   I/O error
         MVC   MT1WR15,=A(-4)          I/O error code
         B     RDTXDONE                Finish up
         END   ,
*
* Check for ATTN, and take care of ?ATTN
*
         IF    PDBCPLA.CPLAATTN,BEGIN  Someone hit ATTN
         MVC   MT1WR15,=A(4)           Set the return code
         IF    (MT1WR01,EQ,1),BEGIN    Might be ?***
         LA    RA,PDBTEXT
         AH    RA,PDBPC                Point at the data
         IF    (@RA,EQ,'?'),BEGIN      We need to signal ATTN too
         MVI   MT1IACT,2               Count 2 idle attn's
         ACALL M1ATTN                  Then signal the ATTN exit
         END   ,
         END   ,
         B     RDTXDONE
         END   ,
         EJECT ,
*
* Finish up the read
*
RDTXDONE LABEL ,
*
* Update the SIB if it needs it
*
         L     RS,MTCBSIB              Get the SIB address
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Get the current one
         END   ,
*
* Free the input buffer and signal the I/O complete
*
         FREEB TBUF                    Free it
         ACALL M1IODONE                Signal the I/O is done
*
* Then finish up the task
*
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*     RTTO --  This is the Mode 1 Read timout exit routine. It  *
*              just sends a BREAK to MILTEN.                    *
*                                                               *
*   Input  --  @XITDATA                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RTTO     PROC  @XITDATA,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,@XITDSA              Pointer to the status area
         WITH  (XITSAREA,RX),'L RX,XITSRPRM'     Get the MTCB address
         IF    (@RX,NE,'MTCB'),'ABORT WHAT??'    *** TEMP ***
         WITH  (MTCB,RX)
*
* Make sure we should still send off the Break
*
         IF    (MT1TIMER,NZ),BEGIN     Timer still out
         CLEAR MT1TIMER                Tell them the Timer fired
*
* Send off the BREAK
*
         L     RM,MTCBIOPA             Get the parm area address
         WITH  (#SCSR,RM)
         CLEAR #SCSR
         L     RY,MTCBPDB              Get the PDB
         WITH  (PDB,RY)
         CLEAR PDB
         MVC   PDBLIN#,MTCBLINE        Line number
         MVI   PDBCMD,TMILBRK          Break command
         MVC   PDBVINFO,MT1PGM         Program info
         FIX   PDB,L'PDB
         ADDSG PDB,L'PDB,#SCSR         Add PDB to segment
         ACALL MILSX                   Send the data to milten
         UNFIX PDB,L'PDB               Unfix the PDB
         END   ,
*
* Now we are done.
*
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*****************************************************************
*                                                               *
*   RDEDIT --  This is the Mode 1 Read edit routine             *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
REWA     RECORD BEGIN
REOLOC   DS    A             Location of the output buffer
REOLEN   DS    H             Length of the output buffer
         END   ,
         SPACE 2
RDEDIT   PROC  @M1IO,REWA,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Address
         WITH  (MTCB,RX)
         CLEAR REWA                    Clear the work area
*
* Enforce 24 bit addressing
*
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR01,0              Location of the input buffer
         MVI   @M1IOR14,0              Location of output data
         END   ,
*
* Validate the input buffer
*
         L     RJ,@M1IOR01             Get the location
         LH    RK,@M1IOR15+2           And the length
         IF    (RK,NP),RDESPEC         Musn't be too small...
         VALBUF (RJ),(RK),MT1RKEY,W    Check it out
         IF    (RVR,NZ),RDEDONE        Some access exception
         ST    RJ,MT1IBLOC             Save the input buffer location
         CEIL  RK,256                  No bigger than 256
         STH   RK,MT1IBLEN             Save the length
*
* Validate the output buffer
*
         CLEAR MT1FREWR                Default = no write data
         LT    RJ,@M1IOR14             Get the location
         IF    NZ,BEGIN                Some write data
         VALBUF (RJ),LA:2,MT1RKEY      Check access to the length
         IF    (RVR,NZ),RDEDONE        Some access exeption
         LH    RK,@RJ                  Get the length
         IF    (RK,Z),EXIT             No write data
         IF    (RK,NEG),RDESPEC        Length can't be negative
         IF    (RK,GT,251),RDESPEC     Length <= 251
         LA    RJ,@RJ+2                Point at the output data
         VALBUF (RJ),(RK),MT1RKEY      Validate it
         IF    (RVR,NZ),RDEDONE        Done if any access exception
         SET   MT1FREWR                Set read-edit write data flag
         ST    RJ,REOLOC               Save the output location
         STH   RK,REOLEN               And the output length
*
* Ready to send the output data off to milten.
*
         L     RM,MTCBIOPA             Get a parameter area
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clean it up
         L     RY,MTCBPDB              Get a PDB to use
         WITH  (PDB,RY)
         CLEAR PDB                     Clean it up too
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Our milten line number
         MVI   PDBCMD,TMILWRIT         The command
         MVC   PDBVINFO,MT1PGM         The program information
         FIX   PDB,L'PDB               Fix it
         ADDSG PDB,L'PDB,#SCSR         Add it to the list to send
*
* Move the data into the buffer
*
         FIX   (RJ),(RK)
         IF    (RK,NZ),BEGIN           Only if there is something
         ADDSG (RJ),(RK),#SCSR         Add the user data
         END   ,
*
* Add a trailing NL
*
         ADDSG =X'15',1,#SCSR          Add it to the buffer
*
* Now we fill in the length of the data for milten
*
         LA    RK,@RK+1                Add the NL to the length
         STH   RK,PDBWC                Save it in the write count
         LA    RK,@RB+6                Needed for milten
         STH   RK,PDBOUTCT             Save it again
*
* Send it off to milten
*
         ACALL MILSX                   Send the transaction off
*
* Unfix the areas we fixed
*
         L     RJ,REOLOC               Get the location again
         LH    RK,REOLEN               And the length
         UNFIX (RJ),(RK)               Unfix the user area
         UNFIX PDB,L'PDB               And the PDB too
         END   ,                       ** End of the write data **
*
* We're doing a read, so we reset the idle attn counter
*
         CLEAR MT1IACT                 Clear it up
*
* Schedule the task to handle the I/O completion
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+RDEDITX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
*
* We are done with the SVC inline stuff, return to the caller
*
         CLEAR RVR                     Good return
         B     RDEDONE
*
RDESPEC  LA    RVR,6                   Cause a Specification error
RDEDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  RDEDITX --  This is the Mode 1 Read edit completion task.    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RDEDITX  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* If there was write data on the request, we wait for the return
* from milten.
*
         IF    MT1FREWR,BEGIN          There was write data
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
*        IF    (PDBCMD,NE,FMILWRIT),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILWRIT),BEGIN
         ORVSNAP 'RDEDITXW',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
         IF    PDBCPLB.CPLBLGF,BEGIN
         ACALL M1LOGOFF                Take care of the exit
         CLEAR MT1WR15                 Good return
         CLEAR MT1WR01                 But with no data
         B     RDEXDONE                Finish up here
         END   ,
         FREEB TBUF                    Done with the buffer
         END   ,
*
* Now send the read edit request to WYLBUR
*
         L     RM,MTCBIOPA             Get the parm area
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clear it out
         L     RY,MTCBPDB              Get a PDB
         WITH  (PDB,RY),BEGIN
         CLEAR PDB                     Make sure it is all cleaned up
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Move in the line number
         MVI   PDBCMD,TMILXCTL         We're going to transfer control
         MVC   PDBSYSNM,MTCBWYLN       Move in wylbur's name
         MVC   PDBVINFO,MT1PGM         Program info
         MVC   PDBOUTCT,=Y(6)          6 + data count = 6
*
* Format the Wylbur command area in the PDB
*
         MVI   FORVCMD,FORVREDT        Read edit command
         IF    ^MTFLFRED,BEGIN         First read edit not done yet
         SET   MTFLFRED                But it has now, set the flag
         MVI   FORVCMDM,REDTRSEN       And tell wylbur to re-send it
         END   ,
         IF    MTFLWATN,BEGIN          Someone hit ATTN
         CLEAR MTFLWATN
         SET   REDTFATT                Tell Wylbur about the ATTN
         END   ,
         IF    MTFLWCME,BEGIN          There was a command error
         CLEAR MTFLWCME
         SET   REDTFCME                Tell wylbur about it
         END   ,
*
* Send it off
*
         FIX   PDB,L'PDB               Fix the PDB
         ADDSG PDB,L'PDB,#SCSR         Tell SCOM about it
         ACALL MILSX                   Send it to wylbur
         UNFIX PDB,L'PDB               Then unfix the PDB
         END   ,
*
* Wait for a response
*
         L     RS,MTCBSIB              Get the SIB pointer
         WITH  (SIB,RS),BEGIN
         IF    ^SIBTVIRT,'SET MTFLSLOW' Not very speedy
         END   ,
         ACALL MILRX                   Wait for a response
         LR    RY,RVR                  Get the buffer
         WITH  (TBUF,RY)
         WITH  (PDB,TBUFDATA)          Address the return PDB
*
* Check out the response
*
*        IF    (PDBCMD,NE,FMILXCTL),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILXCTL),BEGIN
         ORVSNAP 'RDEDITX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
*  If Wylbur is not there log this user off
*
         IF    (PDBSYSNM,Z),'SET  PDBCPLB.CPLBLGF'  Wylbur is gone
*
*  User needs to be logged off
*
         IF    PDBCPLB.CPLBLGF,BEGIN   User logging off
         ACALL M1LOGOFF
         CLEAR MT1WR01
         CLEAR MT1WR15                 Clear the length and RC
         B     RDEXDONE                And finish up here
         END   ,
*
* Save off Wylbur's name for the next I/O
*
         MVC   MTCBWYLN,PDBSYSNM       Save Wylbur's name
*
* We only support a return of an illegal command
*
*        IF    ((FWYLRTNC,NE,RTNCILLC),AND,(FWYLRTNC,NE,X'00')),
*              'ABORT BADRCRE'
*
* Make sure the buffer is still ok
*
         VCALL ASLOCK
         L     RJ,MT1IBLOC             Get the buffer location
         LH    RK,MT1IBLEN             And its length
         VALBUF (RJ),(RK),MT1RKEY,W    Verify the location
         IF    (RVR,NZ),'ABORT BADIVA' It is now no good
*
* Set the return registers and move the data in
*
         CLEAR MT1WR15                 Always a zero Return code
         CLEAR RS                      "Typed" return code
         IF    (FWYLFL.FWYLFNT),'LA  RS,1'   "Not typed" code
         ST    RS,MT1WR14              Set source code
         LH    RB,REDTTXTL             Get the returned length
         CEIL  RK,RB                   Move no more than we have data
         ST    RK,MT1WR01              Return it to the caller
         IF    (RB,NZ),BEGIN
         LA    RA,FWYLTEXT             Move no more than the buffer
         MVCL  RJ,RA                   Move the data in
         END   ,
         VCALL ASULOCK                 Free up the lock
*
* Check for an Attention return from the read edit
*
         IF    (MT1WR01,Z),BEGIN       A zero return length indicator
         MVI   MT1IACT,2               Generate enough ATTNs
         ACALL M1ATTN                  Then call the ATTN routine
         END   ,
*
* Finish up the read
*
         L     RS,MTCBSIB              Get the SIB pointer
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Update it
         END   ,
*
* Finish up the task
*
RDEXDONE FREEB TBUF                    Then free the buffer
         ACALL M1IODONE                Signal the I/O complete
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*****************************************************************
*                                                               *
*   RDTEXT --  This is the Mode 1 Read Text routine.            *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RXWA     RECORD BEGIN
RXCLOC   DS    A             Location of the control info
RXCLEN   DS    H             Length of the control info
RXCODE   DS    X             Request code for WYLBUR
RXLRECL  DS    X             LRECL
         END   ,
         SPACE 2
RDTEXT   PROC  @M1IO,RXWA,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Adddress
         WITH  (MTCB,RX)
         CLEAR RXWA                    Clear the work area
*
* Enforce 24 bit addressing
*
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR01,0              Location of the input buffer
         MVI   @M1IOR14,0              Location of output data
         END   ,
*
* Validate the input buffer
*
         L     RJ,@M1IOR01             Get the location
         LH    RK,@M1IOR15+2           And the length
         IF    (RK,NP),RDXSPEC         Musn't be too small...
         IF    (RK,GT,8192),RDXSPEC    or too big.
         LR    RA,RJ                   Addr of the first byte
         LA    RB,@RA(RK)              Addr of last byte+1
         DECR  RB                      Addr of the last byte
         N     RA,=X'7FFFF000'         Page addr of first byte
         N     RB,=X'7FFFF000'         Page addr of last byte
         SR    RB,RA                   difference
         IF    (RB,GT,4096),RDXSPEC    Crosses 2 or more page bdys
         VALBUF (RJ),(RK),MT1RKEY,W    Check it out
         IF    (RVR,NZ),RDXDONE        Some access exception
         ST    RJ,MT1IBLOC             Save the input buffer location
         STH   RK,MT1IBLEN             And the length
*
* Validate the control buffer
*
         L     RJ,@M1IOR14             Get the control buf location
         IF    (RJ,Z),RDXSPEC          We must have something
         VALBUF (RJ),LA:8,MT1RKEY      Always read 8 bytes
         IF    (RVR,NZ),RDXDONE        Some access exception
         CLEAR RA
         LH    RB,@RJ                  Get the code number
         D     RA,=A(100)              Split them up
         IF    (RA,GT,6),RDXSPEC       Invalid code
         IF    (RB,GT,4),RDXSPEC       Invalid option
         STC   RA,RXCODE               Save the code
*
* Take care of the option modifier
*
         IF    (RB,EQ,1),BEGIN         NOTEXT format
         SET   RXCODE.RTXTNOT
         END   ,
         IF    (RB,EQ,2),BEGIN         LRECL format
         LH    RS,@M1IOR15             Get the user LRECL
         IF    (RS,GT,255),RDXSPEC     Must be 255 or less
         STC   RS,RXLRECL              Save it
         END   ,
         IF    (RB,EQ,3),BEGIN         CARD format
         SET   RXCODE.RTXTNUM
         MVI   RXLRECL,80
         END   ,
         IF    (RB,EQ,4),BEGIN         INTEGER format
         SET   RXCODE.RTXTINT
         MVI   RXLRECL,80
         END   ,
*
* Now validate the rest of the information in the control area
*
         LA    RJ,@RJ+2                Point past the option code
         ST    RJ,RXCLOC               Save the control area loc
         IF    (RA,LT,3),BEGIN         Short fellas
         MVC   RXCLEN,=Y(6)            Length of the control info
         B     CBUFOK                  Done checking
         END   ,
         IF    (RA,EQ,3),BEGIN         A bit longer
         LA    RJ,@RJ+6                Point at the area
         VALBUF (RJ),LA:4,MT1RKEY      Check 4 more bytes
         IF    (RVR,NZ),RDXDONE        Some access exception
         MVC   RXCLEN,=Y(10)           Length of the control area
         B     CBUFOK                  Then we're all done checking
         END   ,
*
* Codes 4,5, and 6 have string data as well
*
         LA    RJ,@RJ+6                Point at the unchecked area
         VALBUF (RJ),LA:10,MT1RKEY     Validate the needed stuff
         IF    (RVR,NZ),RDXDONE        Access exception
         MVC   RXCLEN,=Y(16)           Length of the control info
         LA    RJ,@RJ+8                Location of the string length
         LH    RK,@RJ                  Get the length
         IF    (RK,Z),BEGIN            No text
         IF    (RA,NE,4),RDXSPEC       Only allowed for code 4
         B     CBUFOK
         END   ,
         IF    (RK,GT,255),RDXSPEC     Not too big either
         LA    RJ,@RJ+2                Address of the text
         VALBUF (RJ),(RK),MT1RKEY      Make sure we can read it
         IF    (RVR,NZ),RDXDONE        Some access execption
         AH    RK,RXCLEN               Add the control length
         STH   RK,RXCLEN               And update the value
*
* The information passed to us is all checked out... Format the
* PDB to send it to WYLBUR
*
CBUFOK   L     RM,MTCBIOPA             Get a parameter area
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clean it up
         L     RY,MTCBPDB              Get a PDB to use
         WITH  (PDB,RY)
         CLEAR PDB                     Clean it up too
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Our milten line number
         MVI   PDBCMD,TMILXCTL         The command
         MVC   PDBSYSNM,MTCBWYLN       We're sending it to WYLBUR
         MVC   PDBVINFO,MT1PGM         The program information
         MVI   FORVCMD,FORVRTXT        Tell WYLBUR its a Read Text
         MVI   FORVCMDM,RTXTFNLP       No locked page passes
         MVC   RTXTRLEN,MT1IBLEN       Amount of data we'll accept
         LH    RS,RXCLEN               Get the length of his data
         LA    RS,@RS+2                Count the code and lrecl
         LA    RS,@RS+6                Always add 6
         STH   RS,PDBOUTCT             Tell WYLBUR all about it
         FIX   PDB,L'PDB               Fix it
         ADDSG PDB,L'PDB,#SCSR         Add it to the list to send
         FIX   RXCODE,2                Fix the code/lrecl
         ADDSG RXCODE,2,#SCSR          Add it to the list
         L     RJ,RXCLOC               Location of the user data
         LH    RK,RXCLEN               Length of his data
         FIX   (RJ),(RK)               Fix his area
         ADDSG (RJ),(RK),#SCSR         Add it to the list to go
*
* Send it off to milten
*
         ACALL MILSX                   Send the transaction off
*
* Unfix the areas we fixed
*
         UNFIX (RJ),(RK)               Unfix the user area
         UNFIX RXCODE,2                The code/lrecl
         UNFIX PDB,L'PDB               And the PDB
*
* Schedule the task to handle the I/O completion
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+RDTEXTX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
*
* We are done with the SVC inline stuff, return to the caller
*
         CLEAR RVR                     Good return
         B     RDXDONE
*
RDXSPEC  LA    RVR,6                   Cause a Specification error
RDXDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  RDTEXTX --  This is the Mode 1 read text completion routine. *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RDTEXTX  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Wait for the buffer to come back from milten
*
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
*
* Check out the response
*
*        IF    (PDBCMD,NE,FMILXCTL),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILXCTL),BEGIN
         ORVSNAP 'RDTEXTX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
*  If Wylbur is not there log this user off
*
         IF    (PDBSYSNM,Z),'SET  PDBCPLB.CPLBLGF'  Wylbur is gone
*
*  User needs to be logged off
*
         IF    PDBCPLB.CPLBLGF,BEGIN
         ACALL M1LOGOFF                Schedule the logoff exit
         CLEAR MT1WR01                 No bytes moved
         CLEAR MT1WR15                 Good return though
         CLEAR MT1WR14                 And no lines moved
         B     RTXDONE                 And finish up here
         END   ,
*
* Save off Wylbur's name for the next I/O
*
         MVC   MTCBWYLN,PDBSYSNM       Save Wylbur's name
*
* Handle the returns.
*
         IF    (FWYLRTNC,EQ,RTNCLKPP),'ABORT TERMLKPP'
         LC    RS,FWYLRTNC             Get the return
         ST    RS,MT1WR15              Return that to the user
         IF    (RS,Z),BEGIN            Good return
*
* Make sure the input buffer is still good, then move the data in
*
         L     RJ,MT1IBLOC             Get the buffer location
         LH    RK,MT1IBLEN             and the length
         VCALL ASLOCK                  Lock up the address space
         VALBUF (RJ),(RK),MT1RKEY,W    See if it is still good
         IF    (RVR,NZ),'ABORT BADIVA' Something bad happened
         CEIL  RK,RTXTTXTL             Move no more than we have
         ST    RK,MT1WR01              Save the length for the user
         LA    RA,PDBTEXT              Get the data location
         LR    RB,RK                   Copy the length to move
         MVCL  RJ,RA                   Move the data for the user
         VCALL ASULOCK                 Unlock it
         LH    RS,RTXTNUML             Get the number of lines
         ST    RS,MT1WR14              Return that to the user too
         END   ,
*
* Finish up the write, Update the SIB if that is needed
*
         L     RS,MTCBSIB
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Update needed
         END   ,
*
* Free the input buffer, and post the I/O complete
*
RTXDONE  FREEB TBUF
         ACALL M1IODONE
*
* Finish up the task
*
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*****************************************************************
*                                                               *
*   WRTERM --  This is the Mode 1 terminal Write routine.       *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WRTERM   PROC  @M1IO,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Address
         WITH  (MTCB,RX)
*
* Enforce 24 bit addressing
*
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR01,0              Location of the buffer
         END   ,
*
* Validate the output buffer
*
         L     RJ,@M1IOR01             Get the location
         L     RK,@M1IOR15             And the length
         IF    (RK,NEG),WRTSPEC        Length can't be negative
*oldlim: IF    @M1IODIS,BEGIN
         IF    (RK,GT,8192),WRTSPEC    Display mode <= 8192
*oldlim: END   ELSE,BEGIN
*oldlim: IF    (RK,GT,251),WRTSPEC     Line mode <= 251
*oldlim: END   ,
*
* Make sure we can read the users buffer
*
         IF    (RK,NZ),BEGIN
         VALBUF (RJ),(RK),MT1RKEY      We want to read it
         IF    (RVR,NZ),WRTDONE        Some access violation
         END   ,
*
* All set to go, setup the PDB and parameter area
*
         L     RM,MTCBIOPA             Get a parameter area
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clean it up
         L     RY,MTCBPDB              Get a PDB to use
         WITH  (PDB,RY)
         CLEAR PDB                     Clean it up too
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Our milten line number
         MVI   PDBCMD,TMILWRIT         The command
         MVC   PDBVINFO,MT1PGM         The program information
*
* Handle the mode flags
*
         SET   PDBMODD.MODDNPT         Don't allow page pause text
         IF    @M1IODIS,BEGIN          Display mode
         SET   PDBMODC.MODCDSPL        Set display mode
         SET   PDBMODA.MODACL          Clean
         SET   PDBMODB.MODBSLOL        Slow list (don't expand tabs)
         SET   PDBMODB.MODBUPLO        Uplow
         SET   PDBMODB.MODBUFMT        Unformatted
         SET   PDBMODD.MODDNPAU        Nopause
         END   ,
         ELSE  'SET  PDBMODC.MODCSTOB' Suppress trailing blanks
         FIX   PDB,L'PDB               Fix it
         ADDSG PDB,L'PDB,#SCSR         Add it to the list to send
*
* Fix the user data, then figure out what we have to do for carriage
* control.  (adding leading NLs)
*
         IF    (RK,NZ),BEGIN           We have to have some data
         FIX   (RJ),(RK)
         CLEAR RB                      Count of NLs we're adding
*
* Take care of control characters if we have to
*
         IF    ^@M1IODIS,BEGIN         No CCs for display mode
         IF    MT1FCC,BEGIN            We are interpreting them
         LR    RS,RJ                   Get a pointer to the CC
         LA    RJ,@RJ+1                We won't print it out
         DECR  RK                      Modify the count
         IF    (@RS,EQ,'0'),'LA RB,1'  Add 1 NL
         IF    (@RS,EQ,'-'),'LA RB,2'  Add 2 NLs
         IF    (@RS,EQ,'1'),'LA RB,4'  Add 4 NLs
         IF    (RB,NZ),BEGIN
         ADDSG =X'15151515',(RB),#SCSR Actually add them
         END   ,
         END   ,
         END   ,
*
* Move the user's data into the buffer
*
         IF    (RK,NZ),BEGIN           Only if there is something
         ADDSG (RJ),(RK),#SCSR         Add the user data
         END   ,
         AR    RK,RB                   Get the Total length so far
         END   ,                       end of some user data
*
* Take care of trailing NLs if requested
*
         IF    ^@M1IODIS,BEGIN         Not for display mode
         IF    ^MT1FNWNL,BEGIN         Not No NLs, means we add one
         ADDSG =X'15',1,#SCSR          Add it to the buffer
         LA    RK,@RK+1                Count of our data gets updated
         END   ,
         END   ,
*
* Now we fill in the length of the data for milten
*
         STH   RK,PDBWC                Save it in the write count
         LA    RK,@RB+6                Needed for milten
         STH   RK,PDBOUTCT             Save it again
*
* Send it off to milten
*
         ACALL MILSX                   Send the transaction off
*
* Unfix the areas we fixed
*
         L     RJ,@M1IOR01             Get the location again
         L     RK,@M1IOR15             And the length
         IF    (RK,NZ),BEGIN
         UNFIX (RJ),(RK)               Unfix the user area
         END   ,
         UNFIX PDB,L'PDB               And the PDB too
*
* Schedule the task to handle the I/O completion
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+WRTERMX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
*
* We are done with the SVC inline stuff, return to the caller
*
         CLEAR RVR                     Good return
         B     WRTDONE
*
WRTSPEC  LA    RVR,6                   Cause a Specification error
WRTDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  WRTERMX --  This is the Mode 1 terminal write completion     *
*              routine.
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WRTERMX  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Wait for the buffer to come back from milten
*
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
*
* See if it is the response we wanted.
*
*        IF    (PDBCMD,NE,FMILWRIT),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILWRIT),BEGIN
         ORVSNAP 'WRTERMX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
         IF    PDBCPLB.CPLBLGF,'ACALL M1LOGOFF'
*
* Handle the returns
*
         CLEAR MT1WR15                 Default is good return
         IF    PDBCPLA.CPLAIOE,BEGIN
         MVC   MT1WR15,=A(-4)          I/O error
         B     WRTXDONE
         END   ,
         IF    PDBCPLB.CPLBILT,BEGIN
         MVC   MT1WR15,=A(-12)         Illegal terminal
         B     WRTXDONE
         END   ,
         IF    PDBCPLA.CPLAATTN,BEGIN
         VCALL ASLOCK
         INCR  RS,MT1IACT              Count an attention
         VCALL ASULOCK
         ACALL M1ATTN                  Schedule the attention exit
         MVC   MT1WR15,=A(4)           Ended by attention
         B     WRTXDONE
         END   ,
*
* Finish up the write, Update the Sib if that is needed
*
WRTXDONE LABEL ,
         L     RS,MTCBSIB
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Update needed
         END   ,
*
* Free the input buffer, and post the I/O complete
*
         FREEB TBUF
         ACALL M1IODONE
*
* Finish up the task
*
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   WREDIT --  This is the Mode 1 Write Edit routine.           *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WREDIT   PROC  @M1IO,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Address
         WITH  (MTCB,RX)
*
* Enforce 24 bit addressing
*
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR01,0              Location of the buffer
         END   ,
*
* Validate the output buffer
*
         L     RJ,@M1IOR01             Get the location
         L     RK,@M1IOR15             And the length
         IF    (RK,NP),WRESPEC         Length must be >= 1
         IF    (RK,GT,251),WRESPEC     Must also be <= 251
*
* Make sure we can read the users buffer
*
         VALBUF (RJ),(RK),MT1RKEY      We want to read it
         IF    (RVR,NZ),EXIT           Some access violation
*
* All set to go, setup the PDB and parameter area
*
         L     RM,MTCBIOPA             Get a parameter area
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clean it up
         L     RY,MTCBPDB              Get a PDB to use
         WITH  (PDB,RY)
         CLEAR PDB                     Clean it up too
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Our milten line number
         MVI   PDBCMD,TMILXCTL         The command
         MVC   PDBSYSNM,MTCBWYLN       We're sending it to WYLBUR
         MVC   PDBVINFO,MT1PGM         The program information
         MVI   FORVCMD,FORVWEDT        Tell WYLBUR its a Write Edit
         IF    (@M1IOR14,NZ),'MVI FORVCMDM,WEDTNTYP'  Not typed
         STH   RK,WEDTTXTL             Save the length of the command
         LA    RS,@RK+6                Get the Milten count
         STH   RS,PDBOUTCT             Save it in the PDB
         FIX   PDB,L'PDB               Fix it
         ADDSG PDB,L'PDB,#SCSR         Add it to the list to send
         FIX   (RJ),(RK)
         ADDSG (RJ),(RK),#SCSR         Add the user data too
*
* Send it off to milten
*
         ACALL MILSX                   Send the transaction off
*
* Unfix the areas we fixed
*
         UNFIX (RJ),(RK)               Unfix the user area
         UNFIX PDB,L'PDB               And the PDB too
*
* Schedule the task to handle the I/O completion
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+WREDITX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
*
* We are done with the SVC inline stuff, return to the caller
*
         CLEAR RVR                     Good return
         B     WREDONE
*
WRESPEC  LA    RVR,6                   Cause a Specification error
WREDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  WREDITX --  This is the Mode 1 write edit completion         *
*              routine.                                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WREDITX  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Wait for the buffer to come back from milten
*
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
*
* Check out the response
*
*        IF    (PDBCMD,NE,FMILXCTL),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILXCTL),BEGIN
         ORVSNAP 'WREDITX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
*  If Wylbur is not there log this user off
*
         IF    (PDBSYSNM,Z),'SET  PDBCPLB.CPLBLGF'  Wylbur is gone
*
*  User needs to be logged off
*
         IF    PDBCPLB.CPLBLGF,BEGIN
         ACALL M1LOGOFF                Schedule the logoff exit
         CLEAR MT1WR15                 Good return
         MVC   MT1WR01,=A(4)           Call it an idle attn
         B     WREXDONE                Don't process any more of it
         END   ,
*
* Save off Wylbur's name for the next I/O
*
         MVC   MTCBWYLN,PDBSYSNM       Save Wylbur's name
*
* Handle the returns, first the ATTN status
*
         LH    RS,WEDTATTN             Get the ATTN status
         ST    RS,MT1WR01              Save in the return reg
         IF    (RS,NZ),BEGIN           Some ATTN was signalled
         VCALL ASLOCK                  Lock it up
         INCR  RS,MT1IACT              Up the ATTN count
         VCALL ASULOCK                 Unlock it
         ACALL M1ATTN                  Then schedule the exit
         END   ,
*
* Then take care of the return regarding the command passed
*
         CLEAR MT1WR15                 Default: good return
         IF    (FWYLRTNC,EQ,RTNCCHGB),BEGIN      Changes blocked
         MVC   MT1WR15,=A(-4)
         END   ,
         IF    (FWYLRTNC,EQ,RTNCERR),BEGIN       Command error
         MVC   MT1WR15,=A(-8)
         END   ,
*
* Finish up the write, Update the SIB if that is needed
*
         L     RS,MTCBSIB
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Update needed
         END   ,
*
* Free the input buffer, and post the I/O complete
*
WREXDONE FREEB TBUF
         ACALL M1IODONE
*
* Finish up the task
*
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   WRTEXT --  This is the Mode 1 Write Text routine.           *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WRTEXT   PROC  @M1IO,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Address
         WITH  (MTCB,RX)
*
* Enforce 24 bit addressing
*
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR01,0              Location of the buffer
         END   ,
*
* Validate the output buffer
*
         L     RJ,@M1IOR01             Get the location
         LH    RK,@M1IOR15+2           And the length
         IF    (RK,NP),WRXSPEC         Length must be >= 1
         IF    (RK,GT,8192),WRXSPEC    And <= 8K *** TEMP ***
*
* Make sure we can read the users buffer
*
         VALBUF (RJ),(RK),MT1RKEY      We want to read it
         IF    (RVR,NZ),EXIT           Some access violation
*
* Validate the option code, and LRECL
*
         LH    RA,@M1IOR15             Get the code
         IF    (RA,GT,6),WRXSPEC       Option code too big
         IF    (RA,NEG),WRXSPEC        Or too small
         LH    RS,@M1IOR14+2           Get the count of lines
         IF    (RS,NEG),WRXSPEC        Not less than zero
         CLEAR RB                      Default LRECL
         IF    (RA,EQ,4),BEGIN         He is specifying LRECL
         LH    RB,@M1IOR14             Get his lrecl
         IF    (RB,GT,256),WRXSPEC     His is too big
         IF    (RB,NP),WRXSPEC         Or too small
         END   ,
         IF    (RA,GT,4),'LA RB,80'    Card format LRECL
*
* All set to go, setup the PDB and parameter area
*
         L     RM,MTCBIOPA             Get a parameter area
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clean it up
         L     RY,MTCBPDB              Get a PDB to use
         WITH  (PDB,RY)
         CLEAR PDB                     Clean it up too
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Our milten line number
         MVI   PDBCMD,TMILXCTL         The command
         MVC   PDBSYSNM,MTCBWYLN       We're sending it to WYLBUR
         MVC   PDBVINFO,MT1PGM         The program information
         MVI   FORVCMD,FORVWTXT        Tell WYLBUR its a Write Text
         STC   RA,WTXTOPT              Move in the option byte
         STC   RB,WTXTLREC             The LRECL
         MVC   WTXTNUML,@M1IOR14+2     The number of lines
         STH   RK,WTXTTXTL             And the length of the data
         LA    RS,@RK+6                Milten count
         STH   RS,PDBOUTCT             Save in the PDB
         FIX   PDB,L'PDB               Fix it
         ADDSG PDB,L'PDB,#SCSR         Add it to the list to send
         FIX   (RJ),(RK)               Fix the user data
         ADDSG (RJ),(RK),#SCSR         Send it off
*
* Send it off to milten
*
         ACALL MILSX                   Send the transaction off
*
* Unfix the areas we fixed
*
         UNFIX (RJ),(RK)               Unfix the user area
         UNFIX PDB,L'PDB               And the PDB too
*
* Schedule the task to handle the I/O completion
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+WRTEXTX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
*
* We are done with the SVC inline stuff, return to the caller
*
         CLEAR RVR                     Good return
         B     WRXDONE
*
WRXSPEC  LA    RVR,6                   Cause a Specification error
WRXDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  WRTEXTX --  This is the Mode 1 write text completion         *
*              routine.                                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WRTEXTX  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Wait for the buffer to come back from milten
*
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
*
* Check out the response
*
*        IF    (PDBCMD,NE,FMILXCTL),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILXCTL),BEGIN
         ORVSNAP 'WRTEXTX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
*  If Wylbur is not there log this user off
*
         IF    (PDBSYSNM,Z),'SET  PDBCPLB.CPLBLGF'  Wylbur is gone
*
*  User needs to be logged off
*
         IF    PDBCPLB.CPLBLGF,BEGIN
         ACALL M1LOGOFF                Schedule the exit
         CLEAR MT1WR15                 Make his time left happy time
         B     WTXDONE                 No other info is needed.
         END   ,
*
* Save off Wylbur's name for the next I/O
*
         MVC   MTCBWYLN,PDBSYSNM       Save Wylbur's name
*
* Handle the returns, first the ATTN status
*
         LC    RS,FWYLRTNC             Get the return code
         ST    RS,MT1WR15              Save in the return reg
         IF    (RS,GT,RTNCFULL),BEGIN  We have a residual count
         LH    RS,WTXTRCNT             Get the residual count
         ST    RS,MT1WR01              Return it to the user
         END   ,
*
* Finish up the write, Update the SIB if that is needed
*
         L     RS,MTCBSIB
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Update needed
         END   ,
*
* Free the input buffer, and post the I/O complete
*
WTXDONE  FREEB TBUF
         ACALL M1IODONE
*
* Finish up the task
*
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*****************************************************************
*                                                               *
*    CNTRL --  This is the Mode 1 Control routine.              *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CNTRL    PROC  @M1IO,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get current ASB
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB Address
         WITH  (MTCB,RX)
*
* Decide what kind of Control it is, and dispatch accordingly
*
         L     RS,@M1IOR01             Get the control number
         IF    (RS,NEG),CTLSPEC        It is too small
         IF    (RS,GT,MAXCNTL),CTLSPEC It is too big
         STC   RS,MT1CNTL              Save the control number
         SLL   RS,2                    *4
         B     *+4(RS)                 Branch to the routine
CTTAB1   B     CTL00                 0 Space lines
         B     CTL01                 1 Page eject
         B     CTL02                 2 Set Tabs
         B     CTL03                 3 Sense Tabs
         B     CTL04                 4 Set Upper
         B     CTL05                 5 Set Uplow
         B     CTL06                 6 Sense Case
         B     CTL07                 7 Set CC
         B     CTL08                 8 Set No CC
         B     CTL09                 9 Sense CC
         B     CTLSPEC              10 Set Backspace character
         B     CTLSPEC              11 Sense Backspace character
         B     CTL12                12 Set Wylbur mode word
         B     CTL13                13 Sense Wylbur mode word
         B     WYLCNTL              14 Sense Wylbur active file size
         B     WYLCNTL              15 Sense Wylbur first line number
         B     WYLCNTL              16 Sense Wylbur last line number
         B     WYLCNTL              17 Clear Wylbur active file
         B     CTLSPEC              18 Abort Wylbur command in progress
         B     CTLSPEC              19 Write Wylbur lines to terminal
         B     CTLSPEC              20 Obtain permission for next line
         B     CTL21                21 Sense terminal info
         B     CTLSPEC              22 -- handled in M1SERV --
         B     CTLSPEC              23 -- handled in M1SERV --
         B     CTLSPEC              24 -- handled in M1SERV --
         B     CTL25                25 Clear auto NL on write
         B     CTL26                26 Set auto NL on write
         B     CTL27                27 Sense auto NL status
         B     WYLCNTL              28 Sense wylbur delta
         B     CTLSPEC              29 Open new active file
         B     CTL30                30 Set milten mode word
         B     CTL31                31 Sense milten mode word
         B     CTL32                32 Signal Wylbur exec break
*
MAXCNTL  EQU   (*-CTTAB1)/4            Maximum control number
         EJECT ,
*
* CONTROL  0 - Space N lines.
*
CTL00    LABEL ,
         L     RA,@M1IOR15             Get the skip count
         IF    (RA,NEG),CTLSPEC        Bad number to skip
         IF    (RA,GT,66),CTL01        Pretend it is an eject
         IF    (RA,Z),BEGIN            Skip no lines, that's easy
         CLEAR MT1WR15                 Good return code
         B     CTLIPOST                Do the immediate post
         END   ,
         B     CTEJECT                 Go send it off
*
* CONTROL  1 - Page eject (space 4 lines)
*
CTL01    LABEL ,
         LA    RA,4                    Get the count
*
* Send it to milten, RA Contains the number of NL's
*
CTEJECT  LABEL ,
         L     RM,MTCBIOPA             Get a parm location
         WITH  (#SCSR,RM)
         CLEAR #SCSR
         L     RY,MTCBPDB              Get a PDB
         WITH  (PDB,RY)
         CLEAR PDB                     Clean that up too
         MVC   PDBLIN#,MTCBLINE        Move in the line number
         MVI   PDBCMD,TMILWRIT         Move in the write command
         MVC   PDBVINFO,MT1PGM         And the program info
         STH   RA,PDBWC                Fill in the write count
         LA    RS,@RA+6
         STH   RS,PDBOUTCT             And the total count
         FIX   PDB,L'PDB
         ADDSG PDB,L'PDB,#SCSR         Send the PDB
         ADDSG CTLNLS,(RA),#SCSR       Add the NLs
         ACALL MILSX                   Send it off
         UNFIX PDB,L'PDB               Unfix the PDB
         SET   MT1FCIO                 Control I/O started
         B     CTLSTSK                 Go start up the task
*
CTLNLS   DC    66X'15'                 Some newlines
         EJECT ,
*
* CONTROL  2 - Set tabs, this currently does nothing
*
CTL02    LABEL ,
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR15,0              Enforce 24 bit addresses
         END   ,
         L     RJ,@M1IOR15             Get the tab location address
         VALBUF (RJ),LA:16,MT1RKEY     Can he access that stuff
         IF    (RVR,NZ),CTLDONE        No, an access exception
         CLEAR MT1WR15                 Set good return
         B     CTLIPOST                And post immediately
         SPACE 3
*
* CONTROL  3 - Sense Tabs
*
CTL03    LABEL ,
         IF    ^@M1IOM31,BEGIN
         MVI   @M1IOR15,0              Enforce 24 bit addresses
         END   ,
         L     RJ,@M1IOR15             Get the tab location address
         VALBUF (RJ),LA:16,MT1RKEY,W   Can he access that stuff
         IF    (RVR,NZ),CTLDONE        No, an access exception
         L     RS,MTCBSIB              Get the SIB address
         WITH  (SIB,RS),'MVC @RJ(16),SIBTABS'    Move in the tabs
         CLEAR MT1WR15                 Set good return
         B     CTLIPOST                And post immediately
         EJECT ,
*
* CONTROL  4 - Set upper
*
CTL04    LABEL ,
         L     RB,MTCBSIB              Get the SIB address
         WITH  (SIB,RB),BEGIN
         IF    ^SIBFUPL,BEGIN          It's already set
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                And go post
         END   ,
         END   ,
         B     CTLSTSK                 Finish it in the task
*
* CONTROL  5 - Set Uplow
*
CTL05    LABEL ,
         L     RB,MTCBSIB              Get the SIB address
         WITH  (SIB,RB),BEGIN
         IF    SIBFUPL,BEGIN           It's already set
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                And go post
         END   ,
         END   ,
         B     CTLSTSK                 Otherwize complete in the task
*
* CONTROL  6 - Sense the translation mode
*
CTL06    LABEL ,
         L     RB,MTCBSIB              Get the SIB address
         WITH  (SIB,RB),BEGIN
         CLEAR MT1WR15                 Default (UPPER)
         IF    SIBFUPL,'MVC MT1WR15,=A(4)'
         END   ,
         B     CTLIPOST                And go post
         EJECT ,
*
* CONTROL  7 - Sets no cariage control on terminal writes
*
CTL07    LABEL ,
         CLEAR MT1FCC                  Clear the flag
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                And go postit
*
* CONTROL  8 - Sets carriage control on terminal writes
*
CTL08    LABEL ,
         SET   MT1FCC                  Set the flag
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                Go post
*
* CONTROL  9 - Sense the status of carriage control on writes
*
CTL09    LABEL ,
         CLEAR MT1WR15                 Default is no CC
         IF    MT1FCC,'MVC MT1WR15,=A(4)' CC in effect
         B     CTLIPOST                Then post
         EJECT ,
*
* CONTROL 12 - Set the Wylbur mode word
*
CTL12    LABEL ,
         L     RB,@M1IOR15             Get one desired
         C     RB,MTCBWMW              See if it's the same as ours
         IF    EQ,BEGIN                It is, we can skip the I/O
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                Then go post
         END   ,
         ST    RB,MTCBWMW              Save the new mode word
         B     WYLCNTL                 Go do it
*
* CONTROL 13 - Sense the Wylbur mode word
*
CTL13    LABEL ,
         CLEAR MT1WR15                 Good return
         MVC   MT1WR01,MTCBWMW         Give him the mode word
         B     CTLIPOST                Then post complete
         EJECT ,
*
* Common code for all Wylbur controls
*
WYLCNTL  LABEL ,
         L     RM,MTCBIOPA             Get the parm address
         WITH  (#SCSR,RM)
         CLEAR #SCSR                   Clear the area
         L     RY,MTCBPDB              Get a PDB
         WITH  (PDB,RY)
         CLEAR PDB                     Clear it
*
* Format the PDB
*
         MVC   PDBLIN#,MTCBLINE        Line number
         MVI   PDBCMD,TMILXCTL         Transfer control
         MVC   PDBSYSNM,MTCBWYLN       To wylbur
         MVI   FORVCMD,FORVCNTL        Control command
         MVC   PDBVINFO,MT1PGM         Move in program info
         MVC   FORVCMDM,MT1CNTL        Control number
         IF    (MT1CNTL,EQ,12),BEGIN   Set mode word
         MVC   CNTLMDWD(1),MTCBWMW     Move prompt prefix
         MVC   CNTLMDWD+1(1),MTCBWMW+3 And the data bits
         END   ,
         FIX   PDB,L'PDB               Fix it
         ADDSG PDB,L'PDB,#SCSR         Add it to the list to send
         ACALL MILSX                   Send it off
         UNFIX PDB,L'PDB               Unfix the PDB
         SET   MT1FCIO                 Control I/O started
         B     CTLSTSK                 Go start up the task
         EJECT ,
*
* CONTROL 21 - Sense terminal information, dummied up
*
CTL21    LABEL ,
         L     RA,@M1IOR15             Get the address
         VALBUF (RA),LA:60,MT1RKEY,W   Can we update the area?
         IF    (RVR,NZ),CTLDONE        Nope, access exception
         L     RS,MTCBSIB              SIB address
         WITH  (SIB,RS),BEGIN
         MVC   @RA(2),SIBTINFO         Terminal type
         MVC   @RA+2(1),SIBWID+1       Width
         MVC   @RA+3(1),SIBHEI+1       Height
         END   ,
         CLEAR MT1WR15                 Clear the return code
         B     CTLIPOST                And post complete
         EJECT ,
*
* CONTROL 25 - Clear Auto NL on terminal writes
*
CTL25    LABEL ,
         SET   MT1FNWNL                Set no write new lines
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                Post it complete
*
* CONTROL 26 - Set Auto NL on terminal writes
*
CTL26    LABEL ,
         CLEAR MT1FNWNL                Set write new lines
         CLEAR MT1WR15                 Good return
         B     CTLIPOST                Post it complete
*
* CONTROL 27 - Sense the state of auto newline on writes
*
CTL27    LABEL ,
         CLEAR MT1WR15                 Default: Auto newline
         IF    MT1FNWNL,'MVC MT1WR15,=A(4)'      No auto newline
         B     CTLIPOST                Post it complete
         EJECT ,
*
* CONTROL 30 - Set the milten mode word. We only look at a few bits.
*
CTL30    LABEL ,
         IF    @M1IOR15+3.X'80','SET MT1FCC'     Carriage control on
         ELSE  'CLEAR MT1FCC'                    Carriage control off
         IF    @M1IOR15+3.X'40','SET MT1FNWNL'   No write NL's
         ELSE  'CLEAR MT1FNWNL'                  Set Write NL's
         CLEAR MT1WR15
         B     CTLIPOST                Post complete
*
* CONTROL 31 - Sense the milten mode word (dummy)
*
CTL31    LABEL ,
         CLEAR MT1WR01                 Default is no bits
         IF    MT1FCC,BEGIN            Carriage control on
         SET   MT1WR01+3.X'80'         Tell the caller
         END   ,
         IF    MT1FNWNL,BEGIN          No NL's on Write
         SET   MT1WR01+3.X'40'         Tell the Caller
         END   ,
         CLEAR MT1WR15
         B     CTLIPOST                Post complete
*
* CONTROL 32 - Set WYLBUR exec break or mode retry
*
CTL32    LABEL ,
         IF    (@M1IOR15,Z),'SET MTFLWCME' Command error
         ELSE  'SET MTFLWATN'              Attention
         CLEAR MT1WR15
         B     CTLIPOST                Go post it complete
         EJECT ,
*
* Some action has been initiate that we have to wait for, start up
* the task that will handle the completion
*
CTLSTSK  LABEL ,
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+CNTLX)
         MVC   @TCRPRIO,=A(10)         Higher priority
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the stack
         CLEAR RVR                     All is well here
         B     CTLDONE                 Return to the caller
*
* Post the I/O complete
*
CTLIPOST ACALL M1IODONE                Call the completion routine
         CLEAR RVR                     Signal good return here
         B     CTLDONE
CTLSPEC  LA    RVR,6                   Specification error
CTLDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*    CNTLX --  This is the Mode 1 terminal control completion   *
*              routine.                                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CNTLX    PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Wait for the Response to come back from milten
*
         IF    ^MT1FCIO,DOCTLX         Skip if no control I/O out
         CLEAR MT1FCIO                 Then clear the flag
         ACALL MILRX                   Get the buffer back
         LR    RM,RVR                  Get the TBUF address
         WITH  (TBUF,RM)               Address it
         WITH  (PDB,TBUFDATA)          Address the PDB too
         IF    PDBCPLB.CPLBLGF,BEGIN
         ACALL M1LOGOFF                Schedule a logoff exit
         CLEAR MT1WR15                 Make everyone happy
         B     CTLXLODN                Finish up
         END   ,
*
* Decide what kind of Control it was, and dispatch accordingly
*
DOCTLX   LC    RS,MT1CNTL              Get the control number
         IF    (RS,NEG),CTLXBAD        It is too small
         IF    (RS,GT,MAXCNTL),CTLXBAD It is too big
         SLL   RS,2                    *4
         B     *+4(RS)                 Branch to the routine
CTTAB2   B     CTLX00                0 Space lines
         B     CTLX01                1 Page eject
         B     CTLXBAD               2 Set Tabs
         B     CTLXBAD               3 Sense Tabs
         B     CTLX04                4 Set Upper
         B     CTLX05                5 Set Uplow
         B     CTLXBAD               6 Sense Case
         B     CTLXBAD               7 Set CC
         B     CTLXBAD               8 Set No CC
         B     CTLXBAD               9 Sense CC
         B     CTLXBAD              10 Set Backspace character
         B     CTLXBAD              11 Sense Backspace character
         B     CTLXWYL              12 Set Wylbur mode word
         B     CTLXBAD              13 Sense Wylbur mode word
         B     CTLXWYL              14 Sense Wylbur active file size
         B     CTLXWYL              15 Sense Wylbur first line number
         B     CTLXWYL              16 Sense Wylbur last line number
         B     CTLXWYL              17 Clear Wylbur active file
         B     CTLXWYL              18 Abort Wylbur command in progress
         B     CTLXBAD              19 Write Wylbur lines to terminal
         B     CTLXBAD              20 Obtain permission for next line
         B     CTLXBAD              21 Sense terminal info
         B     CTLXBAD              22 -- handled in M1SERV --
         B     CTLXBAD              23 -- handled in M1SERV --
         B     CTLXBAD              24 -- handled in M1SERV --
         B     CTLXBAD              25 Clear auto NL on write
         B     CTLXBAD              26 Set auto NL on write
         B     CTLXBAD              27 Sense auto NL status
         B     CTLXWYL              28 Sense wylbur delta
         B     CTLXBAD              29 Open new active file
*
MAXCTLX  EQU   (*-CTTAB2)/4            Maximum control number
CTLXBAD  ABORT BADWCNTL                Bad control involving I/O
         EJECT ,
*
* Control 0 and 1, just have a write completion from milten
*
CTLX00   LABEL ,
CTLX01   LABEL ,
*        IF    (PDBCMD,NE,FMILWRIT),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILWRIT),BEGIN
         ORVSNAP 'MILCNTLX',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
* Handle the returns
*
         IF    PDBCPLA.CPLAIOE,BEGIN
         MVC   MT1WR15,=A(-4)          I/O error
         B     CTLXDONE
         END   ,
         IF    PDBCPLA.CPLAATTN,BEGIN
         MVC   MT1WR15,=A(4)           Ended by attention
         B     CTLXDONE
         END   ,
         CLEAR MT1WR15                 Must be a good return
         B     CTLXDONE
         EJECT ,
*
* Control 4 set the terminal translation mode to UPPER by updating
* the SIB.
*
CTLX04   LABEL ,
         L     RS,MTCBSIB              Get the SIB address
         WITH  (SIB,RS),'CLEAR SIBFUPL'  Clear the uplow flag
         ACALL NEWSIB                  Update the SIB
         IF    (RVR,NZ),CTLX04         It didn't work, try again
         CLEAR MT1WR15                 Good return
         B     CTLXXDN                 All done
         SPACE 2
*
* Control 5 set the terminal translation mode to UPLOW by updating
* the SIB.
*
CTLX05   LABEL ,
         L     RS,MTCBSIB              Get the SIB address
         WITH  (SIB,RS),'SET SIBFUPL'  Set the uplow flag
         ACALL NEWSIB                  Update the SIB
         IF    (RVR,NZ),CTLX05         It didn't work, try again
         CLEAR MT1WR15                 Good return
         B     CTLXXDN                 All done
         EJECT ,
*
* The Wylbur controls
*
CTLXWYL  LABEL ,                       Set mode word
*        IF    (PDBCMD,NE,FMILXCTL),'ABORT *SEQERR'
         IF    (PDBCMD,NE,FMILXCTL),BEGIN
         ORVSNAP 'MILCNTLXWYL',MODE=WTL
         ORVSNAP TBUF,255
         END   ,
*
*  If Wylbur is not there log this user off
*
         IF    (PDBSYSNM,Z),BEGIN
         SET   PDBCPLB.CPLBLGF         Wylbur is gone
         ACALL M1LOGOFF                Schedule the exit
         CLEAR MT1WR15                 Make his time left happy time
         B     CTLXLODN                No other info is needed.
         END   ,
*
* Save WYLBUR's name
*
         MVC   MTCBWYLN,PDBSYSNM       Current wylbur name
*
* Handle the returns
*
         CLEAR MT1WR15                 Clear the return code
         IF    (((MT1CNTL,GE,14),AND,(MT1CNTL,LE,16)),OR,              +
               (MT1CNTL,EQ,28)),BEGIN
         LC    RS,FWYLRTNC
         ST    RS,MT1WR15              Give that to the user
         MVC   MT1WR01,CNTLNUML        Return line info in R1
         END   ,
         EJECT ,
*
* Finish up the Control processing, Update the Sib if that is needed
*
CTLXDONE LABEL ,
         L     RS,MTCBSIB
         WITH  (SIB,RS),BEGIN
         IF    (PDBSUC,NE,SIBUC),'ACALL CURSIB'  Update needed
         END   ,
*
* Free the input buffer, and post the I/O complete
*
CTLXLODN FREEB TBUF
CTLXXDN  ACALL M1IODONE
*
* Finish up the task
*
         PSET  @TEXIT
         VCALL TEXIT
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*     HALT --  This is the Mode 1 terminal Halt routine.        *
*                                                               *
*   Input  --  @M1IO                                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
HALT     PROC  @M1IO,SCOPE=LOCAL
*
* Find out where we are
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Get the parm area and PDB
*
         L     RY,MTCBPDB              Get a PDB
         WITH  (PDB,RY)
         CLEAR PDB                     Clean that up too
         L     RM,MTCBIOPA             Get a parm location
         WITH  (#SCSR,RM)
         CLEAR #SCSR
*
* Fill in the PDB
*
         MVC   PDBLIN#,MTCBLINE        Move in the line number
         MVI   PDBCMD,TMILBRK          Send milten a break
         MVC   PDBVINFO,MT1PGM         and the program info
         FIX   PDB,L'PDB
         ADDSG PDB,L'PDB,#SCSR         Send the PDB
         ACALL MILSX                   Send it off
         UNFIX PDB,L'PDB               Unfix the PDB
         PEND
         EJECT ,
*****************************************************************
*                                                               *
*   M1ATTN --  Handle a mode 1 idle attention. This just        *
*              schedules the proper exit routine.               *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
M1ATTN   PROC  @M1IO,SCOPE=LOCAL
         L     RX,PZCURASB             ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Schedule the exit routine
*
         PSET  @XITDO
         MVC   @XITRQID,MTCBATTN       Get the ATTN request ID
         MVC   @XITTSK,MT1ATSK         Move in the ATTN task
         MVI   @XITTYPE,XITTATTN       Mark it as an ATTN exit
         WITH  (@M1TATP,@XITPARM)
         MVC   @M1TATRQ,MT1RQID        Give him a request ID
         LA    RS,MT1IACT              Get the address of the count
         ST    RS,@M1TATCT             Tell M1SERV about it
         VCALL XITDO                   Go do it (no matter the RC)
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* M1LOGOFF --  Handle the terminal going away. This just        *
*              schedules the proper exit routine.               *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
M1LOGOFF PROC  SCOPE=LOCAL
         L     RX,PZCURASB             ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
         IF    MTFLLGOF,EXIT           Already logging off
*
* Schedule the exit routine
*
         PSET  @XITDO
         MVC   @XITRQID,MTCBLGOF       Get the logoff request ID
         MVC   @XITTSK,MT1ATSK         Move in the ATTN task
         MVI   @XITTYPE,XITTLGO        Mark it as an logoff exit
         VCALL XITDO                   Go do it
         IF    (RVR,Z),'SET  MTFLLGOF'    Set the flag
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* M1IODONE --  Signal the I/O requestor that the I/O is         *
*              complete.  It uses information from the MTCB.    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
M1IODONE PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
* Schedule the I/O complete exit
*
         PSET  @XITDO
         MVC   @XITRQID,MTCBIOCP       Move in the request ID
         MVC   @XITTSK,MT1RQTK         Task ID
         MVI   @XITTYPE,XITTIOCN       I/O complete
         MVC   @XITPARM,MT1RQID        Move in the RQID and Regs
         VCALL XITDO                   Schedule the exit
         IF    (RVR,NZ),'ABORT BADIOCPX'  Can't schedule the exit
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* GETCHGS  --  Obtain the current charges for this address      *
*              space.  The information is put into the MTCB.    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
GCWA     RECORD BEGIN
GCTIME   DS    D                       Time conversion area
         END   ,
         SPACE 2
GETCHGS  PROC  ,GCWA,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PZCURASB             Get the current ASB address
         WITH  (ASB,RX),'L RX,ASBTCCB' Get the MTCB address
         WITH  (MTCB,RX)
*
*  Get accounting information
*
         PSET  @ACINFO
         MVC   @ACIASB,PZCURASB        Current ASB address
         VCALL ACINFO
*
*  Put charge info (CPU time and I/O counts) into MTCB
*
         LD    R0,@ACICPU              CPU time in clock units
         DD    R0,=FL8'106667'         Convert to 26 micro-seconds
         AW    R0,=XL8'4E00000000000000'
         STD   R0,GCTIME
         MVC   MT1CPUT,GCTIME+4        CPU time
         L     RS,@ACIIOS              Get the I/O counts
         ST3   RS,MT1DIOCT             Save the count
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  VALBUF  --  Validate a buffer location.                      *
*                                                               *
*   Input  --  @VALBUF                                          *
*                                                               *
*  Output  --  RVR: 0=OK; 4=Protection; 5=Addressing            *
*                                                               *
*****************************************************************
         SPACE 2
VALBUF   PROC  @VALBUF,SCOPE=LOCAL
         L     RJ,@VALBLOC             Get the buffer location
         LH    RK,@VALBLEN             And it's length
         LC    RB,@VALBKEY             Get the key of the issuer
*
* Check out the buffer
*
         PSET  @PAGE
         MVC   @PAGLOC,@VALBLOC        Location of the buffer
         LH    RS,@VALBLEN             Get the length
         ST    RS,@PAGLEN              Tell him about it
         MVC   @PAGKEY,@VALBKEY        Inform him of the key too
         VCALL PAGTPROT                Test the protection
         IF    (RVR,Z),EXIT            All is well
         IF    (RVR,EQ,3),BEGIN        Addressing exception
         LA    RVR,5
         EXIT  VALBUF
         END   ,
         IF    (RVR,EQ,2),BEGIN        No access
         LA    RVR,4
         EXIT  VALBUF
         END   ,
         IF    @VALBWRT,'LA RVR,4'     Only read, he wants write
         ELSE  'CLEAR RVR'             He just wants to look
         PEND  ,
         XTRCDATA ,                    Generate the trace info
         END   .
