GSTINTF  TITLE 'ORVYL''S MVS - Virtual Machine Interface'
         COPY  HEADER
         EJECT ,
GSTINTF  MODULE
         SPACE 3
*
*  TPROT AND LRA CONDITION CODES
*
         DEFCC NOSTR,6                 TPROT - NO STORE
         DEFCC NOACC,2                 TPROT - NO ACCESS
         DEFCC NOTRN,1                 TPROT - NOT TRANSLATABLE
         DEFCC INVLD,4                 LRA   - INVALID SEGMENT
*                                      PSA, CVT, CSD, RCE, SMCA,
         PRINT OFF                     LPDE, DCBD, WPL, TCB, RB
         EJECT
         IHAPSA
         EJECT
         CVT   DSECT=YES
*
USERCVT  RECORD 'USERCVT'          (Scip CVT)
*NCPUs   EJECT
*NCPUs   IHACSD
         EJECT
         IARRCE
         EJECT
         IEESMCA
         EJECT
         IHALPDE
         EJECT ,
         DCBD  DSORG=(PO)
         EJECT
         IEZWPL
         EJECT
         IKJTCB
         EJECT
         IKJRB
GSTINTF  CSECT
         PRINT ON
         COPY  CANPARM
         COPY  CONVPARM
         COPY  CPTPARM
         COPY  FIXPARM
         COPY  FUNCPARM
         COPY  MEMPARM
         COPY  MSGPARM
         COPY  LOCKPARM
         COPY  POOLPARM
         COPY  POSTPARM
         COPY  SBTPARM
         COPY  SPNPARM
         COPY  TRCEPARM
         COPY  WAITPARM
         EJECT
         COPY  SEGCBD
         EJECT
         COPY  DSALPARM
         EJECT
         COPY  SEGPARM
         EJECT
         COPY  IORPARM
         SPACE 3
         COPY  GSTIPARM
         EJECT
         COPY  PARMPARM
         SPACE 3
*
*  Guest interface parameter work area
*
GSTIPARM RECORD BEGIN
GSTIPRMI DS    XL(L'PARMIN)            PARMIN area
GSTIKEY1 DS    CL8                     Key 1
GSTIKEY2 DS    CL8                     Key 2
GSTIKEY3 DS    CL8                     Key 3
GSTIVAL  DS    A                       Integer value
GSTIRDW  EQU   GSTIVAL                 RDW for string parameters
GSTISTR  DS    CL44                    String parameter area
         END   ,
         EJECT ,
         COPY  PZERO
         EJECT ,
*
* GETICAD -- Causes register r1 to be loaded with the effective
*            address of an intercepeted instruction, (S, RS type
*            instructions) or with 2 register numbers (for a
*            RRE type instruction).
*              These values are computed differently depending
*            on whether the interception format 2 of the SIE
*            instruction is installed.
*              The values are obtained from IPB (POPs) which ORVYL
*            calls ICAD1.
         SPACE
         MACRO
&L       GETICAD &R,&TYPE=
         AIF   ('&TYPE' EQ 'S').OK,('&TYPE' EQ 'RS').OK
         AIF   ('&TYPE' EQ 'RRE').OK
         MNOTE 8,'&TYPE is an invalid type for this macro.'
         MEXIT ,
.OK      ANOP  ,
         IF    SIEICIF2,BEGIN          Interruption fmt 2 installed
         AIF   ('&TYPE' NE 'RRE').NOTRRE2
         LH    &R,SIEICAD1             RRE fmt 2
         AGO   .DON2
.NOTRRE2 ANOP  ,                       S type for fmt 2
         LH    &R,SIEICAD1
         SLL   &R,16                   Clear high bits
         LR    EPAR,&R                 | load offset into reg
         SRL   &R,32-4                 | reg
         IF    (&R,NZ),BEGIN           Zero base
         LREGA &R,(&R)
         L     &R,0(,&R)
         END   ,                       OF Zero base
         SLL   EPAR,4                  | offset
         SRL   EPAR,32-12              |
         ALR   &R,EPAR
         AGO   .DON2
.DON2    ANOP  ,
         END   ,                       OF Int fmt 2 installed
         ELSE  BEGIN                   Int fmt 2 NOT installed
         AIF   ('&TYPE' NE 'RRE').NOTRRE1
         L     &R,SIEICAD1             RRE fmt 1
         AGO   .DON1
.NOTRRE1 ANOP  ,                       S type for fmt 1
         L     &R,SIEICAD1
         AGO   .DON1
.DON1    ANOP  ,
         END   ,                       OF Int fmt 2 NOT installed
         MEND
*
* LREGA -- Causes register R1 to be loaded with the address of the
*          guest register R2.  R2 may be contained in a Register
*          as well. Register R1 may not be 0.
         SPACE
         MACRO
&L       LREGA &R1,&R2
&L      $LA    &R1,&R2
         C     &R1,=F'14'              Which register set
         BH    H&SYSNDX
         BL    L&SYSNDX
         LA    &R1,SIEREG14            Load r14
         B     D&SYSNDX
H&SYSNDX LA    &R1,SIEREG15            Load r15
         B     D&SYSNDX
L&SYSNDX SLL   &R1,2
         LA    &R1,CPCREGS(&R1)        One of the set 0-13
D&SYSNDX LABEL ,
         MEND
         SPACE 2
*
* GRA -- This macro tranlates a guest real address into an MVS
*        virtual address.
*
         MACRO
&L       GRA   &R1,&LOC
&L      $LA    &R1,&LOC                Get the real address
         L     RVR,=X'7FFFF000'        Get a page mask
         NR    RVR,&R1                 Mask it out
         IF    Z,'O &R1,SIEPREFX'      0 -> PREFIX
         ELSEIF (RVR,EQ,SIEPREFX),'N &R1,=A(4095)'
         A     &R1,CPCORE              Add MVS offset
         MEND
         EJECT ,
*
* EXINT -- This macro causes an external interrupt on the CPU
*          whose CPUB is now addressable.
*
         SPACE ,
         MACRO
&L       EXINT &CODE=,&CPUREG=
.*
.*  CODE   -- The interrupt code to signal.  If this is left blank
.*            then the interrupt code from the SIE data area is
.*            used.  This should go well into a Y type constant.
.*
.*  CPUREG -- Indicates which register contains the CPU address to
.*            store as the signaller.  If this is not specified
.*            then no value is stored.
.*
&L       LABEL ,
         L     RS,CPPSALOC             Get the location of page 0
         WITH  (PZERO,RS),BEGIN
.*
.* Get us into KEY 0 with the minimum of disturbance
.*
         LR    RVR,R2                  R2 must be saved/restored
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         LR    EPAR,R2
         LR    R2,RVR                  Restore the Register
.*
.* Swap the PSWs
.*
         MVC   PZEXOPSW,SIEPSW         Save the OLD PSW
         MVC   SIEPSW,PZEXNPSW         Fetch the NEW PSW
.*
.* Put in the interrupt code
.*
         AIF   ('&CODE' EQ '').NOCODE
         MVC   PZEXIC,=Y(&CODE)        Move in the ICODE
         AGO   .CPU
.NOCODE  MVC   PZEXIC,SIEIEXCD         Move in the ICODE
.*
.* Put in the CPU address (if requested)
.*
.CPU     AIF   ('&CPUREG' EQ '').NOCPU
         STH   &CPUREG,PZEXCPU         Save the CPU address
.NOCPU   ANOP
         MODESET KEYREG=EPAR           Restore the PSW key
         END   ,
         MEND
         EJECT ,
*
* RSINT -- This sets up for a RESTART interruption for the CPU
*          whose CPUB is now addressable.
*
         SPACE ,
         MACRO
&L       RSINT
&L       LABEL ,
         L     RS,CPPSALOC             Get the location of page 0
         WITH  (PZERO,RS),BEGIN
.*
.* Get us into KEY 0 with the minimum of disturbance
.*
         LR    RVR,R2                  R2 must be saved/restored
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         LR    EPAR,R2
         LR    R2,RVR                  Restore the Register
.*
.* Swap the PSWs
.*
         MVC   PZRSOPSW,SIEPSW         Save the OLD PSW
         MVC   SIEPSW,PZRSNPSW         Fetch the NEW PSW
         MODESET KEYREG=EPAR           Restore the PSW key
         END   ,
         MEND
         EJECT ,
*
* PIINT -- Set up for a PROGRAM interrupt on the CPU whose CPUB is
*          now addressable.
*
         SPACE ,
         MACRO
&L       PIINT &CODE=,&EXA=,&ILEN=,&BACK=NO
.*
.*  CODE -- Interrupt code.  (REG) should fit in a Y type constant.
.*
.*  EXA  -- Exception Address.  Saved as the translation exception
.*          address.  If it is not specified, no address is saved.
.*
.*  ILEN -- Instruction length code.  2, 4, or 6.  If the EX flag
.*          in the SIE block is on it will be set to 4.
.*
.*  BACK -- Whether to back the PSW up to point at the instruction
.*          Valid values are -- YES: Back it up, and
.*                               NO: Don't back it up.
.*
         LCLC  &R
&L       LABEL ,
         L     RS,CPPSALOC             Get the location of page 0
         WITH  (PZERO,RS),BEGIN
.*
.* Get us into KEY 0 with the minimum of disturbance
.*
         LR    RAR,R2                  R2 must be saved/restored
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         LR    EPAR,R2
         LR    R2,RAR                  Restore the Register
.*
.* Swap the PSWs
.*
         MVC   PZPIOPSW,SIEPSW         Save the OLD PSW
         MVC   SIEPSW,PZPINPSW         Fetch the NEW PSW
.*
.* Save the interrupt code
.*
         AIF   ('&CODE' EQ '').NOCODE  Default ICODE
         AIF   ('&CODE'(1,1) EQ '(').REGCODE
         MVC   PZPIIC,=Y(&CODE)        Move in the code
         AGO   .CODEEND
.REGCODE ANOP
&R       SETC  '&CODE'(2,K'&CODE-2)
         STH   &R,PZPIIC               Store the code
         AGO   .CODEEND
.NOCODE  ANOP
         MVC   PZPIIC,SIEIPRCC         Save code given us
.CODEEND ANOP
.*
.* Move in the exception address
.*
         AIF   ('&EXA' EQ '').NOEXA
         AIF   ('&EXA'(1,1) EQ '(').REGEXA
         MVC   PZTREXA,&EXA            Save the exception address
         AGO   .NOEXA
.REGEXA  ANOP
&R       SETC  '&EXA'(2,K'&EXA-2)
         ST    &R,PZTREXA              Save the exception address
.NOEXA   ANOP
.*
.* Move in the instruction length
.*
         AIF   ('&ILEN' EQ '').NOILEN
         AIF   ('&ILEN' EQ '4').ILEN4
         IF    SIEICEX,'MVC PZPIILC,=Y(4)'
         ELSE  'MVC PZPIILC,=Y(&ILEN)'
         AGO   .ILCEND
.ILEN4   ANOP
         MVC   PZPIILC,=Y(4)
         AGO   .ILCEND
.NOILEN  ANOP
         MVC   PZPIILC,SIEIPRCL
.ILCEND  ANOP
.*
.* Handle instruction Backup
.*
         AIF   ('&BACK' NE 'YES').NOBACK
         L     RAR,PZPIOPSW+4
         SH    RAR,PZPIILC             Back it up
         ST    RAR,PZPIOPSW+4
.NOBACK  ANOP
         MODESET KEYREG=EPAR           Restore the PSW key
         END   ,
         MEND
         EJECT
         COPY  GSTCT               Guest interface control block
         EJECT
*******************************************************************
*                                                                 *
*       CPUB - CPU control block.  There is one of these for each *
*              virtual CPU.  It contains information about the    *
*              state of the virtual CPU.                          *
*                                                                 *
*******************************************************************
         SPACE
CPUB     RECORD BEGIN
         DC    CL4'CPUB'     Control block ID
*
* Bookkeeping information
*
CPGSTCT  DS    A             Address of the GSTCT
CPTASKID DS    A             Task Id of the subtask for this CPU
CPSIERA  DS    A             Real address of the SIE control block
CPCORE   DS    A             MVS virtual address of start of memory
CPCLEN   DS    A             Length of the CORE
CPCLAST  DS    A             Addr of Last byte of core+1
CPGRSAVE DS    16A           Register Save area
*
*
*
CPECB    DS    A             Wakeup the CPU ECB
CPCS     FLAG  ,             CPU state flags
         FLAG  CPCSRUN         CPU in running state
         FLAG  CPCSTERM        Guest termination time
         FLAG  CPCSDIS1        Display guest PSW and REGs
CPCPUA   DS    A             CPU Address (with high bit on)
CPCPUID  DS    D             CPU ID
CPPSALOC DS    A             MVS virtual address of PSA
CPCPUTM  DS    D             CPU Time for host services
*
* Signal processor information
*
CPEXCALL DS    A             EXT CALL - Addr of calling CPU
CPEMERG  DS    A             EMER SIG - bit map of calling CPU's
CPRSTRT  DS    A             RESTART - CPU addr of requestor
CPSPFX   DS    A             SET PREFIX - CPU address of requestor
*
* Diagnose routine information
*
CPLOADP  DS    A             Address of the LOAD parms
*
* Profiler information
*
CPSTIMER STIMERM SET,MF=L    Room for the STIMERM parms
CPSTIMID DS    A             ID of the STIMERM for profiling
CPSTPARM DS    A             Parm value for the STIMER routine
CPSTSTK  DS    A             Stack for the STIMER routine
CPSTRTCB DS    A             Address of the RTCB
*
CPCREGS  DS    14A           CPU regs 0-13
*
         DS    XL(256-(*-$$$RCPUB))    Align on 256 byte boundary
         EJECT ,
         COPY  SIEDATA
         END   ,
         EJECT ,
*
*
* IOCB -- This control block represents an I/O request from the
*         guest machine.  It is passed as a parm to IOSERV.
*
*
IOCB     RECORD BEGIN
         DC    C'IOCB'
IOCBNEXT DS    A             Address of the next IOCB
IOCBGSTC DS    A             Address of the GSTCT
*
* Information from the Request
*
IOCBSCH  DS    A             Subchannel ID word
IOCBIPRM DS    A             Interruption parameter
IOCBIFLG DS    A             I/O flags
IOCBCPA  DS    A             Address of the channel program
IOCBORB  EQU   IOCBIPRM,*-IOCBIPRM,C'X'          The ORB
IOCBSTAT DS    A             Subchannel status word (from IOSERV)
*** SIMULATION CODE ***
IOCBHSP  DS    CL1           Hiperspace in use flag
         DS    0F
*** END OF SIMULATION CODE ***
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @DOWTO - DOWTO Parameter area                                *
*                                                                 *
*******************************************************************
         SPACE
@DOWTO   RECORD BEGIN
@DWTLOC  DS    A                       Location of message
@DWTLEN  DS    A                       Length of message
*
@DWTFL   FLAG  ,
         FLAG  @DWTFSYS                Send to system log
         FLAG  @DWTFCON                Send to operator console
         FLAG  @DWTFND                 Make message non-deletable
*
         DS    X                       Reserved
*
@DWTLMAX EQU   L'WPLTXT                Maximum message length
         END   ,
         SPACE 3
DGVMPARM RECORD BEGIN
DGVFLAG  FLAG  ,
         FLAG  DGVFLOCAL   - Display local memory contents
         FLAG  DGVFCOMMON  - Only look at common memory
DGVMCPUB DS    A             CPUB of the CPU to dump
DGVMSCB  DS    A             SEGCB where to write it out
DGVMLOW  DS    A             Lowest address to dump
         END   ,
         EJECT ,
*******************************************************************
*                                                                 *
*    GSTINIT - Initialize the ORVYL virtual machine.              *
*                                                                 *
*                                                                 *
*      Input - Init parm pointer                                  *
*                                                                 *
*     Output - Address of the GSTCT                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GSTINIT  PROC  SCOPE=GLOBAL
*
* First thing to do is allocate our GSTCT
*
         POOLGET L'GSTCT,TYPE=(LOCAL)   Get the memory
         LR    RY,RVR
         WITH  (GSTCT,RY)              Set up the Addressability
         MVC   GSTCT(4),=CL4'GSTC'     Move in a Block Identifier
*
* Get parameter work area
*
         MEMGET L'GSTIPARM             Get work area
         LR    RX,RVR
         WITH  (GSTIPARM,RX)
         WITH  (PARMIN,GSTIPRMI)
*
* Determine number of CPU's
*
         MVC   GSTIKEY1,=CL8'CPUS'     Keyword
         SET   PARMFINT                Integer to be returned
         PSET  @PARMDO
         LA    RS,GSTIPRMI             PARMIN location
         ST    RS,@PARILOC
         LA    RS,L'PARMIN+8           Length of input
         ST    RS,@PARILEN
         LA    RS,GSTIVAL              Location of return area
         ST    RS,@PAROLOC
         LA    RS,L'GSTIVAL            Length of return area
         ST    RS,@PAROLEN
         VCALL PARMDO
         LA    RA,1                    Default is 1
         IF    (RVR,Z),'L  RA,GSTIVAL' Number of CPU's
         ACALL MAXCPUS
         CEIL  RA,RVR
         ST    RA,GSTCNCPU
*
* Determine amount of memory to be used
*
         MVC   GSTIKEY1,=CL8'MEMORY'   Keyword
         MVC   GSTIKEY2,=CL8'MINSIZE'  Sub-keyword
         SET   PARMFINT                Integer to be returned
         PSET  @PARMDO
         PMOV  @PARILOC,LA:GSTIPRMI    PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:GSTIVAL     Location of return area
         PMOV  @PAROLEN,LA:L'GSTIVAL   Length of return area
         VCALL PARMDO
         L     RS,=A(MINMEG*1024)      Default is 2 Megabytes (in K)
         IF    (RVR,Z),BEGIN           Parm supplied
         L     RS,GSTIVAL              Supplied memory value
         FLOOR RS,=A(MINMEG*1024)       with a minimum
         END   ,                       OF Parm supplied
         SLL   RS,10               Convert from "K" to bytes
         ST    RS,GSTCMINL         Save MINSIZE
*
         MVC   GSTIKEY1,=CL8'MEMORY'   Keyword
         MVC   GSTIKEY2,=CL8'SIZE'     Sub-keyword
         SET   PARMFINT                Integer to be returned
         PSET  @PARMDO
         PMOV  @PARILOC,LA:GSTIPRMI    PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:GSTIVAL     Location of return area
         PMOV  @PAROLEN,LA:L'GSTIVAL   Length of return area
         VCALL PARMDO
         L     RS,=A(MINMEG*1024)      Default is 2 Megabytes (in K)
         IF    (RVR,Z),BEGIN           Parm supplied
         L     RS,GSTIVAL              Supplied memory value
         FLOOR RS,=A(MINMEG*1024)       with a minimum
         END   ,                       OF Parm supplied
*
* Get the memory for the Orvyl Virtual Machine
*
         PSET  OMEMP
         SLL   RS,10                   Convert from "K" to bytes
         ST    RS,OMEMSIZE             Size to get
         LCALL OMEMGET
         MVC   GSTCCORE,OMEMLOC        Save the location
         MVC   GSTCCLEN,OMEMSIZE       And the length
*
* Find out what percent of the machine we should take
*
         MVC   GSTIKEY2,=CL8'PERCENT'  Sub-keyword
         SET   PARMFINT                Integer to be returned
         PSET  @PARMDO
         PMOV  @PARILOC,LA:GSTIPRMI    PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:GSTIVAL     Location of return area
         PMOV  @PAROLEN,LA:L'GSTIVAL   Length of return area
         VCALL PARMDO
         L     RS,=A(33)               Default is 33%
         IF    (RVR,Z),'L  RS,GSTIVAL' Supplied memory value
         ST    RS,GSTCRMPC
*
* Approximation of OS memory overhead
*
         MVC   GSTIKEY2,=CL8'OS_OVER'  Sub-keyword
         SET   PARMFINT                Integer to be returned
         PSET  @PARMDO
         PMOV  @PARILOC,LA:GSTIPRMI    PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:GSTIVAL     Location of return area
         PMOV  @PAROLEN,LA:L'GSTIVAL   Length of return area
         VCALL PARMDO
         L     RS,=A(8*1024)           Default is 8 megabytes
         IF    (RVR,Z),'L  RS,GSTIVAL' Supplied memory value
         SLL   RS,10                   Convert K to bytes
         ST    RS,GSTCRMOV
*
* Allocate the RCP area
*
         L     RA,GSTCCLEN             Get total length of region
         SRL   RA,12                   Length in pages
         ST    RA,GSTCRCPL             Length of the RCP area
         POOLGET (RA),TYPE=(LOCAL,PAGE)
         ST    RVR,GSTCRCPA            Save it's location
*
* Allocate the SCA
*
         POOLGET 16,TYPE=(LOCAL,PAGE,FIX)
         ST    RVR,GSTCSCA             Save the Address
*
* Initialize profiling
*
         PSET  PRFINTP
         ST    RY,PRFIGSTC             Save pointer to the GSTCT
         LCALL PROFINIT                Initialize the guest profiler
*
* Load the IPL text into guest memory
*
         PSET  LOADIP
         ST    RY,LIPGSTCT             Address of the GSTCT
         ACALL LOADIPL
*
* allocate and initialize the CPUB's
*
         PSET  GETCPUP
         ST    RY,GETCGSTC             Save pointer to the GSTCT
         LCALL GETCPU                  Get the cpu control blocks
*
* Cause a Restart of CPU0
*
         L     RS,GSTCCPUS             Get address of the CPUB
         WITH  (CPUB,RS),BEGIN
         SET   CPCSRUN                 Put it in the run state
         MVC   CPRSTRT,=X'FFFFFFFF'    Mark it as an IPL restart
         END   ,
*
* Spawn all our subtasks
*
         CLEAR RA
         WHILE (RA,LT,GSTCNCPU),BEGIN  Each 'CPU' gets a subtask
         LR    RB,RA                   get CPU number
         SLL   RB,2                    Get CPUB pointer offset
         L     RB,GSTCCPUS(RB)         Get CPUB address
         WITH  (CPUB,RB)
         PSET  @SPAWN
*
* Setup the task name
*
         MVC   @SPNNAME,=CL8'GSTCPUX'
         LA    RS,=C'0123456789ABCDEF'
         AR    RS,RA                   Get task number offset
         MVC   @SPNNAME+6(1),@RS       Move the character into name
*
* Setup other values
*
         MVC   @SPNDPRI,=A(50)         Fairly low priority
         MVC   @SPNEP,=A(CPUTASK)      Entry point address
         ST    RB,@SPNPARM             Parm is the CPUB address
         VCALL SPAWN                   Activate the task
         ST    RVR,CPTASKID            Save the Task id of the task
         LA    RA,@RA+1                Go to the next CPU number
         END   ,                       Go do the rest
*
* Dump GSTCT
*
         QSNAP GSTCT,248-1
         QSNAP GSTCT+248,L'GSTCT-248-1
*
* Release parameter work area
*
         MEMFREE L'GSTIPARM,A=(RX)     Release work area
*
* Ok.  Now the show is on the road.  Return to our caller.
*
         LR    RVR,RY                  Get the value to return
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    OMEMGET - This local procedure is called to allocate the     *
*              memory needed for the Orvyl Virtual Machine.  It   *
*              is passed the amount of memory needed and it       *
*              obtains this in multiples of 64K bytes on a 64K    *
*              byte boundary.                                     *
*                                                                 *
*                                                                 *
*      Input - OMEMP dsect                                        *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
OMEMP    RECORD BEGIN
OMEMSIZE DS    F             Size (bytes) of the area needed
OMEMLOC  DS    A             Location (MVS virtual) of the area
         END   ,
         SPACE 2
OMEMGET  PROC  OMEMP,SCOPE=LOCAL
*
* Get a first try at the memory
*
         L     RA,OMEMSIZE             Get the size wanted
         N     RA,=X'FFFF0000'         Round down to 64K mult
         ST    RA,OMEMSIZE             This is what we're getting
         A     RA,=A(64*1024)          Add the amount for alignment
         POOLGET (RA),TYPE=(LOCAL,PAGE)
         LR    RJ,RVR                  Save the location
*
* Trim the low area to align on 64K boundary
*
         A     RVR,=A(64*1024-1)
         N     RVR,=X'FFFF0000'        Round off
         ST    RVR,OMEMLOC             This is where it starts
         SR    RVR,RJ                  Amount to trim at the low end
         LR    RB,RVR                  Save it for later
         IF    POS,BEGIN               If we have
         POOLFREE (RB),A=(RJ),TYPE=(LOCAL,PAGE)
         END   ,
*
* Trim the high area
*
         L     RA,=A(64*1024)          Overage amount
         SR    RA,RB                   Overage left to free
         L     RB,OMEMLOC              Get the start of our area
         A     RB,OMEMSIZE             Get the end of our area
         POOLFREE (RA),A=(RB),TYPE=(LOCAL,PAGE)
*
* All done
*
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*     GETCPU - This routine allocates and initializes the CPUB's. *
*                                                                 *
*                                                                 *
*      Input - GETCPUP                                            *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
GETCPUP  RECORD BEGIN
GETCGSTC DS    A             Address of the GSTCT
         END   ,
         SPACE 2
GETCPU   PROC  GETCPUP,SCOPE=LOCAL
         L     RX,GETCGSTC
         WITH  (GSTCT,RX)
*
* Get the memory
*
         L     RA,GSTCNCPU             Count of CPUs
         MH    RA,=Y(L'CPUB)           Size of a CPUB
         POOLGET (RA),TYPE=(LOCAL,FIX,PAGE)
         LR    RY,RVR
         WITH  (CPUB,RY)
         CLEAR RK                      Starting CPU Number
*
* Loop through all the CPUB's, initializing them
*
         WHILE (RK,LT,GSTCNCPU),BEGIN
         LR    RA,RK                   Get the CPU Number
         SLL   RA,2                    Get offset into table
         ST    RY,GSTCCPUS(RA)         Save the CPUB address
*
* Fill in the CPUB
*
         MVC   CPUB(4),=C'CPUB'        Control block id
         ST    RX,CPGSTCT              Address of the GSTCT
         LRA   RS,SIEDATA
         ST    RS,CPSIERA              Real address of the SIE area
         MVC   CPCORE,GSTCCORE         Address of machine memory
         MVC   CPCLEN,GSTCCLEN         Length of the core
         L     RS,CPCORE
         A     RS,CPCLEN
         ST    RS,CPCLAST              Address of last byte +1
*
         LR    RS,RK                   Get CPU number
         O     RS,=X'80000000'         Want this bit on too
         ST    RS,CPCPUA               Save the CPU address
         STIDP CPCPUID                 Save the CPU id
*
* set up the PSA
*
         MVC   CPPSALOC,CPCORE         Real = Absolute
*
         SET   SIESA390                ESA/390 guest
         LH    RS,CPCORE               Address (in 64K segments)
         STH   RS,SIEMSORG             Save main storage origin
         LH    RS,CPCLEN               Length (in 64K segments)
         DECR  RS
         STH   RS,SIEGMSIZ             Save the main storage size
*
         MVC   SIERCP,GSTCRCPA         RCP Area
         LT    RS,GSTCSCA              Get the SCA virtual address
         IF    NZ,'LRA RS,@RS'         Get the real address
         ST    RS,SIEISCAA             Save the SCA real address
*
         AH    RY,=Y(L'CPUB)           Point at the next one
         INCR  RK                      Up the CPU number
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*  PRFINTP - Parameters passed to Profile initialization routine  *
*                                                                 *
*******************************************************************
         SPACE
PRFINTP  RECORD BEGIN
PRFIGSTC DS    A             Address of the GSTCT
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*  PROFWORK - Profile routine work area                           *
*                                                                 *
*******************************************************************
         SPACE
PROFWORK RECORD BEGIN
PRFWPARM DS    XL(L'PARMIN)            Parmin area
PRFWKEY1 DS    CL8                     Key 1
PRFWKEY2 DS    CL8                     Key 2
PRFWKEY3 DS    CL8                     Key 3
PRFWVAL  DS    A                       Integer value
PRFWSTR  DS    CL80                    String parameter area
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*  Default parameters for dynamic initialization of Profile file  *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
PRFDSN   DC    CL44'WYL.GS.ORV.MP.ALPHA.PROFILE'
PRFPTRKS DC    A(150)                  Primary space (tracks)
PRFSTRKS DC    A(150)                  Secondary space (tracks)
PRFGEN   DC    CL8'+1'                 Generation number
         END
         EJECT ,
*******************************************************************
*                                                                 *
*     PROFINIT - Routine to initialize the guest profiler.  It    *
*                obtains the parameters and if profiling is       *
*                desired it allocates and opens the file.         *
*                                                                 *
*                                                                 *
*      Input - none                                               *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
PROFINIT PROC  PRFINTP,PROFWORK,SCOPE=LOCAL
         WITH  (PARMIN,PRFWPARM)
         L     RY,PRFIGSTC
         WITH  (GSTCT,RY)
*
* Set up the profiling information
*
         MVC   GSTCPINT,=FL8S12E3'1000'   Default is 1000 ms
         PSET  @PARMDO
         PMOV  @PARILOC,LA:PARMIN      PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:PRFWSTR     Location of return area
         PMOV  @PAROLEN,LA:L'PRFWSTR   Length of return area
*
* Find out if profiling is wanted
*
         MVC   PRFWKEY1,=CL8'PROFILE'  Main Keyword
         MVC   PRFWKEY2,=CL8'ACTIVE'   Secondary keyword
         SET   PARMFYN
         VCALL PARMDO
*
*  Profiling is requested - first set the profile interval
*
         IF    ((RVR,Z),AND,('CLI PRFWSTR,C"Y"',EQ)),BEGIN
         MVC   PRFWKEY2,=CL8'INTERVAL'  Keyword
         PSET  @PARMDO
         PMOV  @PARILOC,LA:PARMIN      PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:PRFWVAL     Location of return area
         PMOV  @PAROLEN,LA:L'PRFWVAL   Length of return area
         SET   PARMFINT
         VCALL PARMDO
         IF    (RVR,Z),BEGIN
         MVC   GSTCPINT,=XL8'4E00000000000000'   Floating point zero
         MVC   GSTCPINT+4(4),PRFWVAL   Parameter value (in mS)
         LD    R0,GSTCPINT
         MD    R0,=D'4096E3'           Convert mS to TOD fmt
         AW    R0,=XL8'4E00000000000000'   Scale the result
         STD   R0,GSTCPINT
         MVI   GSTCPINT,0              Remove the exponent
         END   ,
*
*  Now build the dynamic allocation parameter area
*
         MEMGET L'@DSALLO
         LR    RK,RVR
         WITH  (@DSALLO,RK)
         MVC   @DSDSN,PRFDSN           Set the data set name
         MVC   @DSMEM,PRFGEN            generation
         MVC   @DSDDN,=CL8'PROFILE'     dd name
         SET   @DSNEW+@DSGDG            new data set and gdg
         SET   @DSARLSE                 release unused space
         MVC   @DSPTQ,PRFPTRKS          primary space
         MVC   @DSSTQ,PRFSTRKS          secondary space
*
*  Now obtain the parameter overrides - start with dsname
*
         MVC   PRFWKEY2,=CL8'DSNAME'    Keyword
         PSET  @PARMDO
         PMOV  @PARILOC,LA:PARMIN      PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:PRFWSTR     Location of return area
         PMOV  @PAROLEN,LA:L'@DSDSN    Length of return area
         SET   PARMFSTR
         VCALL PARMDO
         IF    (RVR,Z),BEGIN
         MVC   @DSDSN,=CL44' '         Blank the name field
         L     RS,@PAROLEN             String length
         DEX   RS,'MVC  @DSDSN(0),PRFWSTR'   Move it in
         CLEAR @DSMEM                  Assume it isn't a gdg
         CLEAR @DSGDG
         END   ,
*
*  Get gdg
*
         MVC   PRFWKEY2,=CL8'GDG'      Keyword
         PSET  @PARMDO
         PMOV  @PARILOC,LA:PARMIN      PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:PRFWSTR     Location of return area
         PMOV  @PAROLEN,LA:L'@DSMEM    Length of return area
         SET   PARMFSTR
         VCALL PARMDO
         IF    (RVR,Z),BEGIN
         MVC   @DSMEM,=CL8' '          Blank the name field
         L     RS,@PAROLEN             String length
         DEX   RS,'MVC  @DSMEM(0),PRFWSTR'   Move it in
         SET   @DSGDG                  Create a new gdg
         END   ,
*
*  Get volume
*
         MVC   PRFWKEY2,=CL8'VOLUME'    Keyword
         PSET  @PARMDO
         PMOV  @PARILOC,LA:PARMIN      PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:PRFWSTR     Location of return area
         PMOV  @PAROLEN,LA:L'@DSVOL    Length of return area
         SET   PARMFSTR
         VCALL PARMDO
         IF    (RVR,Z),BEGIN
         MVC   @DSVOL,=CL6' '          Blank the name field
         L     RS,@PAROLEN             String length
         DEX   RS,'MVC  @DSVOL(0),PRFWSTR'   Move it in
         END   ,
*
*  Get track override
*
         MVC   PRFWKEY2,=CL8'TRACKS'   Keyword
         PSET  @PARMDO
         PMOV  @PARILOC,LA:PARMIN      PARMIN location
         PMOV  @PARILEN,LA:L'PARMIN+16 Length of input
         PMOV  @PAROLOC,LA:PRFWVAL     Location of return area
         PMOV  @PAROLEN,LA:L'PRFWVAL   Length of return area
         SET   (PARMFINT,EQ)
         VCALL PARMDO
         IF    (RVR,Z),BEGIN
         MVC   @DSPTQ,PRFWVAL          Primary value
         MVC   @DSSTQ,PRFWVAL          Secondary value
         END   ,
*
*  Do the dynamic allocation
*
         PSET  @DSDALLO
         ST    RK,@DSDPARM
         VCALL DSALLO
*
*  If allocation failed log the error
*
         IF    ('LTR  RB,RVR',NZ),BEGIN
         WTO   'Profile allocation failure',ROUTCDE=11
         QSNAP @DSRTN,6
         END
*
* If allocation was successful open the data set
*
         ELSE  BEGIN
         POOLGET L'PROFPARM,TYPE=(LOCAL,BELOW16M)
         ST    RVR,GSTCPLOC            Save the location
         LR    RA,RVR
         WITH  (PROFPARM,RA)
         L     RS,=A(AM24CAP)          Get the cap address
         MVC   PAM24,@RS               Copy the cap into the area
         MVC   PDCB,PROFDCB            Copy the DCB in
         MVI   POPENP,X'8F'            Update the options byte
         OPEN  (PDCB),MF=(E,POPENP)    Open it up
         IF    ^PDCB+48.X'10',EXIT     Open was not successful
         SET   GSTCPON                 Note profiling active
*
*  Create the profile lock
*
         LOCKCRE PROFILE
         ST    RVR,GSTCPLCK            Save the lock ID
         END
         END
*
*  Free the Dynamic allocation parameter area
*
         DROP  RK
         MEMFREE L'@DSALLO,A=(RK)
         PEND
         EJECT ,
XPDCB    DCB   DSORG=PS,DDNAME=PROFILE,MACRF=(PM),RECFM=FB,            *
               LRECL=L'PROFDATA,BLKSIZE=200*L'PROFDATA
PROFDCB  EQU   XPDCB,*-XPDCB,C'X'
         EJECT
         LTORG ,
         EJECT ,
*******************************************************************
*                                                                 *
*    GSTDISP1 -                                                   *
*                                                                 *
*      Input - @FUNCPRM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
#DISP1   RECORD BEGIN
#DISP1M  DS    CL27
#DISP1CP DS    CL1
#DISP1ML EQU   *-#DISP1M
         END   ,
GSTDISP1 PROC  @FUNCPRM,#DISP1,SCOPE=GLOBAL
         L     RY,@FUNCDTA             Get the RUCT Address
         WITH  (GSTCT,RY)
         WITH  (CPUB,RM)
         PSET  @DOWTO
         SET   @DWTFSYS
         LA    RB,DISP1MC
         LA    RA,DISP1ML
         LOOP  BEGIN
         LC    R14,@RA                 Length
         PMOV  @DWTLEN,(R14)           Msg len
         PMOV  @DWTLOC,LA:@RA+1        Msg addr
         LA    RA,1(RA,R14)            Next msg
         ACALL DOWTO
         UNTIL (BCT,RB),END
         CLEAR RX
         LA    RA,C'0'
         MVC   #DISP1M,DISP1CP
         WHILE ('LT RM,GSTCCPUS(RX)',NZ),BEGIN
         STC   RA,#DISP1CP
         PSET  @DOWTO
         SET   @DWTFSYS
         PMOV  @DWTLEN,LA:L'DISP1AS    Msg len
         PMOV  @DWTLOC,LA:DISP1AS      Msg addr
         ACALL DOWTO
         PMOV  @DWTLEN,LA:#DISP1ML     Msg len
         PMOV  @DWTLOC,LA:#DISP1M      Msg addr
         ACALL DOWTO
         PMOV  @DWTLEN,LA:L'DISP1AS    Msg len
         PMOV  @DWTLOC,LA:DISP1AS      Msg addr
         ACALL DOWTO
         INCR  RA                      Next CPU tag
         LA    RX,@RX+4                Index to the next CPUB
         LA    RK,16
         LOOP  BEGIN
         SET   SIEIPSTP,MODE=LOCKED,REF=SIEDATA
         SET   CPCSTERM                In case of wait state
         SET   CPCSDIS1
         FPOST LA:CPECB                Wake if asleep
         FWAIT LA:GSTCTECB             Wait until
         UNTIL (BCT,RK),END
         CLEAR CPCSDIS1
         END   ,
         PEND  ,
DISP1AS  DC    C'*****************************'
DISP1CP  DC    C'*** Displays for guest CPU '
*
DISP1ML  DC    AL1(L'DISP1M1)
DISP1M1  DC    C'DISP1 command: Display information about Orvyl guest'
         DC    AL1(L'DISP1M2)
DISP1M2  DC    C' 16 displays for each guest CPU in a tight loop'
         DC    AL1(L'DISP1M3)
DISP1M3  DC    C' - first qsnap is the PSW'
         DC    AL1(L'DISP1M4)
DISP1M4  DC    C' - second qsnap is registers R0 through R15'
         DC    AL1(L'DISP1M5)
DISP1M5 DC C' - third qsnap is the ASB address followed by the task id'
DISP1MC  EQU   5
         EJECT ,
*******************************************************************
*                                                                 *
*    GSTTERMP - Signal guest to start preliminary termination     *
*               routines                                          *
*                                                                 *
*      Input - @FUNCPRM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GSTTERMP PROC  @FUNCPRM,SCOPE=GLOBAL
         L     RY,@FUNCDTA             Get the RUCT Address
         WITH  (GSTCT,RY)
         L     RM,GSTCCPUS             First CPUB
         WITH  (CPUB,RM)
         L     RX,CPPSALOC             Location of page 0
         WITH  (PZERO,RX)
*
* Get us into KEY 0 with the minimum of disturbance
*
         LR    RVR,R2                  R2 must be saved/restored
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         LR    EPAR,R2
         LR    R2,RVR                  Restore the Register
*
* Set termination flag
*
         SET PZATERM                   Tell guest termination time
         MODESET KEYREG=EPAR           Restore the PSW key
         SET   CPCSTERM                In case of wait state
         FPOST LA:CPECB                Wake if asleep

         FWAIT LA:GSTCTECB             Wait until guest terminates

         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    GSTTERM - Terminate the CPU tasks                            *
*                                                                 *
*                                                                 *
*      Input - @FUNCPRM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GSTTERM  PROC  @FUNCPRM,SCOPE=GLOBAL
         L     RY,@FUNCDTA             Get the RUCT Address
         WITH  (GSTCT,RY)
         CLEAR RA                      start at zero
         WHILE (RA,LT,GSTCNCPU),BEGIN  and count up the CPU's
         LR    RB,RA
         SLL   RB,2                    Offset of the CPUB pointer
         L     RB,GSTCCPUS(RB)         Pointer to the CPUB
         WITH  (CPUB,RB)
*
* Remove the subtask
*
         PSET  @CANTASK
         MVC   @CANTID,CPTASKID        Move in the task id
         VCALL CANTASK
         LA    RA,@RA+1                Go on to the next CPU
         END   ,
*
* Subtasks are gone, time to remove the CPUB's
*
         L     RA,GSTCNCPU             Number of CPUB's
         MH    RA,=Y(L'CPUB)           Total length
         POOLFREE (RA),A=L:GSTCCPUS,TYPE=(LOCAL,FIX,PAGE)
*
* All the subtasks and CPUBs are gone... Close the profile
*
         IF    GSTCPON,BEGIN
         L     RA,GSTCPLOC             Get the location
         WITH  (PROFPARM,RA),BEGIN
         MVI   POPENP,X'80'            Mark the end of the list
         CLOSE (PDCB),MF=(E,POPENP)    Close it up
         END   ,
         POOLFREE L'PROFPARM,A=(RA),TYPE=(LOCAL,BELOW16M)
         END   ,
*
* Then free the GSTC
*
         POOLFREE L:GSTCRCPL,A=L:GSTCRCPA,TYPE=(LOCAL,PAGE)
         POOLFREE L'GSTCT,A=(RY),TYPE=(LOCAL)
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    GSTSTAT - Obtain statistics                                  *
*                                                                 *
*                                                                 *
*      Input - None                                               *
*                                                                 *
*     Output -                                                    *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GSTSTAT  PROC  SCOPE=GLOBAL
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    GSTDUMP - Provide diagnostic information.                    *
*                                                                 *
*                                                                 *
*      Input - @DUMPPRM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
*-
#GDWA    RECORD BEGIN
#GDWORK  DS    CL16                Formatting work area
         END
*-
GSTDUMP  PROC  @DUMPPRM,#GDWA,SCOPE=GLOBAL
         L     RY,@DUMPDTA             Get the GSTCT address
         WITH  (GSTCT,RY)
         SEGEOR '*** GUEST MACHINE INTERFACE DATA ***',,@DUMPSCB
         SEGEOR ,
         IF    (RY,Z),BEGIN
         SEGEOB '*** NOT INITIALIZED ***'
         EXIT  GSTDUMP
         END   ,
*
* Format out the CT
*
         SEG    'GSTCT at '
         SEGHEX @DUMPDTA
         IF     (GSTCT,NE,'GSTC'),BEGIN
         SEG    ' *** ID Check Failed.  This may be Garbage. *** '
         END   ,
         SEGEOR
         SEG    'GSTCCORE '
         SEGHEX GSTCCORE
         SEGEOR ' (MVS Virtual address of GUEST main memory)'
         SEG    'GSTCCLEN '
         SEGHEX GSTCCLEN
         SEGEOR ' (Size of the guest machine main memory)'
         SEG    'GSTCRCPA '
         SEGHEX GSTCRCPA
         SEGEOR ' (Location of the Reference/Change table)'
         SEG    'GSTCNCPU '
         SEGHEX GSTCNCPU
         SEGEOR ' (Number of CPUs in the configuration)'
         SEGEOR
         SEGEOR 'Dump of the GSTCT'
         SEGCORE GSTCT,ID=GSTC,REPEAT=YES
         SEGEOR
         SEGEOR
         SEGEOR
         SEGEOB
*-
*-       Loop through the CPUs.
*-
         CLEAR RA
         WHILE (RA,LT,GSTCNCPU),BEGIN
         LR    RB,RA
         SLL   RB,2
         LA    RB,GSTCCPUS(RB)         address of CPUB address
*-
*-       Dump CPUB and PSA.
*-
         SEG   '==> CPU '
         BTD   (RA),#GDWORK,1
         SEG   #GDWORK,1           CPU number
         SEGEOR
         SEGEOR
*
         SEG   'CPUB at '
         SEGHEX @RB,4
         SEGEOR
         SEGEOR
*
         L     RB,@RB              Get CPUB address
         WITH  (CPUB,RB)
*-
*-       Display CPUB.
*-
         SEG    'CPU Address '
         SEGHEX CPCPUA+2,2
         IF    CPCSRUN,BEGIN
         SEGEOR '  **The CPU is running (in RUN state)**'
         END   ELSE,BEGIN
         SEGEOR '  **The CPU is stopped (in STOP state)**'
         END   ,
         SEG    'CPTASKID '
         SEGHEX CPTASKID
         SEGEOR ' (Task ID of this subtask)'
         SEGEOR ,
*
         SEGCORE CPUB,ID=CPUB
         SEGEOR
         SEGEOR
*-
*-       Display PSA.
*-
         SEG    'Page Zero of this CPU at '
         SEGHEX CPPSALOC
         SEGEOR
*         SEGCORE L:CPPSALOC,L:=A(4096),ID=PSA
         L     RN,CPPSALOC
         SEGCORE (RN),L:=A(4096),ID=PZER
         SEGEOR
         SEG    'PSA following Page Zero of this CPU'
         SEGEOR
         LA    RN,@RN+L'PZERO
         SEGCORE (RN),L:=A(4096-L'PZERO),ID=PSA
         SEGEOR
         SEGEOB
*-
*-       Dump the Trace table of this CPU.
*-
         PSET  DGVMPARM
         MVC   DGVMSCB,@DUMPSCB        Move in the SEG control block
         ST    RB,DGVMCPUB             And save the CPUB location
         ACALL DUMPTRC                 Then dump the trace
*
         SEGEOR
         SEGEOR
         INCR  RA                  Next CPU
         END
*-
*-       Dump the virtual address space memory for each CPU.
*-
         CLEAR RA
         WHILE (RA,LT,GSTCNCPU),BEGIN  Go through each CPU...
         LR    RB,RA
         SLL   RB,2
         L     RB,GSTCCPUS(RB)     CPUB address
*
         SEG   '==> Local memory for CPU '
         WITH  (CPUB,RB),'SEGHEX CPCPUA+2,2'
         SEGEOR
         SEGEOR
*
         PSET  DGVMPARM
         SET   DGVFLOCAL           Display local only
         MVC   DGVMSCB,@DUMPSCB    Set SEG control block ptr
         ST    RB,DGVMCPUB         Set CPUB ptr
         MVC   DGVMLOW,=A(1024)
*        MVC   DGVMLOW,=A(15*1024*1024)  Only do local system
         ACALL DUMPGVM             Dump the memory
*
         LA    RA,@RA+1            Next CPU
         END
*-
*-       Display common memory contents.
*-
         SEG   '==> Common memory for Guest'
         SEGEOR
         SEGEOR
*
         PSET  DGVMPARM
         SET   DGVFCOMMON          Display common
         MVC   DGVMSCB,@DUMPSCB    Set SEG control block ptr
         L     RB,GSTCCPUS         CPU 0
         ST    RB,DGVMCPUB         Set CPUB ptr
         MVC   DGVMLOW,=A(1024)
*        MVC   DGVMLOW,=A(16*1024*1024)  Only do Global system High
         ACALL DUMPGVM             Dump the memory
*-
*-       The MVS to Orvyl memory correspondence table is
*-       no longer dumped.  If you need it, patch out the EXIT
*-       instruction.
*-
         BEGIN
         EXIT  ,                       Patch this to print table
         SEG   '==> Orvyl to MVS memory correspondence table'
         SEGEOR
         SEGEOR
*
         PSET  DGVMPARM
         MVC   DGVMSCB,@DUMPSCB        Move in the SEG control block
         ST    RY,DGVMCPUB             And save the GSTCT location
         ACALL DUMPFRL                 Then dump the Frame list
         END   ,
         PEND
*
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    DUMPGVM - Dump the current virtual address space.            *
*                                                                 *
*                                                                 *
*      Input - DGVMPARM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
DGVWA    RECORD BEGIN
DGVCSTE  DS    A             Current Segment table entry address
DGVCPTE  DS    A             Current Page table entry address
DGVSVA   DS    A             Current segment virtual address
DGVPVA   DS    A             Current page virtual address
DGSWK    DS    A             SEG work area
DGVFLG   FLAG  ,
         FLAG  DGVFCSEG      This is a common segment
DGVWORK  DS    XL16          BTD formatting area
         END   ,
*-
DUMPGVM  PROC  DGVMPARM,DGVWA,SCOPE=LOCAL
         CLEAR DGVWA         Clear the work area
         SEGDEF DGVMSCB
*-
*-       Get our CPUB control block.
*-
         L     RX,DGVMCPUB             CPUB address
         WITH  (CPUB,RX)
*-
*-       Find the segment table for this CPU.
*-
         L     RA,SIECRS+1*4           Control register 1
         LR    RB,RA                   Copy it
         N     RB,=X'7FFFF000'         Isolate the address
         N     RA,=X'0000007F'
         LA    RA,@RA+1                Add one
         SLL   RA,4                    Number of words
         LR    RY,RA                   Save number of words
         GRA   RB,(RB)                 Convert to what we understand
         ST    RB,DGVCSTE              Save the address of the current
         SLL   RY,2                    Number of bytes

         SEG   'Segment Table: '
         BTX   (RB),DGVWORK,8
         SEG   DGVWORK,8
         SEG   ', '
         BTX   (RA),DGVWORK,8
         SEG   DGVWORK,8
         SEG   ' entries, '
         BTX   (RY),DGVWORK,8
         SEG   DGVWORK,8
         SEG   ' bytes'
         SEGEOR ,
         SEGCORE (RB),(RY)
         SEGEOR ,
*-
*-       Loop through the segment table entries.
*-
         LOOP  BEGIN                   Segment loop
*-
*-       Find the current page table.
*-
         L     RB,DGVCSTE              Current STE address
         TM    @RB+3,X'20'             Is this one invalid
         IF    Z,BEGIN                 If ok, do this segment
         TM    @RB+3,X'10'             Is it common?
         IF    ON,'SET DGVFCSEG'       Yes
         ELSE  'CLEAR DGVFCSEG'        No
*-
*-       Extract length and address.
*-
         LR    RS,RB                   Save entry address
         L     RB,@RB                  Get the actual entry
         LR    RJ,RB                   Copy the value
         N     RB,=X'0000000F'         Extract the length
         LA    RB,@RB+1                Add one
         SLL   RB,4                    Get the length in words
         LR    RY,RB                   Save number of words
         N     RJ,=X'7FFFF000'         Extract the address
         GRA   RJ,(RJ)                 Get an MVS address
         LRA   R15,@RJ                 Validate MVS address
         IF    NZ,BEGIN                If it is not valid
         SEG   '*** Invalid segment table entry at: '
         BTX   (RS),DGVWORK,8
         SEG   DGVWORK,8
         SEG   ' ***'
         SEGEOR ,
         SEGEOR ,
         END   ,
         ELSE  BEGIN
         ST    RJ,DGVCPTE              Save the PTE address
         CLEAR DGVPVA                  Clear the page virtual address
         SLL   RY,2                    Number of bytes

         BEGIN ,
         IF    (DGVFCSEG,AND,^DGVFCOMMON),EXIT  Not doing Common
         IF    (^DGVFCSEG,AND,^DGVFLOCAL),EXIT  Not doing local
         SEG   'Page Table: '
         BTX   (RJ),DGVWORK,8
         SEG   DGVWORK,8
         SEG   ', '
         SEG   'first address '
         L     RS,DGVSVA               Get the virtual address
         BTX   (RS),DGVWORK,8          Virtual address
         SEG   DGVWORK,8               Seg it
         IF    DGVFCOMMON,BEGIN
         SEG   ' COMMON'
         END   ,
         ELSE  BEGIN
         SEG   ' LOCAL CPU '
         SEGHEX CPCPUA+3,1         Get cpu number
         END   ,
         SEGEOR ,
         SEGCORE (RJ),(RY)
         SEGEOR ,
         END   ,
*-
*-       Loop through the page table.
*-
         LOOP  BEGIN
         L     RY,DGVCPTE              Get the current PTE address
         TM    @RY+2,X'04'             Is it invalid
         IF    Z,BEGIN                 If ok, do it
         IF    (DGVFCSEG,AND,^DGVFCOMMON),EXIT  Not doing Common
         IF    (^DGVFCSEG,AND,^DGVFLOCAL),EXIT  Not doing local
*-
*-       Dump the page contents if requested.
*-
         L     RK,@RY                  Get the entry
         N     RK,=X'7FFFF000'         Extract real address
         ST    RK,DGSWK                Save the address
         GRA   RK,(RK)                 Convert it to MVS
*
         LRA   R15,@RK                 Validate MVS address
         IF    NZ,BEGIN                If it is not valid
         SEG   '*** Invalid page table entry at: '
         BTX   (RY),DGVWORK,8
         SEG   DGVWORK,8
         SEG   ' ***'
         SEGEOR ,
         SEGEOR ,
         END   ,
         ELSE  BEGIN
*
         L     RS,DGVSVA               Segment address
         A     RS,DGVPVA               Add in page address
*-
*-       Check for not dump request
*-
         BEGIN ,
         L     R14,CPGSTCT             GSTCT
         WITH  (GSTCT,R14)
         IF    ('LT R0,GSTCNOTC',Z),EXIT No items
         LOOP  BEGIN                   Check not items
         IF    ((RS,GE,GSTCNOTF),AND,(RS,LE,GSTCNOTL)),EXIT
         LA    R14,GSTCT+L'GSTCNOTI    Next not item
         UNTIL (BCT,R0),END            Check not items
         END   ,
         IF    (R0,NZ),EXIT            Only show desired locations
*
         IF    (RS,LT,DGVMLOW),EXIT    Only show desired locations
*
         IF    DGVFCSEG,'SEG "-COMMON"'
         ELSE  BEGIN          -CPU xx...
         SEG   '-CPU '
         SEGHEX CPCPUA+3,1         Get cpu number
         END
         SEG   ': '
*
         BTX   (RS),DGVWORK,8      Virtual address
         SEG   DGVWORK,8           Seg it
*
         TM    @RY+2,X'02'         Write protected page?
         IF    O,'SEG "  R/O"'     Yes
         ELSE  '  SEG "     "'     No
         SEG   '   Guest Real '
         SEGHEX DGSWK                  Write it out
         ST    RK,DGSWK
         SEG   '   MVS Virtual '
         SEGHEX DGSWK
         SEG   '   PT:'
         SEGHEX @RY+3,1                Format the PT bits
*
         SEGEOR
         L     RY,DGVSVA               Segment address
         A     RY,DGVPVA               Page address
         LCR   RY,RY
         AR    RY,RK                   Compute the print offset
         SEGCORE (RK),LH:=Y(4096),OFFSET=(RY) BNDRY16=NO
         SEGEOR
         END   ,
         END
*-
*-       Set up for the next page.
*-
         L     RS,DGVCPTE              Get the current address
         LA    RS,@RS+4                Point at the next
         ST    RS,DGVCPTE              Update the address
         L     RS,DGVPVA               Get the virtual address
         A     RS,=X'00001000'         address of the new page
         ST    RS,DGVPVA               Save that too
         UNTIL (BCT,RB),END            Go to the next segment
         END   ,
         END
*
* Set up for the next segment
*
         L     RS,DGVCSTE              Get the current address
         LA    RS,@RS+4                Point at the next
         ST    RS,DGVCSTE              Update the address
         L     RS,DGVSVA               Get the virtual address
         A     RS,=X'00100000'         address of the new segment
         ST    RS,DGVSVA               Save that too
         UNTIL (BCT,RA),END            Go to the next segment
         SEGEOR '*** END OF MEMORY ***'
         SEGEOR ,
         SEGEOR ,
         SEGEOR ,
         SEGEOB ,
         PEND  ,
         LTORG
         EJECT ,
*******************************************************************
*                                                                 *
*    DUMPFRL - Dump a list of the guest absolute frames.          *
*                                                                 *
*                                                                 *
*      Input - DGVMPARM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
DGATWA   RECORD BEGIN
DVATWD   DS    A             Word work area
         END   ,
         SPACE 2
DUMPFRL  PROC  DGVMPARM,DGATWA,SCOPE=LOCAL
*
* Get our control block
*
         L     RX,DGVMCPUB             GSTCT address
         WITH  (GSTCT,RX)
*
* Put out the title and header
*
         SEGEOR '*** GUEST ABSOLUTE FRAME TABLE ***',,DGVMSCB
         SEGEOR ,
         SEG   ' GUEST ABSOLUTE'
         SEGCOL 20
         SEG   'MVS VIRTUAL'
         SEGCOL 35
         SEG   'MVS REAL'
         SEGCOL 45
         SEG   'STORAGE KEY'
         SEGEOR ,
         SEGEOR ,
*
* Print out the Table
*
         CLEAR RA                      Get the starting address
         WHILE (RA,LT,GSTCCLEN),BEGIN  Until we're done
*
* Guest absolute
*
         ST    RA,DVATWD               Save the guest absolute
         SEG   ' '
         SEGHEX DVATWD                 Guest absolute
*
* MVS virtual
*
         SEGCOL 20
         LR    RB,RA                   Get the Guest absolute
         A     RB,GSTCCORE             Add the MVS virtual offset
         ST    RB,DVATWD               MVS Virtual address
         SEGHEX DVATWD
*
* MVS real
*
         SEGCOL 35
         LRA   RB,@RB                  Get the real address
         IF    NZ,BEGIN                If it is not valid
         SEG   'INVALID'
         B     DVATEND
         END   ,
         ST    RB,DVATWD               Save the location
         SEGHEX DVATWD                 Do the virtual address
*
* Storage key
*
         SEGCOL 45
         ISKE  RS,RB                   Get the storage key
         STC   RS,DVATWD
         SEGHEX DVATWD,1               Length to seg
*
* Finish up this page
*
DVATEND  SEGEOR ,
         AH    RA,=Y(4096)             Get to the next page
         END   ,
*
* All done
*
         SEGEOR '*** End of the Absolute Frame Table ***'
         SEGEOR ,
         SEGEOR ,
         SEGEOB ,
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*******************************************************************
*                                                                 *
*    DUMPTRC - Dump the current Trace table.                      *
*                                                                 *
*                                                                 *
*      Input - DGVMPARM                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
DGTRWA   RECORD BEGIN
DGTRNAM  DS    CL8           Name of the routine
DGTRCLK  DS    D             TOD clock for trace
DGTRLOC  DS    A             Location of trace parms
         END   ,
         SPACE 2
DUMPTRC  PROC  DGVMPARM,DGTRWA,SCOPE=LOCAL
         CLEAR DGTRWA        Clear the work area
*
* Get our control block
*
         L     RX,DGVMCPUB             CPUB address
         WITH  (CPUB,RX)
         SEG   '*** Current Trace table for CPU ',,DGVMSCB
         SEGHEX CPCPUA+2,2
         SEGEOR ' ***'
         SEGEOR ,
*
* Find the trace table
*
         L     RK,SIECRS+4*12          Get control register 12
         N     RK,=X'7FFFFFFC'         Mask out bits
         GRA   RK,(RK)                 Convert to MVS address
         LR    RJ,RK                   Copy the ending address
         N     RJ,=X'7FFFF000'         Get the start of the page
         MVC   DGTRCLK,@RJ             Copy start time
         LA    RJ,@RJ+8                Get past the clock
         CLEAR RY                      Count of branch entries
*
* Loop through the trace entries
*
TRCLOOP  WHILE (RJ,LT,RK),BEGIN        Only through this page
         EJECT ,
*
* Branch tracing
*
         CLI   @RJ,0                   24 bit trace
         IF    ((@RJ,EQ,X'00'),OR,@RJ.X'80'),BEGIN
*
* Put seven on a line
*
         IF    (RY,Z),BEGIN
         SEG   'BR -- '
         END   ,
         LA    RY,@RY+1                Count this one
         IF    (RY,EQ,8),BEGIN
         SEGEOR
         SEG   '      '
         LA    RY,1                    Back to # 1
         END   ,
*
* Find the routine name
*
         L     RA,@RJ                  Get the address
         SH    RA,=H'12'               Get to a routine name
         PSET  GVAPARM
         ST    RX,GVACPUB              CPU address
         ST    RA,GVAVLOC              Location
         ACALL GVA
         IF    (RVR,GT,4),BRADDR       Only do the address
         L     RA,GVAMLOC              Got the MVS address
         MVC   DGTRNAM,@RA             Move in the name
         TRT   DGTRNAM,TRATAB          Is it ok?
         IF    NZ,BRADDR               Nope
         SEGB  DGTRNAM                 Seg it in
         B     BRTDONE
*
* If something was wrong, just trace the address
*
BRADDR   SEGHEX (RJ),4                 Convert it
         SEG   ' '                     Add a blank
*
* Update the trace address
*
BRTDONE  LA    RJ,@RJ+4                4 byte entry
         NEXT  TRCLOOP
         END   ,
         EJECT ,
*
* Set secondary ASN
*
         IF    (@RJ,EQ,B'00010000'),BEGIN
         IF    (RY,NZ),BEGIN           Manage any left over brs
         SEGEOR
         CLEAR RY
         END   ,
         SEG   'SSAN '
         SEGHEX @RJ+2,2                Move in the new SSAN
         SEGEOR ,
         LA    RJ,@RJ+4                4 byte entry
         NEXT  TRCLOOP
         END   ,
         EJECT ,
*
* Program Call
*
         IF    (@RJ,EQ,B'00100001'),BEGIN
         IF    (RY,NZ),BEGIN           Manage any left over brs
         SEGEOR
         CLEAR RY
         END   ,
         SEG   'Program Call -- '
         SEGHEX @RJ+1,7                Do the entry
         SEGEOR ,
         LA    RJ,@RJ+8                8 byte entry
         NEXT  TRCLOOP
         END   ,
         EJECT ,
*
* Program Transfer
*
         IF    (@RJ,EQ,B'00110001'),BEGIN
         IF    (RY,NZ),BEGIN           Manage any left over brs
         SEGEOR
         CLEAR RY
         END   ,
         SEG   'Program Tran -- '
         SEGHEX @RJ+1,7                Do the entry
         SEGEOR ,
         LA    RJ,@RJ+8                8 byte entry
         NEXT  TRCLOOP
         END   ,
         EJECT ,
*
* Explicit trace
*
         LC    RS,@RJ                  Get the first byte
         SRL   RS,4                    Get just the type
         IF    (RS,EQ,7),BEGIN
         IF    (RY,NZ),BEGIN           Manage any left over brs
         SEGEOR
         CLEAR RY
         END   ,
         LC    RY,@RJ                  Get the type/count
         N     RY,=X'0000000F'         Isolate the count
         LA    RY,@RY+1                Actual count
         SEG   'TRACE -- '             Trace type
         L     RA,@RJ+8                Get trace parameter
         IF    (RA,GE,=A(4096)),BEGIN  New style trace parm
         PSET  GVAPARM
         PMOV  GVACPUB,LA:CPUB
         PMOV  GVAVLOC,(RA)
         ACALL GVA
         MVC   DGTRLOC,GVAMLOC
         IF    (RVR,LE,4),BEGIN        Memory is OK
         REGCH (RA,R2)
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         L     RB,DGTRLOC              Source address - GUEST
         LA    RB,@RB+10                 alpha ID is 10 past start
         MVC   DGTRNAM,@RB
         L     RB,DGTRLOC
         LA    RB,@RB+4                  trace number
         L     RB,@RB
         MODESET KEYADDR=(2)
         SEGB  DGTRNAM                 Trace id
         BTD   (RB),DGTRNAM,5
         SEGB  DGTRNAM,5               Trace number
*
         END   ,                       OF Memory is OK
         ELSE  BEGIN                   Memory isn't OK
         SEG   'Trace parameter not accessible'
         END   ,                       Memory isn't OK
         END   ,                       OF New style trace parm
         ELSE  BEGIN                   Old style trace parm
         BTD   @RJ+8,DGTRNAM,5         Convert the value
         SEGB  DGTRNAM,5               Seg that out
         SEG   '('
         SEGHEX @RJ+8,4                Put it out in hex too
         SEG   ')'
         END   ,                       OF Old style trace parm
         SEG   '    TOD='
         MVC   DGTRCLK+2(6),@RJ+2      Update the clock
         SEGHEX DGTRCLK                Put it out
         LA    RJ,@RJ+12               Get past the preliminaries
*
* Do the REGs
*
         LA    RB,4                    Pre load it
         LOOP  BEGIN
         IF    (RB,EQ,4),BEGIN
         SEGEOR
         SEG   '         '
         CLEAR RB
         END   ,
         SEGHEX @RJ,4                  Do the register
         SEG   ' '                     One blank
         LA    RJ,@RJ+4                Account for the register
         LA    RB,@RB+1                Count the entry
         UNTIL (BCT,RY),END            Do all the entries
         SEGEOR ,
         NEXT  TRCLOOP
         END   ,
         EJECT ,
*
* Any other types
*
         SEGEOR ,
         SEG   'UNKNOWN -- '
         SEGHEX @RJ,4
         LA    RJ,@RJ+4
         SEGEOR ,
         END   ,
*
* Finish up
*
         SEGEOR
         SEGEOR
         SEG   '*** END OF TRACE TABLE *** '
         SEGEOB
         PEND  ,
         EJECT ,
TRATAB   DS    0CL256        Scan table
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'01010101010101010101010101010101'  00
         DC    X'01010101010101010101010101010101'  10
         DC    X'01010101010101010101010101010101'  20
         DC    X'01010101010101010101010101010101'  30
         DC    X'00010101010101010101010101010101'  40
         DC    X'01010101010101010101010101010101'  50
         DC    X'01010101010101010101010101010101'  60
         DC    X'01010101010101010101010101010101'  70
         DC    X'01010101010101010101010101010101'  80
         DC    X'01010101010101010101010101010101'  90
         DC    X'01010101010101010101010101010101'  A0
         DC    X'01010101010101010101010101010101'  B0
         DC    X'01000000000000000000010101010101'  C0
         DC    X'01000000000000000000010101010101'  D0
         DC    X'01010000000000000000010101010101'  E0
         DC    X'00000000000000000000010101010101'  F0
         SPACE 3
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   GSTIIOT - This routine is called asyncronously when an I/O    *
*             request has finished.                               *
*                                                                 *
*     Input - @GSTIIOT                                            *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*******************************************************************
         SPACE 2
GSTIIOT  PROC  @GSTIIOT,SCOPE=GLOBAL
         L     RX,@GSTIRQI
         WITH  (IOCB,RX)
         MVC   IOCBSTAT,@GSTICS        Save the status code
         MVI   IOCBHSP,0       Clear flag HSPCETSK is waiting for
*
* Put this request on the I/O complete queue
*
         L     RY,IOCBGSTC             Get the GSTCT address
         WITH  (GSTCT,RY)
         LM    RA,RB,GSTCIOIQ          Get the current queue ptrs
         LR    RJ,RX                   Get the new IOCB address
         LOOP  BEGIN
         LA    RK,1
         AR    RK,RB
         ST    RA,IOCBNEXT
         CDS   RA,RJ,GSTCIOIQ          Put this one on
         UNTIL Z,END
*
* Now signal all the CPU's in the configuration that an I/O is
* ready
*
         L     RJ,GSTCNCPU             Get the count of CPU's
         LA    RK,GSTCCPUS             And the location of addrs
IOILP    L     RA,@RK                  Get a CPUB address
         WITH  (CPUB,RA),BEGIN
         SET   SIEIPVIO,MODE=LOCKED,REF=SIEDATA  Turn on the bit
         FPOST CPECB                   Wake it up if it's asleep
         END   ,
         LA    RK,@RK+4                Point at next CPUB address
         BCT   RJ,IOILP                Then continue
         PEND                          Return
         EJECT ,
*******************************************************************
*                                                                 *
*    CPUTASK - Subtask that actually runs the user.               *
*                                                                 *
*                                                                 *
*      Input - @SBTPARM  -- contains the address of his CPUB      *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
CPUTASK  PROC  SBTPARM,SCOPE=LOCAL
         L     RY,SBTDATA              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Initialize the Host I/O services
*
         VCALL IOSTINIT                Initialize this task (CPU)
*
* Initialize the CPU timer
*
         VCALL CPTSTART
*
* Make sure the prefix page of this CPU is fixed.
*
         PSET  @FIXPARM
         MVC   @FIXLOC,CPPSALOC
         MVC   @FIXLEN,=A(4096)
         VCALL PAGEFIX                 Fix the PSA page
         LA    R0,CPUB
         ACALL SETCLOC2                Set local time
*
* Initialize real-time timing function
*
         ST    RY,CPSTPARM             Our parm is the CPUB address
         POOLGET 1024,TYPE=(LOCAL)     Get memory for timer stack
         ST    RVR,CPSTSTK             Save the address
         ST    RTCBR,CPSTRTCB          Save the RTCB address too
         L     RK,CPGSTCT              Get the GSTC address
         WITH  (GSTCT,RK)
*
*  If profiling is active or this is CPU 0 then start the clock
*
         IF    (GSTCPON,OR,('OC  CPCPUA+2(2),CPCPUA+2',Z)),BEGIN
         STIMERM SET,ID=CPSTIMID,PARM=CPSTPARM,EXIT=TXIT,              *
               MICVL=GSTCPINT,MF=(E,CPSTIMER)
         END
         EJECT ,
STOPPED  WHILE ^CPCSRUN,BEGIN
         FWAIT LA:CPECB                Wait until we are started
         END   ,
*
* Check for restart SIGP order
*
         LT    RA,CPRSTRT              CPU addr of guy restarting us
         IF    NZ,BEGIN
         RSINT                         Set up the restart interrupt
         CLEAR RS
         ST    RS,CPRSTRT              Clear out the order
         END   ,
*
*  Update the CPU time accumulator and start the guest
*
RUNNING  LABEL ,
         AGO   .NOCPT1
         PSET  @CPTIME
         VCALL CPTREAD
         STD   0,yyy                   Save FPR zero
         LD    0,@CPTTOT               Ending time
         SW    0,xxx                   Less starting time
         AW    0,CPCPUTM               Add it in
         LD    0,yyy                   FPR zero back
.NOCPT1  ANOP  ,
         BEGIN
         STM   R0,R15,CPGRSAVE         Save our registers
         LR    R15,RY                  Save pointer to CPUB
         WITH  (CPUB,R15)
         L     R14,CPSIERA             Real address of the SIE BLOCK
         LM    R0,R13,CPCREGS          Get Guest Registers
         MVI   SIEICODE,0              Clear the ICODE
         SIE   @R14                    Run the Guest machine
         STM   R0,R13,CPCREGS          Save Guest Registers
*-
*-       Very temporary failure checking!!!   (1/22/92)
*-
         BASR  R8,0
         WITH  (*,R8),BEGIN
         L     R1,CVTPTR
         IF    (NIZCVTP,EQ,=F'-1'),BEGIN  First time initialization...
         ST    R1,NIZCVTP          Remember CVT ptr
         B     NIZCONT             (No checking the first time)
         END
*
         LA    R5,1                Failure case 1
         IF    (R1,NE,NIZCVTP),NIZFAIL  Failed
*
         LA    R5,2                Failure case 2
         LR    R2,R1
         SH    R2,=AL2(X'40')      CVT prefix
         IF    (@R2,NE,NIZCVTID),NIZFAIL  Failed also
*
         LA    R5,3                Failure case 3
         L     R2,CVTUSER-CVT(,R1)  User CVT
         IF    (@R2,NE,'SCIP'),NIZFAIL
*
         B     NIZCONT
*
         DC    0D'0'
         DC    C'NIZTRACE'         Our eyecatcher
NIZCVTP  DC    F'-1'               Saved CVT ptr
NIZCVTID DC    C'IEAVCVT'          Eyecatcher in CVT prefix
NIZSTCK  DC    D'0'                Store clock
NIZLOWC  DS    XL768               Low memory
*-
*-       A failure occurred, try PTLB and then cautiously
*-         try to increment counter in SCIPCVT.
*-
NIZFAIL  MVC   NIZLOWC(256),0
         MVC   NIZLOWC+256(256),256
         MVC   NIZLOWC+512(256),512
         STCK  NIZSTCK             Do a STCK for physical cpu id
*
         PTLB  ,
*
         L     R1,CVTPTR
         L     R2,NIZCVTP
         IF    (R1,NE,R2),'LA R6,1; DC H"0"'  Forget it
         LR    R2,R1
         SH    R2,=AL2(X'40')
         IF    (@R2,NE,NIZCVTID),'LA R6,2; DC H"0"'  Sorry
         L     R11,CVTUSER-CVT(,R1)   User CVT
         IF    (@R11,NE,'SCIP'),'LA R6,3; DC H"0"'
         WITH  (USERCVT,R11),BEGIN
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  Key zero
         INCR  R3,USENIZH1         Count the failure
         STH   R5,USENIZH2         Save failure case number too
         MODESET KEYREG=2
*
         QSNAP 'ORVYL soft failure diagnostics:',MODE=WTO
         QSNAP (R3,R5)
         QSNAP NIZSTCK,8
         QSNAP NIZLOWC,128
         QSNAP NIZLOWC+128,128
         QSNAP NIZLOWC+256,128
         QSNAP NIZLOWC+384,128
         QSNAP NIZLOWC+512,128
         QSNAP NIZLOWC+640,128
         QSNAP 'End of diagnostics'
         END
         END
*
NIZCONT  LABEL
*-
*-       End of very temporary failure checking!!!
*-
         LM    R0,R15,CPGRSAVE         Restore our registers
         END   ,
         AGO   .NOCPT2
*
*  Start our clock
*
         PSET  @CPTIME
         VCALL CPTREAD
         MVC   xxx,@CPTTOT
.NOCPT2  ANOP  ,
*
* At this point we have some kind of interception.  We must decide
* what kind it is and take action on it.
*
         LC    RS,SIEICODE             Get the interception code
         IF    (RS,GE,ITABL),BADICODE  Code is too big
         B     ITAB(RS)                Branch based on it
*
ITAB     B     BADICODE                 0 -- RESERVED
         B     INSTRUCT                 4 -- instruction
         B     PROGRAM                  8 -- PI interrupt
         B     INSTPER                 12 -- PER and instruction
         B     EXTPEND                 16 -- Pending external
         B     EXTINT                  20 -- External interrupt
         B     IOPEND                  24 -- Pending I/O interrupt
         B     WAITST                  28 -- Wait state
         B     VALIDITY                32 -- Validity interception
         B     BADICODE                36 -- RESERVED
         B     STOPCODE                40 -- Stop interception
         B     OPEXCEPT                44 -- Operation exception
ITABL    EQU   *-ITAB                  ***************************
         SPACE 2
BADICODE KAPUT BADICODE                gasp!
         EJECT ,
*
* INSTRUCT -- This section of code handles the instruction
*             interception.  First thing... it finds which
*             instruction to handle.
*
INSTRUCT LABEL  ,
*
         IF    (SIEPSW+1.X'01'),BEGIN  Caller is in problem state
         PIINT CODE=2,ILEN=4           Cause a Priv Op exception
         B     RUNNING                 Then re-start caller
         END   ,
*
         IF    (SIEINST,EQ,X'83'),BEGIN          DIAGNOSE
         GETICAD RS,TYPE=S                       Get the code
         SLL   RS,2                              multiply by 4
         IF    (RS,GE,DIAGMAX),INVOP             too big
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB                        Save the CPUB addr
         ACALL DIAGTAB(RS)                       call the routine
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B233'),BEGIN        START SUBCHANNEL
         VCALL CPTREAD                 Start the meter running
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXSSCH
         PSET  @CPTIME
         VCALL CPTREAD                 Turn off the meter
         LM    RA,RB,SIECPUTM          Get the Guest CPU timer
         SDL   RA,@CPTINT              Less this amount
         STM   RA,RB,SIECPUTM          Update the Guest timer
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B236'),BEGIN        TEST PENDING INT
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXTPI
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'AE'),BEGIN          SIGP
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXSIGP
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B229'),BEGIN        ISKE
         L     RS,SIEPSW+4             Get the current PSW
         SH    RS,=Y(4)                Back it up to the ISKE inst
         ST    RS,SIEPSW+4
         B     RUNNING                 Then re-try it
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B22A'),BEGIN        RRBE
         L     RS,SIEPSW+4             Get the current PSW
         SH    RS,=Y(4)                Back it up to the RRBE inst
         ST    RS,SIEPSW+4
         B     RUNNING                 Then re-try it
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B22B'),BEGIN        SSKE
         L     RS,SIEPSW+4             Get the current PSW
         SH    RS,=Y(4)                Back it up to the SSKE inst
         ST    RS,SIEPSW+4
         B     RUNNING                 Then re-try it
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B221'),BEGIN        IPTE
         L     RS,SIEPSW+4             Get the current PSW
         SH    RS,=Y(4)                Back it up to the IPTE inst
         ST    RS,SIEPSW+4
         B     RUNNING                 Then re-try it
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B212'),BEGIN        STORE CPU ADDRESS
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXSTAP
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B210'),BEGIN        SET PREFIX
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXSPX
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B202'),BEGIN        STORE CPU ID
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXSTIDP
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B211'),BEGIN        STORE PREFIX
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXSTPX
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B22C'),BEGIN        TEST BLOCK
         PSET  INTERP,CLEAR=NO
         ST    RY,INTCPUB
         ACALL IXTB
         B     RUNNING
         END   ,
*
        ELSEIF (SIEINST,EQ,X'B234'),'B INVOP'    STORE SUBCHANNEL
*
        ELSEIF (SIEINST,EQ,X'B235'),'B INVOP'    TEST SUBCHANNEL
*
        ELSEIF (SIEINST,EQ,X'B230'),'B INVOP'    CLEAR SUBCHANNEL
*
        ELSEIF (SIEINST,EQ,X'B231'),'B INVOP'    HALT SUBCHANNEL
*
        ELSEIF (SIEINST,EQ,X'B232'),'B INVOP'    MODIFY SUBCHANNEL
*
        ELSEIF (SIEINST,EQ,X'B238'),'B INVOP'    RESUME SUBCHANNEL
*
        ELSEIF (SIEINST,EQ,X'B237'),'B INVOP'    SET ADDRESS LIMIT
*
        ELSEIF (SIEINST,EQ,X'B204'),'B INVOP'    SET CLOCK
*
        ELSEIF (SIEINST,EQ,X'B214'),'B INVOP'    SIE
*
        ELSE   INVOP                             ANY AND ALL OTHERS
*
         B     RUNNING                 Go back for more.
*
* INVOP -- This section of code causes an operation
*          exception in the guest machine.
*
         SPACE 2
INVOP    PIINT CODE=1,ILEN=4           Cause on Operation Exception
         B     RUNNING                 Start the machine up
         EJECT ,
*
* Table of routines that handle diagnose instructions
*
         SPACE 2
DIAGTAB  DS    0A
         DC    A(DTABEND)         000  ABEND ORVYL
         DC    A(DTMEMSZ)         001  Get info on available memory
         DC    A(DTLDBLK)         002  Read a Kernel block
         DC    A(DTLDSTA)         003  Start the Kernel reading
         DC    A(DTLDEND)         004  Finish Kernel loading
         DC    A(DTPAGE)          005  Fix a page to MVS
         DC    A(DTNOPAGE)        006  Un-fix a page to MVS
         DC    A(DTALLOC)         007  Allocate a device id
         DC    A(DTSPIN)          008  Do 'spin' for locks
         DC    A(DTNOSPIN)        009  Take out of 'spin' for locks
         DC    A(DTMVSRD)         010  Read MVS memory
         DC    A(DTMVSWRT)        011  Write MVS memory
         DC    A(DTMVSNM)         012  Find MVS module name
         DC    A(DTSMF)           013  Write an SMF record
         DC    A(DTENQ)           014  Do an MVS ENQ
         DC    A(DTPARM)          015  Get an init parameter
         DC    A(DTMXREAL)        016  Maximum Guest real memory
         DC    A(DTMXCPU)         017  Maximum active CPU's
         DC    A(DTSNAP)          018  Our qsnap facility
         DC    A(DTWTO)           019  Write a message to operator
         DC    A(DTDOM)           020  Delete operator message
         DC    A(DTCPUTM)         021  Obtain host CPU time
         DC    A(DTPARM2)         022  Get init parm (second try)
         DC    A(DTCPUINF)        023  Get general CPU info
         DC    A(DTQSERV)         024  Issue a QSERV svc
         DC    A(DTDPALLO)        025  Allocate a SNAP DUMP data set
         DC    A(DTDPWRIT)        026  Write a line to SNAP DUMP
         DC    A(DTDPCLOS)        027  Close and free a SNAP DUMP
         DC    A(DTERMCOM)        028  Signal guest termination done
         DC    A(DTNOTDMP)        029  Set range of addr to not dump
DIAGMAX  EQU   *-DIAGTAB               Maximum diagnose code
         EJECT ,
*
* PROGRAM -- This section is entered because a guest program
*            interrupt occurred that was intercepted.  We are not
*            at all interested in this so we just swap PSW's and
*            put it on its way.
*
         SPACE
PROGRAM  LABEL ,
         PIINT                         Take the interrupt
         B     RUNNING                 And return to run again
         SPACE 3
*
* INSTPER -- This is entered if a per occurs on an instruction
*            that has already completed but causes interception.
*            This only happens on CS, CDS, and TS instructions
*            when they can cause interception by setting cc=1.
*            Since we don't intercept on these instructions, entry
*            into this section indicates an error.
*
         SPACE
INSTPER  LABEL ,
         KAPUT INSTPER
         EJECT ,
*
* EXTPEND -- This routine is entered when the external interrupt
*            intervention bit is set in the SIE control block and
*            the virtual CPU is enabled for external interrupts.
*            It is the signal that we can now schedule the external
*            interrupts from other CPU's SIGPs to this CPU.
*
         SPACE
EXTPEND  LABEL ,
*
* Clear the pending bit
*
         CLEAR SIEIPEXT,MODE=LOCKED,REF=SIEDATA
*
         LT    RS,CPEMERG              Emergency signal pending?
         IF    NZ,BEGIN                Yep.
*
* Find out which CPU wants us
*
         CLEAR RA                      CPU Address counter 0
         LA    RB,1                    CPU bit map for CPU 0
EMSLOOP  LR    RVR,RB                  Get the bit
         NR    RVR,RS                  Check it out
         IF    Z,BEGIN                 Not found yet
         INCR  RA                      Next CPU address
         SLL   RB,1                    Next bit position
         B     EMSLOOP
         END   ,
*
* Set up the interruption
*
         EXINT CODE=X'1201',CPUREG=RA
*
* Remove the Bit for the CPU we are taking care of.
*
         X     RB,=F'-1'               Mask to turn off the bit
         L     RS,CPEMERG              Get the current mask
         LOOP  BEGIN
         LR    RA,RS
         NR    RA,RB                   Get the updated value
         CS    RS,RA,CPEMERG           Update the core value
         UNTIL Z,END
*
* If any bits still on, or if an external call is waiting, we must
* turn the external intervention bit back on.
*
         IF    ((RA,NZ),OR,(CPEXCALL,NZ)),BEGIN
         SET   SIEIPEXT,MODE=LOCKED,REF=SIEDATA
         B     RUNNING                 keep on trucking
         END   ,
         END   ,
*
* See if there is an external call waiting
*
         LT    RA,CPEXCALL             Get the external call CPU
         IF    NZ,BEGIN                Someone wants us.
*
* Set up the interruption
*
         EXINT CODE=X'1202',CPUREG=RA
*
* Remove the interrupt condition
*
         CLEAR RS
         ST    RS,CPEXCALL             Zero out calling CPU
         END   ,
         B     RUNNING                 Get back in the game
         EJECT ,
*
* EXTINT -- This routine is entered when a guest external
*           interrupt has occured.  We just swap PSW's and
*           we're off.
*
         SPACE ,
EXTINT   LABEL ,
         EXINT                         Set up the interrupt
         B     RUNNING                 Back into the game
         EJECT ,
*
* IOPEND -- This routine is entered when there is a IO interrupt
*           pending for the guest machine.
*
         SPACE ,
IOPEND   LABEL ,
*
* Turn off the pending flag
*
         CLEAR SIEIPVIO,MODE=LOCKED,REF=SIEDATA
*
* See if there are indeed any I/O responses pending
*
         PSET  GTIOCBP,CLEAR=NO
         MVC   GTIGSTC,CPGSTCT
         ACALL GETIOI                  Get an I/O interrupt
         LTR   RX,RVR                  Address of an IOCB
         IF    Z,RUNNING               No interrupt... continue
*
* There is an I/O interrupt pending...Signal it
*
         WITH  (IOCB,RX),BEGIN
         L     RS,CPPSALOC             Get location of PAGE ZERO
         WITH  (PZERO,RS),BEGIN
*
* Move in the I/O parms
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   PZIOSID,IOCBSCH         Move in the Subchannel ID
         MVC   PZIOPRM,IOCBIPRM        The Parameter
         MVC   PZIOSCS,IOCBSTAT        And the ending status
*
* Swap the PSW's
*
         MVC   PZIOOPSW,SIEPSW
         MVC   SIEPSW,PZIONPSW
         MODESET KEYREG=2
         END   ,
         END   ,
*
* Free the IOCT
*
         PSET  FRIOCBP,CLEAR=NO
         MVC   FRIGSTC,CPGSTCT         Address of the GSTCT
         ST    RX,FRIIOCB              Address of the IOCB
         ACALL FREEIOCB                Returns 0 if no more waiting
*
* See if there are anymore pending
*
         IF    (RVR,NZ),BEGIN
         SET   SIEIPVIO,MODE=LOCKED,REF=SIEDATA
         END   ,
         B     RUNNING                 Return to work
         EJECT ,
*
* WAITST -- This routine is entered when the guest machine loads
*           a wait PSW. It just does a wait.  When posted, it
*           checks to see whether an external interrupt should
*           be taken and if so, branches to EXTPEND.
*
         SPACE ,
WAITST   LABEL ,
*
* Check to see if it is disabled.
*
         TM    SIEPSW,B'0000011'
         IF    Z,BEGIN                 Disabled wait
         ABEND 800,DUMP
         END   ,
         FWAIT LA:CPECB
         IF    (SIEIPEXT,AND,SIEPSW.1),EXTPEND
         IF    CPCSTERM,BEGIN
         CLEAR CPCSTERM
         EXINT CODE=0              Clear any residual code
         END   ,
         B     RUNNING
         SPACE 3
*
* VALIDITY -- This routine is entered when a validity interception
*             occurs.  It signals an error.
*
         SPACE ,
VALIDITY LABEL ,
         KAPUT VALIDITY
         EJECT ,
*
* STOPCODE -- This routine is entered when an interception is
*             caused by a stop intervention bit.  This bit is
*             used to implement some of the signal processor
*             orders.  Here we just turn off the bit, and go
*             to the STOPPED section of the loop where a check
*             is made for the results of those orders.
*
         SPACE ,
STOPCODE LABEL ,
         IF    CPCSDIS1,BEGIN
         PSET  @DOWTO
         PMOV  @DWTLOC,LA:PSWMSG
         PMOV  @DWTLEN,LA:L'PSWMSG
         SET   @DWTFSYS
         ACALL DOWTO
         QSNAP SIEPSW,4                Guest PSW
         QSNAP CPCREGS,60              Guest registers
         L     RX,CPPSALOC             Location of page 0
         WITH  (PZERO,RX),BEGIN
         QSNAP PZCURPID,4              ASB addr/task id
         END   ,
         L     RX,CPGSTCT              Point to the GSTCT
         WITH  (GSTCT,RX),BEGIN
         FPOST LA:GSTCTECB             Post termination done
         END   ,
         END   ,
         CLEAR SIEIPSTP,MODE=LOCKED,REF=SIEDATA
         B     STOPPED
PSWMSG   DC    C'***** PSW, registers R0-R15, ASB addr *****'
         SPACE 3
*
* OPEXCEPT -- This is called in an operation exception interception
*             occurs.  All Op Ex's should be handled by the guest so
*             this is an error to us.
*
         SPACE
OPEXCEPT LABEL ,
         KAPUT OPEXCEPT
         PEND
         EJECT ,
         LTORG ,
         EJECT ,
*******************************************************************
*                                                                 *
*       TXIT - Timer exit routine entered from MVS.  It posts the *
*              corresponding CPUB in case it is waiting,          *
*              and takes a snapshot of the PSW for profiling.     *
*                                                                 *
*      Input - MVS ENTRY                                          *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
TXIT     BEGIN                         Not a procedure
*
* Set up the entry
*
         STM   R14,R12,12(R13)         Save the input regs
         LR    RX,R13                  Copy input save area location
         LR    BR,R15                  Copy entry point address
         WITH  (TXIT,BR)               Use it as the Base
         L     RY,@R1+4                Get the CPUB address
         IF    (@RY,NE,'CPUB'),'KAPUT BADTIMP'
         WITH  (CPUB,RY)
         L     RTCBR,CPSTRTCB          Get the RTCB pointer
         L     WAR,CPSTSTK             Get the stack addr
         LA    SPR,@WAR+8              Point beyond it for top
*
* If profiling is active get the lock for the profile area
*
         L     RK,CPGSTCT              Get the GSTC address
         WITH  (GSTCT,RK)
         IF    GSTCPON,BEGIN           Profiling is active
         LOCKOB GSTCPLCK               Get the lock
*
* Write out the desired info
*
         L     RJ,GSTCPLOC             Get the parm location
         WITH  (PROFPARM,RJ),BEGIN
         MVC   PROFCPUA,CPCPUA+3       Move in the CPU address
         MVC   PROFICOD,SIEICODE       Move in the ICODE
         MVC   PROFINST,SIEINST        And the instruction
         MVC   PROFPSW,SIEPSW          Move in the current PSW
         STCK  PROFTOD                 Then save the time
         USING PSA,R0
         L     R15,PSATOLD             TCB for this task
         DROP  R0
         WITH  (TCB,R15),'L  R15,TCBRBP'  Current RB (IRB)
         WITH  (RBSECT,R15),BEGIN
         LOOP  BEGIN
         L     R15,RBLINK              Previous RB
         N     R15,=X'00FFFFFF'
         UNTIL (RBSTAB1.RBFTPRB,EQ),END
         MVC   PROFHIA,RBOPSW+4        Copy instruction address
         END
         LA    RS,PAMPARM              Get the parm address
         WITH  (@AM24,RS),BEGIN
         LA    RVR,PDCB                Get the DCB address
         ST    RVR,@AM24R1             It needs to be in R1
         LA    RVR,PROFDATA            Get the data address
         ST    RVR,@AM24R0             Put in R0
         L     RVR,PDCB+48             Load PUT routine address
         ST    RVR,@AM24R15            Save it's entry point
         END   ,
         LA    EPAR,PAM24              Get the starting addr
         BASSM RAR,EPAR                Go do it
         END   ,
*
* Free the lock
*
         LOCKRL GSTCPLCK               Let someone else go
         END   ,
*
* Wake up the CPU if it needs it
*
         FPOST LA:CPECB                Post it
*
* Re-set the timer
*
         STIMERM SET,ID=CPSTIMID,PARM=CPSTPARM,EXIT=TXIT,              *
               MICVL=GSTCPINT,MF=(E,CPSTIMER)
*
* Return to MVS
*
         LR    R13,RX
         LM    R14,R12,12(R13)
         BSM   0,R14                   Return to the caller
         END   ,
         SPACE 3
         LTORG ,
         EJECT ,
*******************************************************************
*                                                                 *
*     IXSIGP - Routine to interpret Signal processor.             *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
INTERP   RECORD BEGIN
INTCPUB  DS    A             Address of the CPUB
         END   ,
         SPACE 2
IXSIGP   PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
         L     RX,CPGSTCT              Address of the GSTCT
         WITH  (GSTCT,RX)
*
* Get the CPU address it is indended for
*
         LH    RA,SIEINST              Bits 0-15 of the instruction
         N     RA,=X'0000000F'         Leave only the R3 field
         LREGA RA,(RA)                 Address of the register
         L     RA,@RA                  Get the CPU address
         N     RA,=X'0000FFFF'         Mask out other bits
*
* Get the CPUB corresponding to that CPU address
*
         IF    (RA,GE,GSTCNCPU),SIGPCC3  Not operational
*
         SLL   RA,2                    Size of an entry in cpu table
         L     RA,GSTCCPUS(RA)         Get the address of the CPUB
*
* Get the order code
*
         GETICAD RS,TYPE=RS                      Get the code
*        LC    RS,SIEICAD1+3           Bits 24-31 of eff address
         SLL   RS,2                    Size for branch table
         IF    (RS,GE,SIGPMAX),BADSIGP If it is too big...
         B     SIGPTAB(RS)             Go to the proper routine
*
SIGPTAB  B     BADSIGP                 00 Unassigned
         B     SGSENSE                 01 Sense
         B     SGEXTC                  02 External Call
         B     SGEMERS                 03 Emergency Signal
         B     SGSTART                 04 Start
         B     SGSTOP                  05 Stop
         B     SGRSTRT                 06 Restart
         B     BADSIGP                 07 Unassigned
         B     BADSIGP                 08 Unassigned
         B     BADSIGP                 09 Stop and store status
         B     BADSIGP                 0A Unassigned
         B     BADSIGP                 0B Initial CPU reset
         B     BADSIGP                 0C CPU reset
         B     SGSTPX                  0D Set prefix
SIGPMAX  EQU   *-SIGPTAB
         EJECT ,
*
* BADSIGP -- Handles all the SIGP orders we don't handle.
*
         SPACE ,
BADSIGP  LABEL ,
         L     RVR,=A(SIGPINVO)        Invalid order
         B     SIGPCC1                 Store the status
         SPACE 3
*
* SGSTART -- Handles the START order.
*
         SPACE ,
SGSTART  LABEL ,
         WITH  (CPUB,RA),BEGIN         Look at his CPUB
*
* Put it in the operational state
*
         SET   CPCSRUN,MODE=LOCKED,REF=CPUB
         FPOST LA:CPECB                Wake it up
         END   ,
         B     SIGPCC0
         EJECT ,
*
* SGSTOP -- Handles the STOP order.
*
         SPACE ,
SGSTOP   LABEL ,
         WITH  (CPUB,RA),BEGIN
*
* Take it out of the operational state
*
         CLEAR CPCSRUN,MODE=LOCKED,REF=CPUB
*
* Set the stop intervention bit
*
         SET   SIEIPSTP,MODE=LOCKED,REF=SIEDATA
         FPOST LA:CPECB                Then wake it up
         END   ,
         B     SIGPCC0
         EJECT ,
*
* SGRSTRT -- Handles the restart order.
*
         SPACE ,
SGRSTRT  LABEL ,
         L     RS,CPCPUA               Get our cpu address
         WITH  (CPUB,RA),BEGIN
*
* Signal that the restart is to take place.
*
         CLEAR RB
         CS    RB,RS,CPRSTRT           Signal a restart from us
         IF    NZ,SIGPCC2              Someone already has -- busy
*
* Make sure it is in the operational state
*
         SET   CPCSRUN,MODE=LOCKED,REF=CPUB
*
* Then make sure if it is running that it will see our efforts
*
         SET   SIEIPSTP,MODE=LOCKED,REF=SIEDATA
*
* And that if it is not running that it will wake up to them
*
         FPOST LA:CPECB                Then wake it up
         B     SIGPCC0                 All done -- CC 0
         END   ,
         EJECT ,
*
* SGEXTC -- Handles the External Call order
*
         SPACE ,
SGEXTC   LABEL ,
         L     RS,CPCPUA               Get our CPU address
         WITH  (CPUB,RA),BEGIN
*
* Signal the receiver
*
         CLEAR RB
         CS    RB,RS,CPEXCALL          Swap in our id
         IF    NZ,BEGIN                He is busy with another req
         L     RVR,=A(SIGPEXCP)        External call pending code
         B     SIGPCC1                 Store the status
         END   ,
*
* Now we make sure that he will be interrupted when he enables
*
         SET   SIEIPEXT,MODE=LOCKED,REF=SIEDATA
*
* Then we make sure he wakes up if he is asleep
*
         FPOST LA:CPECB
         B     SIGPCC0                 All done.  CC 0
         END   ,
         EJECT ,
*
* SGEMERS -- Handles the Emergency Signal order.
*
SGEMERS  LABEL ,
         LA    RS,1                    Get a low order one bit
         L     RB,CPCPUA               Get the cpu address
         SLL   RS,@RB                  Shift it into position
         WITH  (CPUB,RA),BEGIN
*
* Turn on our bit
*
         L     RB,CPEMERG              Get current bit map
         NR    RB,RS                   Is it on now?
         IF    NZ,SIGPCC0              If so then we are done
         L     RB,CPEMERG              Get current stuff back
         LOOP  BEGIN
         LR    RJ,RB
         OR    RJ,RS
         CS    RB,RJ,CPEMERG           Turn the bit on
         UNTIL Z,END                   No matter the interference
*
* Signal the external interruption...
*
         SET   SIEIPEXT,MODE=LOCKED,REF=SIEDATA
*
* Then make sure he's awake.
*
         FPOST LA:CPECB
         B     SIGPCC0                 All done.  CC 0
         END   ,
         EJECT ,
*
* SGSENSE -- This handles the Sense order.
*
         SPACE ,
SGSENSE  LABEL ,
         WITH  (CPUB,RA),BEGIN
         CLEAR RVR                     Initial status is 0
         IF    ^CPCSRUN,'O RVR,=A(SIGPSTOP)'     stopped
         L     RS,CPEXCALL
         IF    (RS,NZ),'O RVR,=A(SIGPEXCP)'      ext call pending
         B     SIGPCC1                 Store status
         END   ,
         EJECT ,
*
* SGSTPX -- This handles the Set prefix order.
*
         SPACE ,
SGSTPX   LABEL ,
*
* Get the desired prefix
*
         LH    RS,SIEINST              Bits 0-16 of the instruction
         SRL   RS,4                    Get R1 field in low spot
         N     RS,=X'0000000E'         Get even reg
         LA    RS,@RS+1                Get the odd register (parm)
         LREGA RS,(RS)                 Get address of the register
         L     RS,@RS                  Get the prefix value
         N     RS,=X'7FFFF000'         Don't care about other junk
         L     RB,CPCPUA               Get our CPU address
*
* Check on the Addressed CPU
*
         WITH  (CPUB,RA),BEGIN
*
* First lock out other Set prefix orders
*
         CLEAR RVR
         CS    RVR,RB,CPSPFX           Glom onto it
         IF    NZ,SIGPCC2              It is busy
*
* Check the state of the addressed CPU
*
         IF    CPCSRUN,BEGIN           CPU is running
         L     RVR,=A(SIGPICST)        Incorrect state status
         B     SIGPCC1
         END   ,
*
* Check on the status of the page
*
         IF    (RS,GE,CPCLEN),BEGIN    Higher than high core
         L     RVR,=A(SIGPINVP)        Invalid parm
         B     SIGPCC1                 Go store the status
         END   ,
*
* Store the prefix
*
         ST    RS,SIEPREFX             Save prefix register
         A     RS,CPCORE               Get MVS address of PSA
         L     RB,CPPSALOC             Get old PSA address
         ST    RS,CPPSALOC             Update that value as well
*
* First unfix the old PSA page
*
         PSET  @FIXPARM
         ST    RB,@FIXLOC
         MVC   @FIXLEN,=A(4096)
         VCALL PAGEFREE                Free the old one
*
* Then fix the new one
*
         MVC   @FIXLOC,CPPSALOC
         MVC   @FIXLEN,=A(4096)
         VCALL PAGEFIX                 Fix the new one
         LA    R0,CPUB
         ACALL SETCLOC2                Set local time
*
* Finally cause the TLB to be purged
*
         MVC   SIEIHCPU,=X'FFFF'       Cause a PTLB function
*
* Release the interlock
*
         CLEAR RS
         ST    RS,CPSPFX               Allow others in
         B     SIGPCC0
         END   ,
         EJECT ,
*
* SIGPCC1 -- This stores the status passed in RVR in the guest
*            register specified by R1 in the SIGP instruction unless
*            RVR contains 0.  If RVR contains zero then no status is
*            stored and we go to SIGPCC0 to set a zero condition
*            code.  If status is stored, we set the condition code
*            to 1.
         SPACE ,
SIGPCC1  IF    (RVR,Z),SIGPCC0         All zero status
*
* Extract the R1 field of the Instruction
*
         LH    RS,SIEINST              bits 0-15 of the instruction
         SRL   RS,4                    Put R1 field into low end
         N     RS,=X'0000000F'         Mask it out
         LREGA RS,(RS)                 Get the Register address
         ST    RVR,@RS                 Save the status
         NI    SIEPSW+2,X'CF'          Clear the CC
         OI    SIEPSW+2,X'10'          Then make it 1
         EXIT  IXSIGP
         EJECT ,
*
* SIGPCC3 -- This sets the condition code to 3 to indicate that a
*            not operational CPU was addressed by the SIGP inst.
*
         SPACE ,
SIGPCC3  OI    SIEPSW+2,X'30'          Make the CC 3
         EXIT  IXSIGP                  All done here
         SPACE 3
*
* SIGPCC2 -- This sets the condition code to 2 to indicate that a
*            busy condition was encountered and that the order could
*            not be carried out.
*
         SPACE ,
SIGPCC2  NI    SIEPSW+2,X'CF'          Clear the CC
         OI    SIEPSW+2,X'20'          Then make it 2
         EXIT  IXSIGP
         SPACE 3
*
* SIGPCC0 -- This sets the condition code to 0 to indicate that the
*            instruction completed without error and that no status
*            information was put in the register.
*
         SPACE ,
SIGPCC0  NI    SIEPSW+2,X'CF'          CC zero
         SPACE ,
         PEND
*
* SIGP status bit definitions
*
SIGPINVO EQU   X'00000002'
SIGPEXCP EQU   X'00000080'
SIGPSTOP EQU   X'00000040'
SIGPICST EQU   X'00000200'
SIGPINVP EQU   X'00000100'
         EJECT ,
*******************************************************************
*                                                                 *
*     IXSTAP - Routine to interpret Store CPU address.            *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXSTAP   PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Find out where the address is to go
*
         GETICAD RS,TYPE=S             Get the code
         PSET  GVAPARM
         ST    RY,GVACPUB              CPUB address
         ST    RS,GVAVLOC              Address where it is wanted
*        MVC   GVAVLOC,SIEICAD1        Address where it is wanted
         ACALL GVA
*
* Is it available?
*
         IF    (RVR,GT,4),BEGIN
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  IXSTAP
         END   ,
*
* Can it be written?
*
         IF    (RVR,NZ),BEGIN
         PIINT CODE=(RVR),ILEN=4
         EXIT  IXSTAP
         END   ,
*
* Check the range
*
         L     RB,GVAMLOC              Get our location
         IF    (RB,GE,CPCLAST),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXSTAP
         END   ,
*
* How about the protection key...is it safe?
*
         LH    RS,SIEPSW               Get user key int b24-b27
         TPROT @RB,@RS                 Check access
         IF    NZ,BEGIN
         PIINT CODE=4,ILEN=4           Protection exception
         EXIT  IXSTAP
         END   ,
*
* Save the value then.
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   @RB(2),CPCPUA+2         Execute the instruction
         MODESET KEYREG=2
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    IXSTIDP - Routine to interpret Store CPU ID.                 *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXSTIDP  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Find out where the ID is to go
*
         GETICAD RS,TYPE=S             Get the code
         PSET  GVAPARM
         ST    RY,GVACPUB              CPUB address
         ST    RS,GVAVLOC              Address where it is wanted
*        MVC   GVAVLOC,SIEICAD1        Address where it is wanted
         ACALL GVA
*
* Is it available?
*
         IF    (RVR,GT,4),BEGIN
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  IXSTIDP
         END   ,
*
* Can it be written?
*
         IF    (RVR,NZ),BEGIN
         PIINT CODE=(RVR),ILEN=4
         EXIT  IXSTIDP
         END   ,
*
* Check the range
*
         L     RB,GVAMLOC              Get our location
         IF    (RB,GE,CPCLAST),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXSTIDP
         END   ,
*
* How about the protection key...is it safe?
*
         LH    RS,SIEPSW               Get user key int b24-b27
         TPROT @RB,@RS                 Check access
         IF    NZ,BEGIN
         PIINT CODE=4,ILEN=4           Protection exception
         EXIT  IXSTIDP
         END   ,
*
* Save the value then.
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   @RB(8),CPCPUID          Execute the instruction
         MODESET KEYREG=2
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*      IXSPX - Routine to interpret Set Prefix.                   *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXSPX    PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Get the location of the prefix value
*
         GETICAD RS,TYPE=S             Get the code
         PSET  GVAPARM                 Conversion Routine
         ST    RY,GVACPUB              Save the CPU address
         ST    RS,GVAVLOC              Address where it is wanted
*        MVC   GVAVLOC,SIEICAD1        Address of the data
         ACALL GVA                     Do the translation
*
* Check whether it is available
*
         IF    (RVR,GT,4),BEGIN        Some translation problem
*
* Set up the program interrupt
*
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  IXSPX
         END   ,
*
* Get the prefix value desired
*
         L     RS,GVAMLOC
         L     RS,@RS                  Load the prefix value
*
* Check it out
*
         IF    (RS,GE,CPCLEN),BEGIN    Bad address
         PIINT CODE=5,ILEN=4           Signal the error
         EXIT  IXSPX                   All done here
         END   ,
*
* Implement it
*
         L     RB,CPPSALOC             Get old address of the PSA
         ST    RS,SIEPREFX             Update the prefix register
         A     RS,CPCORE               Get MVS virtual address
         ST    RS,CPPSALOC             Save it's address
*
* Unfix the previous PSA
*
         PSET  @FIXPARM
         ST    RB,@FIXLOC
         MVC   @FIXLEN,=A(4096)        One page
         VCALL PAGEFREE                Unfix it
*
* Fix the new PSA
*
         MVC   @FIXLOC,CPPSALOC
         MVC   @FIXLEN,=A(4096)
         VCALL PAGEFIX                 Do the Fix
         LA    R0,CPUB
         ACALL SETCLOC2                Set local time
*
* Then cause the TLB to be purged
*
         MVC   SIEIHCPU,=X'FFFF'       Cause the PTLB
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*     IXSTPX - Routine to interpret Store Prefix.                 *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXSTPX   PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Find out where the prefix value is to go
*
         GETICAD RS,TYPE=S             Get the code
         PSET  GVAPARM
         ST    RY,GVACPUB              CPUB address
         ST    RS,GVAVLOC              Address where it is wanted
*        MVC   GVAVLOC,SIEICAD1        Address where it is wanted
         ACALL GVA
*
* Is it available?
*
         IF    (RVR,GT,4),BEGIN
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  IXSTPX
         END   ,
*
* Can it be written?
*
         IF    (RVR,NZ),BEGIN
         PIINT CODE=(RVR),ILEN=4
         EXIT  IXSTPX
         END   ,
*
* Check the range
*
         L     RB,GVAMLOC              Get our location
         IF    (RB,GE,CPCLAST),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXSTPX
         END   ,
*
* How about the protection key...is it safe?
*
         LH    RS,SIEPSW               Get user key int b24-b27
         TPROT @RB,@RS                 Check access
         IF    NZ,BEGIN
         PIINT CODE=4,ILEN=4           Protection exception
         EXIT  IXSTPX
         END   ,
*
* Save the value then.
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   @RB(4),SIEPREFX         Execute the instruction
         MODESET KEYREG=2
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*       IXTB - Routine to interpret Test Block.                   *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXTB     PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Get the block address
*
         GETICAD RA,TYPE=RRE           Get the code
*        L     RA,SIEICAD1             Get the R1,R2 fields
         N     RA,=X'0000000F'         Isolate the R2 field
         LREGA RA,(RA)                 Get address of the data
         L     RA,@RA                  Get the data address
         LA    RA,@RA                  Clear the high bit
         IF    (RA,GE,CPCLEN),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXTB
         END   ,
         NI    SIEPSW+2,X'CF'          Zero condition code
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*     IXSSCH - Routine to interpret Start Subchannel.             *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXSSCH   PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Get the ORB address  **** MUST BE REAL ****
*
         GETICAD RB,TYPE=S             Get the effective address
*        L     RB,SIEICAD1             Get effective address
         GRA   RB,(RB)                 Get the MVS address
*
* Check the address range
*
         IF    (RB,GE,CPCLAST),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXSSCH
         END   ,
*
* Check to make sure the channel program is within the range
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         L     RJ,@RB+8                Get the Channel program addr
         MODESET KEYREG=2
         GRA   RJ,(RJ)                 Convert to MVS address
         IF    (RJ,GE,CPCLAST),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXSSCH
         END   ,
*
* Get an I/O control block
*
         PSET  GTIOCBP,CLEAR=NO
         MVC   GTIGSTC,CPGSTCT         Move in the parm
         LCALL GETIOCB
         LR    RX,RVR
         WITH  (IOCB,RX)
*
* Get the subchannel number
*
         LREGA RS,1                    It lives in R1
         MVC   IOCBSCH,@RS             Move it to the Control block
*
* Copy in the ORB
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   IOCBORB,@RB             Move it in
         MODESET KEYREG=2
*
* Call IOSERV
*
         PSET  @IORB
         ST    RX,@IORRQID             The IOCB is the REQ id
         MVC   @IOROFF,CPCORE          Offset to get MVS virtual
         MVC   @IORPARM,IOCBCPA        Chan prog addr (guest real)
         MVC   @IORSCH,IOCBSCH         Subchannel number
         MVC   @IORKEY,IOCBIFLG        Move in the key
         NI    @IORKEY,X'F0'           And only the key
         VCALL DOIO                    Then go do it
*
* Reset the condition code
*
         NI    @IORCC,X'30'            Mask all but the CC bits
         NI    SIEPSW+2,X'CF'          Clear out the CC bits
         OC    SIEPSW+2(1),@IORCC      Move in the CC
*
* If it is an immediate return (CC = 1), we update PZERO and free
* the IOCB
*
         IF    (@IORCC,EQ,X'10'),BEGIN I/O already done
*
* Access PZERO
*
         L     RS,CPPSALOC             Get the PZERO address
         WITH  (PZERO,RS)
*
* Move the info into PZERO
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   PZIOSID,IOCBSCH         Move in the subchannel addr
         MVC   PZIOPRM,IOCBIPRM        And the interrupt parm
         ST    RVR,PZIOSCS             And also the status
         MODESET KEYREG=2              Restore our PSW key
*
* Free the IOCB
*
         PSET  FRIOCBP,CLEAR=NO
         MVC   FRIGSTC,CPGSTCT
         ST    RX,FRIIOCB
         LCALL FREEIOCB
         END   ,
         ELSE  'MVI IOCBHSP,0' Clear flag HSPCETSK is waiting for
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*      IXTPI - Routine to interpret Test Pending Interrupt        *
*                                                                 *
*                                                                 *
*      Input - INTERP -- contains the address of the CPUB         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
IXTPI    PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
* Reset the condition code
*
         NI    SIEPSW+2,X'CF'          CC = Zero
*
* Get the address of where to store the interruption parms
*
*    **** THIS MUST BE A REAL ADDRESS ****
*
         GETICAD RB,TYPE=S             Get the effective address
*        LT    RB,SIEICAD1             Get effective address
         LTR   RB,RB
         IF    Z,'LA RB,184'           Use the default address
         GRA   RB,(RB)                 Get the MVS address
*
* Check the address range
*
         IF    (RB,GE,CPCLAST),BEGIN
         PIINT CODE=5,ILEN=4           Addressing exception
         EXIT  IXTPI
         END   ,
*
* See if there are any interrupts pending
*
         PSET  GTIOCBP,CLEAR=NO
         MVC   GTIGSTC,CPGSTCT
         LCALL GETIOI                  Get an interrupt IOCB
         LTR   RX,RVR
         IF    Z,'EXIT IXTPI'          There are none
         WITH  (IOCB,RX)
*
* Not subject to protection exception
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         MVC   @RB(4),IOCBSCH          Move in the subchannel addr
         MVC   @RB+4(4),IOCBIPRM       And the interrupt parm
         MVC   @RB+8(4),IOCBSTAT       And also the status
         MODESET KEYREG=2              Restore our PSW key
*
* Set the condition code
*
         OI    SIEPSW+2,X'10'          CC = 1 (Info stored)
*
* Free the IOCB
*
         PSET  FRIOCBP,CLEAR=NO
         MVC   FRIGSTC,CPGSTCT
         ST    RX,FRIIOCB
         LCALL FREEIOCB
         PEND  ,
         EJECT ,
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    GETIOCB - This routine returns the address of an available   *
*              IOCB.                                              *
*                                                                 *
*      Input - GTIOCBP -- contains the address of the GSTCT       *
*                                                                 *
*     Output - RVR contains the address of an IOCB                *
*                                                                 *
*******************************************************************
         SPACE 2
GTIOCBP  RECORD BEGIN
GTIGSTC  DS    A             Address of the GSTCT
         END   ,
         SPACE 2
GETIOCB  PROC  GTIOCBP,SCOPE=LOCAL
         L     RY,GTIGSTC              Address of the GSTCT
         WITH  (GSTCT,RY)
*
* Attempt first to get an IOCB that is already allocated
*
         LM    RA,RB,GSTCIOFQ          Header of the free queue
         LOOP  BEGIN
         IF    (RA,Z),NEWIOCB          No pre-allocated ones
         WITH  (IOCB,RA),'L RJ,IOCBNEXT'
         LR    RK,RB                   Copy the control value
         CDS   RA,RJ,GSTCIOFQ          Update the queue pointers
         UNTIL Z,END                   Keep trying till we get it
         LR    RVR,RA                  Get the IOCB pointer
         EXIT  GETIOCB
*
* If there are no pre-allocated ones we allocate a new one.
*
*NEWIOCB MEMGET L'IOCB,TYPE=(GLOBAL)
NEWIOCB  LA    RVR,L'IOCB
OBTIOCB  STORAGE OBTAIN,LENGTH=(RVR),SP=12,RELATED=RELIOCB
         LR    RVR,RS                  Insert addr in R0
         LR    RX,RS
         WITH  (IOCB,RX)
         CLEAR IOCB
         MVC   IOCB(4),=C'IOCB'        Init the control block id
         ST    RY,IOCBGSTC             Save GSTC pointer for later
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*     GETIOI - This routine returns the address of an IOCB that   *
*              has been signalled complete.                       *
*                                                                 *
*      Input - GTIOCBP -- contains the address of the GSTCT       *
*                                                                 *
*     Output - RVR contains the address of an IOCB                *
*                                                                 *
*******************************************************************
         SPACE 2
GETIOI   PROC  GTIOCBP,SCOPE=LOCAL
         L     RY,GTIGSTC              Address of the GSTCT
         WITH  (GSTCT,RY)
*
* Get the first IOCB off the interrupt pending queue
*
         LM    RA,RB,GSTCIOIQ          Header of interrupt queue
         LOOP  BEGIN
         IF    (RA,Z),EXIT             No interrupts pending
         WITH  (IOCB,RA),'L RJ,IOCBNEXT; MVI IOCBHSP,0'
         LR    RK,RB                   Copy the control value
         CDS   RA,RJ,GSTCIOIQ          Update the queue pointers
         UNTIL Z,END                   Keep trying till we get it
         LR    RVR,RA                  Get the IOCB pointer
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*   FREEIOCB - This routine takes an IOCB and puts it on the free *
*              queue for the guest machine.                       *
*                                                                 *
*      Input - FRIOCBP                                            *
*                                                                 *
*     Output - RVR = 0 if no more I/Os are queued.                *
*                                                                 *
*******************************************************************
         SPACE 2
FRIOCBP  RECORD BEGIN
FRIGSTC  DS    A             Address of the GSTCT
FRIIOCB  DS    A             Address of the IOCV to free
         END   ,
         SPACE 2
FREEIOCB PROC  FRIOCBP,SCOPE=LOCAL
         L     RY,FRIGSTC              Get the GSTCT address
         WITH  (GSTCT,RY)
         L     RJ,FRIIOCB              Get the IOCB address
         WITH  (IOCB,RJ)
         MVI   IOCBHSP,0       Clear flag HSPCETSK is waiting for
*
* Get the current head off the list and swap ours on
*
         LM    RA,RB,GSTCIOFQ          Get the free queue data
         LOOP  BEGIN
         ST    RA,IOCBNEXT             Update the chain
         LA    RK,1
         AR    RK,RB                   Update the counter
         CDS   RA,RJ,GSTCIOFQ          Update the free queue
         UNTIL Z,END                   All done.
         L     RVR,GSTCIOIQ            Non zero if any I/Os queued
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*        GVA - This routine takes a guest virtual address and     *
*              converts it to an MVS virtual address.             *
*                                                                 *
*      Input - GVAPARM                                            *
*                                                                 *
*     Output - RVR Contains data about the page availability      *
*                  0 -- Page available                            *
*                  4 -- Page may not be written                   *
*                 16 -- Segment Fault                             *
*                 17 -- Page Fault                                *
*                                                                 *
*******************************************************************
         SPACE 2
GVAPARM  RECORD BEGIN
GVACPUB  DS    A             Address of the CPUB
GVAVLOC  DS    A             Guest virtual address
GVAMLOC  DS    A             Return of the MVS virtual address
         END   ,
         SPACE 2
GVA      PROC  GVAPARM,SCOPE=LOCAL
         L     RM,GVACPUB              Get the CPUB pointer
         WITH  (CPUB,RM)
         CLEAR RX                      Protection flag
*
* Check on low address protection
*
         IF    SIECRS.X'10',BEGIN      Low address protection on
         IF    (GVAVLOC,LT,=A(512)),'LA RX,4'    And can't write here
         END   ,
*
* Check on whether DAT is off
*
         IF    ^SIEPSW.4,BEGIN         No translation
         L     RS,GVAVLOC              get the guest real addr
         GRA   RS,(RS)                 Convert to MVS virtual
         B     GVAREAL                 Skip the translation
         END   ,
*
* Get the STO for the correct address space
*
         IF    SIEPSW+2.X'80',BEGIN    Secondary Space mode
         L     RY,SIECRS+7*4           CR 7
         SET   GVAVLOC.X'80'           Indicate secondary
         END   ELSE,BEGIN              Primary Space mode
         L     RY,SIECRS+1*4           CR 1
         END   ,
*
* Break up the virtual address
*
         L     RA,GVAVLOC
         LA    RA,@RA                  Clear the High bit
         SRDL  RA,20                   Shift Seg # to low bits
         SRL   RB,24                   Shift Page # to low bits
*
* Check segment table length
*
         LR    RS,RY                   Copy of the STO
         N     RS,=X'0000007F'         Mask out the length
         INCR  RS                      Get actual # table increments
         SLL   RS,4                    16 STEs per increment
         IF    (RA,GE,RS),BEGIN        Too big.  Segment Fault.
         LA    RVR,16                  Segment fault code
         EXIT  GVA                     Go home
         END   ,
*
* Get the MVS Virtual address of the Segment table
*
         N     RY,=X'7FFFF000'         Guest real address of the ST
         GRA   RY,(RY)                 Translate to MVS virtual
*
* Get the ST entry
*
         SLL   RA,2                    Size of an ST entry
         LA    RY,@RY(RA)              Get the ST entry addr
*
* Check for invalidity
*
         IF    @RY+3.X'20',BEGIN       Invalid...Segment Fault
         LA    RVR,16
         EXIT  GVA
         END   ,
*
         L     RY,@RY                  Get the actual entry
*
* Check PT length
*
         LR    RS,RY
         N     RS,=X'0000000F'         Mask out the PT length
         INCR  RS                      Acutal number of increments
         SLL   RS,4                    16 entries/increment
         IF    (RB,GE,RS),BEGIN        Page Fault
         LA    RVR,17
         EXIT  GVA
         END   ,
*
* Get real address of the PTO
*
         N     RY,=X'7FFFFFC0'         Guest Real
         GRA   RY,(RY)                 to MVS virtual
*
* PT Entry
*
         SLL   RB,2                    Size of a PT entry
         LA    RY,@RY(RB)              Address of the entry
*
* Check Validity
*
         IF    @RY+2.X'04',BEGIN       Invalid...page fault
         LA    RVR,17
         EXIT  GVA
         END   ,
         IF    @RY+2.X'02','LA RX,4'    Protected page
*
* Get the actual entry
*
         L     RY,@RY                  Get it
         N     RY,=X'7FFFF000'         Convert to Guest real
         GRA   RY,(RY)                 Convert to MVS Virtual
*
* Construct total address
*
         L     RS,GVAVLOC              Get the address
         N     RS,=X'00000FFF'         But we only want displacement
         OR    RS,RY                   Get total
GVAREAL  ST    RS,GVAMLOC              Save it
         LR    RVR,RX                  Signal good return / PROTECT
         PEND
         LTORG
         EJECT ,
*******************************************************************
*                                                                 *
*    LOADIPL - This routine loads the IPL text into the first     *
*              page of guest storage.  It is passed the address   *
*              of the GSTCT.                                      *
*                                                                 *
*      Input - LOADIP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
LOADIP   RECORD BEGIN
LIPGSTCT DS    A             Address of the GSTCT
         END   ,
         SPACE 2
LOADIPL  PROC  LOADIP,SCOPE=LOCAL
         L     RX,LIPGSTCT
         WITH  (GSTCT,RX)
         L     RA,GSTCCORE             Address of guest storage
         L     RJ,=V(IPLTEXT)          Location of the IPL text
         L     RK,=A(4096)             length of the IPL text
         LR    RB,RK                   No pad
         MVCL  RA,RJ                   Move the Kernel in
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    DTABEND - This is a DIAGNOSE service routine.  It causes     *
*              ORVYL to DIE.                                      *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTABEND  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB
         WITH  (CPUB,RY)
         STIMERM CANCEL,ID=ALL,MF=(E,CPSTIMER)   Cancel time
*
* Stop all the other CPUs
*
         L     RX,CPGSTCT              Get the GSTCT pointer
         WITH  (GSTCT,RX)
         LA    RA,GSTCCPUS             Address of first CPUB pointer
         CLEAR RB                      Count of CPUs
         WHILE (RB,LT,GSTCNCPU),BEGIN  Loop through them
         L     RJ,@RA                  Get the CPUB
         IF    (RY,NE,RJ),BEGIN        Not ours
         WITH  (CPUB,RJ),BEGIN
         CLEAR CPCSRUN,MODE=LOCKED,REF=CPUB      Not running anymore
         SET   SIEIPSTP,MODE=LOCKED,REF=SIEDATA  Set intervention bit
         FPOST LA:CPECB                Then wake it up
         END   ,
         END   ,
         LA    RA,@RA+4                Get to the next CPU
         LA    RB,@RB+1                Count one more
         END   ,
*
* Then quietly go away
*
         ABEND 999,DUMP
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    DTMEMSZ - This is a DIAGNOSE service routine.  It returns    *
*              the count of available pages in r1.                *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTMEMSZ  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
* Get the info
*
         L     RB,CPCLEN               Get the length in bytes
         SRL   RB,12                   Turn it into pages
*
* Figure out where to put the info
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         ST    RB,@RS                  Save the information
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    DTLDSTA - This is a DIAGNOSE service routine.  It opens and  *
*              sets up for reading the kernel load module.  It    *
*              returns in r1 the size of the program and in r2    *
*              the entry point address.                           *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTLDSTA  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
* Get memory below the line for the load parms
*
         POOLGET L:=A(L'LOADPARM),TYPE=(LOCAL,BELOW16M)
         ST    RVR,CPLOADP             Save the address of it
         LR    RX,RVR                  Address it
         WITH  (LOADPARM,RX)
*
* Initialize the data area
*
         L     RS,=A(AM24CAP)          CAP code
         MVC   LAM24,@RS               Move it in
         MVC   LDCB,MODDCB             Move in the DCB
         MVC   LDECB,MODDECB           Move in the Model
         LA    RS,LDCB
         ST    RS,LDECB+8              Save the DCB address
         LA    RS,LBUFFER
         ST    RS,LDECB+12             Save the buffer address
         MVC   LBLDL,MODBLDL           And the BLDL list
*
* Open the kernel dataset
*
         MVI   LOPENP,X'80'            Update the options byte
         OPEN  (LDCB),MF=(E,LOPENP)    Open the dataset up
*
* Get the information out of the directory block
*
         BLDL  LDCB,LBLDL              Get the info
         FIND  LDCB,LKMOD,D            Position us there
*
* Figure out where to put the info... first the load module length
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L3    RB,LMLEN                Get the load module length
         ST    RB,@RS                  Save the information
*
* ... then the entry point address
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L3    RB,LMEPA                Get the load module length
         ST    RB,@RS                  Save the information
         PEND  ,
         EJECT ,
XBLD     DC    H'1'
         DC    H'62'
         DC    CL8'KERNEL'
         DC    XL6'00'
         DC    XL62'00'
MODBLDL  EQU   XBLD,*-XBLD,C'X'
*
XDCB     DCB   DSORG=PO,DDNAME=KERNLIB,MACRF=(R),BLKSIZE=8192
MODDCB   EQU   XDCB,*-XDCB,C'X'
         READ  XDECB,SF,0,0,'S',MF=L
MODDECB  EQU   XDECB,*-XDECB,C'X'
         EJECT ,
*******************************************************************
*                                                                 *
*    DTLDBLK - This is a DIAGNOSE service routine.  It reads one  *
*              block of the currently open kernel into guest real *
*              storage.  r1 has the guest real address of an      *
*              IDAW list describing the storage for the block.    *
*              The length of the block is returned in r2.         *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTLDBLK  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
         L     RX,CPLOADP              Get the loadparm address
         WITH  (LOADPARM,RX)
*
* Read in a block from the load module
*
         LA    RS,LAMPARM              Address of the parm area
         WITH  (@AM24,RS),BEGIN
         LA    RVR,LDECB               Get the DECB address
         ST    RVR,@AM24R1             This goes in R1
         L     RVR,LDCB+48             RDWR Routine address
         ST    RVR,@AM24R15
         END   ,
         LA    EPAR,LAM24
         BASSM RAR,EPAR                Call the AMODE 24 Routine
*
* Do the check
*
         LA    RS,LAMPARM
         WITH  (@AM24,RS),BEGIN
         LA    RVR,LDECB
         ST    RVR,@AM24R1
         L     RVR,LDCB+52             CHECK Routine address
         ST    RVR,@AM24R15
         END   ,
         LA    EPAR,LAM24
         BASSM RAR,EPAR                Go for it
*
* Find out how long the block was
*
         LA    RA,LDCB                 Get the DCB address
         WITH  (IHADCB,RA),'LH RK,DCBLRECL'
*
* Return the length to the user
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the Address of the Reg
         ST    RK,@RS                  Save the information
*
* Figure out where to move the data
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RS,@RS                  Get the IDAL address (real)
         GRA   RS,(RS)                 Convert to Absolute
*
* Now move the data in up to 2K chunks
*
         LA    RJ,LBUFFER              Source address
         WHILE (RK,NZ),BEGIN           While any left to move
         GRA   RA,L:@RS                Get MVS addr of first seg
         LA    RB,@RA+2048
         N     RB,=X'7FFFF800'         Addr of next 2K bdy
         SR    RB,RA                   Length to move on this try
         CEIL  RB,RK                   But no more than we have
         MVCL  RA,RJ                   Move to the user storage
         LA    RS,@RS+4                Point at the next IDAW
         END   ,
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    DTLDEND - This is a DIAGNOSE service routine.  It terminates *
*              the reading of the kernel.                         *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTLDEND  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
         L     RX,CPLOADP              Get the loadparm address
         WITH  (LOADPARM,RX)
*
* Close the dataset
*
         MVI   LOPENP,X'80'            Mark the end of the list
         CLOSE (LDCB),MF=(E,LOPENP)    Close that baby
*
* Free the LOADPARM area
*
         POOLFREE L:=A(L'LOADPARM),A=(RX),TYPE=(LOCAL,BELOW16M)
         CLEAR CPLOADP                 Clear the pointer to it
         PEND  ,                       Back to the guest
         EJECT ,
*******************************************************************
*                                                                 *
*     DTPAGE - This is a DIAGNOSE service routine.  It notifies   *
*              the "machine" that the guest will be using a page  *
*              frame for paging purposes and that it should be    *
*              fixed to MVS.  This prevents both MVS and the      *
*              guest from playing with the storage keys at the    *
*              same time.  The real address of the frame is       *
*              passed in r1.                                      *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTPAGE   PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
* Find the address of the page
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low bits
         N     RS,=X'0000000F'         Mask it out
         LREGA RS,(RS)                 Get the address of the reg
         L     RS,@RS                  Get the contents of the reg
         GRA   RS,(RS)                 Get the Absolute address
*
* Fix the memory
*
         PSET  @FIXPARM
         ST    RS,@FIXLOC              Save the page address
         MVC   @FIXLEN,=A(4096)        one page
         VCALL PAGEFIX                 Do the fix
         PEND  ,                       All done...return to guest
         EJECT ,
*******************************************************************
*                                                                 *
*   DTNOPAGE - This is a DIAGNOSE service routine.  It notifies   *
*              the "machine" that the page frame whose real       *
*              address is passed in r1 will not be use by the     *
*              guest for paging I/O.  This means that it may be   *
*              unfixed to MVS.  A previous diagnose PAGE should   *
*              have been done.                                    *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTNOPAGE PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
* Find the address of the page
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low bits
         N     RS,=X'0000000F'         Mask it out
         LREGA RS,(RS)                 Get the address of the reg
         L     RS,@RS                  Get the contents of the reg
         GRA   RS,(RS)                 Get the Absolute address
*
* Un-fix the memory
*
         PSET  @FIXPARM
         ST    RS,@FIXLOC              Save the page address
         MVC   @FIXLEN,=A(4096)        one page
         SET   @FIXFREL                release the contents
         VCALL PAGEFREE                Do the free
         PEND  ,                       All done...return to guest
         EJECT ,
*******************************************************************
*                                                                 *
*    DTALLOC - This is a DIAGNOSE service routine.  It calls the  *
*              I/O service routine to allocated a device.  It is  *
*              called with a code passed in r1 and returns to the *
*              guest with r1 containting the 32 bit identifier    *
*              returned from the I/O service routine.             *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTALLOC  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
* Get the code register
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low bits
         N     RS,=X'0000000F'         Mask it out
         LREGA RS,(RS)                 Get the address of the reg
*
* Call the I/O service routine
*
         PSET  @IOUPARM                Setup for the call
         MVC   @IOUDEVT,@RS            Move in the code
         VCALL INITDEV                 Do the allocate
         ST    RVR,@RS                 Put the ID in the Register
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    DTSPIN  - This is a DIAGNOSE service routine.                *
*              This puts the CPU subtask in wait for spin locks   *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTSPIN   PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
*  Put this CPU in wait
*
         FWAIT LA:CPECB
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    DTNOSPIN - This is a DIAGNOSE service routine.               *
*               This wakes up a CPU task from 'spinning' for a    *
*               lock.                                             *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTNOSPIN PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
*
* Get the code register
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low bits
         N     RS,=X'0000000F'         Mask it out
         LREGA RS,(RS)                 Get the address of the reg
         LH    RS,@RS+2                Get the CPU address to post
*
*  Post specified CPU
*
         L     RX,CPGSTCT              Addr to table of CPUs
         WITH  (GSTCT,RX)              |
         SLL   RS,2                    Get CPUB addr for CPU
         L     RA,GSTCCPUS(RS)         |
         WITH  (CPUB,RA),LABEL=OTHER,BEGIN
         FPOST OTHER.CPECB
         END   ,
         PEND  ,
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*       MVRWORK -- MVS memory read work area                      *
*                                                                 *
*******************************************************************
         SPACE
MVRWORK  RECORD BEGIN
MVRADDR  DS    A                       MVS ADDRESS
MVRKEY   DS    A
MVRUADR  DS    A                       CALLER ADDRESS
MVRLEN   DS    A                       TOTAL LENGTH
MVRPLEN  DS    A                       PARTIAL LENGTH
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DTMVSRD  - This is a DIAGNOSE service routine.  It moves      *
*              data from MVS memory to the ORVYL guest.  On       *
*              entry r1 and r2 are each an even-odd register      *
*              pair which contain:                                *
*                 r1    Orvyl guest virtual address               *
*                 r1+1  Length of the area                        *
*                 r2    MVS virtual address                       *
*                 r2+1  Protect Key                               *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTMVSRD  PROC  INTERP,MVRWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTMVSRD
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r1 and r1+1
         STM   R14,R15,MVRUADR         Caller's address and length
*
*  Get parameter registers r2 and r2+1
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTMVSRD
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r2 and r2+1
         STM   R14,R15,MVRADDR         MVS address and key
*
*  Validate the MVS address
*
         LR    RJ,R14                  GET MVS ADDRESS
         L     RK,MVRLEN                AND LENGTH
         AR    RK,RJ                   END ADDRESS + 1
         L     RB,MVRKEY               KEY TO BE USED
MVRCHK   WHILE (RJ,LT,RK),BEGIN
         TPROT @RJ,@RB                 Test protection
*
*  NOT ALLOWED TO FETCH OR STORE (CC = 2)
*
         IF    NOACC,BEGIN
         NI    SIEPSW+2,X'CF'          Clear the CC
         OI    SIEPSW+2,X'20'          Set CC 2
         EXIT  DTMVSRD
         END
*
*  NOT TRANSLATABLE (CC = 3) - CHECK FURTHER
*
         IF    NOTRN,BEGIN
         LRA   RS,@RJ                  Test address
         IF    Z,NEXT,MVRCHK           Valid and in real memory
*
*  ADDRESS INVALID
*
         IF    INVLD,BEGIN             Invalid or not addressable
         OI    SIEPSW+2,X'30'          Set CC 3
         EXIT  DTMVSRD
         END   ,
*
*  NOT CURRENTLY IN MEMORY - TRY TO BRING IT IN
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         L     R15,CVTPTR              Not in memory check it out
         WITH  (CVT,R15),'ACALL CVTPTRV'   translate real to virtual
         TM    @R1+3,X'01'             has page been getmained?
         IF    Z,BEGIN                 No, return error
         MODESET KEYADDR=(2)           Back to our key
         OI    SIEPSW+2,X'30'          Set CC 3
         EXIT  DTMVSRD
         END   ,
         CLI   @RJ,0                   Page it in
         MODESET KEYADDR=(2)           Back to our key
         NEXT  MVRCHK                  Retry same address now
         END
         N     RJ,=A(X'7FFFF000')      4k boundary
         AL    RJ,=A(4096)              and to next block
         END   ,
*
*  Now check user area and move data page by page
*
         WHILE ('LT  RS,MVRLEN',P),BEGIN
         L     RA,MVRUADR              Starting location
         L     RB,=A(4096)             Calculate
         ALR   RB,RA
         N     RB,=X'7FFFF000'          Length on
         SR    RB,RA                     First page
         CEIL  RB,MVRLEN               Not more than wanted
         ST    RB,MVRPLEN              Save partial length
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RA,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTMVSRD
         END   ,
*
*  Area may not be written - cause protection error
*
         IF    (RVR,NZ),BEGIN          Not valid location
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4
         EXIT  DTMVSRD
         END   ,
*
*  Area is in memory and ok - Move the first portion
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         LR    RS,R2                   Save key
         L     R14,MVRADDR             Source address (MVS)
         L     RA,GVAMLOC              Target address (ORVYL)
         LR    R15,RB                  Copy length to move
         MVCL  RA,R14                  Move it
         LR    R2,RS
         MODESET KEYADDR=(2)           Back to our key
*
*  Reset registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the address of the reg
         L     RA,@RS                  Get the original location
         AL    RA,MVRPLEN              Update
         ST    RA,@RS                   and replace
         L     RA,@RS+4                Get the original length
         S     RA,MVRPLEN              Update
         ST    RA,@RS+4                 and replace
*
*  Reset register r2
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the address of the reg
         L     RA,@RS                  Original MVS location
         AL    RA,MVRPLEN              Update
         ST    RA,@RS                   and replace
*
*  Update remaining count
*
         L     RA,MVRLEN               Get the remaining length
         S     RA,MVRPLEN              Update
         ST    RA,MVRLEN                and replace
         END   ,
         NI    SIEPSW+2,X'CF'          Set CC 0
         PEND  ,
         EJECT
*******************************************************************
*                                                                 *
*       MVWWORK -- MVS memory write work area                     *
*                                                                 *
*******************************************************************
         SPACE
MVWWORK  RECORD BEGIN
MVWADDR  DS    A                       MVS ADDRESS
MVWKEY   DS    A
MVWUADR  DS    A                       USER VIRTUAL ADDRESS
MVWLEN   DS    A                       TOTAL LENGTH
MVWPLEN  DS    A                       PARTIAL LENGTH
MVWOPT   DS    A                       OPTION
MVWLOCS  DS    2D                      USER REAL ADDRESSES
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*       MVS memory write data area                                *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
MVWTAB   MVC   @R14(0),@RJ
         OC    @R14(0),@RJ
         NC    @R14(0),@RJ
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DTMVSWR - This is a DIAGNOSE service routine.  It moves,      *
*             AND's or OR's data from the ORVYL guest to MVS.     *
*             On entry r1 and r2 are each an even-odd register    *
*             pair which contain:                                 *
*                                                                 *
*                 r1    Orvyl guest virtual address               *
*                 r1+1  Length of the area                        *
*                 r2    MVS virtual address                       *
*                 r2+1  Bits 0-15   Reserved                      *
*                       Bits 16-23  Option byte                   *
*                                    0 = MVC data                 *
*                                    1 = OR data                  *
*                                    2 = AND data                 *
*                       Bits 24-31  Protect key                   *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTMVSWRT PROC  INTERP,MVWWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTMVSWRT
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r1 and r1+1
         STM   R14,R15,MVWUADR         Caller's address and length
*
*  Validate user supplied length
*
         IF    ((R15,NP),OR,(R15,GT,256)),BEGIN
         PIINT CODE=6,ILEN=4           Length is not valid
         EXIT  DTMVSWRT
         END   ,
*
*  Get parameter registers r2 and r2+1
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTMVSWRT
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r2 and r2+1
         ST    R14,MVWADDR             MVS address
         LA    R14,255                 Isolate
         NR    R14,R15                  protect key
         ST    R14,MVWKEY
         SRL   R15,8                   Isolate
         ST    R15,MVWOPT               option byte
*
*  Validate the MVS address
*
         L     RJ,MVWADDR              GET MVS ADDRESS
         L     RK,MVWLEN                AND LENGTH
         AR    RK,RJ                   END ADDRESS + 1
         L     RB,MVWKEY               KEY TO BE USED
MVWCHK   WHILE (RJ,LT,RK),BEGIN
         TPROT @RJ,@RB                 Test protection
*
*  NOT ALLOWED TO FETCH OR STORE (CC = 1 OR 2)
*
         IF    NOSTR,BEGIN
         NI    SIEPSW+2,X'CF'          Clear the CC
         OI    SIEPSW+2,X'20'          Set CC 2
         EXIT  DTMVSWRT
         END
*
*  NOT TRANSLATABLE (CC = 3) - CHECK FURTHER
*
         IF    NOTRN,BEGIN
         LRA   RS,@RJ                  Test address
         IF    Z,NEXT,MVWCHK           Valid and in real memory
*
*  ADDRESS INVALID
*
         IF    INVLD,BEGIN             Invalid or not addressable
         OI    SIEPSW+2,X'30'          Set CC 3
         EXIT  DTMVSWRT
         END   ,
*
*  NOT CURRENTLY IN MEMORY - TRY TO BRING IT IN
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         L     R15,CVTPTR              Not in memory check it out
         WITH  (CVT,R15),'ACALL CVTPTRV'   translate real to virtual
         TM    @R1+3,X'01'             has page been getmained?
         IF    Z,BEGIN                 No, return error
         MODESET KEYADDR=(2)           Back to our key
         OI    SIEPSW+2,X'30'          Set CC 3
         EXIT  DTMVSWRT
         END   ,
         CLI   @RJ,0                   Page it in
         MODESET KEYADDR=(2)           Back to our key
         NEXT  MVWCHK                  Retry same address now
         END
         N     RJ,=A(X'7FFFF000')      4k boundary
         AL    RJ,=A(4096)              and to next block
         END   ,
*
*  Check user area - page by page
*
         L     RJ,MVWUADR              GET USER ADDRESS
         L     RB,MVWLEN                AND LENGTH
         CLEAR RA                      CLEAR INDEX
         LOOP  BEGIN
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTMVSWRT
         END   ,
*
*  Save real locations and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,MVWLOCS(RA)          Save location
         ST    RK,MVWLOCS+4(RA)         and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,
*
*  Mark end of list
*
         LA    RA,MVWLOCS(RA)          List pointer
         SET   @RA.X'80'                Mark end
*
*  Get a buffer for the data
*
         L     RK,MVWLEN               User data length
         MEMGET  @RK,TYPE=(LOCAL)
         LR    RJ,RVR
*
*  Move the user data to the buffer
*
         LR    RA,RJ
         LA    RS,MVWLOCS
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END   ,
*
*  Now move the data
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         L     R14,MVWADDR             MVS address
         L     RB,MVWOPT               Option code
         MH    RB,=Y(6)                Convert to index
         DEX   RK,MVWTAB(RB)
         MODESET KEYADDR=(2)           Back to our key
*
*  Release the buffer
*
         L     RS,MVWLEN               User data length
         MEMFREE @RS,A=(RJ),TYPE=(LOCAL)
         NI    SIEPSW+2,X'CF'          Set CC 0
         PEND  ,
         EJECT
*******************************************************************
*                                                                 *
*       MVNWORK -- MVS module search work area                    *
*                                                                 *
*******************************************************************
         SPACE
MVNWORK  RECORD BEGIN
MVNNAME  DS    CL8                     MODULE/CSECT NAME
MVNCDE   DS    A                       POINTER TO CDE
MVNADDR  DS    A                       ADDRESS OF ROUTINE
MVNREGS  DS    4A                      REGISTER SAVE
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*       MVS module search data                                    *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
MVNTAB   DC    V(GSTINTF),CL8'GSTINTF'
         DC    V(IOSERV),CL8'IOSERV'
         DC    V(IPLTEXT),CL8'IPLTEXT'
         DC    V(MEMSERV),CL8'MEMSERV'
         DC    V(MPMAST),CL8'MPMAST'
         DC    V(MSGSERV),CL8'MSGSERV'
         DC    V(PARMS),CL8'PARMS'
         DC    V(TASKSERV),CL8'TASKSERV'
         DC    V(TEXTCONV),CL8'TEXTCONV'
MVNTEND  EQU   *
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DTMVSNM - This is a DIAGNOSE service routine.  It searches    *
*              LPA and the MVS Nucleus map for a module or        *
*              csect name.  On entry r1 contains the guest        *
*              virtual address of the 8 byte name field which     *
*              must be on a doubleword boundary.  On return r1    *
*              contains the MVS virtual address if the name was   *
*              found, otherwise it contains zero.                 *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTMVSNM  PROC  INTERP,MVNWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
         CLEAR MVNCDE                  CLEAR
         CLEAR MVNADDR
*
*  GET THE NAME SUPLIED BY THE CALLER
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RA,@RS                  Module name address (virtual)
         IF    ('EX  RA,"TM  =X'07',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Address not on double word
         EXIT  DTMVSNM
         END
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RA,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTMVSNM
         END   ,
*
*  Address ok, copy in name
*
         L     RS,GVAMLOC              MVS address of name
         MVC   MVNNAME,@RS             Copy in module name
*
*  FIRST SEARCH THE ORVYL TABLE
*
         LA    RA,MVNTAB               TABLE POINTER
         LA    RS,MVNTEND               END OF TABLE
         WHILE (RA,LT,RS),BEGIN
         CLC   MVNNAME,@RA+4           NAMES MATCH?
         IF    EQ,'MVC  MVNADDR,@RA; EXIT'
         LA    RA,@RA+12               NEXT ENTRY
         END   ,
*
*  THEN SEARCH LPA CDE CHAIN
*
         IF    (MVNADDR,Z),BEGIN
         L     RB,CVTPTR               CVT
         WITH  (CVT,RB)
         STM   R8,R11,MVNREGS          SAVE REGISTERS
         L     R8,CVTQLPAQ             LPA QUEUE HEAD
         LA    R9,MVNNAME              NAME POINTER
         ACALL CVTQCDSR                GO TO SEARCH ROUTINE
*
*  RETURN TO R14+0 IF FOUND - R14+4 IF NOT
*
         ST    R11,MVNCDE              SET CDE POINTER
         LM    R8,R11,MVNREGS          RETRIEVE REGISTERS
*
*  IF NOT THERE TRY FULL LPA SEARCH
*
         IF    (MVNCDE,Z),BEGIN
         IF    ^CVTDIRST.CVTDICOM,EXIT   LPA DIRECTORY DOESN'T EXIST
         STM   R6,R9,MVNREGS           SAVE REGISTERS
         ACALL CVTLPDSR                LPA SEARCH ROUTINE
*
*  RETURN TO R14+0 IF FOUND - R14+4 IF NOT
*
         ST    R0,MVNCDE               LPDE POINTER
         LM    R6,R9,MVNREGS           RETRIEVE REGISTERS
         END   ,
*
*  IF CDE OR LPDE FOUND SET ADDRESS
*
         IF    ('LT  RA,MVNCDE',NZ),BEGIN
         WITH  (LPDE,RA),'MVC  MVNADDR,LPDENTP'    GET ENTRY POINT
         END   ,
*
*  ROUTINE TO SEARCH NUCLEUS FOR CSECT NAME
*
         IF    (MVNADDR,Z),BEGIN
*        NUCLKUP BYNAME,NAME=(1),ADDR=(0)
         LA    R1,MVNNAME              NAME POINTER
         CLEAR R0
         ACALL CVTNUCLU                GO DO IT
*
*  IF R15 = 0 ADDRESS RETURNED
*
         IF    (R15,Z),'ST  R0,MVNADDR'   SAVE ADDRESS
         END   ,
         END   ,
*
*  RETURN MODULE ADDRESS
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         MVC   @RS(4),MVNADDR          Set the information
         PEND
         EJECT
*******************************************************************
*                                                                 *
*     SMFREC -- MVS SMF record area                               *
*                                                                 *
*******************************************************************
         SPACE
SMFREC   RECORD BEGIN
*
*  Standard Smf header
*
         CNOP  2,4                 Alignment
SMFLEN   DS    AL2                 Total record length
SMFSEG   DS    AL2                 Segment descriptor
SMFFLG   DS    X                   System indicator
SMFTYPE  DS    X                   Smf record no.
SMFTIME  DS    A                   Time stamp (in .01 sec)
SMFDATE  DS    A                   Date (00yydddf)
SMFSID   DS    CL4                 System identification
SMFHDR   EQU   *-SMFLEN,*-SMFLEN,C'X'    Length of header portion
*
*  Data portion - supplied by caller
*
SMFDATA  DS    0X                  Data portion of record
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*       SMFWORK -- SMF write routine work area                    *
*                                                                 *
*******************************************************************
         SPACE
SMFWORK  RECORD BEGIN
SMFADDRS DS    9D                      Address/length pairs
SMFUADD  DS    A                       User virtual location
SMFULEN  DS    A                       Total length of user data
SMFUNUM  DS    X                       User supplied record number
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DTSMF  - This is a DIAGNOSE service routine.  It writes a     *
*            record to SMF. On entry r1 contains the guest        *
*            virtual address of the caller's SMF record area;     *
*            r2 contains:                                         *
*                Bits 0-7    SMF record number                    *
*                Bits 8-15   Reserved                             *
*                Bits 16-31  Length of the user supplied data     *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - CC = 0  Record written                             *
*                 = 3  Record not written                         *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTSMF    PROC  INTERP,SMFWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
*  Get the record address
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RJ,@RS                  Get record address
         ST    RJ,SMFUADD
         EJECT
*
*  Get the record number and length
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the Address of the Reg
         IC    RA,@RS                  Get record number
         STC   RA,SMFUNUM               and save
         LH    RB,@RS+2                Get length
         ST    RB,SMFULEN               and save
*
*  Validate user supplied length
*
         IF    ((RB,NP),OR,(RB,GE,32768)),BEGIN
         PIINT CODE=6,ILEN=4           Length is not valid
         EXIT  DTSMF
         END   ,
*
*  Check user area - page by page
*
         CLEAR RA                      CLEAR INDEX
         LOOP  BEGIN
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTSMF
         END   ,
*
*  Update location and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,SMFADDRS(RA)         Save location
         ST    RK,SMFADDRS+4(RA)        and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,
*
*  Mark end of list
*
         LA    RA,SMFADDRS(RA)         List pointer
         SET   @RA.X'80'                Mark end
*
*  Get a buffer for the SMF record
*
         L     RS,SMFULEN              User data length
         LA    RS,@RS+L'SMFREC
         MEMGET  @RS,TYPE=(LOCAL,BELOW16M)
         LR    RJ,RVR
         WITH  (SMFREC,RJ)
*
*  Set up record header
*
         LA    RS,@RK+L'SMFHDR         Record length
         STH   RS,SMFLEN
         MVC   SMFTYPE,SMFUNUM         Record number
*
*  Set date and time
*
         TIME  BIN                     Get info from MVS
         ST    R1,SMFDATE              Set date
         ST    R0,SMFTIME               and time
*
*  Get SMF system Id
*
         L     R15,CVTPTR              CVT
         WITH  (CVT,R15),'L  R15,CVTSMCA'      SMF info area
         WITH  (SMCABASE,R15),'MVC  SMFSID,SMCASID'     Machine Id
*
*  Move the user supplied portion
*
         LA    RA,SMFDATA              User data portion of record
         LA    RS,SMFADDRS
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END
*
*  Write the record
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         LA    RK,SMFLEN               Record location
         SMFEWTM  (RK),BRANCH=YES      Send it
         MODESET KEYADDR=(2)
*
*  Set the condition code from the SMF return code
*
         NI    SIEPSW+2,X'CF'          Assume ok - CC = zero
         IF    (R15,NZ),'OI  SIEPSW+2,X"30"'   Error - set CC = 3
*
*  Release the buffer
*
         L     RS,SMFULEN              User data length
         LA    RS,@RS+L'SMFREC
         MEMFREE @RS,A=(RJ),TYPE=(LOCAL,BELOW16M)
         PEND
         EJECT
*******************************************************************
*                                                                 *
*       MVEWORK -- MVS enqueue work area                          *
*                                                                 *
*******************************************************************
         SPACE
MVEWORK  RECORD BEGIN
MVERADD  DS    A                       Resource name address
MVERLEN  DS    A                        and Length
MVEQADD  DS    A                       Queue name address
MVEOPTS  DS    A                       Options
MVERLOC  DS    2D                      Resource name real address
MVEQLOC  DS    2D                      Queue name real address
MVENAME  DS    CL44                    Rsource name
         END   ,
         SPACE 3
         COPY  MVSPARM
         EJECT
*******************************************************************
*                                                                 *
*   DTENQ - This is a DIAGNOSE service routine.  It issues an     *
*           MVS ENQ or DEQ.  On entry r1 and r2 are each an       *
*           even-odd register pair which contain:                 *
*                 r1    Guest virtual address of resource name    *
*                 r1+1  Length of the resource name               *
*                 r2    Guest virtual address of queue name       *
*                 r2+1  Option bits                               *
*                       Bits  0-29  Reserved                      *
*                       Bit     30  Exclusive control request     *
*                       Bit     31  Enqueue request               *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTENQ    PROC  INTERP,MVEWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTENQ
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r1 and r1+1
         STM   R14,R15,MVERADD         Resource address and length
*
*  Validate user supplied length
*
         IF    ((R15,NP),OR,(R15,GT,44)),BEGIN
         PIINT CODE=6,ILEN=4           Length is not valid
         EXIT  DTENQ
         END   ,
*
*  Get parameter registers r2 and r2+1
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTENQ
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r2 and r2+1
         ST    R14,MVEQADD             Queue name address
         ST    R15,MVEOPTS             Options
*
*  Check Resource name area - page by page
*
         L     RJ,MVERADD              GET USER ADDRESS
         L     RB,MVERLEN               AND LENGTH
         CLEAR RA                      CLEAR INDEX
         LOOP  BEGIN
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTENQ
         END   ,
*
*  Save real locations and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,MVERLOC(RA)          Save location
         ST    RK,MVERLOC+4(RA)         and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,
*
*  Mark end of list
*
         LA    RA,MVERLOC(RA)          List pointer
         SET   @RA.X'80'                Mark end
*
*  Check Queue name area - page by page
*
         L     RJ,MVEQADD              GET USER ADDRESS
         LA    RB,8                     AND LENGTH
         CLEAR RA                      CLEAR INDEX
         LOOP  BEGIN
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTENQ
         END   ,
*
*  Save real locations and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,MVEQLOC(RA)          Save location
         ST    RK,MVEQLOC+4(RA)         and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,
*
*  Mark end of list
*
         LA    RA,MVEQLOC(RA)          List pointer
         SET   @RA.X'80'                Mark end
*
*  Move resource name to work area
*
         PSET  @MVSENQ
         LA    RA,MVENAME
         LA    RS,MVERLOC
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END   ,
*
*  Move queue name to MVS ENQUEUE service parameter list
*
         PSET  @MVSENQ
         LA    RA,@MVNQQNM
         LA    RS,MVEQLOC
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END   ,
*
*  Set options and call service routine
*
         LA    RS,MVENAME              Name pointer
         ST    RS,@MVNQRNM              to parameter list
         MVC   @MVNQRNL,MVERLEN        Name length
         IF    MVEOPTS+3.X'01','SET  @MVNQENQ'   MARK ENQUEUE
         IF    MVEOPTS+3.X'02','SET  @MVNQEXC'   MARK EXCLUSIVE
         VCALL MVSENQ                  GO DO IT
*
*  SET CONDITION CODE
*
         NI    SIEPSW+2,X'CF'          Clear the CC
         IF    (RVR,NZ),BEGIN
         IPM   RS                      Return code
         SRL   RS,24                    To low byte
         EX    RS,'OI  SIEPSW+2,0'     Set new CC
         END   ,
         PEND
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*  DTPARM - This is a DIAGNOSE service routine.  It returns the   *
*           value of a keyword parameter from the init file.      *
*           On entry r1 and r2 are each an                        *
*           even-odd register pair which contain:                 *
*                 r1    Guest virtual address of return area      *
*                 r1+1  Length of return area (strings must be at *
*                       least 5 bytes, 4 bytes for VB record RDW  *
*                       and 1 byte minimum of data area)          *
*                 r2    Guest virtual address of input parameters *
*                 r2+1  Length of parameters (fixed length + 8    *
*                       bytes each keyword, padded with blanks)   *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
PARWORK  RECORD BEGIN
PARILOC  DS    A                       Input parameters - loc
PARILEN  DS    A                       | len
PAROLOC  DS    A                       Output parameters - loc
PAROLEN  DS    A                       | len
PARAREA  DS    A                       Pointer to input/output areas
PARIHLOC DS    A                       Input parameters - Host
PAROHLOC DS    A                       Output parameters - Host
PARR1    DS    A                       Register r1 addr
PARR2    DS    A                       Register r2 addr
         END   ,
         SPACE
DTPARM   PROC  INTERP,PARWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTPARM
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r1 and r1+1
         STM   R14,R15,PAROLOC         Return location/len
*
*  Get parameter registers r2 and r2+1
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTPARM
         END
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r2 and r2+1
         STM   R14,R15,PARILOC         Input location/len
*
         LA    RK,PARILOC
         ST    RK,PARAREA
         LOOP  BEGIN                   Bring parm areas in core
         L     RK,PARAREA
*
*  Make sure input and output areas are in core
*
         LM    RA,RB,@RK
         WHILE (RB,POS),BEGIN          Bring in all of area
         L     RK,=A(4096)             Calculate
         AR    RK,RA
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RA                     First page
         CEIL  RK,RB                   Not more than wanted
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RA,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTPARM
         END   ,
         L     RJ,PARAREA
         LA    EPAR,PAROLOC
         IF    (RJ,EQ,EPAR),BEGIN      Check output area for write
*
*  Area may not be written - cause protection error
*
         IF    (RVR,NZ),BEGIN          Not valid location
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4
         EXIT  DTPARM
         END   ,
         END   ,                       OF Check output area for write
*
*  Update remaining count
*
         LA    RA,@RA(RK)              Next location
         SR    RB,RK                   Remaining length
         END   ,                       OF Bring in all of area
*
         L     RK,PARAREA
         LA    RK,@RK+8
         ST    RK,PARAREA
         LA    RJ,PAROLOC
         UNTIL (RK,GT,RJ),END          OF Bring parm areas in core
*
*  Move input area to buffer
*
         MEMGET L:PARILEN,TYPE=GLOBAL
         LR    RJ,RVR
         ST    RJ,PARIHLOC             Save contig memory addr
*
*  Move input to contig buffer
         L     RX,PARILOC              Guest VA
         L     RS,PARILEN              | length
         L     RJ,PARIHLOC             Host VA
         LOOP  BEGIN                   Copy across page bndrys
         PSET  GVAPARM                 Get Host VA of guest area
         ST    RY,GVACPUB              |
         ST    RX,GVAVLOC              |
         ACALL GVA                     |
         L     RA,GVAMLOC              |
         LR    RK,RA                   Length on this page
         AL    RK,=A(4096)             |
         N     RK,=X'7FFFF000'         |
         SR    RK,RA                   |
         CEIL  RK,RS                   | not more than total
         ALR   RX,RK                   Next guest VA
         SR    RS,RK                   Remaining length
         LR    RB,RK
*
         REGCH (RA,R2)
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         LR    EPAR,RA                 Save key
         L     RA,GVAMLOC              Source address - GUEST
         MVCL  RJ,RA
         LR    RA,EPAR
         MODESET KEYADDR=(2)
*
         UNTIL (RS,ZERO),END           OF Copy across page bndrys
*
         MEMGET L:PAROLEN,TYPE=GLOBAL
         LR    RK,RVR
         ST    RK,PAROHLOC             Save contig memory addr
*
*  Call parameter routines
*
         PSET  @PARMDO
         L     RX,PARIHLOC
         WITH  (PARMIN,RX),BEGIN       Addr to PARMIN
         PMOV  @PARILOC,LA:PARMIN
         PMOV  @PARILEN,PARILEN
         L     RA,PAROHLOC
         L     RB,PAROLEN
         IF    (PARMFSTR,OR,PARMFYN),BEGIN      Adjust for RDW
         LA    RVR,4
         ALR   RA,RVR
         SLR   RB,RVR
         END   ,                       OF Adjust for RDW
         STM   RA,RB,@PAROLOC
         END   ,                       OF Addr to PARMIN
         VCALL PARMDO
         NI    SIEPSW+2,X'CF'          Set CC to match that of return
         LTR   RVR,RVR                 |
         IPM   RS                      |
         N     RS,=X'30000000'         | mask off all but CC
         SRL   RS,24                   | put in lower byte
         EX    RS,'OI SIEPSW+2,0'      | set CC
*
         IF    (RVR,ZERO),BEGIN        Data to move
*
*  Move return data to guest
*
         L     RX,PAROLOC              Guest VA
         L     RS,@PAROLEN             | length returned
         L     RJ,PAROHLOC             Host VA
         L     RA,PARIHLOC
         WITH  (PARMIN,RA),BEGIN       Addr to Input parms
         IF    (PARMFSTR,OR,PARMFYN),BEGIN      Set up RDW
         AH    RS,=Y(4)                |
         STH   RS,@RJ
         CLEAR (@RJ+2,2)
         END   ,                       OF Set up RDW
         END   ,                       OF Addr to Input parms
         LOOP  BEGIN                   Copy across page bndrys
         PSET  GVAPARM                 Get Host VA of guest area
         ST    RY,GVACPUB              |
         ST    RX,GVAVLOC              |
         ACALL GVA                     |
         L     RA,GVAMLOC              |
         LR    RK,RA                   Length on this page
         AL    RK,=A(4096)             |
         N     RK,=X'7FFFF000'         |
         SR    RK,RA                   |
         CEIL  RK,RS                   | not more than total
         ALR   RX,RK                   Next guest VA
         SR    RS,RK                   Remaining length
         LR    RB,RK
*
*
         REGCH (RA,R2)
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         LR    EPAR,RA                 Save key
         L     RA,GVAMLOC              Target address - GUEST
         MVCL  RA,RJ
         LR    RA,EPAR
         MODESET KEYADDR=(2)
*
         UNTIL (RS,ZERO),END           OF Copy across page bndrys
         END   ,                       OF Data to move
*
*  Release buffers
*
         MEMFREE A=L:PARIHLOC,L:PARILEN,TYPE=GLOBAL
         MEMFREE A=L:PAROHLOC,L:PAROLEN,TYPE=GLOBAL
         PEND  ,
         EJECT
*******************************************************************
*                                                                 *
*  DTPARM2- This is a DIAGNOSE service routine.  It returns the   *
*           value of a keyword parameter from the init file.      *
*           On entry r1 and r2 are each an                        *
*           even-odd register pair which contain:                 *
*                 r1    Guest virtual address of return area      *
*                 r1+1  Length of return area                     *
*                 r2    Guest virtual address of input parameters *
*                 r2+1  Length of parameters (fixed length + 8    *
*                       bytes each keyword, padded with blanks)   *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none to host                                       *
*            - guest return area or guest registers set           *
*                CC = 0 Keyword found, value returned             *
*                CC > 0 Keyword not found                         *
*                CC < 0 Keyword found, type mismatch or invalid   *
*                       type requested                            *
*                When CC = 0                                      *
*                  For string type parameters                     *
*                    r1   Guest pointer to string                 *
*                    r1+1 Length of string                        *
*                  For integer type parameters                    *
*                    r1   Integer value                           *
*                  For float type parameters                      *
*                    r1   Short float value                       *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE
DTPARM2  PROC  INTERP,PARWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTPARM2
         END
         LREGA RS,(RS)                 Get the address of the reg
         ST    RS,PARR1                 and save it
         LM    R14,R15,@RS             r1 and r1+1
         STM   R14,R15,PAROLOC         Return location/len
*
*  Get parameter registers r2 and r2+1
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTPARM2
         END
         LREGA RS,(RS)                 Get the address of the reg
         ST    RS,PARR2                 and save it
         LM    R14,R15,@RS             r2 and r2+1
         STM   R14,R15,PARILOC         Input location/len
*
*  Make sure input area is in core
*
         LM    RA,RB,PARILOC
         WHILE (RB,POS),BEGIN          Bring in all of area
         L     RK,=A(4096)             Calculate
         AR    RK,RA
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RA                     First page
         CEIL  RK,RB                   Not more than wanted
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RA,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTPARM2
         END   ,
*
*  Update remaining count
*
         LA    RA,@RA(RK)              Next location
         SR    RB,RK                   Remaining length
         END   ,                       OF Bring in all of area
*--------------
*  Move input area to host buffer
*--------------
         MEMGET L:PARILEN,TYPE=GLOBAL
         LR    RJ,RVR
         ST    RJ,PARIHLOC             Save contig memory addr
DTPARM2I BEGIN ,                       Input buffer alloc
*
*  Move input to contig buffer
         L     RX,PARILOC              Guest VA
         L     RS,PARILEN              | length
         L     RJ,PARIHLOC             Host VA
         LOOP  BEGIN                   Copy across page bndrys
         PSET  GVAPARM                 Get Host VA of guest area
         ST    RY,GVACPUB              |
         ST    RX,GVAVLOC              |
         ACALL GVA                     |
         L     RA,GVAMLOC              |
         LR    RK,RA                   Length on this page
         AL    RK,=A(4096)             |
         N     RK,=X'7FFFF000'         |
         SR    RK,RA                   |
         CEIL  RK,RS                   | not more than total
         ALR   RX,RK                   Next guest VA
         SR    RS,RK                   Remaining length
         LR    RB,RK
*
         REGCH (RA,R2)
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         LR    EPAR,RA                 Save key
         L     RA,GVAMLOC              Source address - GUEST
         MVCL  RJ,RA
         LR    RA,EPAR
         MODESET KEYADDR=(2)
*
         UNTIL (RS,ZERO),END           OF Copy across page bndrys
         EJECT ,
*--------------
*  Check input parameters to see if we need an output area
*--------------
         L     RM,PARIHLOC
         WITH  (PARMIN,RM)
         IF    (PARMFSTR,OR,PARMFYN),BEGIN      Strings need out area
*
*  Make sure output area is in core and writeable
*
         LM    RA,RB,PARILOC
         WHILE (RB,POS),BEGIN          Bring in all of area
         L     RK,=A(4096)             Calculate
         AR    RK,RA
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RA                     First page
         CEIL  RK,RB                   Not more than wanted
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RA,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTPARM2I
         END   ,
*
*  Area may not be written - cause protection error
*
         IF    (RVR,NZ),BEGIN          Not valid location
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4
         EXIT  DTPARM2I
         END   ,
*
*  Update remaining count
*
         LA    RA,@RA(RK)              Next location
         SR    RB,RK                   Remaining length
         END   ,                       OF Bring in all of area
         END   ,                       OF Strings need out area
         ELSE  'MVC PAROLEN,=A(4)'     Numbers need only 4 bytes
         MEMGET L:PAROLEN,TYPE=GLOBAL
         LR    RK,RVR
         ST    RK,PAROHLOC             Save contig memory addr
         EJECT ,
*--------------
*  Call parameter routines
*--------------
         PSET  @PARMDO
         PMOV  @PARILOC,PARIHLOC
         PMOV  @PARILEN,PARILEN
         PMOV  @PAROLOC,PAROHLOC
         PMOV  @PAROLEN,PAROLEN
         VCALL PARMDO
         NI    SIEPSW+2,X'CF'          Set CC to match that of return
         LTR   RVR,RVR                 |
         IPM   RS                      |
         N     RS,=X'30000000'         | mask off all but CC
         SRL   RS,24                   | put in lower byte
         EX    RS,'OI SIEPSW+2,0'      | set CC
*
         IF    (RVR,ZERO),BEGIN        Data to set
         IF    (PARMFSTR,OR,PARMFYN),BEGIN      Move string data
*
*  Move string data to guest
*
         L     RX,PAROLOC              Guest VA
         L     RJ,PAROHLOC             Host VA
         L     RS,@PAROLEN             Length returned
         L     RA,PARR1                |   set new length in
         ST    RS,@RA+4                |    r1+1
         LOOP  BEGIN                   Copy across page bndrys
         PSET  GVAPARM                 Get Host VA of guest area
         ST    RY,GVACPUB              |
         ST    RX,GVAVLOC              |
         ACALL GVA                     |
         L     RA,GVAMLOC              |
         LR    RK,RA                   Length on this page
         AL    RK,=A(4096)             |
         N     RK,=X'7FFFF000'         |
         SR    RK,RA                   |
         CEIL  RK,RS                   | not more than total
         ALR   RX,RK                   Next guest VA
         SR    RS,RK                   Remaining length
         LR    RB,RK
*
*
         REGCH (RA,R2)
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  get into key zero
         LR    EPAR,RA                 Save key
         L     RA,GVAMLOC              Target address - GUEST
         MVCL  RA,RJ
         LR    RA,EPAR
         MODESET KEYADDR=(2)
*
         UNTIL (RS,ZERO),END           OF Copy across page bndrys
         END   ,                       OF Move string data
         ELSE  BEGIN                   Data will fit in register
         L     RA,PARR1                Put it in r1
         L     RB,PAROHLOC              source
         MVC   @RA(4),@RB
         END   ,                       OF Data will fit in register
         END   ,                       OF Data to set
*
*  Release buffers
*
         MEMFREE A=L:PAROHLOC,L:PAROLEN,TYPE=GLOBAL
         END   ,                       OF Input buffer allocated
         MEMFREE A=L:PARIHLOC,L:PARILEN,TYPE=GLOBAL
         PEND  ,
         EJECT
*******************************************************************
*
*   DTMXREAL - This is the DIAGNOSE "MAXREAL" service routine.
*
*              On return:
*
*              r1   contains the maximum number of frames which
*                     the Guest paging routines should long term
*                     fix.
*              r1+1 contains the minimum number of frames
*
*
*      Input - INTERP dsect
*
*     Output - none
*
*
*******************************************************************
         SPACE 2
DTMXREAL PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
         L     RX,CPGSTCT              Get the GSTCT pointer
         WITH  (GSTCT,RX)
*
*  Compute maximum real memory value
*
         L     RK,CVTPTR               CVT
         WITH  (CVT,RK),'L  RB,CVTRCEP'   RCE pointer
         WITH  (RCE,RB),'L  RB,RCEPOOL'   Online and available
         L     RA,GSTCRMOV             Minus OS overhead
         SRL   RA,12                    in frames
         SLR   RB,RA                     leaves amount do divy up
         M     RA,GSTCRMPC             Our share
         D     RA,=A(100)               is in RB
         FLOOR RB,=Y(MINMEG*256)         with a minimum
         L     RA,GSTCCLEN             Total virtual memory
         SRL   RA,12                   Convert to frames
         CEIL  RB,RA                   Most we can use
*-
*-       Return maximum allowable frames in "r1".
*-
         LH    RS,SIEINST
         SRL   RS,4                Move r1 field to low order
         N     RS,=X'0000000F'     Isolate the r1 field
         LR    R15,RS              Copy
         LREGA RS,(RS)             Get the Address of the Reg
         ST    RB,@RS              Put the value in r1
*
         LA    RS,@R15+1           Calc r1+1
         IF    (RS,GT,15),'CLEAR RS'  Wrap to R0
         LREGA RS,(RS)             Get the address of the reg
         L     RA,GSTCMINL         Minimum allowable size
         SRL   RA,12               Convert to frames
         CEIL  RA,RB               Min can't be more than max
         IF    (RA,Z),'LR RA,RB; SRL RA,2'  Default min = 1/4 max
         ST    RA,@RS              Put the value in r1+1
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   DTMXCPU  - This is a DIAGNOSE service routine.  On return     *
*              r1 contains the maximum number of virtual CPUs     *
*              which should curently be active.                   *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTMXCPU  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
         L     RX,CPGSTCT              Get the GSTCT pointer
         WITH  (GSTCT,RX)
*
*  Get current number of CPU's online
*
         LCALL MAXCPUS
         CEIL  RVR,GSTCNCPU            Maximum CPUs allowed
*
*  Return active CPU value
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         ST    RVR,@RS                 Put the value in r1
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   MAXCPUS  - Routine to determine the maximum number of         *
*              virtual CPUs that should currently be active.      *
*                                                                 *
*                                                                 *
*      Input - none                                               *
*                                                                 *
*     Output - RVR contains number of CPUs                        *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
MAXCPUS  PROC  ,SCOPE=LOCAL
*
*  Get current number of CPU's online
*
         LA    RB,8                Assume maximum of 8 cpus
*
*NCPUs   L     RA,CVTPTR               CVT
*NCPUs   WITH  (CVT,RA),'L  RA,CVTCSD'   CSD Pointer
*NCPUs   WITH  (CSD,RA),'LH  RB,CSDCPUOL'   Number of online CPU's
*
         LR    RVR,RB                  Return value
         PEND
         EJECT
*******************************************************************
*                                                                 *
*       SNAPPARM - ORVSNAP parameter area                         *
*                                                                 *
*******************************************************************
         SPACE
SNAPPARM RECORD BEGIN
SNPFLAG  FLAG  ,
         FLAG  SNPFMSG                 PRINT TEXT
         FLAG  SNPFREGS                PRINT REGS
         FLAG  SNPFADDR                DUMP STORAGE
         FLAG  SNPFSCON                DUMP STORAGE - S TYPE
         FLAG  SNPFWTO                 WRITE TO CONSOLE
         FLAG  SNPFWTL                 WRITE TO SYSLOG
*
SNPCNT   DS    X                       LENGTH OR NUMBER OF REGS
SNPADDR  DS    AL4                     ADDRESS
SNPSCON  EQU   SNPADDR+2,2,C'H'
SNPREGS  EQU   SNPADDR+2,2,C'H'
         END
         SPACE 3
*******************************************************************
*                                                                 *
*       SNAPSEG - ORVSNAP SEG work area                           *
*                                                                 *
*******************************************************************
         SPACE
SNAPSEG  RECORD BEGIN
SNSEGCB  DS    XL(L'SEGCBD)            Seg control block
SNAPBUFF DS    CL110                   Buffer
         END
         SPACE 3
*******************************************************************
*                                                                 *
*       SNAPWORK - ORVSNAP work area                              *
*                                                                 *
*******************************************************************
         SPACE
SNAPWORK RECORD BEGIN
SNWPARM  DS    XL(L'SNAPPARM)
SNWSCB   DS    A                       SEGCB location
SNWBUFF  DS    A                       Local data buffer
SNWIA    DS    A                       Instruct addr of snap request
SNWGVA   DS    A                       Guest virtual address
SNWREG   DS    A                       Register number work area
SNWADDRS DS    2D                      Address/length pairs
         END
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   DTSNAP  - This is a DIAGNOSE service routine.  It displays    *
*             registers or memory in the same manner as the       *
*             QSNAP SVC.                                          *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTSNAP   PROC  INTERP,SNAPWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
         WITH  (SNAPPARM,SNWPARM)
         CLEAR SNAPWORK
*
*  First set pointers to parameters
*
         L     RJ,SIEPSW+4             PSW Instruction address
         N     RJ,=X'7FFFFFFF'
         ST    RJ,SNWIA                Save location
         LA    RA,SNAPPARM             Work area address
         LA    RB,L'SNAPPARM            and length
*
*  Check user area - page by page
*
         LOOP  BEGIN
         LR    RK,RJ
         AL    RK,=A(4096)             Calculate
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC              Starting location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTSNAP
         END   ,
*
*  Copy parameters into work area
*
         L     R14,GVAMLOC             MVS virtual address
         LR    R15,RK                  Length this page
         MVCL  RA,R14                  Move this portion
         IF    (RB,NP),EXIT
         AR    RJ,RK                   To next location
         END   ,
*
*  Request is for a memory area or a message - we must now check
*      that area too
*
         IF    SNPFADDR+SNPFSCON+SNPFMSG,BEGIN
*
*  First translate base-displacement
*
         IF    SNPFSCON+SNPFMSG,BEGIN
         LH    RS,SNPSCON              Base register
         SRL   RS,12                   Move reg field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RJ,@RS                  Get the value in rj
         LH    RS,SNPSCON              Base - displacement
         N     RS,=X'00000FFF'         Isolate displacement
         ALR   RJ,RS                   Address of area or message
         END   ,
         ELSE  'ICM  RJ,B"1111",SNPADDR'     Otherwise get address
         LA    RJ,@RJ
         ST    RJ,SNWGVA               Guest virtual
*
*  Check data area - page by page
*
         LC    RB,SNPCNT               User supplied length
         CLEAR RA                      CLEAR INDEX
         LOOP  BEGIN
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate data area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTSNAP
         END   ,
*
*  Update location and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,SNWADDRS(RA)         Save location
         ST    RK,SNWADDRS+4(RA)        and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,
*
*  Mark end of list
*
         LA    RA,SNWADDRS(RA)         List pointer
         SET   @RA.X'80'                Mark end
*
*  Get a buffer for the data
*
         MEMGET 256,TYPE=(LOCAL,BELOW16M)
         ST    RVR,SNWBUFF             Save pointer
*
*  Move the user supplied data
*
         L     RA,SNWBUFF              Local buffer
         LA    RS,SNWADDRS             Address/length words
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END   ,
         END   ,
*
*  Update PSW address
*
         LA    RA,L'SNAPPARM           Length of parameters
         AL    RA,SIEPSW+4             Old PSW Instruction address
         ST    RA,SIEPSW+4             New PSW Instruction address
*
*  Create SEG work area
*
         MEMGET  L'SNAPSEG             Get SEG and buffer areas
         ST    RVR,SNWSCB
         LR    RX,RVR
         WITH  (SNAPSEG,RX)
         WITH  (SEGCBD,SNSEGCB)
         SEGINIT SNAPBUFF,,LA:SNSEGCB,RTN=SNAPOUT
         LA    RS,SNWPARM              Snap parms
         ST    RS,SEGUSER               for output routine
         SEG   'Orvsnap at '
         SEGHEX SNWIA ,4,SNAPSEG
         SEG   ':'
         SEGEOR ,
*
*  Process register requests
*
         IF    SNPFREGS,BEGIN
         L     RA,=X'00008000'         Bit mask
         CLEAR RB                      Register number
         CLEAR RJ                      Counter
         WHILE (RB,LT,16),BEGIN
         LCM   R15,B'0011',SNPREGS     Register mask
*
*  Format a register
*
         IF    ('NR  R15,RA',NZ),BEGIN    Wants this one
         SEG   'R'
         BTD   (RB),SNWREG,2           Convert register number
         OI    SNWREG,C'0'              Force leading zero
         SEG   SNWREG,2                  and then seg it
         SEG   ' = '
         LREGA RS,(RB)                 Address of register contents
         SEGHEX @RS,4                   seg that
         SEG   '  '
         INCR  RJ                      Number formatted
*
*  Four registers have been displayed, signal end of line
*
         IF    (RJ,EQ,4),BEGIN
         SEGEOR ,
         CLEAR RJ
         END   ,
         END   ,
         SRL   RA,1                    Update bit mask
         INCR  RB                      Update register number
         END   ,
         IF    (RJ,NZ),'SEGEOR'        Force out last buffer
         END   ,
*
*  Process memory requests
*
         ELSEIF SNPFADDR+SNPFSCON,BEGIN
         L     RS,SNWGVA               Compute offset
         LCR   RS,RS
         L     R15,SNWBUFF
         AR    RS,R15
         SEGCORE L:SNWBUFF,LC:SNPCNT,OFFSET=(RS)
         END   ,
*
*  Process message requests
*
         ELSEIF SNPFMSG,BEGIN
         SEG   L:SNWBUFF,LC:SNPCNT
         SEGEOR ,
         END   ,
*
*  Free work areas
*
         MEMFREE L'SNAPSEG,A=SNWSCB    Free SEG and buffer areas
         L     RS,SNWBUFF              User data buffer
         IF    (RS,NZ),BEGIN
         MEMFREE 256,A=(RS),TYPE=(LOCAL,BELOW16M)
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SNAPOUT - This is the output routine for the SNAP service.    *
*                                                                 *
*                                                                 *
*      Input - @SEGRTN                                            *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
SNAPOUT  PROC  @SEGRTN,SCOPE=LOCAL
         L     RY,@SEGRCB              Seg control block address
         WITH  (SEGCBD,RY)
         IF    SEGFINIT,EXIT           No initialization needed
         L     RA,SEGUSER              Snap parms
         WITH  (SNAPPARM,RA)
         PSET  @DOWTO
         MVC   @DWTLOC,SEGADD          Message location
         MVC   @DWTLEN+2(2),SEGCNT      and length
         IF    SNPFWTL,'SET  @DWTFSYS'   To system log
         IF    SNPFWTO,'SET  @DWTFCON'   To console
         LCALL DOWTO                   Go do it
         CLEAR SEGCNT,SEGMCNT,SEGRCNT
         SEG   '  ',,(RY)              Force indent
         PEND
         EJECT
*******************************************************************
*                                                                 *
*       WTOWORK -- WTO routine work area                          *
*                                                                 *
*******************************************************************
         SPACE
WTOWORK  RECORD BEGIN
WTOADDRS DS    2D                      Address/length pairs
WTOULBF  DS    A                       Local buffer
WTOULEN  DS    A                       Total length of user data
WTOUPRM  DS    A                       Message parameters
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DTWTO  - This is a DIAGNOSE service routine.  It writes a     *
*            message to the MVS console operator.  On entry r1    *
*            contains the guest virtual address of the message    *
*            area, r1+1 contains the length of the message and    *
*            r2 contains control information as follows:          *
*                                                                 *
*                Bits 0-28   Reserved                             *
*                Bit    29   Message should be non-deletable      *
*                Bit    30   Write message to console             *
*                Bit    31   Write message to system log          *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTWTO    PROC  INTERP,WTOWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
*  Get the message address
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LR    R15,RS                  Copy
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RJ,@RS                  Get message address
         EJECT
*
*  Get the message length
*
         LR    RS,R15                  r1 field
         INCR  RS                      r1+1
         IF    (RS,GT,15),'CLEAR RS'   Wrap to R0
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RB,@RS                  Get length
         CEIL  RB,@DWTLMAX              snip it
         ST    RB,WTOULEN                and save
*
*  Get the message parameters
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the Address of the Reg
         MVC   WTOUPRM,@RS             Get the parameters
*
*  Check user area - page by page
*
         CLEAR RA
         LOOP  BEGIN
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTWTO
         END   ,
*
*  Update location and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,WTOADDRS(RA)         Save location
         ST    RK,WTOADDRS+4(RA)        and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,
*
*  Mark end of list
*
         LA    RA,WTOADDRS(RA)         List pointer
         SET   @RA.X'80'                Mark end
*
*  Get a buffer for the message
*
         L     RS,WTOULEN              User data length
         MEMGET  @RS,TYPE=(LOCAL,BELOW16M)
         LR    RJ,RVR
*
*  Move the user supplied portion
*
         LR    RA,RJ                   Buffer area
         LA    RS,WTOADDRS
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END
*
*  Write the message
*
         PSET  @DOWTO
         ST    RJ,@DWTLOC              Message location
         MVC   @DWTLEN,WTOULEN          and length
         IF    WTOUPRM+3.X'01','SET  @DWTFSYS'   To system log
         IF    WTOUPRM+3.X'02','SET  @DWTFCON'   To console
         IF    WTOUPRM+3.X'04','SET  @DWTFND'    Non-deletable
         LCALL DOWTO                   Go do it
*
*  Provide the WTO return code in r2
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the Address of the Reg
         ST    RVR,@RS                 Return code set
*
*  Release the buffer
*
         L     RS,WTOULEN              User data length
         MEMFREE @RS,A=(RJ),TYPE=(LOCAL,BELOW16M)
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DWTOWORK - DOWTO Work area                                   *
*                                                                 *
*******************************************************************
         SPACE
DWTOWORK RECORD BEGIN
DWTBUF   DS    A                       Work buffer
DWTSIZ   DS    A                       Work buffer size
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DOWTO - This is routine processes WTO requests and sends      *
*           messages to the designated place                      *
*                                                                 *
*                                                                 *
*      Input - @DOWTO                                             *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DOWTO    PROC  @DOWTO,DWTOWORK,SCOPE=LOCAL
*
*  First get a work buffer
*
         L     RS,@DWTLEN              Message length
         IF    (RS,Z),EXIT             Too short
         CEIL  RS,@DWTLMAX
         STMAX RS,@DWTLEN
   LA    RS,@RS+(WPLTXT-WPL+32+L'WPLROUT)
*         LA    RS,@RS+(WPLTXT-WPL+L'WPLFLGS+L'WPLROUT)  Overhead
*         LA    RS,@RS+(WPLTXT-WPL
         ST    RS,DWTSIZ               Buffer size
         MEMGET (RS),TYPE=BELOW16M
         ST    RVR,DWTBUF              Local buffer
         LR    RJ,RVR
         WITH  (WPL,RJ)
*
*  Move message to work buffer
*
         L     R14,@DWTLOC             Message location
         L     R15,@DWTLEN              and length
         LA    RA,WPLTXT               Message area
         LR    RB,R15
         MVCL  RA,R14
*
*  Set message length
*
         L     RS,@DWTLEN              Message length
         LA    RS,@RS+L'WPLLGH+L'WPLMCSF  plus length and flag field
         STH   RS,WPLLGH
*
*  Set MCS info for console messages
*
         WITH  (WPLFLGS,RA),LABEL=MSGEND
         SET   WPLMCSF.WPLMCSFA        Route/Descriptor codes added
*
*  Write message to Jes job log and system log only
*
         IF    (@DWTFCON,Z),BEGIN
         SET   MSGEND:WPLDESC1.WPLDESCG       Job status
         IF    (@DWTFSYS,Z),'SET  WPLMCSF2.WPLMCSFN'
         END   ,
*
*  Console message is non-deletable
*
         ELSEIF  @DWTFND,BEGIN
         SET   MSGEND:WPLDESC1.WPLDESCB       Immediate action
         SET   MSGEND:WPLROUT1.WPLROUTA+WPLROUTH   Master & Tp cons
         END
*
*  Standard informational console message
*
         ELSE  BEGIN
         SET   MSGEND:WPLDESC1.WPLDESCD       System status
         SET   MSGEND:WPLROUT1.WPLROUTB+WPLROUTH   Master & Tp cons
         END
*
*  Issue SVC
*
         WTO   ,MF=(E,WPL)
         LR    RA,R1                   Message Id
*
*  Release the Buffer
*
         MEMFREE L:DWTSIZ,A=DWTBUF,TYPE=BELOW16M
         LR    RVR,RA                  Return code
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   DTDOM  - This is a DIAGNOSE service routine.  It deletes a    *
*            previously issued console operator meesage.  On      *
*            entry r1 contains the message id returned by the     *
*            WTO routine.                                         *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTDOM    PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
*  GET THE MESSAGE ID
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RS,@RS                  Get message id number
*
*  Issue the DOM
*
         DOM   MSG=(1)
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   DTCPUTM - This is a DIAGNOSE service routine.  It returns     *
*             the accumulated CPU time value for host services    *
*             in the 8 byte doubleword aligned area pointed to    *
*             by the address in r1.                               *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTCPUTM  PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
*  Get the answer area address
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RA,@RS                  Answer area address (virtual)
*
*  Make sure answer area on one page
*
         LA    RS,=X'FFF'
         NR    RS,RA
         LA    RS,@RS+8
         IF    (RS,GT,4096),BEGIN
         PIINT CODE=6,ILEN=4           Address not on double word
         EXIT  DTCPUTM
         END
*
*  Validate the user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RA,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTCPUTM
         END   ,
*
*  Area may not be written - cause protection error
*
         IF    (RVR,NZ),BEGIN          Not valid location
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4
         EXIT  DTCPUTM
         END   ,
*
*  Address ok, return time
*
         L     RS,GVAMLOC              MVS address area
         MVC   @RS(8),CPCPUTM          Copy in CPU time
         PEND
         EJECT
*box
*
*   DTCPUINF - This is a DIAGNOSE service routine.  It returns
*             the general CPU information in the 8 byte
*             doubleword aligned area pointed to by the address
*             in r1.
*
*      Input - INTERP dsect
*
*     Output - none
*
DTCPUINF PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB          Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
         L     RX,CPGSTCT          Get GSTCT ptr
         WITH  (GSTCT,RX)
*-
*-       Build CPU information word and in RA.
*-
         L     RA,GSTCNCPU         Currently it's just no. of cpus
*-
*-       Now put it back into the caller's resume register "r1".
*-
         LH    RS,SIEINST
         SRL   RS,4                Move r1 field to low order
         N     RS,=X'0000000F'     Isolate the r1 field
         LR    R15,RS              Copy
         LREGA RS,(RS)             Get the Address of the Reg
         ST    RA,@RS              Put the value in r1
         PEND
*box
*
*   DTQSERV - This is a DIAGNOSE service routine.  It issues a
*             QSERV SVC with information provided by the user.
*
*             *** Not yet implemented ***
*
*      Input - INTERP dsect
*
*     Output - none
*
DTQSERV  PROC  INTERP,SCOPE=LOCAL
         ABEND 1200,DUMP           Not yet
         PEND
         EJECT
*******************************************************************
*     DTDPALLO -This is a DIAGNOSE service routine.  It calls the *
*                I/O service routine to allocate a SNAPDUMP       *
*                sysout data set.  It returns to the guest with   *
*                r1 containing a token representing the opened    *
*                dump data set.  This token must be presented for *
*                all subsequent requests for this particular data *
*                set.                                             *
*                                                                 *
*                                                                 *
*      Input - none                                               *
*                                                                 *
*     Output - r1 contains token for dump data set created by     *
*              this service routine.                              *
*                                                                 *
*******************************************************************
         SPACE 2
DTDPALLO PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
*  Go allocate and open a SNAP DUMP data set
*
         PSET  @SNDPPRM
         VCALL SNDPALLO
         NI    SIEPSW+2,X'CF'          Set CC 0
         IF (RVR,Z),BEGIN              If SNDPALLO RC was good
*
*  Return token in r1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         MVC   @RS(4),@SNDTOKN         Put the value in r1
         END   ,                       OF If SNDPALLO RC was good
         ELSE 'OI SIEPSW+2,X"10"'
         PEND
         EJECT
*******************************************************************
*                                                                 *
*       DPWWORK -- MVS memory write work area                     *
*                                                                 *
*******************************************************************
         SPACE
DPWWORK  RECORD BEGIN
DPWADDR  DS    A                       MVS BUFFER AREA
DPTOKEN  DS    A                       SNAP DUMP DATA SET TOKEN
DPWUADR  DS    A                       USER VIRTUAL ADDRESS
DPWLEN   DS    A                       TOTAL LENGTH
DPWLOCS  DS    2D                      USER REAL ADDRESSES
         END   ,
         SPACE 3
@SNDPPRM RECORD BEGIN
@SNDADDR DS    A                       SNAP DUMP LINE TO WRITE
@SNDLEN  DS    A                       SNAP DUMP LINE LENGTH
@SNDTOKN DS    A                       SNAP DUMP DATA SET ID
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DTDPWRIT - This is a DIAGNOSE service routine.  It moves a    *
*             line of ORVYL guest snap dump output to the host    *
*             for MVS to pass to the JES writer.                  *
*                                                                 *
*             On entry r1 is an even-odd register pair while r2   *
*             is a register containing the following values:      *
*                                                                 *
*                 r1    Orvyl guest virtual address               *
*                 r1+1  Length of the area                        *
*                 r2    Token from prior call to DTJSALLO         *
*                                                                 *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTDPWRIT PROC  INTERP,DPWWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter registers r1 and r1+1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         IF    ('EX RS,"TM  =X'01',0"',NZ),BEGIN See if even reg
         PIINT CODE=6,ILEN=4           Register not even
         EXIT  DTDPWRIT
         END   ,                       OF See if even reg
         LREGA RS,(RS)                 Get the address of the reg
         LM    R14,R15,@RS             r1 and r1+1
         STM   R14,R15,DPWUADR         Caller's address and length
*
*  Validate user supplied length
*
         IF    ((R15,NP),OR,(R15,GT,235)),BEGIN See if length OK
         PIINT CODE=6,ILEN=4           Length is not valid
         EXIT  DTDPWRIT
         END   ,                       OF See if length OK
*
*  Get parameter register r2
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the address of the reg
         L     R14,@RS                 r2
         ST    R14,DPTOKEN             MVS address
*
*  Check user area - page by page
*
         L     RJ,DPWUADR              Get user address
         L     RB,DPWLEN                and length
         CLEAR RA                      Clear index
         LOOP  BEGIN                   Test one page at a time
         L     RK,=A(4096)             Calculate
         ALR   RK,RJ
         N     RK,=X'7FFFF000'          Length on
         SR    RK,RJ                     this page
         CEIL  RK,RB                   Not more than total
*
*  Validate user area
*
         PSET  GVAPARM
         ST    RY,GVACPUB              Set the CPUB pointer
         ST    RJ,GVAVLOC               Location
         ACALL GVA
*
*  Area not in memory - cause a page fault
*
         IF    (RVR,GT,4),BEGIN        Not currently in memory
         PIINT CODE=(RVR),EXA=GVAVLOC,ILEN=4,BACK=YES
         EXIT  DTDPWRIT
         END   ,                       OF Not currently in memory
*
*  Save real locations and lengths
*
         L     RS,GVAMLOC              Get MVS virtual address
         ST    RS,DPWLOCS(RA)          Save location
         ST    RK,DPWLOCS+4(RA)         and length
         AR    RJ,RK                   To next location
         SR    RB,RK                    reduce length remaining
         IF    (RB,NP),EXIT            All done
         LA    RA,@RA+8                Reset index
         END   ,                       OF Test one page at a time
*
*  Mark end of list
*
         LA    RA,DPWLOCS(RA)          List pointer
         SET   @RA.X'80'                Mark end
*
*  Get a buffer for the data
*
         L     RK,DPWLEN               User data length
         MEMGET  @RK,TYPE=(LOCAL,BELOW16M)
         LR    RJ,RVR
*
*  Move the user data to the buffer
*
         LR    RA,RJ
         LA    RS,DPWLOCS
         LOOP  BEGIN
         LM    R14,R15,@RS
         LR    RB,R15                  Length of this portion
         MVCL  RA,R14                  Move this portion
         IF    @RS.X'80',EXIT          End of list
         LA    RS,@RS+8                Next entry
         END   ,
         ST    RJ,DPWADDR              MVS address
         PSET  @SNDPPRM                Setup for VCALL
         ST    RJ,@SNDADDR
         MVC   @SNDLEN,DPWLEN
         MVC   @SNDTOKN,DPTOKEN
         VCALL SNDPWRT                 Call Write routine
*  Release the buffer
*
         NI    SIEPSW+2,X'CF'          Set CC 0
         IF    (RVR,NZ),'OI SIEPSW+2,X"1"'  set CC to 1
         L     RA,DPWADDR             MVS address
         L     RS,DPWLEN               User data length
         MEMFREE @RS,A=(RJ),TYPE=(LOCAL,BELOW16M)
         PEND  ,
         EJECT
*******************************************************************
*    DTDPCLOS - This is a DIAGNOSE service routine.  It calls the *
*                I/O service routine to close and deallocate a    *
*                snap dump sysout data set.                       *
*                                                                 *
*                                                                 *
*      Input - r1 must contain the token for the dump data set to *
*              be closed.                                         *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
DTDPCLOS PROC  INTERP,DPWWORK,SCOPE=LOCAL
         L     RY,INTCPUB              Get the cpub address
         WITH  (CPUB,RY)
*
*  Get parameter register r1
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the address of the reg
         L     R14,@RS                 r1
         PSET  @SNDPPRM                Setup for call
         ST    R14,@SNDTOKN            Pass the token
         VCALL SNDPCLS                 Call close routine
         NI    SIEPSW+2,X'CF'          Set CC 0
         IF    (RVR,NZ),'OI SIEPSW+2,X"1"'  set CC to 1
         PEND  ,
         LTORG ,
         EJECT
*******************************************************************
*    DTERMCOM - This is a DIAGNOSE service routine. It signals    *
*                the termination process that guest termination   *
*                routines have been completed.                    *
*                                                                 *
*     Input  - none                                               *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
DTERMCOM PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Get the CPUB address
         WITH  (CPUB,RY)
         L     RX,CPGSTCT              Point to the GSTCT
         WITH  (GSTCT,RX)
         FPOST LA:GSTCTECB             Post termination done
         PEND  ,
         EJECT
*******************************************************************
*                                                                 *
*   DTNOTDMP  - This is a DIAGNOSE service routine.  It adds a    *
*               range of address to not include in a guest dump   *
*               to a table of ranges.                             *
*                                                                 *
*      Input - INTERP dsect                                       *
*                                                                 *
*     Output - None                                               *
*                                                                 *
*******************************************************************
         SPACE 2
DTNOTDMP PROC  INTERP,SCOPE=LOCAL
         L     RY,INTCPUB              Parm is the CPUB pointer
         WITH  (CPUB,RY)
*
*  Get the first address
*
         LH    RS,SIEINST
         SRL   RS,4                    Move r1 field to low order
         N     RS,=X'0000000F'         Isolate the r1 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RA,@RS                  Get first address
         L     RB,=A(16*1024*1024)     Only do Global system High
         IF    (RA,LT,RB),EXIT
*
*  Get the length
*
         LH    RS,SIEINST
         N     RS,=X'0000000F'         Isolate the r2 field
         LREGA RS,(RS)                 Get the Address of the Reg
         L     RB,@RS                  Get length
*
*  Remove partial pages on both ends of range
*
         AR    RB,RA                   Point to end of not dump
         LA    RA,4095(RA)
         N     RA,=X'7FFFF000'         No partial pages
         N     RB,=X'7FFFF000'         No partial pages
         S     RB,=X'00001000'         Back up to last page to not dump
         IF    (RB,LT,RA),EXIT         No complete pages to not dump
*
*  Update the not dump table
*
         L     RX,CPGSTCT              GSTCT
         WITH  (GSTCT,RX)
         L     R14,GSTCNOTC
         IF    (R14,GE,=A(GSTCNOTM)),EXIT No more room for entries
         LA    R15,@R14+1
         ST    R15,GSTCNOTC            Update count
         MH    R14,=Y(L'GSTCNOTI)      Calc disp to next item
         ST    RA,GSTCNOTF(R14)        Save first page
         ST    RB,GSTCNOTL(R14)        Save last page
         PEND  ,
         EJECT
*******************************************************************
*   SETCLOCK - This routine will reset the local time offset for  *
*              all guest CPUs.                                    *
*                                                                 *
*     Input  - none                                               *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
SETCLOCK PROC  @FUNCPRM,SCOPE=GLOBAL
         L     RX,@FUNCDTA         Get the RUCT Address
         WITH  (GSTCT,RX)
         L     RY,GSTCNCPU         Number of CPUs
         LOOP  BEGIN
         IF    ('LT R0,GSTCCPUS',Z),EXIT
         ACALL SETCLOC2
         LA    RX,GSTCT+L'GSTCCPUS Increment to next CPU
         UNTIL (BCT,RY),END        For all CPUs
         PEND ,
*******************************************************************
*    SETCLOC2 - This routine will periotically set the guest      *
*                local time offset.                               *
*                                                                 *
*     Input  - R0 contains CPUB pointer                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*******************************************************************
         SPACE 2
SETCLOC2 PROC  SCOPE=LOCAL
         LR    RY,R0
         WITH  (CPUB,RY)
         L     RX,CVTPTR
         WITH  (CVT,RX),'L RX,CVTEXT2'
         WITH  (CVTXTNT2,RX)
         LM    RM,RN,CVTLDTO
         SDL   RM,CVTLSO
         L     RJ,CPPSALOC
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         WITH  (PZERO,RJ)
         STM   RM,RN,PZTZOFF       Set local time offset
         MODESET KEYADDR=(2)
         PEND  ,
         EJECT
*******************************************************************
*                                                                 *
*    AM24PARM - AMODE 24 Cap routine request parameters           *
*                                                                 *
*******************************************************************
         SPACE
@AM24    RECORD BEGIN
@AM24SVA DS    18A                     Save area
@AM24PRM DS    3A                      Parameters for MVS service
@AM24R15 EQU   @AM24PRM,4,C'A'         Parameter register 15
@AM24R0  EQU   @AM24PRM+4,4,C'A'       Parameter register 0
@AM24R1  EQU   @AM24PRM+8,4,C'A'       Parameter register 1
@AM24CRS DS    16A                     Caller's registers
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   AM24CAP - Cap routine for MVS I/O services which must be      *
*             entered in AMODE 24.                                *
*                                                                 *
*     Input - @AM24 in R1                                         *
*                                                                 *
*    Output - As defined by MVS service                           *
*                                                                 *
*******************************************************************
         SPACE 3
AM24CAP  LABEL ,
         USING @AM24,R1
         STM   R2,R14,@AM24CRS         Save caller's registers
         LR    R13,R1                  Establish save area pointer
         LM    R15,R1,@AM24PRM         MVS service parms
         DROP  R1
         BALR  R14,R15                 Branch to MVS service
         USING @AM24,R13
         LM    R2,R14,@AM24CRS         Restore caller's registers
         DROP  R13
         BSM   0,R14                   Return to caller
         SPACE 2
AM24     EQU   AM24CAP,*-AM24CAP,C'X'   Length of capping routine
         EJECT ,
*
* LOADPARM - This data area lives below the line and has all the
*            information for the three load diagnose routines.
*
LOADPARM RECORD BEGIN
LAM24    DS    XL(L'AM24)              AM24 cap routine
         DS    0F
LAMPARM  DS    XL(L'@AM24)             AM24 parm
LOPENP   OPEN  (,),MF=L                Open parameter list
LDECB    DS    XL(L'MODDECB)           DECB for read/check
LDCB     DS    XL(L'MODDCB)            DCB
LBLDL    DS    XL(L'MODBLDL)           BLDL list
LKMOD    EQU   LBLDL+4,8,C'C'          Module name
LTTRK    EQU   LBLDL+4+8,4,C'A'        Track address of the module
LMLEN    EQU   LBLDL+4+24,3,C'A'       Total length of the module
LMEPA    EQU   LBLDL+4+29,3,C'A'       Entry point address
         DS    0D
LBUFFER  DS    8192X                   Input buffer
         END   ,
*
* PROFPARM - This data area lives below the line and has all the
*            information for the profiling function.
*
PROFPARM RECORD BEGIN
PAM24    DS    XL(L'AM24)              AM24 cap routine
         DS    0F
PAMPARM  DS    XL(L'@AM24)             AM24 parm
POPENP   OPEN  (,OUTPUT),MF=L          Open parameter list
PDCB     DS    XL(L'PROFDCB)           DCB
*
* Profile output record.
*
PROFOUT  DS    0D
PROFCPUA DS    X                       CPU address
PROFICOD DS    X                       Intercept code
PROFINST DS    H                       Intercepted instruction
PROFHIA  DS    A                       Host instruction address
PROFPSW  DS    D                       Current PSW
PROFTOD  DS    D                       TOD clock value
PROFDATA EQU   PROFOUT,*-PROFOUT,C'X'  Profile output data
         END   ,
         END   .
