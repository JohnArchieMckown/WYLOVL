FILEMAN  TITLE 'ORVYL''S File Manager'
         COPY  HEADER
FILEMAN  MODULE TRCNUM=9,ID=MA
         EJECT ,
         COPY  PZERO
         USING PZERO,R0
         EJECT ,
         COPY  MAT
         EJECT ,
         COPY  FPC
         EJECT ,
         COPY  QLISTMAC
         EJECT ,
         COPY  SLISTMAC
         EJECT ,
         COPY  LISTPARM
         EJECT ,
         COPY  LSTMAC
         EJECT ,
         COPY  FILCONST
         EJECT ,
         COPY  FILECB      File control block (one only)
         EJECT ,
         COPY  FBHDR
         EJECT ,
         COPY  FSB         File system control block (one per file sys)
         EJECT ,
         COPY  ASB         Address space control block
         EJECT ,
         COPY  NTRY
         EJECT
         COPY  FILEPARM
         EJECT ,
         COPY  FCATPARM
         EJECT ,
         COPY  LOCKPARM
         EJECT ,
         COPY  PAGEPARM
         EJECT ,
         COPY  SBPARM
         EJECT ,
         COPY  SIGPARM
         EJECT ,
         COPY  VMPARM
         EJECT ,
         COPY  ACCTPARM
         EJECT ,
         COPY  DISPPARM
         EJECT ,
         COPY  GRPARM
         EJECT ,
         COPY  XITPARM
         EJECT ,
         COPY  IXR
         EJECT ,
         COPY  HASHPARM
         EJECT ,
         COPY  ATFB
         EJECT ,
*
* User File Block (address space)
*
ASFB    RECORD BEGIN
ASFBID   DC    CL4'ASFB'           Block id
         DS    F                   Spare

ASFBFW   SHEAD ,                   Free RQWB chain
ASFBFQ   SHEAD ,                   Free RQFB chain
ASFBRQ   LHEAD PFX=ASFBRQ          Inuse RQFB chain

ASFBSAGR DS    CL2                 Group
ASFBSADO DS    CL1                 Dot
ASFBSAUS DS    CL3                 User
ASFBSACC EQU   ASFBSAGR,*-ASFBSAGR,C'C' Signed on account

ASFBPAGR DS    CL2                 Group
ASFBPAD1 DS    CL1                 Dot
ASFBPAUS DS    CL3                 User
ASFBPACC EQU   ASFBPAGR,*-ASFBPAGR,C'C' Pseudo account
         END   ,
         EJECT ,
         KWREC FLAGS
         EJECT ,
*
* File Request Work Block - this block lasts from SVC through wait
*
RQWB    RECORD BEGIN

RQWBID   DC    CL4'RQWB'           Block id


* Attach area - fields that are maintained from the attach of a file
* through the detach of the file.
RQATT    DS    0A
RQAPERM  DS    X                   File access permits

* These file flags are from the catalog
RQCODE   FLAG  ,                   File flags
         FLAG  (RQCCLP,NTFCLP)     Only CLP can attach this file
         FLAG  (RQCSFORM,NTFSFORM) User info is format data
         FLAG  (RQCNOCLP,NTFNOCLP) CLP can't change this file
         FLAG  (RQCNIXR,NTFNIXR)   Non-IXR file
         FLAG  (RQCSPI,NTFSPI)     Only Spires can attach this file
* A hybrid file is a non-IXR file where all the records in the array
* are IXRs (not user records as in regular non-IXR files). When the
* hybrid flag is on, the non-IXR flag is also on.
         FLAG  (RQCHYBR,NTFHYBR)   Hybrid file

RQAFLG   FLAG  ,                   Attach modes
         FLAG  RQADONE             Attach complete
         FLAG  RQATMP              Temp file
         FLAG  RQASHR              Attached in share mode
         FLAG  RQACLP              CLP attached
         FLAG  RQASPI              Spires attached
         FLAG  RQAHALT             File halt processing
         FLAG  RQADET              File detach processing

RQAFLG2  FLAG  ,                   Attach modes
         FLAG  RQAOWN              Attached by file owner
         FLAG  RQAMAG              Attached by file sys owner or master
         FLAG  RQARES              File is reserved by this guy
         FLAG  RQASTAT             Status SVC
         FLAG  RQAS117             Status 117 in progress

* Note: the following field may be from the signed-on user or
*       the pseudo user set by status 107.
RQFACC   DS    CL6                 File access account

         DS    XL2                 Spare

RQAGRH   DS    A                   Attach general resource id
RQRGRH   DS    A                   Reserve general resrource id
RQATFB   DS    A                   File attach block

RQATTF   EQU   RQATT,*-RQATT,C'C'

* Request area - fields initialized and used from IO reqest
* through return from wait.

RQTYPE   FLAG  ,                   Request type
         FLAG  (RQATCH,4,EQ)       Attach
         FLAG  (RQREAD,8,EQ)       Read
         FLAG  (RQWRIT,12,EQ)      Write
         FLAG  (RQCONT,16,EQ)      Control
         FLAG  (RQSTAT,20,EQ)      Status
         FLAG  (RQDTCH,24,EQ)      Detach
         FLAG  (RQRSRV,28,EQ)      Reserve
         FLAG  (RQRLSE,32,EQ)      Release

RQPRIV   DS    X                   User privileges

RQIFLG   FLAG  ,                   Input flags
         FLAG  RQIF14              R14 complimented
         FLAG  RQIF15              R15 complimented
         FLAG  RQIF00              R0 complimented
         FLAG  RQIF01              R1 complimented

         FLAG  (RQNAX,RQIFLG.RQIF14)
         FLAG  (RQWAIT,RQIFLG.RQIF00)
         FLAG  (RQSHR,RQIFLG.RQIF01)
         FLAG  (RQOLD,RQIFLG.RQIF15)
         FLAG  (RQSKIP,RQIFLG.RQIF15)
         FLAG  (RQFORM,RQIFLG.RQIF01)
         FLAG  (RQSDEF,RQIFLG.RQIF15) Use space default

* This field is a combination of the user permits determined
* at attach time and the owner permits (file mask) which can
* change at any time. This field is redetermined at each SVC.
* The filemask can be changed by the file owner at any time
* and it takes effect immediately for all users with the file
* attached. All SVCs that modify the file check the masked
* version of the permits. Those that modify the catalog only
* check the unmasked version of the permits.
RQMPERM  FLAG  ,                   Masked file access permits

RQRFLG   FLAG  ,                   Request flags
         FLAG  RQRFRE              Done with this RQFB
         FLAG  RQRM31              User in 31 bit addressing mode
         FLAG  RQR1ST              First to attach

RQPKEY   DS    X                   User psw key
         DS    XL2                 Spare

RQFSB    DS    A                   FSB pointer
RQWBRQFB DS    A                   Pointer back to RQFB for dump
         DS    A                   Spare

* Input parameter registers
RQIR14   DS    A
RQIR15   DS    A
RQIR00   DS    A
RQIR01   DS    A
RQIREG   EQU   RQIR14,*-RQIR14,C'C'

* Status input
RQISTAT  EQU   RQIR00,L'RQIR00,C'C' Status type
RQISPRM  EQU   RQIR01+3,1,C'C'      Access permits
RQISUSA  EQU   RQIR15,L'RQIR15,C'C' User A
RQISUSB  EQU   RQIR14,L'RQIR14,C'C' User B
RQISLOC  EQU   RQIR01,L'RQIR01,C'C' Data location
RQISLEN  EQU   RQIR15,L'RQIR15,C'C' Data length
RQISUSE  EQU   RQIR01,L'RQIR01,C'C' User
RQISFIL  EQU   RQIR14,L'RQIR14,C'C' File name
RQISACC  EQU   RQIR01,L'RQIR01,C'C' Account
RQISPAC  EQU   RQIR15,L'RQIR15,C'C' Max space
RQISTYP  EQU   RQIR15,L'RQIR15,C'C' Request type
RQISBLK  EQU   RQIR14,L'RQIR14,C'C' Count of blocks
RQIS116  EQU   RQIR01,L'RQIR01,C'C' File sys and block count
RQIS117  EQU   RQIR01,L'RQIR01,C'C' Suspend for this many 0.1 seconds

* Control input
RQICON   EQU   RQIR01,L'RQIR01,C'C' Control type
RQICLOC  EQU   RQIR15,L'RQIR15,C'C' Buffer location
RQICLEN  EQU   RQIR14,L'RQIR14,C'C' Buffer length
RQICBLK  EQU   RQIR15,L'RQIR15,C'C' Block number
RQICBL2  EQU   RQIR14,L'RQIR14,C'C' Block number
RQICINF  EQU   RQIR15,L'RQIR15,C'C' Control info
RQICUSA  EQU   RQIR14,L'RQIR14,C'C' User

* Read/Write input
RQIBLK   EQU   RQIR14,L'RQIR14,C'C' Block number
RQILEN   EQU   RQIR15,L'RQIR15,C'C' Data length
RQIDAT   EQU   RQIR01,L'RQIR01,C'C' IO buffer address

* Attach input
RQIFILE  EQU   RQIR01,L'RQIR01,C'C' File name pointer
RQIFLEN  EQU   RQIR15,L'RQIR15,C'C' File name length

* Return parameter registers
RQRR14   DS    A
RQRR15   DS    A
RQRR00   DS    A
RQRR01   DS    A
RQRREG   EQU   RQRR14,*-RQRR14,C'C'

RQRTYPE  EQU   RQRR01,L'RQRR01,C'C' Record type and length
RQRPRIV  EQU   RQRR01,L'RQRR01,C'C' Public privileges
RQRPCNT  EQU   RQRR14,L'RQRR14,C'C' Number of users sensed
RQRFCNT  EQU   RQRR01,L'RQRR01,C'C' Count of files
RQRBLK   EQU   RQRR14,L'RQRR14,C'C' Block number
RQRLEN   EQU   RQRR01,L'RQRR01,C'C' Data length
RQRUSB   EQU   RQRR01,L'RQRR01,C'C' User written blocks
RQRBIB   EQU   RQRR14,L'RQRR14,C'C' Billable blocks
RQRS116  EQU   RQRR01,L'RQRR01,C'C' First block in range
RQRCBK   EQU   RQRR01,L'RQRR01,C'C' Block number return
RQRABK   EQU   RQRR01,L'RQRR01,C'C' Allocated blocks
RQRUBK   EQU   RQRR14,L'RQRR14,C'C' Used blocks
RQRETC   EQU   RQRR15,L'RQRR15,C'C' Return code
RQRFID   EQU   RQRR00,L'RQRR00,C'C' Return file id
RQRARO   EQU   RQRR01,L'RQRR01,C'C' ARO secondary return code
RQRFORM  EQU   RQRR01,L'RQRR01,C'C' File format field

* Imediate wait return registers, use when no IO necessary
* but wait SVC required anyway.
RQWR14   DS    A
RQWR15   DS    A
RQWR01   DS    A

RQWUSB   EQU   RQWR01,L'RQWR01,C'C' User written blocks (wait)
RQWBIB   EQU   RQWR14,L'RQWR14,C'C' Billable blocks (wait)
RQWCBK   EQU   RQWR01,L'RQWR01,C'C' Block number return (wait)
RQWRETC  EQU   RQWR15,L'RQWR15,C'C' Wait return code
RQWDSZ   EQU   RQWR01,L'RQWR01,C'C' File system data block size
RQWHFSZ  EQU   RQWR01,L'RQWR01,C'C' Max possible user recs
RQWHIXR  EQU   RQWR14,L'RQWR14,C'C' Hybrid IXR count

* This is the first block for non-IXR'd or the high level IXR
RQFBLK   DS    A                   First block number
RQBLKC   DS    A                   Count of blocks (non-XIR'd)
RQFIID   DS    A                   File id (IDT index)
RQRQID   DS    A                   Request id (IDT pointer)
RQASFB   DS    A                   Addr space file control block
RQLBLK   DS    A                   Last block number (used for write)
RQTSK    DS    A                   Task id of IO requester


RQNAME   DS    0CL44               File name
RQNORV   DS    CL4                 ORV.
RQNAMS   DS    0CL40               ORVless file name
RQNACC   DS    0CL6                Owner account
RQNGRP   DS    CL2                 Group
RQND1    DS    C                   Dot
RQNUSE   DS    CL3                 User
RQND2    DS    C                   Dot
RQNPFX   EQU   RQNAME,*-RQNAME,C'C' File name prefix
RQNAM2   DS    CL(L'RQNAME-L'RQNPFX) Rest of the file name

RQVARI   DS    0CL44               Variable fields for different SVCs
RQACCNA  DS    CL6                 Status account A
RQACCNB  DS    CL6                 Status account B
         ORG   RQVARI              Rename work area
RQWKNAME DS    CL44                Rename work name
         ORG   ,
         END   ,
*
* File Request Block - this block lasts from attach to detach
*
RQFB    RECORD BEGIN
RQFBFP   DS    A                   fwd ptr
RQFBBP   DS    A                   bwd ptr
RQFBID   DC    CL4'RQFB'           Block id
RQFBRQWB DS    A                   Pointer to the RQWB
RQFBASV  DS    CL(L'RQATTF)        Attached file save fields
         END   ,
         EJECT ,
*
*  This record is used to pass information about IXR files to a
*  system task which will delete them. It is used for regular files
*  and temp files. Temp files are all deleted at detach time.
*  The processing is slightly different in the two cases. FDELB
*  is used as a pointer to an IO buffer which contains the high
*  level IXR for regular files. This same field is used for the
*  block number of the high level IXR for temp files. This is
*  because the count of blocks needs to be obtained from the IXR
*  for regular files before it is passed off to be deleted. We are
*  also trying to avoid any file IO for temp files at detach time.
*  There are also some other minor differences in the two processes.
*
FDEL     RECORD BEGIN              Temp file delete control block
FDELFP   DS    A                   Forward pointer
FDELID   DS    C'FILD'             Block id
FDELF    DS    A                   FSB
FDELB    DS    F                   IXR or block no of file to delete
FDELC    DS    F                   Block count (non-ixr and hybrid)
FDELFLG  FLAG  ,
         FLAG  FDELFN              Non-IXR file
         FLAG  FDELFH              Hybrid file
         END   ,
         EJECT ,
         MACRO
&L       ADFCB ,                   Address the FILECB
&L       L     RY,MATPTR
         WITH  (MAT,RY),'L RY,MATFILCB'
         WITH  (FILECB,RY)
         MEND  ,

@IXRGEPU RECORD BEGIN              Interface to IXR IO routines
@IXRGFSB DS    A                   FSB address
@IXRGBNO DS    F                   IXR block number
@IXRGADR DS    A                   IXR block address
         END   ,

@CHKMEM RECORD BEGIN               Check memory protection
@CMEMLOC DS    A                   Location of the area
@CMEMLEN DS    H                   Length of the area
@CMEMKEY DS    X                   Key to use for check
@CMEMFL  FLAG  ,
         FLAG  @CMEMWRT            Check write access
         END   ,

         MACRO
&L       CHKMEM &LOC,&LEN,&TYPE
&L       PSET  @CHKMEM
         PMOV  @CMEMLOC,&LOC
         PMOV  @CMEMLEN,&LEN
         PMOV  @CMEMKEY,RQPKEY
         AIF   ('&TYPE' NE 'W').NOWRT
         SET   @CMEMWRT
.NOWRT   ANOP
         ACALL CHKMEM
         MEND

@CHKACC  RECORD BEGIN              Validate account
@CHKAFSB DS    A
@CHKACCN DS    0CL6
@CHKACCG DS    CL2                 Group
@CHKACCD DS    CL1                 Dot
@CHKACCU DS    CL3                 User
         END   ,

         MACRO
&L       CHKACC &ACC
&L       PSET  @CHKACC
         PMOV  @CHKACCN,&ACC
         ACALL CHKACC
         MVC   &ACC,@CHKACCN
         L     RB,@CHKAFSB
         LTR   RVR,RVR
         MEND  ,
         EJECT ,
FILEMAN  CSECT ,
*---------------------------------------------------------------------*
*  M1FILE - File SVC processing, set up work areas and call appropriate
*           SVC edit routine. Then create a task to do any file IO if
*           necessary.
*
*   Inputs - @M1FILE
*
*   Output -
*---------------------------------------------------------------------*
M1FILE   PROC  @M1FILE,SCOPE=GLOBAL

         WITH  (RQFB,RK)

* Set up trace table registers
         LM    R14,R1,@M1FR14      Get SVC input R14 to R1
         ICM   R2,B'1111',@M1FLAG  Get flag, user key & priv, SVC type
         CLEAR R3
         IF    ('LT RK,@M1FDVID',NZ),BEGIN
         WITH  (RQATTF,RQFBASV),'L R3,RQATFB' Attached file pointer
         END   ,
         L     R4,PZCURASB         ASB pointer
         XTRC  R14,R4,M1FILE       Save some clues

         WITH  (ASFB,RJ)
         WITH  (RQWB,RA)

         L     RS,PZCURASB
         WITH  (ASB,RS),BEGIN
         IF    (ASBASFB,Z),'ACALL FMASFINI' Build ASFB
         L     RJ,ASBASFB          Get local (AS) file block
         END   ,

         SAVAIL HEAD=ASFBFW,LEN=L'RQWB,LOC=LOCSYS Get an avail RQWB

* Note: RA is set here and remains set throughout
         LR    RA,RVR
         CLEAR RQWB
         MVC   RQWBID,=C'RQWB'
         ST    RJ,RQASFB           Set pointer back

         IF    ('LT RK,@M1FDVID',Z),BEGIN No file attached
         IF    (^@M1FATCH,AND,^@M1FSTAT),BEGIN
         LA    RVR,1               No IO
         MVC   @M1FR15,=F'-12'     Set not available
         EXIT  M1FILE              Return
         END   ,
         SAVAIL HEAD=ASFBFQ,LEN=L'RQFB,LOC=LOCSYS Get an avail RQFB
         LR    RK,RVR
         CLEAR RQFB
         MVC   RQFBID,=C'RQFB'
         LADD  ASFBRQ,LA:RQFB,WR=RS Add to the list
         IF    (^RQACLP,AND,(ASFBPACC,NZ)),BEGIN
         MVC   RQFACC,ASFBPACC     Get pseudo account
         CLEAR RQPRIV              Can't inherit privileges
         END   ,
         ELSE  BEGIN
         MVC   RQFACC,ASFBSACC     Get auth user for file
         END   ,
         END   ,                   No file attached
         ELSE  BEGIN               File attached
         IF    (@M1FATCH,OR,@M1FSTAT),'ABORT YESRQFB'
         MVC   RQATTF,RQFBASV      Get saved fields
         MVC   RQNORV,=CL4'ORV.'   Set start of file name
         L     R14,RQATFB
         WITH  (ATFB,R14),BEGIN
         MVC   RQNAMS,ATFBNAME     Get file name
         MVC   RQFSB,ATFBFSB       Get FSB pointer
         MVC   RQFBLK,ATFBFBLK     Get first block number
         MVC   RQBLKC,ATFBBLKC     Get block count (non-IXR'd)
         MVC   RQMPERM,RQAPERM     Get attach permits
         NC    RQMPERM,ATFBMASK    Limit with file mask
         END   ,
         END   ,                   File attached

         IF    (RQFACC,EQ,=C'GG.ORV'),'SET RQAMAG' Master account
         MVC   RQRQID,@M1FRQID     Set request id
         LC    R14,@M1FILID
         ST    R14,RQFIID          Set file id
         IF    @M1FCLP,'SET RQACLP'
         IF    @M1FSPI,'SET RQASPI'
         IF    @M1FM31,'SET RQRM31'

         MVC   RQIREG,@M1FREG      Set input registers
         L     R15,=X'80000000'
         ST    R15,RQRR00          Set ind
         ST    R15,RQRR01          Set ind
         ST    R15,RQRR15          Set ind
         ST    R15,RQRR14          Set ind
         ST    R15,RQWR01          Set ind
         ST    R15,RQWR15          Set ind
         ST    R15,RQWR14          Set ind
         MVC   RQPKEY,@M1FPKEY     Set psw key
         MVC   RQPRIV,@M1FPRIV     Set user privileges
         MVC   RQTYPE,@M1FTYPE     Set request type

* Set input flags from high order bits of input regs
         IF    ('LT RS,RQIR14',M),BEGIN
         SET   RQIF14              R14 was complimented
         LCR   RS,RS
         ST    RS,RQIR14
         END   ,

         IF    ^RQCONT,BEGIN  Control 14 needs this unchanged
         IF    ('LT RS,RQIR15',M),BEGIN
         SET   RQIF15              R15 was complimented
         LCR   RS,RS
         ST    RS,RQIR15
         END   ,
         END   ,

         IF    ('LT RS,RQIR00',M),BEGIN
         SET   RQIF00              R0 was complimented
         LCR   RS,RS
         ST    RS,RQIR00
         ST    RS,RQRR00           Always return clear device id
         END   ,

         IF    ^RQSTAT,BEGIN  Status 117 needs this unchanged
         IF    ('LT RS,RQIR01',M),BEGIN
         SET   RQIF01              R1 was complimented
         LCR   RS,RS
         ST    RS,RQIR01
         END   ,
         END   ,

* This should only happen when CLP is detaching a file during HALT
* processing.
         IF    ('LT RN,RQFBRQWB',NZ),BEGIN IO already in progress?
         IF    (^RQAHALT,OR,^RQACLP,OR,^RQDTCH),BEGIN
         ORVSNAP 'NOT_CLP_DET_HALT',MODE=WTL
         ORVSNAP RQWB,L'RQWB
         WITH  (RQWB,RN),'ORVSNAP RQWB,L"RQWB'
         END   ,
         WITH  (RQWB,RN),BEGIN
         SET   RQAHALT             Make sure he knows
         CLEAR RQWBRQFB            He is an orphan now
         CLEAR RQATFB              We'll detach for him
         END   ,
         END   ,                   IO already in progress?

         ST    RA,RQFBRQWB         Set pointer from RQFB to RQWB
         ST    RK,RQWBRQFB         And vice versa

         IF    (RQAHALT,AND,^RQACLP),BEGIN
         LA    RVR,1               No IO
         MVC   RQRR15,=F'-12'      Set not available
         END   ,
         ELSE  BEGIN
         LC    RN,RQTYPE           Set request type
         L     RN,RTNTAB(RN)       Get routine address
         ACALL (RN)                Edit SVC parameters
         END   ,

* Set return registers
         IF    (RQRR14,NE,=X'80000000'),'MVC @M1FR14,RQRR14'
         IF    (RQRR15,NE,=X'80000000'),'MVC @M1FR15,RQRR15'
         IF    (RQRR00,NE,=X'80000000'),'MVC @M1FR00,RQRR00'
         IF    (RQRR01,NE,=X'80000000'),'MVC @M1FR01,RQRR01'

* Sometimes all the returns for the wait svc are already known
* and IO or further processing is not necessary
         MVC   @M1FWR14,RQWR14     Set wait regs in case
         MVC   @M1FWR15,RQWR15
         MVC   @M1FWR01,RQWR01

         MVC   RQFBASV,RQATTF      Get saved fields

         IF    RQRFRE,BEGIN        All done?
         LR    RN,RVR
         PSET  @RELRQFB
         PMOV  @RELRQFP,LA:RQFB
         ACALL RELRQFB             Free RQFB
         CLEAR RK                  Clear pointer
         SPUSH HEAD=ASFBFW,ITEM=RQWB Put avail item on free list
         LR    RVR,RN
         END   ,
         ELSEIF (RVR,Z),BEGIN      Start IO
         MVC   RQTSK,PZCURTSK      Get requestor task id
         PSET  @TCREATE
         ST    RK,@TCRPARM         RQFB is the parameter
         ST    RA,@TCRPARM+4       RQWB is the parameter
         LA    RS,1
         ST    RS,@TCRPRIO         Just above the caller
         MVC   @TCRPSW(4),=X'070C0000' Set PSW
         MVC   @TCRPSW+4(4),=A(M1FILEIO)
         SET   @TCRPSW+4.X'80'     31 bit addressing
         SET   @TCRFSTK            Task needs a stack
         VCALL TCREATE             Just do it!
         CLEAR RVR
         END   ,
         ELSE  BEGIN               No IO, done with RQWB
         CLEAR RQFBRQWB
         LR    RN,RVR
         SPUSH HEAD=ASFBFW,ITEM=RQWB Put avail item on free list
         LR    RVR,RN
         END   ,

         ST    RK,@M1FDVID         Set this field

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FILEIO - Created task to process file IO requests
*
*   Inputs -  @TEPARM
*
*   Output -
*---------------------------------------------------------------------*
M1FILEIO PROC  @TENTRY

* Set up trace table registers
         L     RK,@TEPARM          RQFB addr
         WITH  (RQFB,RK)
         L     RN,@TEPARM+4
         WITH  (RQWB,RN),BEGIN
* Note: these registers are not un-complimented
         LM    R14,R1,RQIR14       Set SVC input R14 to R1
         LC    R2,RQTYPE           SVC type
         L     R3,RQATFB           Attached file pointer
         L     R4,PZCURASB         ASB pointer
         END   ,
         XTRC  R14,R4,M1FILEIO     Save some clues

         WITH  (RQWB,RA)
         L     RA,@TEPARM+4

         MVC   RQRR14,=X'80000000' Set ind
         MVC   RQRR15,=X'80000000' Set ind
         MVC   RQRR00,=X'80000000' Set ind
         MVC   RQRR01,=X'80000000' Set ind

         IF    (RQAHALT,AND,^RQACLP),BEGIN
         MVC   RQRR15,=F'-4'       Set error
         END   ,
         ELSE  BEGIN
         LC    RN,RQTYPE           Get type
         L     RN,RTNTABI(RN)      Get routine address
         ACALL (RN)                Do the IO
         END   ,

* Halt processing started while IO was occuring? (CLP detached the
* file?)
         IF    (RQWBRQFB,NZ),BEGIN Not superceded by halt processing
         MVC   RQFBASV,RQATTF      Get saved fields
         IF    RQRFRE,BEGIN        All done?
         PSET  @RELRQFB
         PMOV  @RELRQFP,LA:RQFB
         ACALL RELRQFB
         END   ,
         ELSE  'CLEAR RQFBRQWB'
         END   ,                   Not superceded by halt processing

*  Notify task of completion
         PSET  @XITNEW             Get exit request ID
         VCALL XITNEW
         LR    RX,RVR

         PSET  @XITDO              Notify task
         PMOV  @XITRQID,(RX)
         PMOV  @XITTSK,RQTSK
         PMOV  @XITTYPE,LA:XITTIOCN
         WITH  (@M1FPOST,@XITPARM)
         PMOV  @M1FPRQI,RQRQID
         IF    RQRFRE,'OI @M1FPRQI,@M1FREDV'
         PMOV  @M1FPR01,RQRR01
         PMOV  @M1FPR14,RQRR14
         PMOV  @M1FPR15,RQRR15
         VCALL XITDO

         PSET  @XITDEL             Delete exit request ID
         PMOV  @XITDID,(RX)
         VCALL XITDEL

         L     RJ,RQASFB
         WITH  (ASFB,RJ)
         SPUSH HEAD=ASFBFW,ITEM=RQWB Put avail item on free list

         PSET  @TEXIT              Exit this task
         VCALL TEXIT

         PEND  CODE=NO

RTNTAB   DC    A(0)                SVC routines
         DC    A(M1FATCH)
         DC    A(M1FREAD)
         DC    A(M1FWRIT)
         DC    A(M1FCONT)
         DC    A(M1FSTAT)
         DC    A(M1FDTCH)
         DC    A(M1FRSRV)
         DC    A(M1FRLSE)

RTNTABI  DC    A(0)                IO routines
         DC    A(M1IATCH)
         DC    A(M1IREAD)
         DC    A(M1IWRIT)
         DC    A(M1ICONT)
         DC    A(M1ISTAT)
         DC    A(0)                No IO
         DC    A(M1IRSRV)
         DC    A(0)                No IO
         EJECT ,
*---------------------------------------------------------------------*
*  M1FATCH - File ATTACH processing, preliminary edits
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
#FATCH   RECORD BEGIN
#FATCHF  FLAG  ,
         FLAG  #FATCHFN            Newly attached
         END   ,

M1FATCH  PROC  ,#FATCH
         WITH  (RQWB,RA)
         WITH  (FSB,RB)

         L     RM,RQASFB           Point to ASFB
         WITH  (ASFB,RM)
         WITH  (ATFB,RX)
         ADFCB ,                   FILECB
         CLEAR #FATCH

         IF    (RQIFILE,Z),BEGIN   Temp file
         IF    RQOLD,M1FATW16      Can't be an old file
         SET   RQATMP
*  Create a name for the file
         PSET  @SETFNAM
         PMOV  @SETFNA,LA:=C'TEMP'
         PMOV  @SETFNL,LA:4
         ACALL SETFNAME            Set file name
         IF    (RVR,NZ),M1FATRVR   Error return
         IF    (FILTEMPF,NZ),'MVC RQFSB,FILTEMPF' Set special file sys
         L     RB,RQFSB            Point to FSB
         BAS   RS,M1FATAV          Check availability
         MVI   RQNAM2+4,C'.'       Set dot after TEMP
         LA    RS,RQNAM2+5         Point to end of name
         ACALL SETTEMPN            Finish with date and time
         SAVAIL HEAD=FILEATFB,LEN=L'ATFB Get an avail ATFB
         LR    RX,RVR
         ST    RX,RQATFB           Save pointer
* Note: this block is not put on the hash table but is
*       referenced only by the RQFB.
         CLEAR ATFB
         MVC   ATFBFP(8),=CL8'TempFile' This block is not on a list
         MVC   ATFBID,=CL4'ATFB'   Set block id
         MVC   ATFBNAME,RQNAMS     Set name
         MVC   ATFBCNT,=Y(1)       Set to one attached
         MVC   ATFBFSB,RQFSB       Set FSB pointer
         INCRS CTFILATP            Current attached temp files
         L     R14,CTFILAPM
         L     R15,CTFILATP
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,CTFILAPM    Set new high water mark
         UNTIL Z,END
         INCRS TTFILATP            Current attached temp files
         L     R14,TTFILAPM
         L     R15,TTFILATP
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,TTFILAPM    Set new high water mark
         UNTIL Z,END
         END   ,                   Temp file

         ELSE  BEGIN               Not temp file
         PSET  @SETFNAM
         PMOV  @SETFNA,RQIFILE
         PMOV  @SETFNL,RQIFLEN
         ACALL SETFNAME            Set file name
         IF    (RVR,NZ),M1FATRVR   Error return
         L     RB,RQFSB            Point to FSB
         BAS   RS,M1FATAV          Check availability
         L     RJ,FSBAHFB          Get file attach hash table ptr
         WITH  (AHFB,RJ)

         PSET  @HASH
         PMOV  @HSHSTR,LA:RQNAME   File name
         PMOV  @HSHLEN,LA:L'RQNAME Length
         PMOV  @HSHVAL,LA:AHFBCNT  Hash value
         SET   @HSHBLNK            Don't use trailing blanks
         VCALL HASHIT              Calculate hash number
         LR    RK,RVR              Get hash number
         MH    RK,=Y(L'AHFBL)      Calculate index
         LA    RK,AHFBL(RK)        Point to queue
         WITH  (AHFBL,RK)

         GRGET RID=AHFBGRID,EXCL=YES Reserve the table

         L     RX,AHFBLFP          Point to first on list
         WHILE (RX,NE,RK),BEGIN    While not end of list
         IF    (ATFBNAME,EQ,RQNAMS),EXIT
         L     RX,ATFBFP           Point to next on list
         END

         IF    (RX,NE,RK),BEGIN    Already attached by someone
         INCR  RS,ATFBCNT
         END   ,                   Already attached by someone
         ELSE  BEGIN               First to attach
         SET   RQR1ST              Indicate such
         SAVAIL HEAD=FILEATFB,LEN=L'ATFB Get an avail ATFB
         LR    RX,RVR
         CLEAR ATFB
         MVC   ATFBID,=CL4'ATFB'   Set block id
         ST    RK,ATFBATL          Set attached list address
         MVC   ATFBNAME,RQNAMS     Set name
         MVC   ATFBCNT,=Y(1)       Set to one attached
         MVC   ATFBFSB,RQFSB       Set FSB pointer
         GRCRE CID=(RX)            Create a general resource
         ST    RVR,ATFBAGRI        One for attaching
         GRCRE CID=(RX)            Create a general resource
         ST    RVR,ATFBRGRI        One for reserve processing
         LADD  AHFBL,LA:ATFB,WR=RS Add to the list
         SET   #FATCHFN            Indicate newly attached
         END   ,                   First to attach
         ST    RX,RQATFB           Save pointer
         GRREL RID=AHFBGRID        Release the hash table

         INCRS CTFILAUS            Current user attached files
         L     R14,CTFILAUM
         L     R15,CTFILAUS
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,CTFILAUM    Set new high water mark
         UNTIL Z,END
         INCRS TTFILAUS            Current user attached files
         L     R14,TTFILAUM
         L     R15,TTFILAUS
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,TTFILAUM    Set new high water mark
         UNTIL Z,END
         IF    #FATCHFN,BEGIN      Newly attached
         INCRS CTFILATT            Current attached files
         L     R14,CTFILATM
         L     R15,CTFILATT
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,CTFILATM    Set new high water mark
         UNTIL Z,END
         INCRS TTFILATT            Current attached files
         L     R14,TTFILATM
         L     R15,TTFILATT
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,TTFILATM    Set new high water mark
         UNTIL Z,END
         END   ,                   Newly attached

* check for already attached
         L     RN,ASFBRQFP         First RQFB
         WITH  (RQFB,RN)
         LA    R15,ASFBRQ          Point to list
         WHILE (RN,NE,R15),BEGIN   Check all RQFBs
         IF    (RA,NE,RQFBRQWB),BEGIN Not this item
         WITH  (RQATTF,RQFBASV),LABEL=L Map RQWB saved fields in RQFB
         IF    (RQATFB,EQ,L.RQATFB),BEGIN Already attached
         MVC   RQRFID,L.RQFIID     Set file id
         IF    ^L:RQADONE,M1FATR04 Attach in progress
         IF    L:RQASHR,M1FATR12   Already attached, mode=share
         B     M1FATR08            Already attached, not mode=share
         END   ,                   Already attached
         END   ,                   Not this item
         L     RN,RQFBFP           Point to next RQ
         END   ,                   Check all RQFBs
         END   ,                   Not temp file

         MVC   RQRFID,RQFIID       Set file id
         CLEAR RVR
         CLEAR RQRETC              Set good return code
         EXIT  M1FATCH

M1FATAV  LABEL ,
* check for file system availability
         IF    (FSBANAVL),BEGIN    Not available
         CLEAR RQRARO              Set secondary return
         B     M1FAT_12
         END   ,
         IF    (FSBARO,AND,^RQOLD),BEGIN Read only
         MVC   RQRARO,=F'4'        Set secondary return
         B     M1FAT_12
         END   ,
         BR    RS                  Return if good

M1FATRVR LABEL ,
         ST    RVR,RQRETC          Set error return code
         B     M1FATCHE            Exit

M1FATR04 LABEL ,
         MVC   RQRETC,=F'4'        Attach already begun
         B     M1FATCHE            Exit

M1FATR08 LABEL ,
         MVC   RQRETC,=F'8'        Already attached, not share mode
         B     M1FATCHE            Exit

M1FATR12 LABEL ,
         MVC   RQRETC,=F'12'       Already attached, share mode
         B     M1FATCHE            Exit

M1FATW16 LABEL ,
         CLEAR RQRETC              This error reported on wait svc
         MVC   RQWRETC,=F'16'      File does not exist
         B     M1FATCHE            Exit

M1FAT_12 LABEL ,
         MVC   RQRETC,=F'-12'      File system not available
         B     M1FATCHE            Exit

M1FATCHE LABEL ,
         SET   RQRFRE              Don't need an RQFB
         LA    RVR,1               Set error exit, no attach
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1IATCH - File ATTACH processing, IO part
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1IATCH  PROC  ,
         WITH  (RQWB,RA)
         L     RB,RQFSB
         WITH  (FSB,RB)

         L     RX,RQATFB
         WITH  (ATFB,RX)

         IF    RQATMP,BEGIN        Temp file
         MVI   RQAPERM,FPALL       Set permits
         MVI   RQMPERM,FPALL       Set masked permits
         MVI   ATFBMASK,FPALL      Set file mask
         PSET  @FMIXRAD
         PMOV  @FMIXFSB,LA:FSB
         MVC   @FMIXNAM,RQNAMS
         ACALL FMIXRADD            Build an IXR for the temp file
         IF    (RVR,NZ),M1IATRVR   Exit if error
         IF    RQAHALT,M1IAT_04    Halt started during IXR build
         MVC   RQFBLK,@FMIXBLK     Set first block number
         MVC   ATFBFBLK,RQFBLK     Set in ATFB
         ADFCB ,                   FILECB
         INCRS TTFILTBK            Number of blocks in temp files
         L     R14,TTFILTBM
         L     R15,TTFILTBK
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,TTFILTBM    Set new high water mark
         UNTIL Z,END
         END   ,                   Temp file

         ELSE  BEGIN               Not a temp file
         PSET  @FCPERM
         PMOV  @FCPFSB,LA:FSB
         PMOV  @FCPNAME,RQNAMS     File name
         PMOV  @FCPACC,RQFACC
         IF    RQAMAG,'SET @FCPFMAG'
         IF    RQAOWN,'SET @FCPFMAG'
         IF    (RQACLP,AND,RQNAX),'SET @FCPFNAX' CLP just looking
* Special kludge
         IF    ((RQFACC,EQ,=C'GG.ORV'),AND,RQNAX),'SET @FCPFNAX'
* End special kludge
         IF    ^RQR1ST,'SET @FCPFNAX' Don't update time every time
         IF    RQOLD,'VCALL FCATOPRM'
         ELSE  'VCALL FCATNPRM'    Get permits for attach
         IF    (RVR,NZ),M1IATRVR   Exit if error
         IF    RQAHALT,M1IAT_04    Not available

         MVC   RQAPERM,@FCPPERM    Permits
         MVC   RQMPERM,RQAPERM     Determine masked permits
         NC    RQMPERM,@FCPFLGO    Limit with filemask
         MVC   RQCODE,@FCPCODE     File code
         MVC   RQFBLK,@FCPBLK      First block
         MVC   RQBLKC,@FCPBLKC     Block count (non-IXR'd)
         IF    (RQAPERM.FPS,AND,^RQSHR),M1IATR32 Att share only
         IF    (^RQAOWN,AND,^RQAMAG),BEGIN Not an owner
         IF    (RQCCLP,AND,^RQACLP),M1IATR04 Only CLP can attach
         IF    (RQCSPI,AND,^RQASPI,AND,^RQACLP),M1IATR04 Spires only
         IF    (RQOLD,AND,(RQPRIV.KWRIFAPR,NZ)),EXIT Special priv
         IF    (RQMPERM.FPALL,Z),M1IATR04 No permits
         END   ,                   Not the owner
* Note: no locking necessary with STC
         IC    R15,@FCPFLGO        Get file mask
         STC   R15,ATFBMASK        Set file mask
         L     R15,RQFBLK
         ST    R15,ATFBFBLK        Set first block
         L     R15,RQBLKC
         ST    R15,ATFBBLKC        Set block count (non-IXR'd)

         PSET  @GRES
         PMOV  @GRID,ATFBAGRI
         IF    RQWAIT,'SET @GRWAIT' Wait if not avail
         IF    RQSHR,'SET RQASHR'  Set attached in share mode
         ELSE  'SET @GREXCL'       Get exclusive hold
         VCALL GRGET               Get resource id
         IF    (RVR,Z),M1IAT_04    Not available
         ST    RVR,RQAGRH          Set resource hold id
         IF    (ATFBNAME,NE,RQNAMS),M1IATR16 Deleted or renamed!
* The file access time in the catalog is updated when the first
* user attaches and when the last user detaches only. All other
* attaches or detaches do not update the catalog.
         IF    (ATFBCNT,GT,1),'SET ATFBFTIM' Update at last detach
         IF    ^RQOLD,BEGIN        New file
         ADFCB ,
         INCRS FILECRE             Number of files created
         END   ,                   New file
         END   ,                   Not a temp file

         CLEAR RQRETC
         SET   RQADONE             Set to attach done
         EXIT  M1IATCH

M1IAT_04 LABEL ,
         MVC   RQRETC,=F'-4'       Not immediately available
         B     M1IATCHE

M1IATR04 LABEL ,
         MVC   RQRETC,=F'4'        Access not permitted
         B     M1IATCHE

M1IATR16 LABEL ,
         MVC   RQRETC,=F'16'       File does not exist
         B     M1IATCHE

M1IATR32 LABEL ,
         MVC   RQRETC,=F'32'       File only attachable share mode
         B     M1IATCHE

M1IATRVR LABEL ,
         ST    RVR,RQRETC          Set return code from catalog stuff

M1IATCHE LABEL ,
         SET   RQRFRE              Free RQFB
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FDTCH - File DETACH processing
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1FDTCH  PROC
         WITH  (RQWB,RA)

         IF    ^RQASTAT,'SET RQRFRE' Done with this RQFB
         CLEAR RQRETC              Set return
         LA    RVR,1               No IO necessary
* Note: no registers changed at wait time

         PEND  ,
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FREAD - File READ processing, preliminary edits
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1FREAD  PROC
         WITH  (RQWB,RA)
         L     RB,RQFSB            FSB addr
         WITH  (FSB,RB)

         IF    ^RQMPERM.FPR,BEGIN  No read access
         MVC   RQWRETC,=F'8'       No access
         CLEAR RQRETC              Clear SVC return
         LA    RVR,1               No IO necessary
         EXIT  M1FREAD
         END   ,                   Check input parms

         ACALL FMRANGE             Check input parms
         IF    (RVR,M),BEGIN       Panic
         EXIT  M1FREAD
         END   ,
         ELSEIF (RVR,NZ),BEGIN
         MVC   RQWRETC,=F'12'      Block does not exist
         CLEAR RQRETC              Clear SVC return
         LA    RVR,1               No IO necessary
         END   ,                   Check input parms
         ELSE  BEGIN               Check availability
         LA    RVR,1               Init to no IO necessary
         IF    (FSBANAVL),'MVC RQRETC,=F"-12"' Set to not available
         ELSE  'CLEAR RQRETC,RVR'  Operation started
         END   ,                   Check availability

         PEND  ,
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1IREAD - File READ processing, IO part
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
#REAWK   RECORD BEGIN
#REASIX  DS    A                   SIXR address
#REAIXR  DS    A                   IXR address
#REAUSE  DS    A                   User record addr
#REASIXE DS    A                   End of SIXR address
#REAIXE  DS    A                   End of IXR address
#REANBLK DS    A                   Number of next block to process
#REABCNT DS    A                   Count of bytes processed
#REALCNT DS    A                   Count of bytes left to process
         END   ,
M1IREAD  PROC  ,#REAWK
         WITH  (RQWB,RA)
         L     RB,RQFSB            FSB addr
         WITH  (FSB,RB)

         CLEAR #REAWK

         IF    (RQASHR,AND,^RQARES),BEGIN Not already reserved
         L     RX,RQATFB           Point to attach block
         WITH  (ATFB,RX)
         PSET  @GRES
         PMOV  @GRID,ATFBRGRI      Point to reserve grid
         IF    RQWAIT,'SET @GRWAIT' Wait if not avail
         VCALL GRGET               Get resource id hold (share mode)
         ST    RVR,RQRGRH          Set reserve id
         IF    (RQRGRH,Z),M1IREE04 No reserve, not available
         END   ,                   Not already reserved

         IF    ^RQCNIXR,M1IREADX   IXR file
         IF    RQCHYBR,M1IREADH    Hybrid file
         L     RM,RQILEN           Init count of bytes to read
         CLEAR RN                  Init count of bytes read

         L     RY,RQIBLK           Get the first block number
         A     RY,RQFBLK           Calculate real block number

         LOOP  BEGIN
         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         SET   @FDOFR+@FDOFUSE     Indicate read user record
         PMOV  @FDODATA,#REAUSE    Set buffer
         PMOV  @FDODATL,FSBDSZ     Data length
         PMOV  @FDOBLK,(RY)        Block number
         VCALL FDOIODO             Read record
         MVC   #REAUSE,@FDODATA    Set buffer
         IF    (RVR,NZ),M1IREE_4   IO error

         LH    RK,@FDODATL         Get count to move

         CHKMEM RQIDAT,RQILEN,W    Make sure memory not released
         IF    (RVR,NZ),M1IREE_4   IO error

         INCR  RY                  Increment block number
         L     R14,#REAUSE         Point to data just read
         L     RJ,RQIDAT           Point to user data area
         AR    RJ,RN               Point pass already moved
         IF    (RM,GT,RK),BEGIN    Need to read more blocks
         IF    (RK,LT,FSBDSZ),'CLEAR RM' Don't read no more
         ELSE  'SR RM,RK'          Calc remaining to read
         END   ,                   Need to read more blocks
         ELSE  BEGIN               All data on this block
         LR    RK,RM               Get count to move
         CLEAR RM                  Don't read no more
         END   ,                   All data on this block
         AR    RN,RK               Calc count moved thus far
         LR    R15,RK              Source and destination lens same
         MVCL  RJ,R14              Move the data

         UNTIL (RM,Z),END          Until done
         S     RY,RQFBLK           Calc unreal next block
         ST    RY,#REANBLK         Set return block value
         ST    RN,#REABCNT         Set count of bytes read
         CLEAR RQRETC              Set return code
         B     M1IREADE            Exit
         LTORG ,

M1IREADH LABEL ,                   Hybrid files

         WITH  (IXR,RX)            IXR record
         WITH  (IXR,RY),LABEL=S    Super IXR record

         L     RN,RQIBLK           Get block no requested
         ST    RN,#REANBLK         Init next block to read
         MVC   #REALCNT,RQILEN     Get count of bytes to read

         CLEAR RM
         D     RM,=A(IXRNT#)       Calc index and IXR number
         MH    RM,=Y(L'IXRNT)      Calc displacement
         A     RN,RQFBLK           Calc real IXR number

         CLEAR R14
         LR    R15,RN              IXR block number
         BAS   RS,M1IREAD6         Get IXR
         LR    RX,R14              Point to IXR
         ST    RX,#REAIXR          Set IXR pointer
         LA    RY,IXR              Get IXR pointer
         LA    RN,IXR+(L'IXRNT*IXRNT#) Point past the end of IXR
         LA    RX,IXR(RM)          Point to user block number

         LOOP  BEGIN               Read all the data

         IF    (IXRNT,Z),BEGIN
         IF    ^RQSKIP,M1IREE12    No block for this one
         END   ,
         ELSE  BEGIN               Read the record
         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDOBLK,IXRNT       Block number
         PMOV  @FDODATA,#REAUSE    Use this block (if there)
         PMOV  @FDODATL,FSBDSZ     Data length
         SET   @FDOFR+@FDOFUSE     Indicate read user record
         VCALL FDOIODO             Read user record
         L     RJ,@FDODATA         Get data pointer
         ST    RJ,#REAUSE          Save data pointer
         IF    (RVR,NZ),M1IREE_4   IO error
         L     RK,#REALCNT         Get count left
         IF    (RK,LE,@FDODATL),'CLEAR #REALCNT' Enough on this block
         ELSE  BEGIN               Get all this block
         LH    RK,@FDODATL         Set length read
         IF    (@FDODATL,LT,FSBDSZ),'CLEAR #REALCNT' Block not full
         ELSE  BEGIN               Set count left to read
         L     R14,#REALCNT        Get count left to read
         SR    R14,RK              Calc count remaining
         ST    R14,#REALCNT        Set
         END   ,                   Set count left to read
         END   ,                   Get all this block
         CHKMEM RQIDAT,RQILEN,W    Make sure memory not released
         IF    (RVR,NZ),M1IREE_4   IO error
         LR    R14,RK              Get count read
         LR    RS,RK               Get len
         L     RVR,RQIDAT          Point to user buffer
         A     RVR,#REABCNT        Point past part already read
         MVCL  RVR,RJ              Move the data read
         A     R14,#REABCNT        Calc total bytes read
         ST    R14,#REABCNT        Set
         END   ,                   Read the record

         INCR  R14,#REANBLK        Increment next block to read

         IF    (#REALCNT,Z),EXIT   All done

         LA    RX,IXR+L'IXRNT      Point to next user number
         IF    (RX,GE,RN),BEGIN    Past the end of this IXR
         LA    R14,S.IXR           Get IXR pointer
         L3    R15,S.IXRECNO       Get the number of this IXR
         INCR  R15                 Calc next IXR number
         L     R14,RQFBLK          Calc last IXR + 1
         A     R14,RQBLKC
         IF    (R15,GE,R14),M1IREE12 Out of range
         LA    R14,S.IXR           Get IXR pointer
         BAS   RS,M1IREAD6         Get the IXR
         LA    RX,S.IXR            Point to the IXR
         END   ,                   Past the end of this IXR
         END   ,                   Read all the data

         CLEAR RQRETC              Set return code
         B     M1IREADE


M1IREADX LABEL ,                   IXR files

         CLEAR R14
         L     R15,RQFBLK          Set first block number
         BAS   RS,M1IREAD6         Get IXR
         LR    RX,R14              Set IXR pointer

         L     RN,RQIBLK           Get block no requested
         ST    RN,#REANBLK         Init next block to read
         MVC   #REALCNT,RQILEN     Get count of bytes to read
         CLEAR RY                  Clear super IXR pointer

         IF    IXRSIXR,BEGIN       Super IXR
         LR    RY,RX               Point to super IXR
         ST    RY,#REASIX          Save address of SIXR
         LA    R14,S.IXR+(L'IXRNT*IXRIXNT#) Point past the end of SIXR
         ST    R14,#REASIXE        Save address
         CLEAR RM
         D     RM,=A(IXRNT#)       Calc IXR index
         MH    RN,=Y(L'IXRNT)      Calc displacement to block number
         LA    RY,S.IXR(RN)        Point to it
         LR    RN,RM               Get remainder from divide

M1IREAD2 BEGIN ,                   Get IXR record number

         IF    (RY,GE,#REASIXE),M1IREE12 Out of range
         IF    (S.IXRNT,Z),BEGIN   IXR record does not exist
         IF    ^RQSKIP,M1IREE12    No IXR for this one
         LA    R14,IXRNT#          Get total blocks per IXR
         SR    R14,RN              Calc number to end of IXR
         A     R14,#REANBLK        Add to next block to read
         ST    R14,#REANBLK        Set next block to read
         CLEAR RN                  Will start from the top on skip
         LA    RY,S.IXR+L'IXRNT    Point to next IXR number
         NEXT  M1IREAD2            Continue
         END   ,                   IXR record does not exist
         END   ,                   Get IXR record number

         L     R14,#REAIXR         Reuse block if exists
         L3    R15,S.IXRNT         Set block number
         BAS   RS,M1IREAD6         Get IXR
         LR    RX,R14              Set IXR pointer
         ST    RX,#REAIXR          Set IXR pointer
         LA    RY,S.IXR+L'IXRNT    Point to next IXR number in case
         END   ,                   Super IXR record
         ELSE  BEGIN               Master IXR record
         ST    RX,#REAIXR          Set IXR pointer
         IF    (RN,GE,IXRNT#),M1IREE12 Out of range
         END   ,                   Master IXR record

         LA    R14,IXR+(L'IXRNT*IXRNT#) Point past the end of IXR
         ST    R14,#REAIXE         Save address
         MH    RN,=Y(L'IXRNT)      Calc displacement to block number
         LA    RX,IXR(RN)          Point to it

M1IREAD4 BEGIN ,                   Get user record number

         IF    (RX,GE,#REAIXE),BEGIN None on this IXR
         IF    (RY,Z),M1IREE12     Out of range
         CLEAR RN                  Start from beginning
         B     M1IREAD2            Continue
         END   ,                   None on this IXR
         IF    (IXRNT,Z),BEGIN     User record does not exist
         IF    ^RQSKIP,M1IREE12    No user record
         LA    RX,IXR+L'IXRNT      Point to next user number
         INCR  R14,#REANBLK        Increment last to read
         NEXT  M1IREAD4            Continue
         END   ,                   User record does not exist
         END   ,                   Get user record number

         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDOBLK,IXRNT       Block number
         PMOV  @FDODATA,#REAUSE    Use this block (if there)
         PMOV  @FDODATL,FSBDSZ     Data length
         SET   @FDOFR+@FDOFUSE     Indicate read user record
         VCALL FDOIODO             Read user record
         L     RJ,@FDODATA         Get data pointer
         ST    RJ,#REAUSE          Save data pointer
         IF    (RVR,NZ),M1IREE_4   IO error
         LA    RX,IXR+L'IXRNT      Point to next user number in case
         INCR  R14,#REANBLK        Increment next block to read

         L     RK,#REALCNT         Get count left
         IF    (RK,LE,@FDODATL),'CLEAR #REALCNT' Enough on this block
         ELSE  BEGIN               Get all this block
         LH    RK,@FDODATL         Set length read
         IF    (@FDODATL,LT,FSBDSZ),'CLEAR #REALCNT' Block not full
         ELSE  BEGIN               Set count left to read
         L     R14,#REALCNT        Get count left to read
         SR    R14,RK              Calc count remaining
         ST    R14,#REALCNT        Set
         END   ,                   Set count left to read
         END   ,                   Get all this block

         CHKMEM RQIDAT,RQILEN,W    Make sure memory not released
         IF    (RVR,NZ),M1IREE_4   IO error

         LR    R14,RK              Get count read
         LR    RS,RK               Get len
         L     RVR,RQIDAT          Point to user buffer
         A     RVR,#REABCNT        Point past part already read
         MVCL  RVR,RJ              Move the data read
         A     R14,#REABCNT        Calc total bytes read
         ST    R14,#REABCNT        Set
         IF    (#REALCNT,NZ),M1IREAD4 Get some more
         CLEAR RQRETC              Set return code
         B     M1IREADE
         LTORG ,

M1IREAD6 LABEL ,
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,(R14)      Set buffer address
         PMOV  @IXRGBNO,(R15)      Set block number
         ACALL FMIXRGET            Get IXR record
         L     R14,@IXRGADR        Get buffer address
         BR    RS

M1IREE_4 LABEL ,
         MVC   RQRETC,=F'-4'
         B     M1IREADE

M1IREE04 LABEL ,
         MVC   RQRETC,=F'4'
         B     M1IREADE

M1IREE08 LABEL ,
         MVC   RQRETC,=F'8'
         B     M1IREADE

M1IREE12 LABEL ,
         MVC   RQRETC,=F'12'
         B     M1IREADE

M1IREADE LABEL ,

         MVC   RQRLEN,#REABCNT     Set count of bytes read
         MVC   RQRBLK,#REANBLK     Set last block read + 1

         IF    (^RQARES,AND,(RQRGRH,NZ)),BEGIN
         GRREL RID=RQRGRH          Release file reserve
         CLEAR RQRGRH              Clear hold id
         END   ,

         LA    RM,#REASIX          Release IO buffers
         LA    RN,3
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         LOOP  BEGIN
         MVC   @SBFADR,@RM
         IF    (@SBFADR,NZ),'VCALL SBUFREE'
         LA    RM,@RM+4
         DECR  RN
         UNTIL (RN,Z),END

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FWRIT - File WRITE processing, preliminary edits
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1FWRIT  PROC
         WITH  (RQWB,RA)
         L     RB,RQFSB            FSB addr
         WITH  (FSB,RB)

         IF    ^RQMPERM.FPW,BEGIN  No write access
* Append only OK for IXR or hybrid
         IF    (RQMPERM.FPA,AND,(^RQCNIXR,OR,RQCHYBR)),EXIT
         MVC   RQWRETC,=F'8'       No access
         CLEAR RQRETC              Clear SVC return
         LA    RVR,1               No IO necessary
         EXIT  M1FWRIT
         END   ,                   No write access

         ACALL FMRANGE             Check input parms
         IF    (RVR,M),BEGIN       Panic
         EXIT  M1FWRIT
         END   ,
         ELSEIF (RVR,NZ),BEGIN
         MVC   RQWRETC,=F'24'      Set out of range wait return
         CLEAR RQRETC              Clear SVC return
         LA    RVR,1               No IO necessary
         END   ,                   Check input parms
         ELSE  BEGIN               Check availability
         LA    RVR,1
         IF    (FSBANAVL,OR,FSBARO),'MVC RQRETC,=F"-12"' Not available
         ELSE  'CLEAR RQRETC,RVR'  Operation started
         END   ,                   Check availability

         PEND  ,
         LTORG ,
         EJECT ,
#WRIWK   RECORD BEGIN
#WRISIX  DS    A                   SIXR address
#WRIIXR  DS    A                   IXR address
#WRIUSE  DS    A                   User record addr
#WRIBCNT DS    A                   Count of bytes processed
#WRILCNT DS    A                   Count of bytes left to process
#WRICBLK DS    A                   Current block number
#WRISIXN DS    H                   Current IXR number in SIXR
#WRIIXRN DS    CL3                 Current block number in IXR
#WRIFLG  FLAG  ,
         FLAG  #WRIFSIX            The SIXR needs to be written
         FLAG  #WRIFIXR            The IXR needs to be written
#WRIBASR DS    A                   Linkage register save
#WRIBAS2 DS    A                   Another one
         END   ,
*---------------------------------------------------------------------*
*  M1IWRIT - File WRITE processing, IO part
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1IWRIT  PROC  ,#WRIWK
         WITH  (RQWB,RA)
         L     RB,RQFSB            FSB addr
         WITH  (FSB,RB)

         CLEAR #WRIWK

         IF    (RQASHR,AND,^RQARES),BEGIN Not already reserved
         L     RX,RQATFB           Point to attach block
         WITH  (ATFB,RX)
         PSET  @GRES
         PMOV  @GRID,ATFBRGRI      Point to reserve grid
         SET   @GREXCL             Get exclusive hold
         IF    RQWAIT,'SET @GRWAIT' Wait if not avail
         VCALL GRGET               Get resource id hold
         ST    RVR,RQRGRH          Set reserve id
         IF    (RQRGRH,Z),M1IWRE04 No reserve, not available
         END   ,                   Not already reserved

         PSET  @SBGET
         PMOV  @SBGPOO,FSBRBT      Get an io buffer
         VCALL SBUFGET
         MVC   #WRIUSE,@SBGADR     Save user buffer address

         IF    ^RQCNIXR,M1IWRITX   IXR file
         IF    RQCHYBR,M1IWRITH    Hybrid file

         L     RM,RQILEN           Init count of bytes to write
         CLEAR RN                  Init count of bytes to written

         L     RJ,#WRIUSE          Get buffer address
         L     RY,RQIBLK           Get the first block number
         A     RY,RQFBLK           Calc real block number

         LOOP  BEGIN

         IF    (RQILEN,NZ),BEGIN
         CHKMEM RQIDAT,RQILEN      Make sure memory not released
         IF    (RVR,NZ),M1IWRE_4   IO error
         END   ,

         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDODATA,(RJ)       Set data buffer
         PMOV  @FDOTYPE,LA:FBHTUSER Set to user record
         SET   @FDOFW+@FDOFUSE     Indicate write user record

         LR    RVR,RJ              Get IO buffer pointer
         LH    RS,FSBDSZ           Len of IO buffer
         L     R14,RQIDAT          Point to user data
         AR    R14,RN              Point past part already written

         IF    (RM,GT,RS),BEGIN
         SR    RM,RS               Subtract from the total to write
         AR    RN,RS               Add to total written
         LR    R15,RS              Get len to move to IO buffer
         END   ,
         ELSE  BEGIN
         LR    R15,RM              Get len to move to IO buffer
         AR    RN,RM               Add to total written
         CLEAR RM                  Clear len left to write
         END   ,

         PMOV  @FDODATL,(R15)      Set data length
         PMOV  @FDOBLK,(RY)        Set block number
         MVCL  RVR,R14             Move data to IO buffer

         VCALL FDOIODO             Write record
         IF    (RVR,NZ),M1IWRE_4   IO error
         INCR  RY                  Increment block number

         UNTIL (RM,Z),END

         S     RY,RQFBLK           Calc unreal next block
         ST    RY,RQRBLK           Set return block value
         ST    RN,RQRLEN           Set count of bytes written
         CLEAR RQRETC              Set good return
         B     M1IWRITE            Done

M1IWRITH LABEL ,                   Hybrid file

         WITH  (IXR,RX)            IXR record
         WITH  (IXR,RY),LABEL=S    Super IXR record
         WITH  (IXR,RJ),LABEL=M    IXR misc

         CLEAR R14
         L     R15,RQFBLK
         BAS   RS,M1IWRIT6         Get first IXR

         LR    RY,R14              Get IXR pointer
         ST    RY,#WRISIX          Save buffer pointer

         MVC   #WRILCNT,RQILEN     Get count of bytes to write
         L     RN,RQIBLK           Get block no requested
         ST    RN,#WRICBLK         Set last block processed

         CLEAR RM
         D     RM,=A(IXRNT#)       Calc block and index
         ST3   RM,#WRIIXRN         Save user index in IXR

         IF    (RN,Z),BEGIN
         LR    RX,RY               First record
         END   ,
         ELSE  BEGIN               Get IXR
         CLEAR R14
         LR    R15,RN
         A     R15,RQFBLK
         BAS   RS,M1IWRIT6         Get IXR
         LR    RX,R14              Get IXR pointer
         ST    RX,#WRIIXR          Save buffer pointer
         END   ,                   Get IXR

         LR    RJ,RX               Get IXR pointer
         LA    RK,IXR+(L'IXRNT*IXRNT#) Point past the end of IXR
         LR    R14,RM
         MH    R14,=Y(L'IXRNT)     Calc displacement
         LA    RX,IXR(R14)         Point to user block

* Control 0 comes through here also for create a block (must
* not already exist).
         IF    (RQCONT,AND,(IXRNT,NZ)),M1IWRE12

         IF    ^RQMPERM.FPW,BEGIN  Append only
         L     R15,RQIBLK          Get first block to write
         IF    (IXRNRCS,NZ),BEGIN  File not empty
         DECR  R15                 Set to previous block
         IF    (R15,NE,IXRHIRF),M1IWRE08 Must be last in file
         END   ,                   File not empty
         ELSEIF (R15,NZ),M1IWRE08  Must be first block in file
         END   ,                   Append only

         LOOP  BEGIN               Write all the data

         IF    (IXRNT,Z),BEGIN     New user record
         BAS   RS,M1IWRIT8         Get a new user block number
         ST3   RVR,IXRNT           Set new block number
         IF    ((M.IXRNT,Z),AND,(M.IXRLWRC,Z)),BEGIN
         MVC   M.IXRLWRC,#WRIIXRN  Set low record index
         END   ,
         ELSEIF (#WRIIXRN,LT,M.IXRLWRC),BEGIN
         MVC   M.IXRLWRC,#WRIIXRN  Set low record index
         END   ,
         IF    (#WRIIXRN,GT,M.IXRHIRC),'MVC M.IXRHIRC,#WRIIXRN'
         CLC   S.IXRLWRF,#WRICBLK+1
         IF    (GT,OR,(S.IXRNRCS,Z)),'MVC S.IXRLWRF,#WRICBLK+1'
         CLC   S.IXRHIRF,#WRICBLK+1
         IF    LT,'MVC S.IXRHIRF,#WRICBLK+1'
         INCR  R14,S.IXRNRCS       One more user record
         INCR  R14,S.IXRRRCS       One more total record
         SET   #WRIFSIX            First IXR needs writing
         IF    (RY,NE,RJ),'SET #WRIFIXR' Other IXR needs writing
         END   ,                   New user record

         IF    (RQILEN,NZ),BEGIN
         CHKMEM RQIDAT,RQILEN      Make sure memory not released
         IF    (RVR,NZ),M1IWRE_4   IO error
         END   ,

         L     R15,#WRILCNT        Set len
         IF    (R15,LE,FSBDSZ),'CLEAR #WRILCNT' Enough room on block
         ELSE  BEGIN               Get all this block
         LH    R15,FSBDSZ          Set length to write
         L     R14,#WRILCNT        Get count remaining
         SR    R14,R15             Calc new count remaining
         ST    R14,#WRILCNT        Set
         END   ,                   Set count left to write

         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDOBLK,IXRNT       Block number
         PMOV  @FDODATA,#WRIUSE    Use this block
         PMOV  @FDODATL,(R15)      Data length
         PMOV  @FDOTYPE,LA:FBHTUSER Set to user record
         SET   @FDOFW+@FDOFUSE     Indicate write user record
         LH    RS,FSBDSZ           Get len
         L     RVR,#WRIUSE         Point to user IO buffer
         L     R14,RQIDAT          Point to user data
         A     R14,#WRIBCNT        Point past part already written
         MVCL  RVR,R14             Move the data to write
         LH    R14,@FDODATL        Get length written
         A     R14,#WRIBCNT        Calc total bytes written
         ST    R14,#WRIBCNT        Set

         VCALL FDOIODO             Write user record
         IF    (RVR,NZ),M1IWRE_4   IO error

         IF    (#WRILCNT,Z),EXIT   No more data

         LA    RX,IXR+L'IXRNT      Point to next user block number
         INCR  R15,#WRICBLK        Increment current block number
         INCR  R15,#WRIIXRN        Increment current block no in IXR
         IF    (RX,GE,RK),BEGIN    Use next IXR
         IF    #WRIFIXR,BEGIN      IXR needs writing
         CLEAR #WRIFIXR            Next one might not
         LR    R14,RJ
         BAS   RS,M1IWRIT5         Write the IXR
         END   ,                   IXR needs writing
         CLEAR #WRIIXRN            Start at block zero
         INCR  RN
         L     R14,#WRIIXR         Get buffer pointer
         LR    R15,RN
         A     R15,RQFBLK
         BAS   RS,M1IWRIT6         Get IXR
         LR    RX,R14              Get IXR pointer
         ST    RX,#WRIIXR          Save buffer pointer
         LA    RJ,IXR              Point to the IXR
         LA    RK,IXR+(L'IXRNT*IXRNT#) Point past the end of IXR
         END   ,                   Use next IXR
         END   ,                   Write all the data

         CLEAR RQRETC              Set return code
         B     M1IWRITE

M1IWRITX LABEL ,                   IXR file

         CLEAR R14
         L     R15,RQFBLK
         BAS   RS,M1IWRIT6         Get first IXR
         LR    RX,R14              Get IXR pointer
         ST    RX,#WRIIXR          Save buffer pointer
*
* For append only, the block previous to the first one being written
* must currently be the last block in the file (or the first one
* being written must be block zero if there are currently no blocks
* in the file).
*
* MIXR append only edit
         IF    (^RQMPERM.FPW,AND,^IXRSIXR),BEGIN MIXR case
         L     R15,RQIBLK          Get block number to write
         IF    (IXRNRCS,NZ),BEGIN  File not empty
         DECR  R15                 Set to previous block
         IF    (R15,NE,IXRHIRC),M1IWRE08 Must be last block in MIXR
         END   ,                   File not empty
         ELSEIF (R15,NZ),M1IWRE08  Must be first block in file
         END   ,                   MIXR case
* Append only edit to follow for SIXR

         IF    (IXRSIXR,OR,(RQLBLK,GE,IXRNT#)),BEGIN Need SIXR buffer
         PSET  @SBGET
         PMOV  @SBGPOO,FSBRBT      Get another IO buffer
         VCALL SBUFGET
         MVC   #WRISIX,@SBGADR     Set SIXR buffer address
         END   ,                   File needs SIXR

         MVC   #WRILCNT,RQILEN     Get count of bytes to write
         L     RN,RQIBLK           Get block no requested
         ST    RN,#WRICBLK         Set last block processed
         CLEAR RM
         D     RM,=A(IXRNT#)       Calc IXR index
         STH   RN,#WRISIXN         Save IXR index in SIXR
         ST3   RM,#WRIIXRN         Save user index in IXR
         MH    RN,=Y(L'IXRNT)      Calc displacement into SIXR

         IF    IXRSIXR,BEGIN       SIXR record
         MVC   #WRIIXR,#WRISIX     Set IXR buffer address
         ST    RX,#WRISIX          Set SIXR buffer address
         LA    RY,IXR(RN)          Point to IXR block number in SIXR

         IF    ^RQMPERM.FPW,BEGIN  Append only edit
* Previous block must be in the last IXR
         L     R15,RQIBLK          Get block number to write
         DECR  R15                 Set to previous block
         CLEAR R14
         D     R14,=A(IXRNT#)      Calc IXR index
         IF    (R15,NE,IXRHIXR),M1IWRE08 Must be in last IXR
* When writting first in new IXR, last in previous IXR must exist
         IF    (S.IXRNT,Z),BEGIN   New IXR needed
         IF    (#WRIIXRN,NZ),M1IWRE08 Must be first block in new IXR
         LA    RJ,S.IXR            Point to IXR number
         SH    RJ,=Y(L'IXRNT)      Point to previous IXR number
         L     R14,#WRIIXR         Point to IXR buffer
         L3    R15,M.IXRNT         Get previous IXR number
         BAS   RS,M1IWRIT6         Get IXR
         LR    RX,R14              Get IXR pointer
         IF    (IXRHIRC,NE,IXRNT#-1),M1IWRE08 Previous blk must exist
         END   ,                   New IXR needed
         END   ,                   Append only edit
         BAS   RS,M1IWRIT7         Get the IXR
* Edit for append only when not the first in new IXR
         IF    (^RQMPERM.FPW,AND,(#WRIIXRN,NZ)),BEGIN Check append only
         L3    R15,#WRIIXRN        Get user record index
         DECR  R15                 Calc index for previous block in IXR
         IF    (R15,NE,IXRHIRC),M1IWRE08 Must be last block in IXR
         END   ,                   Check append only
* End of append edits
         END   ,                   SIXR record
         ELSEIF (RQLBLK,GE,IXRNT#),BEGIN Convert MIXR to SIXR
* If not a SIXR and last block number greater than max for MIXR
* then create a SIXR and make the MIXR the first IXR in the SIXR.
         L     RY,#WRISIX          Get SIXR buffer address
         SET   #WRIFSIX            SIXR needs saving
         MVC   S.IXRPREF,IXRPREF   Get header
         MVC   S.IXRECNO,RQFBLK+1  Set SIXR record number
         CLEAR S.IXRNIXR,S.IXRLWXR,S.IXRHIXR Init SIXR special counters
         SET   S:IXRSTATE.IXRMIXR+IXRSIXR Set to super IXR
         CLEAR S.IXRLWRC,S.IXRHIRC Not used in SIXR
* If the orginal MIXR not empty, it is now the first IXR
* so get a new block number, set it up and save it.
         IF    (IXRNRCS,NZ),BEGIN  Original MIXR not empty
         CLEAR IXRSTATE            Set to lowley IXR
         CLEAR IXRRRCS             Only used for MIXR/SIXR
         BAS   RS,M1IWRIT8         Get a new block number
         ST3   RVR,IXRECNO         Set new IXR number
         MVC   S.IXRNT,IXRECNO     Set IXR record number
         INCR  R14,S.IXRNIXR       Increment number of IXRs in file
         INCR  R14,S.IXRRRCS       Increment total number of blocks
         LA    R14,IXR             Set IXR address
         BAS   RS,M1IWRIT5         Write IXR
         END   ,                   Original MIXR not empty
         LA    RY,S.IXR(RN)        Point to IXR block number in SIXR
         BAS   RS,M1IWRIT7         Get the IXR
         END   ,                   Convert MIXR to SIXR
         ELSE  'CLEAR RY'          Indicate simple MIXR case

         L3    R15,#WRIIXRN        Get index to user block number
         MH    R15,=Y(L'IXRNT)     Calc displacement to block number
         LA    RX,IXR(R15)         Point to it

* Control 0 comes through here also for create a block (must
* not already exist).
         IF    (RQCONT,AND,(IXRNT,NZ)),M1IWRE12

         LOOP  BEGIN               Write all the data

         IF    (IXRNT,Z),BEGIN     New user record
         SET   #WRIFIXR            IXR needs writing
         BAS   RS,M1IWRIT8         Get a new user block number
         ST3   RVR,IXRNT           Set new block number
         L     RJ,#WRIIXR          Get IXR pointer
         INCR  R14,M.IXRNRCS       One more user record
         IF    ((#WRIIXRN,LT,M.IXRLWRC),OR,(M.IXRNRCS,EQ,1)),BEGIN
         MVC   M.IXRLWRC,#WRIIXRN  Set low record index
         END   ,
         IF    (#WRIIXRN,GT,M.IXRHIRC),'MVC M.IXRHIRC,#WRIIXRN'
         IF    (RY,Z),BEGIN        IXR is a MIXR
         INCR  R14,M.IXRRRCS       One more total record
         END   ,                   IXR is a MIXR
         ELSE  BEGIN               Increment in SIXR also
         SET   #WRIFSIX            SIXR needs to be filed also
         L     RJ,#WRISIX
         INCR  R14,M.IXRNRCS       One more user record
         INCR  R14,M.IXRRRCS       One more total record
         END   ,                   Increment in SIXR also
         END   ,                   New user record

         L     RK,#WRILCNT         Set len
         IF    (RK,LE,FSBDSZ),'CLEAR #WRILCNT' Enough room on block
         ELSE  BEGIN               Get all this block
         LH    RK,FSBDSZ           Set length to write
         L     R14,#WRILCNT        Get count remaining
         SR    R14,RK              Calc new count remaining
         ST    R14,#WRILCNT        Set
         END   ,                   Set count left to write

         IF    (RQILEN,NZ),BEGIN
         CHKMEM RQIDAT,RQILEN      Make sure memory not released
         IF    (RVR,NZ),M1IWRE_4   IO error
         END   ,

         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDOBLK,IXRNT       Block number
         PMOV  @FDODATA,#WRIUSE    Use this block
         PMOV  @FDODATL,(RK)       Data length
         PMOV  @FDOTYPE,LA:FBHTUSER Set to user record
         SET   @FDOFW+@FDOFUSE     Indicate write user record
         LR    R14,RK              Get count to write
         LH    RS,FSBDSZ           Get len
         L     RVR,#WRIUSE         Point to user IO buffer
         L     RJ,RQIDAT           Point to user data
         A     RJ,#WRIBCNT         Point past part already written
         MVCL  RVR,RJ              Move the data to write
         A     R14,#WRIBCNT        Calc total bytes written
         ST    R14,#WRIBCNT        Set

         VCALL FDOIODO             Write user record
         IF    (RVR,NZ),M1IWRE_4   IO error

         IF    (#WRILCNT,Z),EXIT   No more data

         LA    RX,IXR+L'IXRNT      Point to next user block number
         INCR  R15,#WRICBLK        Increment current block number
         INCR  R15,#WRIIXRN        Increment current block no in IXR
         L     RJ,#WRIIXR          Get IXR pointer
         LA    R15,M.IXR+(L'IXRNT*IXRNT#) Point past the end of IXR
         IF    (RX,GE,R15),BEGIN   Use next IXR
         IF    #WRIFIXR,BEGIN      IXR needs writing
         CLEAR #WRIFIXR            Next one might not
         L     R14,#WRIIXR         Set IXR address
         BAS   RS,M1IWRIT5         Write IXR
         END   ,                   IXR needs writing
         LA    RY,S.IXR+L'IXRNT    Point to next IXR number
         INCR  R14,#WRISIXN        Increment IXR disp in SIXR
         CLEAR #WRIIXRN            Start at block zero
         BAS   RS,M1IWRIT7         Get the IXR
         END   ,                   Use next IXR
         END   ,                   Write all the data

         CLEAR RQRETC              Set return code
         B     M1IWRITE
         LTORG ,

M1IWRIT5 LABEL ,
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,(R14)      Set IXR address
         ACALL FMIXRPUT            File the IXR away
         BR    RS

M1IWRIT6 LABEL ,
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,(R14)      Set buffer address
         PMOV  @IXRGBNO,(R15)      Set block number
         ACALL FMIXRGET            Get IXR record
         L     R14,@IXRGADR        Get buffer address
         BR    RS

M1IWRIT7 LABEL ,
         ST    RS,#WRIBASR
         L     RX,#WRIIXR          Get IXR IO buffer pointer
         IF    (S.IXRNT,Z),BEGIN   IXR record does not exist
         SET   #WRIFSIX            The SIXR needs filing
         BAS   RS,M1IWRIT8         Get a new block number
         ST3   RVR,S.IXRNT         Set new block number
         LR    RVR,RX
         LH    RS,FSBDSZ
         CLEAR R15
         MVCL  RVR,R14             Clear the buffer
         MVC   IXRECNO,S.IXRNT     Set IXR record number
         L     RJ,#WRISIX
         MVC   IXRNAME,M.IXRNAME   Get file name
         INCR  R14,M.IXRRRCS       Increment total number of blocks
         INCR  R14,M.IXRNIXR       Increment number of IXRs in file

         IF    (#WRISIXN,LT,M.IXRLWXR),'MVC M.IXRLWXR,#WRISIXN'
         IF    (M.IXRNIXR,EQ,=H'1'),'MVC M.IXRLWXR,#WRISIXN'
         IF    (#WRISIXN,GT,M.IXRHIXR),'MVC M.IXRHIXR,#WRISIXN'
         END   ,                   IXR record does not exist
         ELSE  BEGIN               IXR record exists
         L     R14,#WRIIXR         Set buffer address
         L3    R15,S.IXRNT         Set block number
         BAS   RS,M1IWRIT6         Get IXR record
         END   ,                   IXR record exists
         L     RS,#WRIBASR
         BR    RS

M1IWRIT8 LABEL ,
         IF    ^RQATMP,BEGIN       Not a temp file
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,=A(1)      Space needed
         VCALL FCATGSPA            Update catalog space
         IF    (RVR,NZ),M1IWRE16   Can't do it
         END   ,                   Not a temp file
         ELSE  BEGIN               Temp file
         ST    RS,#WRIBAS2
         L     RS,MATPTR
         WITH  (MAT,RS),'L RS,MATFILCB'
         WITH  (FILECB,RS),BEGIN
         INCRS TTFILTBK            Current attached temp files
         L     R14,TTFILTBM
         L     R15,TTFILTBK
         LOOP  BEGIN
         IF    (R15,LE,R14),EXIT   No new high water mark
         CS    R14,R15,TTFILTBM    Set new high water mark
         UNTIL Z,END
         END   ,
         L     RS,#WRIBAS2
         END   ,                   Temp file
         PSET  @FMFSB              Get a block number
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITGET
         IF    (RVR,Z),M1IWRE20    No more blocks
         BR    RS                  Return to caller

M1IWRE_4 LABEL ,
         MVC   RQRETC,=F'-4'
         B     M1IWRITE

M1IWRE04 LABEL ,
         MVC   RQRETC,=F'4'
         B     M1IWRITE

M1IWRE08 LABEL ,                   Can only append
         IF    ^RQCONT,M1IWRE12    Old orvyl returned 12 for write
         CLEAR #WRIFSIX,#WRIFIXR   Don't write either of these
         MVC   RQRETC,=F'8'
         B     M1IWRITE

M1IWRE12 LABEL ,
         CLEAR #WRIFSIX,#WRIFIXR   Don't write either of these
         MVC   RQRETC,=F'12'
         B     M1IWRITE

M1IWRE16 LABEL ,
         MVC   RQRETC,=F'16'
         B     M1IWRITE

M1IWRE20 LABEL ,
         MVC   RQRETC,=F'20'
         B     M1IWRITE

M1IWRITE LABEL ,

         IF    (^RQCNIXR,OR,RQCHYBR),BEGIN Not non-IXR
         MVC   RQRLEN,#WRIBCNT     Set count of bytes written
         L     R15,#WRICBLK        Get last block written
         INCR  R15
         ST    R15,RQRBLK          Set last block written + 1
         IF    #WRIFIXR,BEGIN      IXR needs saving
         L     R14,#WRIIXR
         BAS   RS,M1IWRIT5
         END   ,                   IXR needs saving
         IF    #WRIFSIX,BEGIN      SIXR needs saving
         L     R14,#WRISIX
         BAS   RS,M1IWRIT5
         END   ,                   SIXR needs saving
         END   ,                   Not non-IXR

         IF    (^RQARES,AND,(RQRGRH,NZ)),BEGIN
         GRREL RID=RQRGRH          Release file reserve
         CLEAR RQRGRH              Clear hold id
         END   ,

         LA    RM,#WRISIX          Release IO buffers
         LA    RN,3
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         LOOP  BEGIN
         MVC   @SBFADR,@RM
         IF    (@SBFADR,NZ),'VCALL SBUFREE'
         LA    RM,@RM+4
         UNTIL (BCT,RN),END

         PEND  ,
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FCONT - File CONTROL processing, preliminary edits
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1FCONT  PROC
         WITH  (RQWB,RA)
         L     RB,RQFSB
         WITH  (FSB,RB)

         L     R14,RQICON          Get control type
         LC    R15,M1FCIOTP(R14)   Get IO type
         SLL   R14,3               Times eight
         A     R14,=A(RTNTABC)     Point to control routine address
         IF    ((R14,LT,=A(RTNTABC)),OR,(R14,GT,=A(RTNTABCM))),M1FCSPEC

         IF    (FSBANAVL),M1FCEM12 File system unavailable
         IF    (R15,NZ),BEGIN      Write IO type
         IF    FSBARO,M1FCEM12     File in read only mode
         END   ,

         L     R14,@R14            Get routine address
         BR    R14                 Go to routine

M1FC02   LABEL ,                   Delete a range of file blocks

         IF    RQCHYBR,BEGIN
         L     R14,RQBLKC          Get block count
         MH    R14,=Y(IXRNT#)      Each block is an IXR
         IF    (R14,LE,RQICBL2),M1FCSPEC Check against block count
         END   ,
         ELSEIF (RQICBL2,GE,=A(IXRMXNT#)),M1FCSPEC
         IF    (RQICBLK,GT,RQICBL2),M1FCSPEC

M1FC00   LABEL ,                   Create a file block

M1FC01   LABEL ,                   Delete a file block
         IF    RQCHYBR,BEGIN
         L     R14,RQBLKC          Get block count
         MH    R14,=Y(IXRNT#)      Each block is an IXR
         IF    (R14,LE,RQICBLK),M1FCSPEC Check against block count
         END   ,
         ELSEIF (RQICBLK,GE,=A(IXRMXNT#)),M1FCSPEC
         IF    ((RQICON,NZ),OR,^RQMPERM.FPA),BEGIN Ctl 0 and append ok
         IF    ^RQMPERM.FPW,M1FCEW08 Need write access
         END   ,
         IF    (RQCNIXR,AND,^RQCHYBR),M1FCSPEC
         B     M1FCDOIO

M1FC03   LABEL ,                   Test for file block existence
         IF    RQCHYBR,BEGIN       Hybrid file
         L     R14,RQBLKC          Count of IXRs
         MH    R14,=Y(IXRNT#)      Max count of user RECs
         IF    (R14,LE,RQICBLK),M1FCSPEC
         END   ,                   Hybrid file
         ELSEIF RQCNIXR,BEGIN      Non-IXR files
         IF    (RQICBLK,GE,RQBLKC),M1FCEW12 Does not exist
         B     M1FCEW00            Done
         END   ,                   Non-IXR files
         ELSE  BEGIN               IXR file
         IF    (RQICBLK,GE,=A(IXRMXNT#)),M1FCSPEC
         END   ,                   IXR file
         B     M1FCDOIO            Continue

M1FC04   LABEL ,                   Obtain first block number
         IF    (RQCNIXR,AND,^RQCHYBR),BEGIN Non-IXR files
         CLEAR RQWCBK              Zero is first
         B     M1FCEW00            Done
         END   ,                   Non-IXR files

         B     M1FCDOIO            Continue

M1FC05   LABEL ,                   Obtain last block number
         IF    (RQCNIXR,AND,^RQCHYBR),BEGIN Non-IXR files
         L     R14,RQBLKC          Get count of blocks
         DECR  R14                 Relative to zero for block number
         ST    R14,RQWCBK          Set last block number
         B     M1FCEW00            Done
         END   ,                   Non-IXR files
         B     M1FCDOIO            Continue

M1FC06   LABEL ,                   Obtain count of user blocks
         IF    (RQCNIXR,AND,^RQCHYBR),BEGIN Non-IXR files
         MVC   RQWUSB,RQBLKC       Get block count
         MVC   RQWBIB,RQBLKC       Billable blocks
         B     M1FCEW00            Done
         END   ,                   Non-IXR files
         B     M1FCDOIO            Continue

M1FC07   LABEL ,                   Update file index
         B     M1FCEW00            Done

M1FC08   LABEL ,                   Erase or rename a file
         IF    RQASHR,M1FCEM04     Can't be attached in share mode
         IF    RQATMP,M1FCSPEC     Can't be a temp file
         IF    (RQICLOC,NZ),BEGIN  Rename option
         IF    ^RQMPERM.FPW,M1FCEW08 Need write access
         IF    (RQICLEN,Z),M1FCSPEC Can't rename to nothing
         IF    (RQICLEN,GT,=A(L'RQNAME)),M1FCEM08
         IF    (RQICLEN,LE,=A(1)),M1FCEM08
         CHKMEM RQICLOC,L:RQICLEN  Check read access
         IF    (RVR,NZ),'EXIT M1FCONT' Denied
         MVC   RQWKNAME,RQNAME      Save file name
         CLEAR RQNAME
         PSET  @SETFNAM
         PMOV  @SETFNA,RQICLOC
         PMOV  @SETFNL,RQICLEN
         ACALL SETFNAME            Set file name
         IF    (RVR,NZ),M1FCERVR   Invalid name
         IF    (RQNPFX,NE,RQWKNAME),M1FCER04 Can't rename this part
         IF    (RQNAME,EQ,RQWKNAME),M1FCEM08 That's dumb
         END   ,                   Rename option
         ELSE  BEGIN               Erase option
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    ^RQMPERM.FPW,M1FCEW08 Need write access
         END   ,
         IF    (RQFBLK,EQ,FSBCATSB),M1FCEW08 Can't erase catalog
         IF    (RQFBLK,EQ,FSBBITSB),M1FCEW08 Can't erase bitmap
         END   ,                   Erase option
         B     M1FCDOIO            Done

M1FC09   LABEL ,                   Assigning Account Level File Priv
         IF    RQATMP,M1FCSPEC     Can't be a temp file
         IF    (RQICUSA,NZ),BEGIN  Account specified
         IF    ^RQAPERM.FPW+FPE,M1FCEW08 Need write and extend priv
         CHKMEM RQICUSA,LA:L'RQACCNA Check memory read
         IF    (RVR,NZ),'EXIT M1FCONT' Denied
         L     R14,RQICUSA
         MVC   RQACCNA,@R14        Get account
         CHKACC RQACCNA            Edit account
         IF    (RVR,EQ,-8),M1FCERVR Exit if error
         END   ,                   Account specified
         ELSE  BEGIN               Update owner privileges (file mask)
         IF    (^RQAOWN,AND,^RQAMAG),M1FCER04 Can't do it
         END   ,                   Update owner privileges
         B     M1FCDOIO            Done

M1FC10   LABEL ,                   Assigning public file privileges
         IF    ^RQAPERM.FPW,M1FCEW08 Need write access
         IF    (^RQAOWN,AND,^RQAMAG),M1FCER04 Can't do it
         B     M1FCTEMP            Check temp

M1FC11   LABEL ,                   Reading File Access Privileges
         IF    (RQICLEN,NZ),BEGIN  If buffer provided
         IF    (RQICLEN,LT,=A(L'NTRYPR)),M1FCSPEC One member at least
         CHKMEM RQICLOC,L:RQICLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FCONT' Denied
         END   ,
         B     M1FCTEMP            Check temp

M1FC12   LABEL ,                   Set share only mode for attach
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    ^RQAPERM.FPW,M1FCEW08 Need write access
         IF    (^RQAOWN,AND,^RQAMAG),M1FCER04 Can't do it
         END   ,
         B     M1FCTEMP            Check temp

M1FC14   LABEL ,                   Set file format field
         IF    ^RQMPERM.FPW,M1FCEW08 Need write access
         B     M1FCTEMP            Check temp

M1FC16   LABEL ,                   Set file NOCLP condition
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    ^RQAPERM.FPW,M1FCEW08 Need write access
         IF    (^RQAOWN,AND,^RQAMAG),M1FCER04 Can't do it
         END   ,
         B     M1FCTEMP            Check temp

M1FC18   LABEL ,                   Set file CLP only condition
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    ^RQAPERM.FPW,M1FCEW08 Need write access
         IF    (^RQAOWN,AND,^RQAMAG),M1FCER04 Can't do it
         END   ,
         B     M1FCTEMP            Check temp

M1FC20   LABEL ,                   Sense file type
         IF    RQCHYBR,M1FCEW28
         IF    RQCNIXR,M1FCEW12
         B     M1FCEW00            Done

M1FC21   LABEL ,                   Set Spires Only status
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    ^RQAPERM.FPW,M1FCEW08 Need write access
         IF    (^RQAOWN,AND,^RQAMAG),M1FCER04 Can't do it
         END   ,
         B     M1FCTEMP            Check temp

M1FC23   LABEL ,                   Sense file blocksize
         LH    R14,FSBDSZ
         ST    R14,RQWDSZ          Set file blocksize
         B     M1FCEW00            Done

M1FC24   LABEL ,                   Obtain maximum number of blocks
         IF    RQACLP,'CLEAR RQWHIXR' Clear number of IXRs
         IF    RQCNIXR,BEGIN       Non-IXR file
         L     R14,RQBLKC          Get block count
         IF    RQCHYBR,BEGIN       Hybrid
         IF    RQACLP,'ST R14,RQWHIXR' Set IXR count
         MH    R14,=Y(IXRNT#)      Calc max user blocks
         END   ,                   Hybrid
         ST    R14,RQWHFSZ         Set total file capacity
         END   ,                   Non-IXR file
         ELSE  BEGIN               IXR file
         MVC   RQWHFSZ,=A(IXRMXNT#) Set maximum user blocks
         END   ,                   IXR file
         B     M1FCEW00            Done

M1FC25   LABEL ,                   Convert file to hybrid file
         IF    ^RQAPERM.FPW,M1FCEW08 Need write access
         IF    RQASHR,M1FCEM04     Can't be attached in share mode
         IF    ('LT R15,RQICBLK',NP),M1FCSPEC
         IF    (R15,GT,=A(16700000)),M1FCSPEC
         B     M1FCTEMP            Check temp

M1FCEW00 LABEL ,
         CLEAR RQWRETC             Set wait return
         B     M1FCNOIO

M1FCEW08 LABEL ,
         MVC   RQWRETC,=F'8'       Set not authorized wait return
         B     M1FCNOIO

M1FCEW12 LABEL ,
         MVC   RQWRETC,=F'12'      Does not exist
         B     M1FCNOIO

M1FCEW28 LABEL ,
         MVC   RQWRETC,=F'28'      Does not exist
         B     M1FCNOIO

M1FCERVR LABEL ,
         ST    RVR,RQRETC          Set error return code
         LA    RVR,1               No IO necessary
         EXIT  M1FCONT

M1FCEM04 LABEL ,
         MVC   RQRETC,=F'-4'
         LA    RVR,1               No IO necessary
         EXIT  M1FCONT

M1FCEM08 LABEL ,
         MVC   RQRETC,=F'-8'
         LA    RVR,1               No IO necessary
         EXIT  M1FCONT

M1FCEM12 LABEL ,
         MVC   RQRETC,=F'-12'
         LA    RVR,1               No IO necessary
         EXIT  M1FCONT

M1FCER04 LABEL ,
         MVC   RQRETC,=F'4'
         LA    RVR,1               No IO necessary
         EXIT  M1FCONT

M1FCSPEC LABEL ,
         L     RVR,=X'80000006'    Specification
         EXIT  M1FCONT

M1FCNOIO LABEL ,
         LA    RVR,1               No IO necessary
         CLEAR RQRETC
         EXIT  M1FCONT

M1FCTEMP LABEL ,
         IF    RQATMP,M1FCSPEC     Can't be a temp file
M1FCDOIO LABEL ,
         CLEAR RQRETC,RVR          IO necessary

         PEND  ,
M1FCIOTP DC    3AL1(1)                 CONTROLS 0-2 DO WRITES
         DC    4AL1(0)                 CONTROLS 3-6 DO READS
         DC    3AL1(1)                 CONTROLS 7-9 DO WRITES
         DC    5AL1(1,0)               CONTROLS 10-19 ALTERNATE
         DC    AL1(0)                  CONTROL 20 READS
         DC    AL1(1)                  CONTROL 21 WRITES
         DC    AL3(0)                  CONTROL 22-24 READS
         DC    AL1(1)                  CONTROL 25 WRITES
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1ICONT - File CONTROL processing, IO part
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
#ICONT   RECORD BEGIN
#ICONBU1 DS    A                   IO buffer address
#ICONBU2 DS    A                   IO buffer address
#ICONBU3 DS    A                   IO buffer address
#ICONBU4 DS    A                   IO buffer address
#ICONBLK DS    A                   First block
#ICONCNT DS    A                   Count of blocks
#ICONFLG FLAG  ,
         FLAG  #ICONSET
         END   ,

M1ICONT  PROC  ,#ICONT
         WITH  (RQWB,RA)
         L     RB,RQFSB
         WITH  (FSB,RB)
         WITH  (IXR,RX)            IXR
         WITH  (IXR,RY),LABEL=S    Super IXR record
         WITH  (IXR,RJ),LABEL=F    First hybrid IXR record
         WITH  (IXR,RK),LABEL=H    Hybrid IXR record
         CLEAR #ICONT

         L     RS,RQICON           Get control type
         SLL   RS,3                Times eight
         L     RS,RTNTABC+4(RS)    Point to control routine
         BR    RS                  Just do it

M1IC00   LABEL ,                   Create a file block
         MVC   RQIBLK,RQICBLK      Set up to call write routine
         MVC   RQLBLK,RQICBLK
         LA    R14,RQVARI
         ST    R14,RQIDAT
         CLEAR RQILEN
         ACALL M1IWRIT             Write code is the same
         EXIT  M1ICONT             Done

M1IC01   LABEL ,                   Delete a file block
         MVC   RQICBL2,RQICBLK     End of range
M1IC02   LABEL ,                   Delete a range of file blocks
         BAS   RS,M1ICXRES         Get reserve
         BAS   RS,M1ICGIXR         Get IXR
         L     RS,IXRRRCS          Get before block count
         PSET  @BLKDEL
         PMOV  @BLKDRQW,LA:RQWB
         PMOV  @BLKDADR,LA:IXR
         ACALL FMDELBLK            Delete the blocks
         LR    RN,RVR              Save return code
         IF    (RQICON,EQ,2),BEGIN
         MVC   RQRCBK,@BLKDCNT     Set number of blocks deleted
         END   ,
         S     RS,IXRRRCS          Calc real blocks deleted
         IF    P,BEGIN             Some deleted
         IF    ^RQATMP,BEGIN       Not a temp file
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,(RS)       Space released
         VCALL FCATPSPA            Update catalog space
         END   ,                   Not a temp file
         ELSE  BEGIN               Temp file
         L     RM,MATPTR
         WITH  (MAT,RM),'L RM,MATFILCB'
         WITH  (FILECB,RM),BEGIN
         L     R14,TTFILTBK
         LOOP  BEGIN
         LR    R15,R14
         SR    R15,RS              Calc new number of temp blocks
         CS    R14,R15,TTFILTBK    Set new number of temp blocks
         UNTIL Z,END
         END   ,
         END   ,                   Temp file
         END   ,                   Some deleted
         LR    RVR,RN              Restore return code
         B     M1ICERVR            Exit

M1IC03   LABEL ,                   Test for file block existence
         BAS   RS,M1ICSRES         Get reserve
         BAS   RS,M1ICGIXR         Get IXR
         IF    (IXRNRCS,Z),M1ICEX12 No blocks at all
         L     RN,RQICBLK          Get block number
         CLEAR RM
         IF    RQCHYBR,BEGIN       Hybrid file
         D     RM,=A(IXRNT#)       Calc IXR number
         IF    (RN,NZ),BEGIN       Already have the first one
         A     RN,RQFBLK           Calc IXR block number
         LR    R14,RN              Get block number
         LA    R15,IXR             Use same buffer
         BAS   RS,M1ICGIX2         Get IXR
         END   ,                   Already have the first one
         LR    RN,RM               Get remainder
         END   ,                   Hybrid file
         ELSE  BEGIN               IXR file
         IF    IXRSIXR,BEGIN       Super IXR
         D     RM,=A(IXRNT#)       Calc IXR index
         MH    RN,=Y(L'IXRNT)      Calc displacement to block number
         LA    RY,IXR(RN)          Point to it
         IF    (S.IXRNT,Z),M1ICEX12 It does not exist
         L3    R14,S.IXRNT         Get block number
         LA    R15,IXR             Use same buffer
         BAS   RS,M1ICGIX2         Get IXR
         LR    RN,RM               Get remainder
         END   ,                   Super IXR
         ELSE  BEGIN               MIXR record
         IF    (RN,GE,IXRNT#),M1ICEX12 It does not exist
         END   ,                   MIXR record
         END   ,                   IXR record
         MH    RN,=Y(L'IXRNT)      Calc displacement to block number
         LA    RY,IXR(RN)          Point to it
         IF    (S.IXRNT,Z),M1ICEX12 Does not exist
         B     M1ICEX00            Does indeed exist

M1IC04   LABEL ,                   Obtain first block number
         BAS   RS,M1ICSRES         Get reserve
         BAS   RS,M1ICGIXR         Get IXR
         IF    (IXRNRCS,Z),M1ICEX12 No blocks at all
         IF    RQCHYBR,BEGIN       Hybrid file
         L3    RN,IXRLWRF          Get first block number
         END   ,                   Hybrid file
         ELSE  BEGIN               IXR file
         IF    IXRSIXR,BEGIN       Super IXR
         LH    RY,IXRLWXR          Lowest IXR
         LR    RN,RY               Save
         MH    RY,=Y(L'IXRNT)      Calc displacemenet
         LA    RY,IXR(RY)          Point to IXR number
         L3    R14,S.IXRNT         Get block number
         LA    R15,IXR             Use same buffer
         BAS   RS,M1ICGIX2         Get IXR
         MH    RN,=Y(IXRNT#)       Calc first block number this IXR
         L3    R14,IXRLWRC         Get first existing block this IXR
         AR    RN,R14              Calculate first block number
         END   ,                   Super IXR
         ELSE  BEGIN
         L3    RN,IXRLWRC          Set first block number
         END   ,
         END   ,                   IXR file
         ST    RN,RQRCBK           Set first block number return
         B     M1ICEX00            Exit

M1IC05   LABEL ,                   Obtain last block number
         BAS   RS,M1ICSRES         Get reserve
         BAS   RS,M1ICGIXR         Get IXR
         IF    (IXRNRCS,Z),M1ICEX12 No blocks at all
         IF    RQCHYBR,BEGIN       Hybrid file
         L3    RN,IXRHIRF          Get last block number
         END   ,                   Hybrid file
         ELSE  BEGIN               IXR file
         IF    IXRSIXR,BEGIN       Super IXR
         LH    RY,IXRHIXR          Highest IXR
         LR    RN,RY               Save
         MH    RY,=Y(L'IXRNT)      Calc displacemenet
         LA    RY,IXR(RY)          Point to IXR number
         L3    R14,S.IXRNT         Get block number
         LA    R15,IXR             Use same buffer
         BAS   RS,M1ICGIX2         Get IXR
         MH    RN,=Y(IXRNT#)       Calc last block number this IXR
         L3    R14,IXRHIRC         Get last existing block this IXR
         AR    RN,R14              Calculate last block number
         END   ,                   Super IXR
         ELSE  BEGIN
         L3    RN,IXRHIRC          Set last block number
         END   ,
         END   ,                   IXR file
         ST    RN,RQRCBK           Set last block number return
         B     M1ICEX00            Exit

M1IC06   LABEL ,                   Obtain total number of blocks
         BAS   RS,M1ICSRES         Get reserve
         BAS   RS,M1ICGIXR         Get IXR
         MVC   RQRUSB,IXRNRCS      Number of user blocks
         MVC   RQRBIB,IXRRRCS      Number of billable blocks
         B     M1ICEX00            Exit

M1IC08   LABEL ,                   Erasing and renaming files
         BAS   RS,M1ICXRES         Get reserve
         WITH  ((AHFB,RJ),(ATFB,RM)),BEGIN
         IF    (RQICLOC,NZ),BEGIN  Rename option
         PSET  @FCRNAME
         PMOV  @FCRNFSB,LA:FSB
         MVC   @FCRNAM1,RQWKNAME+4 File name
         PMOV  @FCRNAM2,RQNAM2     New file name
         VCALL FCATRNAM            Rename
         IF    (RVR,NZ),M1ICERVR   Exit on error
         PSET  @HASH
         PMOV  @HSHSTR,LA:RQNAME   File name
         PMOV  @HSHLEN,LA:L'RQNAME Length
         PMOV  @HSHVAL,LA:AHFBCNT  Hash value
         SET   @HSHBLNK            Don't use trailing blanks
         VCALL HASHIT              Calculate hash number
         LR    RK,RVR              Get hash number
         L     RJ,FSBAHFB          Get file attach hash table ptr
         L     RM,RQATFB           Point to attached file block
         GRGET RID=AHFBGRID,EXCL=YES Reserve the table
         L     RN,ATFBATL          Point to hash list
         WITH  (AHFBL,RN),BEGIN
         LREM  AHFBL,LA:ATFB,WR=RS Remove from list
         END   ,
         MVC   ATFBNAME,RQNAMS     Set new name
         MH    RK,=Y(L'AHFBL)      Calculate index
         LA    RN,AHFBL(RK)        Point to queue
         ST    RN,ATFBATL          Set new hash list pointer
         WITH  (AHFBL,RN),BEGIN
         LADD  AHFBL,LA:ATFB,WR=RS Add to the new list
         END   ,
         GRREL RID=AHFBGRID
         IF    ^RQCNIXR,BEGIN      IXR file
         BAS   RS,M1ICGIXR         Get IXR
         MVC   IXRNAME(L'RQNAMS),RQNAMS Set new file name
         LA    R15,IXR
         BAS   RS,M1ICPIXR         Put IXR
         IF    IXRSIXR,BEGIN       Super IXR
         LR    RY,RX               Set SIXR address
         LA    RN,IXRIXNT#         Count of IXRs in super IXR
         CLEAR RX
         LOOP  BEGIN               Put the new name in all IXRs
         IF    (S.IXRNT,NZ),BEGIN  IXR exists
         L3    R14,S.IXRNT         Get block number
         LA    R15,IXR             Use same buffer
         BAS   RS,M1ICGIX2         Get IXR
         LR    RX,R15              Get IXR address
         MVC   IXRNAME(L'RQNAMS),RQNAMS Set new file name
         BAS   RS,M1ICPIXR         Put IXR back
         END   ,                   IXR exists
         LA    RY,S.IXR+L'IXRNT    Increment SIXR pointer
         UNTIL (BCT,RN),END        Put the new name in all IXRs
         ST    RX,#ICONBU2         Save buffer pointer
         END   ,                   Super IXR
         END   ,                   IXR file
         ELSEIF RQCHYBR,BEGIN      Hybrid file
         L     RM,RQFBLK           Get first IXR block number
         L     RN,RQBLKC           Get IXR count
         CLEAR RX
         LOOP  BEGIN               Put the new name in all IXRs
         LR    R14,RM              Get block number
         LA    R15,IXR             Use same buffer
         BAS   RS,M1ICGIX2         Get IXR
         LR    RX,R15              Get pointer
         MVC   IXRNAME(L'RQNAMS),RQNAMS Set new file name
         BAS   RS,M1ICPIXR         Put IXR back
         INCR  RM                  Next block
         UNTIL (BCT,RN),END        Put the new name in all IXRs
         ST    RX,#ICONBU2         Save buffer pointer
         END   ,                   Hybrid file
         END   ,                   Rename option
         ELSE  BEGIN               Erase option
         PSET  @FCDLETE
         PMOV  @FCDLFSB,LA:FSB
         PMOV  @FCDLNAM,RQNAMS
         VCALL FCATDLET            Delete the name from the catalog
         IF    (RVR,NZ),M1ICERVR   Exit on error
         L     R14,RQATFB
         WITH  (ATFB,R14),'CLEAR ATFBNAME' Indicated deleted
         SET   RQRFRE              Free RQFB
         IF    (^RQCNIXR,OR,RQCHYBR),BEGIN IXR or hybrid
         BAS   RS,M1ICGIXR         Get IXR
         CLEAR #ICONBU1            Don't release this buffer
         L     RK,IXRRRCS          Number of blocks
         END   ,                   IXR or hybrid
         ELSE  BEGIN               Non-IXR
         L     RK,RQBLKC           Number of blocks
         L     RX,RQFBLK           First block number
         END   ,                   Non-IXR
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,(RK)       Space released
         VCALL FCATPSPA            Update catalog space
         ADFCB ,                   Address file control block
         SAVAIL HEAD=FILEDB,LEN=L'FDEL
         WITH  (FDEL,RK)
         LR    RK,RVR              Get pointer
         CLEAR FDEL
         MVC   FDELID,=C'FILD'
         ST    RB,FDELF            FSB
         ST    RX,FDELB            First IXR
         MVC   FDELC,RQBLKC        Block count (non-ixr or hybrid)
         IF    RQCNIXR,'SET FDELFN' Non-ixr
         IF    RQCHYBR,'SET FDELFH' Hybrid
         SPUSH HEAD=FILEDF,ITEM=FDEL Put on list of things to do
         TS    FILEDTS
         IF    Z,BEGIN
         SIGNL FILEDECB,,FILEDASB,FILEDSYR Been waiting long?
         END   ,
         END   ,                   Erase option
         END   ,                   With
         B     M1ICEX00            Exit

M1IC09   LABEL ,                   Assigning Account Level File Priv
         IF    (RQICUSA,Z),BEGIN   User not specified
         PSET  @FCUINFO            Update owner permits
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         L     R14,RQICINF
         STC   R14,@FCUINF
         SET   @FCUIOWN
         VCALL FCATUINF            Set info
         IF    (RVR,NZ),M1ICERVR   Exit if error
         L     R14,RQICINF         Get permits
         N     R14,=A(FPALL)       Clear unnecessary
         L     R15,RQATFB
* Note: no locking necessary with STC
         WITH  (ATFB,R15),'STC R14,ATFBMASK' Set file mask

* Eventially do not maintain file mask in IXRSTATE    ***
* Removed in spring of 2002
*         IF    ^RQCNIXR,BEGIN      IXR file           ***
*         BAS   RS,M1ICXRES         Get reserve        ***
*         BAS   RS,M1ICGIXR         Get IXR            ***
*         L     R14,RQICINF         Get permits        ***
*         N     R14,=A(FPALL)       Clear unnecessary  ***
*         NI    IXRSTATE,255-FPALL  Clear permits      ***
*         LC    R15,IXRSTATE        Get flags          ***
*         OR    R15,R14             Set new permits    ***
*         STC   R15,IXRSTATE        Reset              ***
*         LA    R15,IXR             Set IXR            ***
*         BAS   RS,M1ICPIXR         Put IXR back       ***
*         END   ,                                      ***
* File mask maintained in IXRSTATE will be obsolete   ***

         B     M1ICEX00
         END   ,                   User not specified
         ELSE  BEGIN               User is specified
         PSET  @FCASACC
         PMOV  @FCASFSB,LA:FSB
         PMOV  @FCASUSR,RQACCNA    User receiving privileges
         PMOV  @FCASUSE,RQFACC     User extending privileges
         PMOV  @FCASNAM,RQNAMS     File name
         L     R14,RQICINF
         STC   R14,@FCASPRI        Set permits
         IF    RQAMAG,'SET @FCASFM' Set to magic account
         VCALL FCATASAC            Go do it
         B     M1ICERVR            Exit
         END   ,                   User is specified

M1IC10   LABEL ,                   Assigning PUBLIC File Privileges
         PSET  @FCUINFO
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         L     R14,RQICINF
         STC   R14,@FCUINF
         SET   @FCUIPUB
         VCALL FCATUINF            Set info
         B     M1ICERVR            Exit

M1IC11   LABEL ,                   Reading File Access Privileges
         PSET  @FCGPERM
         PMOV  @FCGPFSB,LA:FSB
         PMOV  @FCGPLOC,RQICLOC    Privilege buffer
         PMOV  @FCGPLEN,RQICLEN    Buffer length
         PMOV  @FCGPNAM,RQNAMS     File
         SET   @FCGPFF             File request
         IF    (RQAOWN,OR,RQAMAG),'SET @FCGPFM' Set to magic account
         VCALL FCATGPRM            Go do it
         IF    (RVR,Z),BEGIN
         MVC   RQRPCNT,@FCGPCNT    Get count of users
         LC    R14,@FCGPPP         Get public privileges
         SLL   R14,8               Put into next byte
         IC    R14,@FCGPMS         Get file mask
         ST    R14,RQRPRIV         Set return
         END   ,
         B     M1ICERVR            Exit

M1IC12   LABEL ,                   Set share only mode
         PSET  @FCUINFO
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         SET   @FCUISHR            Set share info
         IF    (RQICINF,NZ),'SET @FCUISHO' Set share on
         VCALL FCATUINF            Set info
         B     M1ICERVR            Exit

M1IC13   LABEL ,                   Sense share only mode
         PSET  @FCFINFO
         PMOV  @FCFFSB,LA:FSB
         PMOV  @FCFNAM,RQNAMS
         VCALL FCATFINF            Get file info
         WITH  (NTFLOC,@FCFINF),BEGIN
         IF    NTFPSHR,M1ICEX12    Share only mode
         END   ,                   With
         B     M1ICEX00            Exit

M1IC14   LABEL ,                   Set format field
         PSET  @FCUINFO
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         PMOV  @FCUINF,RQICINF
         SET   @FCUIUIN
         IF    RQFORM,'SET @FCUIFRM'
         VCALL FCATUINF            Set info
         B     M1ICERVR            Exit

M1IC15   LABEL ,                   Sense file format field
         PSET  @FCFINFO
         PMOV  @FCFFSB,LA:FSB
         PMOV  @FCFNAM,RQNAMS
         VCALL FCATFINF            Get file info
         WITH  (NTFLOC,@FCFINF),BEGIN
         MVC   RQRFORM,NTFUINFO    Get format field
         IF    ^NTFSFORM,M1ICEX12  Format option not set
         END   ,                   With
         B     M1ICEX00            Exit

M1IC16   LABEL ,                   Set file NOCLP condition
         PSET  @FCUINFO
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         SET   @FCUINCL            Set NOCLP info
         IF    (RQICINF,NZ),'SET @FCUINCO' Set NOCLP on
         VCALL FCATUINF            Set info
         B     M1ICERVR            Exit

M1IC17   LABEL ,                   Sense file NOCLP condition
         PSET  @FCFINFO
         PMOV  @FCFFSB,LA:FSB
         PMOV  @FCFNAM,RQNAMS
         VCALL FCATFINF            Get file info
         WITH  (NTFLOC,@FCFINF),BEGIN
         IF    NTFNOCLP,M1ICEX12   NOCLP option set
         END   ,                   With
         B     M1ICEX00            NOCLP option not set

M1IC18   LABEL ,                   Set file CLP only condition
         PSET  @FCUINFO
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         SET   @FCUICLP            Set CLP info
         IF    (RQICINF,NZ),'SET @FCUICLO' Set CLP on
         VCALL FCATUINF            Set info
         B     M1ICERVR            Exit

M1IC19   LABEL ,                   Sense file CLP only condition
         PSET  @FCFINFO
         PMOV  @FCFFSB,LA:FSB
         PMOV  @FCFNAM,RQNAMS
         VCALL FCATFINF            Get file info
         WITH  (NTFLOC,@FCFINF),BEGIN
         IF    NTFCLP,M1ICEX12     CLP option set
         END   ,                   With
         B     M1ICEX00            CLP option not set

M1IC21   LABEL ,                   Set spires only flag
         PSET  @FCUINFO
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         SET   @FCUISPI            Set spires info
         IF    (RQICINF,NZ),'SET @FCUISPO' Set spires on
         VCALL FCATUINF            Set info
         B     M1ICERVR            Exit

M1IC22   LABEL ,                   Sense spires only flag
         PSET  @FCFINFO
         PMOV  @FCFFSB,LA:FSB
         PMOV  @FCFNAM,RQNAMS
         VCALL FCATFINF            Get file info
         WITH  (NTFLOC,@FCFINF),BEGIN
         IF    NTFSPI,M1ICEX12     Spires only
         END   ,
         B     M1ICEX00            Not spires only

M1IC25   LABEL ,                   Convert file to hybrid file
*
* Convert a file (IXR, non-IXR, or hybrid) into a hybrid file.
* Typically the new hybrid file would have a much larger capacity
* than the file being converted.
*
* Calculate number of IXRs needed for hybrid file
         CLEAR RM
         L     RN,RQICBLK          Get block count
         LA    RN,@RN+IXRNT#-1     Rount up
         D     RM,=A(IXRNT#)       Calc IXRs needed
         ST    RN,#ICONCNT         Save IXR count

         BAS   RS,M1ICSRES         Get reserve
* Make sure the existing file would not be truncated by the request by
* determining the number of IXRs needed to hold the current data and
* comparing to the number of IXRs needed for the file size requested.
         IF    (RQCNIXR,AND,^RQCHYBR),BEGIN Non-IXR file
         CLEAR RJ
         L     RK,RQBLKC           Get current block count
         CLEAR RJ
         LA    RK,@RK+IXRNT#-1     Rount up
         D     RJ,=A(IXRNT#)       Calc IXRs needed
         END   ,                   Non-IXR file
         ELSE  BEGIN               IXR file
         BAS   RS,M1ICGIXR         Get first IXR
         IF    IXRZIXR,BEGIN       Hybrid file
         L     RK,RQBLKC           Get current IXR count
         END   ,                   Hybrid file
         ELSEIF IXRSIXR,BEGIN      Super IXR
         LH    RK,IXRHIXR          Highest IXR number (relative to 0)
         INCR  RK                  Calc count of IXR
         END   ,                   Super IXR
         ELSE  BEGIN
         LA    RK,1                Only one IXR
         END   ,
         END   ,                   IXR file
         IF    (RK,GT,#ICONCNT),M1ICEX12 Can't truncate the file

* Get enough contiguous blocks for the hybrid IXR array
         L     RVR,#ICONCNT        Get hybrid IXR count
         PSET  @FMFSB
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITGCON            Get this many contiguous
         IF    (RVR,Z),M1ICEX20    Can't do
         ST    RVR,#ICONBLK        Save first block

* Adjust the number of blocks in use for the account
         CLEAR RS                  No existing IXRs for non-IXRd
         IF    (^RQCNIXR,OR,RQCHYBR),BEGIN Not non-IXR
         L     RS,IXRRRCS          Get total records in file
         S     RS,IXRNRCS          Calc number of IXRs
         END   ,                   Not non-IXR
         L     RVR,#ICONCNT        Get hybrid IXR count
         CR    RVR,RS              Compare to number of hybrid IXRs
         IF    NE,BEGIN            Must adjust blocks in use
         IF    GT,BEGIN            Get some more
         SR    RVR,RS              Calc delta
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,(RVR)      Space needed
         VCALL FCATGSPA            Update catalog space
         IF    (RVR,NZ),BEGIN      Can't do it
         L     RS,#ICONBLK         Get fist block
         L     RVR,#ICONCNT        Get count
         PSET  @FMFSB              Release bit numbers
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITRCON            Release back to the system
         B     M1ICEX16
         END   ,                   Not enough space
         END   ,                   Get some more
         ELSE  BEGIN               Put some back
         SR    RS,RVR              Calc delta
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,(RS)       Space released
         VCALL FCATPSPA            Update catalog space
         END   ,                   Put some back
         END   ,                   Must adjust blocks in use

* Initialize the hybrid IXR array
         PSET  @FMIXRAD
         PMOV  @FMIXFSB,LA:FSB
         MVC   @FMIXNAM,RQNAMS
         MVC   @FMIXBLK,#ICONBLK   Set first block number
         MVC   @FMIXCNT,#ICONCNT   Set count of blocks to init
         VCALL FMHYINIT            Initialize hybrid file

* Get the first hybrid IXR
         L     R14,#ICONBLK        First hybrid IXR
         CLEAR R15                 New buffer
         BAS   RS,M1ICGIX2         Get IXR
         LR    RJ,R15              Set address
         ST    R15,#ICONBU3        Save buffer address

         IF    (RQCNIXR,AND,^RQCHYBR),BEGIN Non-IXR files
         L     R14,RQBLKC          Get current block count
         END   ,                   Non-IXR files
         ELSE  BEGIN               IXR or hybrid file
         L     R14,IXRNRCS         Get number of user records
         END   ,                   IXR or hybrid file
         ST    R14,F.IXRNRCS       Set
         A     R14,F.IXRRRCS       Calc total number of records
         ST    R14,F.IXRRRCS       Set

* Rereference user blocks from new hybrid file
         IF    RQCHYBR,BEGIN       Hybrid to hybrid
         MVC   IXRECNO,F.IXRECNO   Set new record number
         MVC   IXRRRCS,F.IXRRRCS   Set total number of records
         LA    R15,IXR             Set buffer
         BAS   RS,M1ICPIXR         File the first one
         IF    (IXRNRCS,NZ),BEGIN  Some user records
         L3    R15,IXRHIRF
         IF    (R15,GE,=A(IXRNT#)),BEGIN Not all in first
         L3    R15,IXRLWRF         Get low record
         IF    (R15,LT,=A(IXRNT#)),BEGIN In first
         LA    R15,1               Start with second
         END   ,
         ELSE  BEGIN               Calc
         CLEAR R14
         D     R14,=A(IXRNT#)      Calc start IXR index
         END   ,                   Calc
         L3    RN,IXRHIRF          Get high record
         CLEAR RM
         D     RM,=A(IXRNT#)       Calc end IXR index
         INCR  RN
         SR    RN,R15              Calc count of IXRs
         LR    RM,R15              Get start IXR index
         LOOP  BEGIN               Get and file IXRs in new place
         LR    R14,RM
         A     R14,RQFBLK          Calc IXR number
         LA    R15,IXR             Use this buffer
         BAS   RS,M1ICGIX2         Get IXR
         LR    R14,RM
         A     R14,#ICONBLK        Calc new IXR number
         ST3   R14,IXRECNO         Set
         BAS   RS,M1ICPIXR         File in new place
         INCR  RM                  Increment IXR index
         UNTIL (BCT,RN),END        Get and file IXRs in new place
         END   ,                   Not all in first
         END   ,                   Some user records
         END   ,                   Hybrid to hybrid
         ELSEIF RQCNIXR,BEGIN      Non-IXR to hybrid
         L     R14,RQBLKC          Count of user blocks
         DECR  R14
         ST3   R14,F.IXRHIRF       Set high block number
         L     RY,RQFBLK           Get first block number
         L     RN,RQBLKC           Count of blocks
         CLEAR RM                  IXR index
         LOOP  BEGIN
         IF    (RM,NZ),BEGIN       Already have first hybrid IXR
         LR    R14,RM
         A     R14,#ICONBLK        Calc IXR number
         LA    R15,F.IXR           Use this buffer
         BAS   RS,M1ICGIX2         Get hybrid IXR
         END   ,                   Already have first hybrid IXR
         LA    RX,F.IXR            Set IXR base
         IF    (RN,GT,=A(IXRNT#)),BEGIN
         S     RN,=A(IXRNT#)       Decrement count left
         L     RK,=A(IXRNT#)       Set loop count
         END   ,
         ELSE  BEGIN
         LR    RK,RN               Set loop count
         CLEAR RN                  None left
         END   ,
         LR    R15,RK              Get block count
         DECR  R15                 Calc last block in IXR
         ST3   R15,IXRHIRC         Set
         LOOP  BEGIN
         ST3   RY,IXRNT            Set block number
         LA    RX,IXR+L'IXRNT      Increment IXR pointer
         INCR  RY                  Increment block number
         UNTIL (BCT,RK),END
         LA    R15,F.IXR           Point to hybrid IXR
         BAS   RS,M1ICPIXR         File it away
         INCR  RM
         UNTIL (RN,Z),END
         END   ,                   Non-IXR to hybrid
         ELSE  BEGIN               IXR to hybrid
         IF    (IXRNRCS,NZ),BEGIN  Some user records
         IF    IXRSIXR,BEGIN       Super IXR
         LR    RY,RX               Set SIXR pointer
         CLEAR RX                  Clear IXR pointer
         CLEAR RM                  Hybrid IXR index
         LA    RN,IXRIXNT#         Number of SIXR entries
         CLEAR RK                  Init hybrid IXR pointer
         LOOP  BEGIN               Copy data to hybrid file
         L3    R14,S.IXRNT         Get IXR pointer
         IF    (R14,NZ),BEGIN      IXR exists
         LA    R15,IXR             Reuse this buffer
         BAS   RS,M1ICGIX2         Get IXR
         LR    RX,R15              Get IXR pointer
         ST    R15,#ICONBU2        Save pointer
         IF    (RM,Z),BEGIN        First hybrid IXR
         LR    RK,RJ               Set this temporarily
         END   ,
         ELSE  BEGIN               Get hybrid IXR
         LR    R14,RM
         A     R14,#ICONBLK        Calc IXR number
         LA    R15,H.IXR           Use this buffer
         BAS   RS,M1ICGIX2         Get hybrid IXR
         LR    RK,R15              Set pointer
         ST    R15,#ICONBU4        Save pointer
         END   ,                   Get hybrid IXR
         MVC   F.IXRLWRC,IXRLWRC   Set low record number
         MVC   F.IXRLWRC,IXRHIRC   Set high record number
         LA    R14,IXRNT           Block number area
         LA    R15,IXRNT#*L'IXRNT  Length
         LA    RVR,H.IXRNT         Point to destination
         LR    RS,R15              Length
         MVCL  RVR,R14             Move user blocks
         IF    ^#ICONSET,BEGIN     This not set yet
         SET   #ICONSET            Don't do it again
         LR    R15,RY              Save
         L     RY,#ICONBU1         Reset base
         LH    R14,S.IXRLWXR       Get low IXR number
         LR    RY,R15              Restore base
         MH    R14,=Y(IXRNT#)      Calc block number
         L3    R15,IXRLWRC         Get first block number in IXR
         AR    R14,R15             Calc first block in file
         ST3   R14,F.IXRLWRF       Save
         END   ,                   This not set yet
         IF    (RM,Z),BEGIN        First hybrid IXR
         CLEAR RK                  Clear temporary pointer
         END   ,
         ELSE  BEGIN
         LA    R15,H.IXR           Point to hybrid IXR
         BAS   RS,M1ICPIXR         File it away
         END   ,
         END   ,                   IXR exists
         LA    RY,S.IXR+L'IXRNT    Point to next IXR
         INCR  RM                  Increment hybrid IXR index
         UNTIL (BCT,RN),END        Copy data to hybrid file
         L     RY,#ICONBU1         Reset base
         LH    R14,S.IXRHIXR       Get high IXR number
         MH    R14,=Y(IXRNT#)      Calc block number
         L3    R15,IXRHIRC         Get last block number in IXR
         AR    R14,R15             Calc last block in file
         ST3   R14,F.IXRHIRF       Save
         END   ,                   Super IXR
         ELSE  BEGIN               Master IXR record
         L3    R14,IXRLWRC         Get low record number
         ST3   R14,F.IXRLWRC       Set hybrid field
         ST3   R14,F.IXRLWRF       Set hybrid field
         L3    R14,IXRHIRC         Get low record number
         ST3   R14,F.IXRLWRC       Set hybrid field
         ST3   R14,F.IXRHIRF       Set hybrid field
         LA    R14,IXRNT           Block number area
         LA    R15,IXRNT#*L'IXRNT  Length
         LA    RVR,F.IXRNT         Point to destination
         LR    RS,R15              Length
         MVCL  RVR,R14             Move user blocks
         END   ,                   Master IXR record
         END   ,                   Some user records
         LA    R15,F.IXR           Point to First IXR
         BAS   RS,M1ICPIXR         File the first one
         END   ,                   IXR to hybrid

* Convert catalog entry to hybrid file
         PSET  @FCUINFO            Convert to hybrid
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         PMOV  @FCUIBLK,#ICONBLK   Get first block number
         PMOV  @FCUICNT,#ICONCNT   Get block count
         SET   @FCUIHYB            Convert to hybrid
         VCALL FCATUINF            Set info

* Release the IXR file IXRs back to the file system
         IF    RQCHYBR,BEGIN       Hybrid file
         L     RS,RQFBLK           Old first block
         L     RVR,RQBLKC          Old count of IXRs
         PSET  @FMFSB              Release bit numbers
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITRCON            Release back to the system
         END   ,                   Hybrid file
         ELSEIF ^RQCNIXR,BEGIN     IXR file
         PSET  @FMFSB              Release bit numbers
         PMOV  @FMFSBP,LA:FSB
         L     RX,#ICONBU1         Reset base
         L3    RVR,IXRECNO         Get record block number
         VCALL FBITREL             Release back to the system
         IF    IXRSIXR,BEGIN       Super IXR
         LA    RN,IXRIXNT#         Get count
         LOOP  BEGIN
         L3    RVR,IXRNT           Get block number
         IF    (RVR,NZ),'VCALL FBITREL' Release back to the system
         LA    RX,IXR+L'IXRNT      Increment to next number
         UNTIL (BCT,RN),END
         END   ,                   Super IXR
         END   ,                   IXR file

* Reset RQWB fields for the file
         SET   RQCNIXR             Set non-ixr
         SET   RQCHYBR             Set hybrid file
         L     R14,RQATFB
         WITH  (ATFB,R14),BEGIN
         MVC   ATFBFBLK,#ICONBLK   Get first block number
         MVC   ATFBBLKC,#ICONCNT   Get block count (non-IXR'd)
         END   ,

         B     M1ICEX00            Done

M1ICERVR LABEL ,
         ST    RVR,RQRETC          Set return code
         B     M1ICEXIT

M1ICEX00 LABEL ,
         CLEAR RQRETC              Request completed successfully
         B     M1ICEXIT

M1ICEX04 LABEL ,
         MVC   RQRETC,=F'4'        File not immediately available
         B     M1ICEXIT

M1ICEX12 LABEL ,
         MVC   RQRETC,=F'12'       The answer is yes or no
         B     M1ICEXIT            (depending on the question)

M1ICEX16 LABEL ,
         MVC   RQRETC,=F'16'       Can't have any more blocks
         B     M1ICEXIT

M1ICEX20 LABEL ,
         MVC   RQRETC,=F'20'       Not enough file space
         B     M1ICEXIT

M1ICXRES LABEL ,                   Get exclusive reserve
         LA    R15,1
         B     M1ICRESV
M1ICSRES LABEL ,                   Get shared reserve
         CLEAR R15
M1ICRESV LABEL ,
         IF    (RQASHR,AND,^RQARES),BEGIN Not already reserved
         PSET  @GRES
         L     R14,RQATFB           Point to attach block
         WITH  (ATFB,R14),'PMOV @GRID,ATFBRGRI' Point to reserve grid
         IF    RQWAIT,'SET @GRWAIT' Wait if not avail
         IF    (R15,NZ),'SET @GREXCL' Exclusive hold
         VCALL GRGET               Get resource id hold
         IF    (RVR,Z),M1ICEX04    No reserve, not available
         ST    RVR,RQRGRH          Set reserve id
         END   ,                   Not already reserved
         BR    RS

M1ICGIXR LABEL ,                   Get first IXR record
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGBNO,RQFBLK     Set block number
         ACALL FMIXRGET            Get IXR record
         L     RX,@IXRGADR         Set IXR pointer
         ST    RX,#ICONBU1         Save buffer address
         BR    RS

M1ICGIX2 LABEL ,                   Get IXR record
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGBNO,(R14)      Set block number
         PMOV  @IXRGADR,(R15)      Set buffer address
         ACALL FMIXRGET            Get IXR record
         L     R15,@IXRGADR        Get buffer address
         BR    RS

M1ICPIXR LABEL ,                   File IXR
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,(R15)      Set buffer address
         ACALL FMIXRPUT            File the IXR away
         BR    RS

M1ICEXIT LABEL ,
         IF    (^RQARES,AND,(RQRGRH,NZ)),BEGIN
         GRREL RID=RQRGRH          Release file reserve
         CLEAR RQRGRH              Clear hold id
         END   ,

         LA    RM,#ICONBU1         Release IO buffers
         LA    RN,4
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         LOOP  BEGIN
         MVC   @SBFADR,@RM
         IF    (@SBFADR,NZ),'VCALL SBUFREE'
         LA    RM,@RM+4
         UNTIL (BCT,RN),END

         PEND  ,
RTNTABC  DC    A(M1FC00),A(M1IC00)
         DC    A(M1FC01),A(M1IC01)
         DC    A(M1FC02),A(M1IC02)
         DC    A(M1FC03),A(M1IC03)
         DC    A(M1FC04),A(M1IC04)
         DC    A(M1FC05),A(M1IC05)
         DC    A(M1FC06),A(M1IC06)
         DC    A(M1FC07),A(0)
         DC    A(M1FC08),A(M1IC08)
         DC    A(M1FC09),A(M1IC09)
         DC    A(M1FC10),A(M1IC10)
         DC    A(M1FC11),A(M1IC11)
         DC    A(M1FC12),A(M1IC12)
         DC    A(M1FCTEMP),A(M1IC13)
         DC    A(M1FC14),A(M1IC14)
         DC    A(M1FCTEMP),A(M1IC15)
         DC    A(M1FC16),A(M1IC16)
         DC    A(M1FCTEMP),A(M1IC17)
         DC    A(M1FC18),A(M1IC18)
         DC    A(M1FCTEMP),A(M1IC19)
         DC    A(M1FC20),A(0)
         DC    A(M1FC21),A(M1IC21)
         DC    A(M1FCTEMP),A(M1IC22)
         DC    A(M1FC23),A(0)
         DC    A(M1FC24),A(0)
RTNTABCM DC    A(M1FC25),A(M1IC25)
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FSTAT - File STATUS processing, preliminary edits
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
#STATWK  RECORD BEGIN
#STATORV DS    CL4
#STATNAM DS    CL40
         ORG   #STATORV
#STATACC DS    0CL6
#STATGRP DS    CL2
#STATDFF DS    CL4
         ORG   ,
         END   ,
M1FSTAT  PROC  ,#STATWK,NBR=2
         WITH  (RQWB,RA)
         WITH  (FSB,RB)
         ADFCB ,

         SET   RQASTAT             Status request
         L     R14,RQISTAT         Get status type
         IF    (R14,GE,100),BEGIN  Adjust for privileged status
         SH    R14,=Y(100-((RTNTABSX-RTNTABS)/(L'RTNTABS*2)))
         END   ,
         ELSE  BEGIN
         IF    (R14,GT,=A((RTNTABSX-RTNTABS)/(L'RTNTABS*2))),M1FSPEC
         END   ,
         SLL   R14,3               Times eight
         LA    R14,RTNTABS(R14)    Point to control routine address
         L     R15,@R14            Get routine address

         IF    ((R14,LT,=A(RTNTABS)),OR,(R14,GT,=A(RTNTABSM))),M1FSPEC
         IF    (R15,Z),M1FSPEC     Specification
         BR    R15                 Branch to routine

M1FS00   LABEL ,                   Assigning Global File Access
         CHKMEM RQISUSA,LA:L'RQACCNA   Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISUSA
         MVC   RQACCNA,@R14        Get account
         IF    (RQISUSB,Z),'MVC RQACCNB,RQFACC' Default
         ELSE  BEGIN
         CHKMEM RQISUSB,LA:L'RQACCNB   Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISUSB
         MVC   RQACCNB,@R14        Get account
         END   ,
         CHKACC RQACCNB            Edit account
         IF    NZ,M1FSERVR         Exit if error
         ST    RB,RQFSB            Set FSB address
         CHKACC RQACCNA            Edit account
         IF    (RVR,EQ,-8),M1FSERVR Exit if error
         IF    (RQACCNA,EQ,RQACCNB),M1FSBA44
         B     M1FSEX00            Out of here

M1FS01   LABEL ,                   Assigning Global Pubic Access
         CHKACC RQFACC             Get FSB address
         IF    NZ,M1FSERVR         Exit if error
         ST    RB,RQFSB            Set FSB address
         B     M1FSEX00            Out of here

M1FS02   LABEL ,                   List file names
         IF    (RQISLEN,LT,=A(56)),M1FSPEC At least one
M1FS02A  LABEL ,                   Status 111 joins here
         CHKMEM RQISLOC,L:RQISLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         MVI   RQNAME,C' '
         MVC   RQNAME+1(L'RQNAME-1),RQNAME
         IF    (RQISFIL,NZ),BEGIN  File name or user provided
         CHKMEM RQISFIL,LA:CFSBFLSZ Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISFIL         Point to file name
         IF    (('CLI @R14+6,C" "',E),OR,('CLI @R14+7,C" "',E)),BEGIN
         MVC   RQNACC,@R14         Get account
         END   ,                   Account only
         ELSE  BEGIN               Full file name
         MVC   #STATORV,=C'ORV.'
         MVC   #STATNAM,@R14
         PSET  @SETFNAM
         PMOV  @SETFNA,LA:#STATORV
         PMOV  @SETFNL,LA:L'RQNAME
         ACALL SETFNAME            Format file name
         IF    (RVR,NZ),M1FSERVR
         END   ,                   Full file name
         END   ,                   File name or user provided
         ELSE  'MVC RQNACC,RQFACC' Set to signed on account
         CHKACC RQNACC
         IF    NZ,M1FSERVR         Exit if error
         ST    RB,RQFSB            Set FSB address
         B     M1FSEX00            Out of here

M1FS03   LABEL ,                   Detect Account Level Privileges
         IF    (RQISLEN,LT,=A(L'NTRYPR)),M1FSPEC One member at least
         CHKMEM RQISLOC,L:RQISLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         IF    (RQISUSB,Z),BEGIN   Showing ones own account
         MVC   RQACCNB,RQFACC      Default
         SET   RQAOWN              Set to owner of account
         END   ,                   Showing ones own account
         ELSE  BEGIN
         CHKMEM RQISUSB,LA:L'RQACCNB Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISUSB
         MVC   RQACCNB,@R14        Get account
         IF    (RQACCNB,EQ,RQFACC),'SET RQAOWN' Account owner
         END   ,
         CHKACC RQACCNB
         IF    NZ,M1FSERVR         Exit if error
         ST    RB,RQFSB            Set FSB address
         B     M1FSEX00            Out of here

M1FS04   LABEL ,                   Get current space and usage stats
         IF    (RQISUSE,NZ),BEGIN
         CHKMEM RQISUSE,LA:L'RQACCNB Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISUSE
         MVC   RQACCNB,@R14        Get account
         END   ,
         ELSE  'MVC RQACCNB,RQFACC' Default
         CHKACC RQACCNB
         IF    NZ,M1FSERVR         Exit if error
         ST    RB,RQFSB            Set FSB address
         B     M1FSEX00            Out of here

M1FS05   LABEL ,                   Extend a non-IXR'd file
M1FS06   LABEL ,                   Create a non-IXR'd file
M1FS07   LABEL ,                   Create a hybrid file
         IF    (RQISBLK,GT,=X'00FFFFFF'),M1FSPEC Invalid block cnt
         IF    (RQISBLK,Z),M1FSPEC Invalid block cnt
         CHKMEM RQISLOC,L:RQISLEN  Check read access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         PSET  @SETFNAM
         PMOV  @SETFNA,RQISLOC
         PMOV  @SETFNL,RQISLEN
         ACALL SETFNAME            Set file name
         IF    (RVR,NZ),M1FSERVR   Invalid name
         L     RB,RQFSB
         B     M1FSEX00

M1FS100  LABEL ,                   Create a new account
M1FS102  LABEL ,                   Reset space allowed
M1FS104  LABEL ,                   Reset space used
         IF    ^RQSDEF,BEGIN       If do not default
         IF    (RQISPAC,GT,=X'00FFFFFF'),M1FSPEC Invalid space value
         END   ,
M1FS101  LABEL ,                   Delete an account
         CHKMEM RQISACC,LA:L'RQNACC Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R15,RQISACC
         MVC   RQNACC,@R15         Set account name
         CHKACC RQNACC
         IF    NZ,M1FSERVR         Bad account
         ST    RB,RQFSB            Set FSB address
         B     M1FSEX00

M1FS103  LABEL ,                   List accounts and space used
* Input: R1  = Data location
*        R15 = Data length
*        R14, byte 0 = File system id
*        R14, bytes 1-3 = Start account location
         LC    RN,RQIBLK           Get file number
         BAS   RS,M1FSFSB          Set FSB pointer
         IF    (RQISLEN,LT,=A(14)),M1FSPEC At least one
         CHKMEM RQISLOC,L:RQISLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L3    RS,RQISFIL+1
         IF    (RS,NZ),BEGIN       Start account specified
         CHKMEM (RS),LA:L'RQNACC   Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         MVC   RQNACC,@RS          Get account start
         END   ,
         B     M1FSEX00

M1FS105  LABEL ,     Delete file entry without releasing blocks
         CHKMEM RQISLOC,L:RQISLEN  Check read access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         PSET  @SETFNAM
         PMOV  @SETFNA,RQISLOC
         PMOV  @SETFNL,RQISLEN
         ACALL SETFNAME            Set file name
         IF    (RVR,NZ),M1FSERVR   Invalid name
         B     M1FSEX00            Done

M1FS106  LABEL ,                   Read real block number
* Input: R1  = Data location
*        R15 = Data length
*        R14, byte 0 = File system id
*        R14, bytes 1-3 = Absolute block number
         LC    RN,RQIBLK           Get file number
         BAS   RS,M1FSFSB          Set FSB pointer
         L     R15,RQILEN
         IF    (R15,LT,4),M1FSPEC  Data length of at least 4
         IF    (R15,GT,FSBDSZ),'LH R15,FSBDSZ' Not more than rec size
         ST    R15,RQILEN
         CHKMEM RQIDAT,RQILEN,W    Check write protect
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L3    RS,RQIBLK+1         Get block number
         IF    (RS,GE,FSBTBLK),M1FSPEC Not greater than max
         B     M1FSEX00            Out of here

M1FS107  LABEL ,                   Set pseudo user
         L     RS,RQASFB
         WITH  (ASFB,RS),BEGIN
         IF    (RQISACC,Z),'CLEAR ASFBPACC' Clear pseudo
         ELSE  BEGIN               Set pseudo
         CHKMEM RQISACC,LA:L'RQNACC Check memory read
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R15,RQISACC
         MVC   RQFACC,@R15         Set account name
         CHKACC RQFACC
         IF    (RVR,EQ,-8),M1FSERVR Bad account
* Note: it may seem strange that magic accounts can't set
* a pseudo user until one realizes that they don't have to
* because they can already do anything.
         IF    (RQPRIV.KWRIFSPR,Z),M1FSPEC Not special privilege
         MVC   ASFBPACC,RQFACC     Set pseudo
         END   ,                   Set pseudo
         END   ,
         B     M1FSWE00            Done

M1FS108  LABEL ,                   Turn file system read only on/off
* Input: R1 = Data location for file system name
*                    -or-
*             File system number
         L     RN,RQIDAT           Get file system name ptr
         BAS   RS,M1FSFSB          Edit file system name
         L     R15,RQISTYP         Request type
         IF    (R15,Z),BEGIN       Clear read only
         IF    ^FSBARO,M1FSBA44    Not read only already
         END   ,
         ELSEIF (R15,EQ,4),BEGIN   Set to read only
         IF    FSBARO,M1FSBA44     Already read only
         END   ,
         ELSEIF (R15,EQ,8),BEGIN   Set to available
         IF    ^FSBANAVL,M1FSBA44  Already available
         END   ,
         ELSEIF (R15,EQ,12),BEGIN  Set to unavailable
         IF    FSBANAVL,M1FSBA44   Already unavailable
         END   ,
         ELSE  M1FSBACC            Error
         B     M1FSEX00            Out of here

M1FS109  LABEL ,                   Write real block number
* Input: R1  = Data location
*        R15, bytes 0-1 = Record type
*        R15, bytes 2-3 = Data length
*        R14, byte 0 = File system id
*        R14, bytes 1-3 = Absolute block number
         LC    RN,RQIBLK           Get file number
         BAS   RS,M1FSFSB          Set FSB pointer
         LH    RS,RQILEN+2         Get length
         IF    (RS,GT,FSBDSZ),M1FSPEC Not more than record size
         CHKMEM RQIDAT,(RS)        Check read protect
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L3    RS,RQIBLK+1         Get block number
         IF    (RS,GE,FSBTBLK),M1FSPEC Not greater than max
         B     M1FSEX00            Out of here

M1FS110  LABEL ,     Update first block for file
         CHKMEM RQISLOC,L:RQISLEN  Check read access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         PSET  @SETFNAM
         PMOV  @SETFNA,RQISLOC
         PMOV  @SETFNL,RQISLEN
         ACALL SETFNAME            Set file name
         IF    (RVR,NZ),M1FSERVR   Invalid name
         L     RB,RQFSB            Point to FSB
         IF    (RQIBLK,GE,FSBTBLK),M1FSPEC
         B     M1FSEX00

M1FS111  LABEL ,                   Return catalog entry
         IF    (RQISLEN,LT,=A(L'NTRYGR)),M1FSPEC At least one
         B     M1FS02A             The rest is the same as 2

M1FS112  LABEL ,              Given file sys id or name, return both
         IF    (RQISLEN,LT,=A(9)),M1FSPEC At least one
         L     RN,RQISFIL          Get file id or name
         BAS   RS,M1FSFSB          Edit file system name
         CHKMEM RQISLOC,L:RQISLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISLOC
         MVC   @R14(L'FSBID),FSBID Get the info
         MVC   @R14+L'FSBID(L'FSBNAME),FSBNAME
         B     M1FSWE00            Done

M1FS113  LABEL ,          Return file system id and name for group
         IF    (RQISLEN,LT,=A(9)),M1FSPEC At least one
         CHKMEM RQISLOC,L:RQISLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         CHKMEM RQISUSB,LA:2       Check read protect for group
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     R14,RQISUSB
         MVC   #STATGRP,@R14       Get group id
         MVC   #STATDFF,=C'.DFF'   Dummy user
         CHKACC #STATACC           Get FSB
         IF    NZ,M1FSERVR         Bad group
         L     R14,RQISLOC
         MVC   @R14(L'FSBID),FSBID Get the info
         MVC   @R14+L'FSBID(L'FSBNAME),FSBNAME
         B     M1FSWE00            Done

M1FS114  LABEL ,                   Return group/filesys table
         IF    (RQISLEN,LT,=A(36*26)),M1FSPEC At least one
         CHKMEM RQISLOC,L:RQISLEN,W Check write access
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     RVR,FILEFSGT
         L     RS,=A(36*26)
         L     R14,RQISLOC
         L     R15,RQISLEN
         MVCL  R14,RVR             Get the table
         MVC   RQRLEN,FILEFSBC     Return count of file systems
         B     M1FSWE00            Done

M1FS115  LABEL ,                   Read real block header
* Input: R1  = Data location
*        R15 = Data length
*        R14, byte 0 = File system id
*        R14, bytes 1-3 = Absolute block number
         L     R15,RQILEN
         IF    (R15,LT,4),M1FSPEC  Data length of at least 4
         IF    (R15,GT,32),M1FSPEC Not more than header size
         CHKMEM RQIDAT,RQILEN,W    Check write protect
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         LC    RN,RQIBLK           Get file number
         BAS   RS,M1FSFSB          Set FSB pointer
         L3    RS,RQIBLK+1         Get block number
         IF    (RS,GE,FSBTBLK),M1FSPEC Not greater than max
         B     M1FSEX00            Out of here

M1FS116  LABEL ,                   Get contiguous range of blocks
*        R1, byte 0 = File system id
*        R1, bytes 1-3 = Block count
         LC    RN,RQIS116          Get file number
         BAS   RS,M1FSFSB          Set FSB pointer
         L3    RS,RQIS116+1        Get block number
         IF    (RS,GE,FSBTBLK),M1FSPEC Not greater than max
         B     M1FSEX00            Out of here

M1FS117  LABEL ,                   Suspend program execution
         LT    R15,RQIS117
         IF    NP,M1FSPEC          Must be positive
         SET   RQAS117             Status 117 in progress
         B     M1FSEX00            Out of here

M1FSFSB  LABEL ,
         IF    (RN,GE,255),BEGIN   Must be file name
         CHKMEM (RN),LA:L'FSBNAME Check read protect
         IF    (RVR,NZ),'EXIT M1FSTAT' Denied
         L     RB,FILEFFSB         Point to first FSB
         L     R0,FILEFSBC         Count of FSB's
         LOOP  BEGIN
         CLC   FSBNAME,@RN
         IF    EQ,EXIT             Found
         L     RB,FSBCHAIN         Next in chain
         UNTIL (BCT,R0),END
         IF    (R0,Z),M1FSBAD8     Invalid file system name
         END   ,                   Must be file name
         ELSE  BEGIN               Must be file ID
         L     RB,FILEFFSB         Point to first FSB
         L     R0,FILEFSBC         Count of FSB's
         LOOP  BEGIN
         IF    (RN,EQ,FSBID),EXIT
         L     RB,FSBCHAIN         Next in chain
         UNTIL (BCT,R0),END
         IF    (R0,Z),M1FSBADC     File system not available
         END   ,                   Must be file ID
         ST    RB,RQFSB            Set pointer to FSB
         BR    RS

M1FSPEC  LABEL ,
         L     RVR,=X'80000006'    Specification
         EXIT  M1FSTAT

M1FSERVR LABEL ,
         ST    RVR,RQRETC          Set error return
         B     M1FSERRX

M1FSBA44 LABEL ,
         MVC   RQRETC,=F'4'
         B     M1FSERRX

M1FSBACC LABEL ,
         MVC   RQRETC,=F'12'
         B     M1FSERRX

M1FSBAD8 LABEL ,
         MVC   RQRETC,=F'-8'
         B     M1FSERRX

M1FSBADC LABEL ,
         MVC   RQRETC,=F'-12'
         B     M1FSERRX

M1FSWE00 LABEL ,                   Set wait return to zero
         CLEAR RQWRETC
         SET   RQRFRE              Done with RQFB
         LA    RVR,1               No IO
         B     M1FSEXIT            Continue

M1FSERRX LABEL ,                   No IO for this one
         SET   RQRFRE              Done with RQFB
         LA    RVR,1               No IO
         EXIT  M1FSTAT

M1FSEX00 LABEL ,
         CLEAR RVR                 Clear return code
         B     M1FSEXIT

M1FSEXIT LABEL ,
         L     RB,RQFSB            Reset pointer
         IF    (RQFACC,EQ,FSBOWNER),'SET RQAMAG' File system owner
         IF    (RQNACC,EQ,RQFACC),'SET RQAOWN'   File owner
         L     R14,RQISTAT         Get status type
         IF    (R14,GE,100),BEGIN  Adjust for big status
         SH    R14,=Y(100-((RTNTABSX-RTNTABS)/(L'RTNTABS*2)))
         IF    ^RQAMAG,BEGIN
         LC    R15,STATPRIV(R14)   These are privileged stats
         LC    RS,RQPRIV           Get privileges
         IF    ('NR RS,R15',Z),M1FSPEC Under privileged
         END   ,
         END   ,
         LC    R15,M1FSIOTP(R14)   Get IO type
         IF    ((R15,EQ,2),AND,FSBARO),M1FSBADC Not available
         IF    ((R15,NZ),AND,FSBANAVL),M1FSBADC Not available

         CLEAR RQRETC              Clear return code
         MVC   RQRFID,RQFIID       Set file id

         PEND  ,
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1ISTAT - File STATUS processing, IO part
*
*   Inputs - RA points to RQWB (note: there is no file attached for
*            status processing)
*
*   Output -
*---------------------------------------------------------------------*
M1ISTAT  PROC
         WITH  (RQWB,RA)
         L     RB,RQFSB
         WITH  (FSB,RB)

         SET   RQRFRE              Free RQFB when done, no matter what

         L     R14,RQISTAT         Get status type
         IF    (R14,GE,100),BEGIN  Adjust for big status
         SH    R14,=Y(100-((RTNTABSX-RTNTABS)/(L'RTNTABS*2)))
         END   ,
         SLL   R14,3               Times eight
         L     R14,RTNTABS+4(R14)  Get routine address
         BR    R14                 Just do it!

M1IS00   LABEL ,                   Assigning Global File Access
         PSET  @FCXTND
         PMOV  @FCXFSB,LA:FSB
         PMOV  @FCXUSR,RQACCNA     User receiving privileges
         PMOV  @FCXUSO,RQACCNB     File owner
         PMOV  @FCXUSE,RQFACC      User extending privileges
         PMOV  @FCXPRI,RQISPRM     Set permits being assigned
         IF    RQAMAG,'SET @FCXFM' Set to magic account
         VCALL FCATXTND            Go do it
         ST    RVR,RQRETC          Set return code
         EXIT  M1ISTAT             Done

M1IS01   LABEL ,                   Assigning Global Pubic Access
         PSET  @FCEPUB
         PMOV  @FCEPFSB,LA:FSB
         PMOV  @FCEPACC,RQFACC     Signed on account
         PMOV  @FCEPPUB,RQISPRM    Set permits
         VCALL FCATEPUB            Set public permits
         ST    RVR,RQRETC          Set return code
         EXIT  M1ISTAT

M1IS02   LABEL ,                   List files names
         PSET  @FCFLIS
         PMOV  @FCFLFSB,LA:FSB
         PMOV  @FCFLLOC,RQISLOC    File name buffer
         PMOV  @FCFLLEN,RQISLEN    Buffer len
         PMOV  @FCFLNAM,RQNAMS     Start file name
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    (^RQAMAG,AND,^RQAOWN),'PMOV @FCFLUSE,RQFACC'
         END   ,
         IF    RQACLP,'SET @FCFLCLP' Indicate if CLP mode
         VCALL FCATFLIS            List file names
         ST    RVR,RQRETC          Set return
         IF    (RVR,Z),BEGIN
         MVC   RQRFCNT,@FCFLCNT    Set count returned
         END   ,
         EXIT  M1ISTAT

M1IS03   LABEL ,                   Detect Account Level Privileges
         PSET  @FCGPERM
         PMOV  @FCGPFSB,LA:FSB
         PMOV  @FCGPLOC,RQISLOC    Privilege buffer
         PMOV  @FCGPLEN,RQISLEN    Buffer length
         PMOV  @FCGPUSE,RQFACC     User
         PMOV  @FCGPACC,RQACCNB    Account
         SET   @FCGPFA             Account request
         IF    (RQAOWN,OR,RQAMAG),'SET @FCGPFM' Set to magic account
         VCALL FCATGPRM            Go do it
         ST    RVR,RQRETC          Set return code
         IF    (RVR,Z),BEGIN
         MVC   RQRPCNT,@FCGPCNT    Get count of users
         LC    R14,@FCGPPP         Get public privileges
         SLL   R14,8               Put into next byte
         ST    R14,RQRPRIV         Set return
         END   ,
         EXIT  M1ISTAT             Done

M1IS04   LABEL ,                   Get current space and usage stats
         PSET  @FCAINFO
         PMOV  @FCAIFSB,LA:FSB
         PMOV  @FCAIACC,RQACCNB    Set account
         IF    (RQPRIV.KWRIFAPR,Z),BEGIN Not special privilege
         IF    (^RQAMAG,AND,(RQACCNB,NE,RQFACC)),BEGIN
         PMOV  @FCAIUSE,RQFACC     Set user
         END   ,
         END   ,
         VCALL FCATAINF            Get current space and usage stats
         ST    RVR,RQRETC          Set return code
         IF    (RVR,Z),BEGIN
         MVC   RQRABK,@FCAIABK     Allocated blocks
         IF    (RQRABK,EQ,=X'00FFFFFF'),'MVI RQRABK,255' Make negitive
         MVC   RQRUBK,@FCAIUBK     Used blocks
         END   ,
         EXIT  M1ISTAT             Done

M1IS05   LABEL ,                   Extend a non-IXR'd file
         PSET  @FCNIXR
         PMOV  @FCNFSB,LA:FSB
         PMOV  @FCNBLKC,RQISBLK    Blocks requested
         PMOV  @FCNNAME,RQNAMS     File name
         PMOV  @FCNACC,RQFACC
         IF    RQAMAG,'SET @FCNFMAG'
         IF    RQAOWN,'SET @FCNFMAG'
         VCALL FCATNIXE            Extend the file
         ST    RVR,RQRETC
* If not enough blocks to extend the full requested amount,
* return the amount that is currently possible
         IF    (RQRETC,EQ,=F'4'),'MVC RQRCBK,@FCNBLKC'

         EXIT  M1ISTAT

M1IS06   LABEL ,                   Create a non-IXR file
         IF    ^FSBONIXR,BEGIN
         MVC   RQRETC,=F'28'       Not allowed
         EXIT  M1ISTAT
         END   ,
         PSET  @FCNIXR
         PMOV  @FCNFSB,LA:FSB
         PMOV  @FCNBLKC,RQISBLK    Blocks requested
         PMOV  @FCNNAME,RQNAMS     File name
         PMOV  @FCNACC,RQFACC
         IF    RQAMAG,'SET @FCNFMAG'
         IF    RQAOWN,'SET @FCNFMAG'
         VCALL FCATNIXR            Create a non-IXR file
         ST    RVR,RQRETC
         IF    (RVR,Z),BEGIN
         ADFCB ,
         INCRS FILECRE             Number of files created
         END   ,
         EXIT  M1ISTAT

M1IS07   LABEL ,                   Create a hybrid file
         CLEAR R14
         L     R15,RQISBLK         Get blocks requested
         LA    R15,@R15+IXRNT#-1   Round up
         D     R14,=A(IXRNT#)      Calc number of IXR's
         PSET  @FCNIXR
         PMOV  @FCNFSB,LA:FSB
         PMOV  @FCNBLKC,(R15)      Blocks requested
         PMOV  @FCNNAME,RQNAMS     File name
         PMOV  @FCNACC,RQFACC
         IF    RQAMAG,'SET @FCNFMAG'
         IF    RQAOWN,'SET @FCNFMAG'
         SET   @FCNFHYB            Hybrid file
         VCALL FCATNIXR            Create a hybrid file
         ST    RVR,RQRETC
         IF    (RVR,Z),BEGIN
         ADFCB ,
         INCRS FILECRE             Number of files created
         END   ,
         EXIT  M1ISTAT

M1IS100  LABEL ,                   Create a new account
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         IF    RQSDEF,'L R14,=X"00FFFFFF"' Set to default
         ELSE  'L R14,RQISPAC'     Get supplied space
         PMOV  @FCACSPA,(R14)      Space
         VCALL FCATAADD            Add the account
         ST    RVR,RQRETC
         EXIT  M1ISTAT

M1IS101  LABEL ,                   Delete an account
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         VCALL FCATADEL            Delete the account
         ST    RVR,RQRETC
         EXIT  M1ISTAT

M1IS102  LABEL ,                   Reset max space allowed
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,RQISPAC    Space
         VCALL FCATMSPA            Add the account
         ST    RVR,RQRETC
         EXIT  M1ISTAT

M1IS103  LABEL ,                   List accounts and space used
         PSET  @FCALIS
         PMOV  @FCALFSB,LA:FSB
         PMOV  @FCALLOC,RQISLOC    File name buffer
         PMOV  @FCALLEN,RQISLEN    Buffer len
         PMOV  @FCALNAM,RQNACC     Start account
         VCALL FCATALIS            List accounts
         ST    RVR,RQRETC          Set return
         IF    (RVR,Z),BEGIN
         MVC   RQRFCNT,@FCALCNT    Set count returned
         END   ,
         EXIT  M1ISTAT

M1IS104  LABEL ,                   Reset space used
         PSET  @FCACMOD
         PMOV  @FCACFSB,LA:FSB
         PMOV  @FCACCNT,RQNACC
         PMOV  @FCACSPA,RQISPAC    Space
         VCALL FCATUSPA            Space used
         ST    RVR,RQRETC
         EXIT  M1ISTAT

M1IS105  LABEL ,        Delete file entry without releasing blocks
         L     RJ,FSBAHFB          Get file attach hash table ptr
         WITH  (AHFB,RJ)
         PSET  @HASH
         PMOV  @HSHSTR,LA:RQNAME   File name
         PMOV  @HSHLEN,LA:L'RQNAME Length
         PMOV  @HSHVAL,LA:AHFBCNT  Hash value
         SET   @HSHBLNK            Don't use trailing blanks
         VCALL HASHIT              Calculate hash number
         LR    RK,RVR              Get hash number
         MH    RK,=Y(L'AHFBL)      Calculate index
         LA    RK,AHFBL(RK)        Point to queue
         WITH  (AHFBL,RK)
         GRGET RID=AHFBGRID,EXCL=YES Reserve the table
         L     RX,AHFBLFP          Point to first on list
         WITH  (ATFB,RX)
         WHILE (RX,NE,RK),BEGIN    While not end of list
         IF    (ATFBNAME,EQ,RQNAMS),EXIT
         L     RX,ATFBFP           Point to next on list
         END
         IF    (RX,NE,RK),'LA RVR,4' Already attached by someone
         ELSE  BEGIN
         PSET  @FCDLETE
         PMOV  @FCDLFSB,LA:FSB
         PMOV  @FCDLNAM,RQNAMS
         VCALL FCATDLET            Delete the name from the catalog
         END   ,
         ST    RVR,RQRETC
         GRREL RID=AHFBGRID
         EXIT  M1ISTAT

M1IS106  LABEL ,                   Read absolute block number
         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         L3    R15,RQIBLK+1
         PMOV  @FDOBLK,(R15)       Block number
         PMOV  @FDODATL,FSBDSZ     Data length
         SET   @FDOFR+@FDOS106     Indicate 106 read
         VCALL FDOIODO             Read record
         L     R14,@FDODATA
         LH    R15,@FDODATL
         ST    R15,RQRTYPE         Return length of record
         L     R0,RQIDAT
         L     R1,RQILEN
         MVCL  R0,R14              Move data to output buffer
         LC    R14,@FDOTYPE        Get record type
         STH   R14,RQRTYPE         Set return
         L     R14,@FDODATA
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,(R14)
         VCALL SBUFREE             Free buffer
         CLEAR RQRETC
         EXIT  M1ISTAT

M1IS108  LABEL ,                   Turn file system read only on/off
         L     R15,RQISTYP         Request type
         IF    (R15,Z),BEGIN       Clear read only
         BAS   RN,M1IS108N         Set file sys name and len
         LA    RN,3                Enqueue exclusive
         SYSCTL R0,RM,TYPE=MVSENQ
         IF    NZ,BEGIN            Offline still has it!
         MVC   RQRETC,=F'4'        Set to unavailable
         EXIT  M1ISTAT             Done
         END   ,
         BAS   RN,M1IS108A         Activate bitmap processing
         CLEAR FSBARO
         BAS   RN,M1IS108J         Tell JES about the change
         END   ,
         ELSEIF (R15,EQ,4),BEGIN   Set to read only
         SET   FSBARO
         BAS   RN,M1IS108J         Tell JES about the change
         BAS   RN,M1IS108D         Deactivate bitmap processing
         BAS   RN,M1IS108N         Set file sys name and len
         CLEAR RN                  Release the file sys to offline
         SYSCTL R0,RM,TYPE=MVSENQ
         END   ,
         ELSEIF (R15,EQ,8),BEGIN   Set to available
         BAS   RN,M1IS108A         Activate bitmap processing
         CLEAR  FSBANAVL
         END   ,
         ELSEIF (R15,EQ,12),BEGIN  Set to unavailable
         SET   FSBANAVL
         BAS   RN,M1IS108D         Deactivate bitmap processing
         END   ,
         CLEAR RQRETC
         EXIT  M1ISTAT

M1IS108A LABEL ,                   Activate bitmap processing
         PSET  @FMFSB
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITACT
         BR    RN

M1IS108D LABEL ,                   Deactivate bitmap processing
         LA    R0,50               50 * 0.1 = 5 seconds
         VCALL M1GOWAIT            Wait for system to quiesce
         PSET  @FMFSB
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITDEA
         BR    RN

M1IS108N LABEL ,                   Set filesys name and length
         LA    R0,FSBNAME          Set name pointer
         LA    R1,L'FSBNAME        Get length
         LA    R14,FSBNAME+L'FSBNAME-1 Point to last character
         LOOP  BEGIN               Determine len of name w/o spaces
         CLI   @R14,C' '
         IF    NE,EXIT
         DECR  R14
         UNTIL (BCT,R1),END
         L     RM,MATPTR
         WITH  (MAT,RM),'LA RM,MATSNAME' Which Orvyl
         BR    RN

M1IS108J LABEL ,                   Inform JES of current Orvyl status
         VCALL STATFS
         VCALL M1GOSTAT
         BR    RN

M1IS109  LABEL ,                   Write absolute block number
         PSET  @SBGET
         PMOV  @SBGPOO,FSBRBT      Get an io buffer
         VCALL SBUFGET
         L     R14,@SBGADR         Get buffer address
         LH    R15,FSBDSZ          Get length
         L     R0,RQIDAT
         LH    R1,RQILEN+2
         MVCL  R14,R0              Get record data
         L     RN,@SBGADR          Save buffer address
         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         L3    R15,RQIBLK+1
         PMOV  @FDOBLK,(R15)       Block number
         PMOV  @FDODATA,(RN)
         LH    R15,RQILEN+2
         PMOV  @FDODATL,(R15)      Data length
         LH    R15,RQILEN
         PMOV  @FDOTYPE,(R15)      Record type
         SET   @FDOFW+@FDOS106     Indicate 106 write
         VCALL FDOIODO             Write record
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,(RN)
         VCALL SBUFREE             Free buffer
         CLEAR RQRETC
         EXIT  M1ISTAT

M1IS110  LABEL ,                   Update first block for file
         PSET  @FCUINFO            Convert to hybrid
         PMOV  @FCUIFSB,LA:FSB
         PMOV  @FCUINAM,RQNAMS
         PMOV  @FCUIBLK,RQIBLK     Get first block number
         SET   @FCUINEW            Set new block number
         VCALL FCATUINF            Set info
         ST    RVR,RQRETC          Set return
         EXIT  M1ISTAT

M1IS111  LABEL ,                   Get account or file entry
         PSET  @FCS111
         PMOV  @FCS1FSB,LA:FSB
         PMOV  @FCS1LOC,RQISLOC    Ntry buffer
         PMOV  @FCS1LEN,RQISLEN    Buffer len
         PMOV  @FCS1NAM,RQNAMS     Account or file name
         VCALL FCATS111            Get entry
         ST    RVR,RQRETC          Set return
         EXIT  M1ISTAT

M1IS115  LABEL ,                   Read absolute block header
         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         L3    R15,RQIBLK+1
         PMOV  @FDOBLK,(R15)       Block number
         PMOV  @FDODATL,FSBDSZ     Data length
         SET   @FDOFR+@FDOS115     Indicate 115 read
         VCALL FDOIODO             Read record
         L     R14,@FDODATA
         LH    R15,@FDODATL
         ST    R15,RQRLEN          Set header length
         L     R0,RQIDAT
         L     R1,RQILEN
         MVCL  R0,R14              Move data to output buffer
         L     R14,@FDODATA
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,(R14)
         VCALL SBUFREE             Free buffer
         CLEAR RQRETC
         EXIT  M1ISTAT

M1IS116  LABEL ,                   Get range of blocks
         L3    RVR,RQIS116+1       Get count of blocks
         PSET  @FMFSB
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITGCON            Get this many contiguous
         IF    (RVR,Z),BEGIN       Can't do
         MVC   RQRETC,=F'4'
         END   ,
         ELSE  BEGIN
         ST    RVR,RQRS116         Set first in range
         CLEAR RQRETC
         END   ,
         EXIT  M1ISTAT

M1IS117  LABEL ,                   Suspend program execution
         L     RVR,RQIS117         Get time
         VCALL M1GOWAIT
         IF    (RVR,NZ),'LA RVR,4'
         ST    RVR,RQRETC
         EXIT  M1ISTAT

         PEND  ,
RTNTABS  DC    A(M1FS00),A(M1IS00)
         DC    A(M1FS01),A(M1IS01)
         DC    A(M1FS02),A(M1IS02)
         DC    A(M1FS03),A(M1IS03)
         DC    A(M1FS04),A(M1IS04)
         DC    A(M1FS05),A(M1IS05)
         DC    A(M1FS06),A(M1IS06)
         DC    A(M1FS07),A(M1IS07)
RTNTABSX DC    A(M1FS100),A(M1IS100)
         DC    A(M1FS101),A(M1IS101)
         DC    A(M1FS102),A(M1IS102)
         DC    A(M1FS103),A(M1IS103)
         DC    A(M1FS104),A(M1IS104)
         DC    A(M1FS105),A(M1IS105)
         DC    A(M1FS106),A(M1IS106)
         DC    A(M1FS107),A(0)
         DC    A(M1FS108),A(M1IS108)
         DC    A(M1FS109),A(M1IS109)
         DC    A(M1FS110),A(M1IS110)
         DC    A(M1FS111),A(M1IS111)
         DC    A(M1FS112),A(0)
         DC    A(M1FS113),A(0)
         DC    A(M1FS114),A(0)
         DC    A(M1FS115),A(M1IS115)
         DC    A(M1FS116),A(M1IS116)
RTNTABSM DC    A(M1FS117),A(M1IS117)



STATP    DC    AL1(KWRIFAPR+KWRIFSPR+KWRIFADM)  STATUS 100
         DC    AL1(KWRIFAPR+KWRIFSPR+KWRIFADM)  STATUS 101
         DC    AL1(KWRIFAPR+KWRIFSPR+KWRIFADM)  STATUS 102
         DC    AL1(X'FF')              STATUS 103 - EVERYONE FOR NOW
         DC    AL1(KWRIFSPR)           STATUS 104 - SYSTEM PRIVS
         DC    AL1(KWRIFSPR)           STATUS 105 - SYSTEM PRIVS
         DC    AL1(KWRIFSPR)           STATUS 106 - SYSTEM PRIVS
         DC    AL1(X'FF')              STATUS 107 - EVERYONE FOR NOW
         DC    AL1(KWRIFSPR)           STATUS 108 - SYSTEM PRIVS
         DC    AL1(KWRIFSPR)           STATUS 109 - SYSTEM PRIVS
         DC    AL1(KWRIFSPR)           STATUS 110 - SYSTEM PRIVS
         DC    AL1(KWRIFSPR)           STATUS 111 - SYSTEM PRIVS
         DC    AL1(X'FF')              STATUS 112 - EVERYONE FOR NOW
         DC    AL1(X'FF')              STATUS 113 - EVERYONE FOR NOW
         DC    AL1(X'FF')              STATUS 114 - EVERYONE FOR NOW
         DC    AL1(KWRIFSPR)           STATUS 115 - SYSTEM PRIVS
         DC    AL1(KWRIFSPR)           STATUS 116 - SYSTEM PRIVS
         DC    AL1(X'FF')              STATUS 117 - EVERYONE FOR NOW
STATPRIV EQU   STATP-((RTNTABSX-RTNTABS)/(L'RTNTABS*2))

M1FSIOTP DC    2AL1(2)                 STATUS 0-1 WRITE
         DC    3AL1(1)                 STATUS 2-4 READ
         DC    6AL1(2)                 STATUS 5-7, 100-102 WRITE
         DC    AL1(1)                  STATUS 103 READS
         DC    2AL1(2)                 STATUS 104-105 WRITE
         DC    AL1(0)                  STATUS 106 don't check
         DC    AL1(1)                  STATUS 107 READ
         DC    8AL1(0)                 STATUS 108-115 don't check
         DC    AL1(2)                  STATUS 116 WRITE
         DC    AL1(0)                  STATUS 117 don't check
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FRSRV - Get exclusive reserve of the file
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1FRSRV  PROC
         WITH  (RQWB,RA)
         CLEAR RQRETC,RVR          Operation started
         PEND  ,

*---------------------------------------------------------------------*
*  M1IRSRV - Get exclusive reserve of the file
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1IRSRV  PROC
         WITH  (RQWB,RA)

         IF    ^RQMPERM.FPW,BEGIN   No write access
         IF    (RQCNIXR,OR,^RQMPERM.FPA),M1IRS08 Append only OK
         END   ,                   No write access
* If not attached in share mode or already reserved
         IF    (^RQASHR,OR,RQARES),M1IRS00
         L     RX,RQATFB           Point to attach block
         WITH  (ATFB,RX)
         PSET  @GRES
         PMOV  @GRID,ATFBRGRI      Point to reserve grid
         SET   @GREXCL             Get exclusive hold
         IF    RQWAIT,'SET @GRWAIT' Wait if not avail
         VCALL GRGET               Get resource id hold
         ST    RVR,RQRGRH          Set reserve id
         IF    (RVR,Z),M1IRS04     Not available
         SET   RQARES              Set to reserved status
         SET   ATFBFRES            Set for VFILE display

M1IRS00  LABEL ,
         CLEAR RQRETC              Set return code
         EXIT  M1IRSRV             Exit

M1IRS04  LABEL ,
         MVC   RQRETC,=F'4'        Not available
         EXIT  M1IRSRV             Exit

M1IRS08  LABEL ,
         MVC   RQRETC,=F'8'        No access
         EXIT  M1IRSRV             Exit

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  M1FRLSE - Release file reserve
*
*   Inputs - RA points to RQWB
*
*   Output -
*---------------------------------------------------------------------*
M1FRLSE  PROC
         WITH  (RQWB,RA)

         IF    (RQRGRH,NZ),BEGIN   Reserved
         L     RX,RQATFB           Point to attach block
         WITH  (ATFB,RX),'CLEAR ATFBFRES' Clear reserve flag
         GRREL RID=RQRGRH          Release reserve
         CLEAR RQRGRH,RQARES       Clear reserve
         END   ,                   Reserved

         CLEAR RQRETC,RQWRETC      Set return code
         LA    RVR,1               No IO necessary
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  SETFNAME - Set file name and file system pointers
*
*   Inputs -  RA points to the RQWB
*
*   Output -
*---------------------------------------------------------------------*
@SETFNAM RECORD BEGIN
@SETFNA  DS    A                   File name pointer
@SETFNL  DS    A                   Length
         END   ,
SETFNAME PROC  @SETFNAM
         WITH  (RQWB,RA)

         L     RX,@SETFNA          Point to file name
         IF    ('LT RY,@SETFNL',Z),SETFNERR Set length of filename
         IF    (RY,GT,=A(L'RQNAME)),SETFNERR
         CHKMEM @SETFNA,@SETFNL     Make sure we can read it
         IF    (RVR,NZ),'EXIT SETFNAME' RVR contains panic code

         IF    (=CL4'ORV.',EQ,@RX),BEGIN Fully qualified name
         IF    (RY,LE,=A(L'RQNPFX)),SETFNERR
         MVC   RQNPFX,@RX          Move prefix stuff
         LA    RX,@RX+L'RQNPFX     Point pass the prefix stuff
         SH    RY,=Y(L'RQNPFX)     Adjust the length
         IF    ('CLI RQND1,C"."',NE),SETFNERR
         IF    ('CLI RQND2,C"."',NE),SETFNERR
         END   ,                   Fully qualified name
         ELSE  BEGIN               Not fully qualified
         MVC   RQNORV,=CL4'ORV.'   Set
         MVC   RQNACC,RQFACC       Default to signed on account
         MVI   RQND2,C'.'

         BAS   RS,SETFNGRP         Group specified?
         IF    (EQ),BEGIN
         BAS   RS,SETFNUSE         Check if user specified
         END   ,                   End group specified
         ELSE  BEGIN
         BAS   RS,SETFNUSE         User specified?
         IF    (EQ),BEGIN
         BAS   RS,SETFNGRP         Check if group specified
         END   ,                   End user specified
         END   ,
         END   ,                   End not fully qualified

         LA    RN,@RX(RY)          Point to the last character
         DECR  RN
         WHILE ('CLI @RN,C" "',EQ),BEGIN Ignore trailing blanks
         DECR  RN
         DECR  RY                  Reduce the edit length
         END   ,

         IF    (RY,GT,=Y(L'RQNAM2)),SETFNERR Name too long
         MVI   RQNAM2,C' '         Clear filename
         MVC   RQNAM2+1(L'RQNAM2-1),RQNAM2
         LR    RN,RY
         DEX   RN,'MVC RQNAM2(1),@RX' Get rest of name

         CHKACC RQNACC             Edit account
         IF    NZ,'EXIT SETFNAME'  Error
         ST    RB,RQFSB            Set pointer to FSB
         WITH  (FSB,RB)

         LA    RX,RQNAM2           Point to file name (RY = len)
         BAS   RS,SETFNABC         First must be a letter
         WHILE (NZ),'BAS RS,SETFNCHR' Edit the rest

         IF    (RQFACC,EQ,FSBOWNER),'SET RQAMAG'   File system owner
         IF    (RQFACC,EQ,RQNACC),'SET RQAOWN'     File owner

         CLEAR RVR                 Set good return
         EXIT  SETFNAME

SETFNGRP LABEL ,                   Check for @gg.
         CLI   @RX,C'@'            Group?
         BNER  RS                  No, return
         MVC   RQNGRP,@RX+1        Set specified group
         SH    RY,=Y(4)            Decrement length
         BNP   SETFNERR            Get real
         CLI   @RX+3,C'.'          Dot?
         BNE   SETFNERR            No, error
         LA    RX,@RX+4            Increment pointer
         BR    RS

SETFNUSE LABEL ,                   Check for &uuu.
         CLI   @RX,C'&&'           User?
         BNER  RS                  No, return
         MVC   RQNUSE,@RX+1        Set specified user
         SH    RY,=Y(5)            Decrement length
         BNP   SETFNERR            Get real
         CLI   @RX+4,C'.'          Dot?
         BNE   SETFNERR            No, error
         LA    RX,@RX+5            Increment pointer
         BR    RS

SETFNCHR LABEL ,
         IF    ^RQACLP,SETFNCH1
         CLI   @RX,C'-'
         BE    SETFNCHE
SETFNCH1 LABEL ,
         CLI   @RX,C'.'
         BE    SETFNCHE
         CLI   @RX,C'*'
         BE    SETFNCHE
         CLI   @RX,C'_'
         BE    SETFNCHE
         CLI   @RX,C'0'
         BL    SETFNABC
         CLI   @RX,C'9'
         BNH   SETFNCHE
SETFNABC LABEL ,                   Must be a letter
         CLI   @RX,C'A'
         BL    SETFNERR
         CLI   @RX,C'I'
         BNH   SETFNCHE
         CLI   @RX,C'J'
         BL    SETFNERR
         CLI   @RX,C'R'
         BNH   SETFNCHE
         CLI   @RX,C'S'
         BL    SETFNERR
         CLI   @RX,C'Z'
         BH    SETFNERR
SETFNCHE LABEL ,
         LA    RX,@RX+1
         DECR  RY
         LTR   RY,RY               Set cc
         BR    RS

SETFNERR LABEL ,
         L     RVR,=F'-8'        Invalid file name
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  RELRQFB - Release a RQFB
*
*   Inputs - @RELRQFB
*
*   Output - None
*---------------------------------------------------------------------*
@RELRQFB RECORD BEGIN
@RELRQFP DS    A
         END   ,
RELRQFB  PROC  @RELRQFB
         L     RN,@RELRQFP         RQFB
         WITH  (RQFB,RN)
         WITH  (ATFB,RX)
         WITH  (FSB,RB)

         WITH  (RQATTF,RQFBASV)    Map RQWB saved fields in RQFB

         IF    RQADET,EXIT         Already released
         SET   RQADET              Don't do it again

         IF    ('LT RX,RQATFB',NZ),BEGIN File attached
         ADFCB ,                   FILECB
         L     RB,ATFBFSB          FSB
         IF    (RQRGRH,NZ),BEGIN
         GRREL RID=RQRGRH          Release reserve
         END   ,
         IF    (RQAGRH,NZ),BEGIN
         GRREL RID=RQAGRH          Release attach
         END   ,

         IF    RQATMP,BEGIN        Temp file
         DECRS CTFILATP            Current attached files
         DECRS TTFILATP            Current attached files
* Temp files are deleted when detached
         IF    (ATFBFBLK,NZ),BEGIN File was created
         WITH  (FDEL,RK)
         ADFCB ,                   Address file control block
         SAVAIL HEAD=FILEDB,LEN=L'FDEL
         LR    RK,RVR              Get pointer
         CLEAR FDEL
         MVC   FDELID,=C'TMPD'
         ST    RB,FDELF            FSB
         MVC   FDELB,ATFBFBLK      First block
         SPUSH HEAD=FILEDT,ITEM=FDEL Put on list of things to do
         TS    FILEDTS
         IF    Z,BEGIN
         SIGNL FILEDECB,,FILEDASB,FILEDSYR Been waiting long?
         END   ,
         CLEAR ATFBFBLK            Don't do it again
         END   ,                   File was created
         END   ,                   Temp file

         ELSE  BEGIN               Not a temp file
         DECRS CTFILAUS            Current user attached files
         DECRS TTFILAUS            Current user attached files
         L     RJ,FSBAHFB          Get file attach hash table ptr
         WITH  (AHFB,RJ)
         L     RK,ATFBATL          Get attached list hash list address
         WITH  (AHFBL,RK)
         GRGET RID=AHFBGRID,EXCL=YES Reserve the table
         DECR  RS,ATFBCNT          Decrement the count
         IF    (ATFBCNT,NZ),BEGIN  Others still attached
         CLEAR RX                  Don't free the ATFB
         GRREL RID=AHFBGRID        Release the table
         END   ,                   Others still attached
         ELSE  BEGIN               File no longer attached
         LREM  AHFBL,LA:ATFB,WR=RS Remove from list
         GRREL RID=AHFBGRID        Release the table
         DECRS CTFILATT            Current attached files
         DECRS TTFILATT            Current attached files
         IF    (ATFBFTIM,AND,^RQAHALT),BEGIN Update the time?
         PSET  @FCPERM
         PMOV  @FCPFSB,LA:FSB
         PMOV  @FCPNAME,ATFBNAME   File name
         SET   @FCPFMAG            Everyone is magic for this
         VCALL FCATOPRM            Update last access time
         END   ,                   Update the time
         END   ,                   File no longer attached
         END   ,                   Not a temp file

         IF    (RX,NZ),BEGIN       Free ATFB
         IF    (ATFBAGRI,NZ),BEGIN
         GRDEL RID=ATFBAGRI        Delete the resource id
         GRDEL RID=ATFBRGRI        Delete the resource id
         END   ,
         CLEAR ATFB
         MVC   ATFBID,=C'aTFB'
         SPUSH HEAD=FILEATFB,ITEM=ATFB put on free list
         END   ,                   Free ATFB
         END   ,                   File attached

         L     RM,PZCURASB
         WITH  (ASB,RM),'L RM,ASBASFB'
         WITH  (ASFB,RM)
         LREM  ASFBRQ,LA:RQFB,WR=RS Remove from the list
         CLEAR RQFB
         MVC   RQFBID,=C'rQFB'
         SPUSH HEAD=ASFBFQ,ITEM=RQFB Put avail item on free list

         CLEAR RVR
         PEND  ,
         EJECT ,
#FMANFDT RECORD BEGIN
#FMANFDB DS    XL(L'FDEL)
         END   ,
*---------------------------------------------------------------------*
*  FMANFDT -  Delete file task
*
*              This task is created by the delete temp file address
*              space to delete a file.
*
*   Inputs -   Delete file control block
*
*   Output -   None
*---------------------------------------------------------------------*
FMANFDT  PROC  @TENTRY,#FMANFDT

         ADFCB ,                   Address file control block
         L     RN,@TEPARM          Get block pointer
         WITH  (FDEL,RN),BEGIN
         MVC   #FMANFDB,FDEL       Get info
         CLEAR FDEL
         MVC   FDELID,=C'fDEL'
         SPUSH HEAD=FILEDB,ITEM=FDEL Put on free list post haste
         END   ,
         WITH  (FDEL,#FMANFDB)
         WITH  (FSB,RB)
         WITH  (IXR,RX)
         L     RB,FDELF            FSB pointer

         IF    (^FDELFN,OR,FDELFH),BEGIN IXR or hybrid
         L     RX,FDELB            Get first IXR
         IF    ^FDELFN,BEGIN       IXR file
         PSET  @DELIXR
         PMOV  @IXRDFSB,LA:FSB
         PMOV  @IXRDADR,LA:IXR
         ACALL FMDELIXR            Release all blocks
         END   ,                   IXR file
         ELSE  BEGIN               Hybrid
         L3    RM,IXRECNO          Get the first block number
         CLEAR IXRECNO             Don't release block number
         ST    RM,FDELB            Set for release blocks
         PSET  @DELIXR
         PMOV  @IXRDFSB,LA:FSB
         PMOV  @IXRDADR,LA:IXR
         ACALL FMDELIXR            Release blocks in first IXR
         L     RN,FDELC            Get block count
         DECR  RN                  Already did the first
         IF    (RN,NZ),BEGIN       More than one IXR
         LOOP  BEGIN
         INCR  RM                  Next block
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGBNO,(RM)       Set block number
         PMOV  @IXRGADR,LA:IXR     Use this buffer
         ACALL FMIXRGET            Get IXR record
         CLEAR IXRECNO             Don't release block number
         PSET  @DELIXR
         PMOV  @IXRDFSB,LA:FSB
         PMOV  @IXRDADR,LA:IXR
         ACALL FMDELIXR            Release all blocks
         UNTIL (BCT,RN),END
         END   ,                   More than one IXR
         END   ,                   Hybrid
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,LA:IXR
         VCALL SBUFREE             Free IO buffer
         END   ,                   IXR or hybrid

         IF    FDELFN,BEGIN        Non-IXR or hybrid
         PSET  @FMFSB              Release bit numbers
         PMOV  @FMFSBP,LA:FSB
         L     RS,FDELB            Get first block
         L     RVR,FDELC           Get count of blocks
         VCALL FBITRCON            Release blocks
         END   ,                   Non-ixr

         DECRS FILEDCNT            One less task

         PSET  @TEXIT              Exit this task
         VCALL TEXIT

         PEND  CODE=NO
         EJECT ,
*---------------------------------------------------------------------*
*  FMANTDT -  Delete temporary file task
*
*              This task is created by the delete file address
*              space to delete a temporary file.
*
*   Inputs -   Delete temp file control block
*
*   Output -   None
*---------------------------------------------------------------------*
FMANTDT  PROC  @TENTRY

         ADFCB ,                   Address file control block
         WITH  (FSB,RB)
         WITH  (FDEL,RK)
         L     RK,@TEPARM          Get block pointer
         L     RB,FDELF            FSB pointer
         L     RX,FDELB            Get first block number

         CLEAR FDEL
         MVC   FDELID,=C'fDEL'
         SPUSH HEAD=FILEDB,ITEM=FDEL Put on free list

         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGBNO,(RX)       Set first block number
         ACALL FMIXRGET            Get IXR record
         L     RX,@IXRGADR         Get IXR address
         WITH  (IXR,RX),'L RS,IXRRRCS' IXR block count
         PSET  @DELIXR
         PMOV  @IXRDFSB,LA:FSB
         PMOV  @IXRDADR,(RX)
         ACALL FMDELIXR            Release all blocks
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,(RX)
         VCALL SBUFREE             Free IO buffer
         L     R14,TTFILTBK
         LOOP  BEGIN
         LR    R15,R14
         SR    R15,RS              Calc new number of temp blocks
         CS    R14,R15,TTFILTBK    Set new number of temp blocks
         UNTIL Z,END

         DECRS FILEDCNT

         PSET  @TEXIT              Exit this task
         VCALL TEXIT

         PEND  CODE=NO
         EJECT ,
*---------------------------------------------------------------------*
*  FMANTDEL -  Delete file processing
*
*              This task is started during file initialization
*              processing. It checks a queue for temporary files
*              and a queue of regular IXR files to delete when awaken,
*              starting a new task each time one is found.
*
*   Inputs -   None
*
*   Output -   None
*---------------------------------------------------------------------*
FMANTDEL PROC  SCOPE=GLOBAL
         VCALL DISPSHLD            Make us non-swapable
         ADFCB ,                   Address file control block
         MVC   FILEDASB,PZCURASB   Set ASB pointer
         PSET  @SYSRNEW            Get system routine ID
         VCALL SYSRNEW
         ST    RVR,FILEDSYR        Save pointer
         LOOP  BEGIN               Do forever
         IF    (FILEDCNT,GE,16),BEGIN Don't get carried away
         LA    R0,2                2 * 0.1 = .2 seconds
         VCALL M1GOWAIT            Throttle the process
         INCR  R14,FILEDCN2        Count it
         END   ,                   Don't get carried away
         ELSE  BEGIN               Create tasks
         SPOP  HEAD=FILEDT         Get the next control block
         IF    (R0,NZ),BEGIN       Got one!
         INCRS FILEDCNT
         PSET  @TCREATE
         ST    R0,@TCRPARM         Parm is the control block
         MVC   @TCRPRIO,=A(-10)    Lower priority
         MVC   @TCRPSW(4),=X'070C0000' Set PSW
         MVC   @TCRPSW+4(4),=A(FMANTDT) Temp file delete
         SET   @TCRPSW+4.X'80'     31 bit addressing
         SET   @TCRFSTK            Task needs a stack
         VCALL TCREATE             Just do it!
         END   ,                   Got one!
         ELSE  BEGIN               Check for other kind
         SPOP  HEAD=FILEDF         Get the next control block
         IF    (R0,NZ),BEGIN       Got one!
         INCRS FILEDCNT
         PSET  @TCREATE
         ST    R0,@TCRPARM         Parm is the control block
         MVC   @TCRPRIO,=A(-5)     Lower priority
         MVC   @TCRPSW(4),=X'070C0000' Set PSW
         MVC   @TCRPSW+4(4),=A(FMANFDT) IXR file delete
         SET   @TCRPSW+4.X'80'     31 bit addressing
         SET   @TCRFSTK            Task needs a stack
         VCALL TCREATE             Just do it!
         END   ,                   Got one!
         ELSE  BEGIN               Wait a while
         AWAIT FILEDECB,LEN=LONG   Wait as long as necessary
         CLEAR FILEDTS
         END   ,                   Wait a while
         END   ,                   Check for other kind
         END   ,                   Create tasks
         END   ,                   Do forever

         PEND  CODE=NO
         EJECT ,
*---------------------------------------------------------------------*
*  FMANTDIN -  Initialize delete temporary file processing
*
*   Inputs -   None
*
*   Output -   None
*---------------------------------------------------------------------*
FMANTDIN PROC  SCOPE=GLOBAL
*
*  Create an address space for deleting temporary files
*
         PSET  @ACREATE
         MVC   @ACRPSW(4),=X'070C0000' Default location
         L     RA,MATPTR
         WITH  (MAT,RA),'OC @ACRPSW+1(1),MATSKEY' System Key
         MVC   @ACRPSW+4(4),=A(X'80000000'+FMANTDEL)
         VCALL ACREATE                 Create the address space
         PEND  ,
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMASINIT -  Build a ASFB for this address space. This block exists
*              for the entire time the address space exists (user
*              stays logged on).
*
*   Inputs -   None
*
*   Output -   None
*---------------------------------------------------------------------*
FMASFINI PROC  ,
         VMGET L'ASFB,LOC=LOCSYS
         IF    ('LTR RJ,RVR',Z),'ABORT NOASFBMEM'
         WITH  (ASFB,RJ)
         CLEAR ASFB
         MVC   ASFBID,=C'ASFB'     Set block id
         LA    R15,ASFBRQ          Init list
         ST    R15,ASFBRQFP
         ST    R15,ASFBRQBP
         L     RS,PZCURASB
         WITH  (ASB,RS),'ST RJ,ASBASFB' set pointer
         ACALL FMSETSOU            Get signed on account
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  Halt file operations in progress and serialize behind with any
*  tasks waiting for resources
*
*   Input - @FILEHALT
*
*  Output - None
*
*---------------------------------------------------------------------*
         SPACE
FILEHALT PROC  @FILEHALT,SCOPE=GLOBAL
         L     R0,@FHRQID
         L     R1,PZCURASB
         XTRC  R0,R1,FILEHALT      Save some clues

         WITH  (ATFB,RX)
         WITH  (RQFB,RK)

         CLEAR RVR

         IF    ('LT RK,@FHRQID',Z),EXIT Nothing to do

         IF    ('LT RA,RQFBRQWB',NZ),BEGIN IO in progress
         WITH  (RQWB,RA)
         SET   RQAHALT             Indicate file halt processing
         CLEAR RQWBRQFB            He is an orphan now
         CLEAR RQATFB              We'll detach for him
         CLEAR RQFBRQWB            He is an orphan now
         END   ,

         WITH  (RQATTF,RQFBASV)    Map RQWB saved fields in RQFB
         SET   RQAHALT             Indicate file halt processing

         IF    RQAS117,BEGIN       Halt status 117
         VCALL M1CANWAI            Cancel
         EXIT  FILEHALT            Done
         END   ,

         IF    ('LT RX,RQATFB',Z),EXIT

         IF    (ATFBRGRI,NZ),BEGIN
         GRCAN RID=ATFBRGRI        Cancel tasks waiting for reserve
         END   ,
         IF    (ATFBAGRI,NZ),BEGIN
         GRCAN RID=ATFBAGRI        Cancel tasks waiting for attach
         END   ,

         IF    ('LT RB,ATFBFSB',Z),EXIT Done
         WITH  (FSB,RB)
         GRGET RID=FSBCGRI,EXCL=YES Serialize with catalog
         GRREL RID=(RVR)

         L     RJ,FSBAHFB          Get file attach hash table ptr
         WITH  (AHFB,RJ)
         GRGET RID=AHFBGRID,EXCL=YES Serialize with hash table
         GRREL RID=(RVR)

         CLEAR RVR
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  SETTEMPN - Build "ccyymmdd.hh:mm:ss" string
*
*   Inputs -  RS points to format area
*
*   Output -  format area formated
*---------------------------------------------------------------------*
SETTEMPN PROC  ,
         LR    RX,R1               Get pointer to format area
         VCALL M1TIME              Get current
         LR    RY,R0               Save time
         LCR   R0,R1               Get date
         LR    R1,RX               Point to date format area
         XCALL DATE                VCR entry point
         MVI   @R1+8,C'.'
         LA    R1,@R1+9            Next target
         LR    R0,RY               Restore time
         XCALL TIME                VCR entry point
         PEND  ,
         EJECT ,
*-------------------------------------------------------------------*
*
*  CHKACC  --  Check account
*
*   Input  --  @CHKACC
*
*  Output  --  Return code
*               RVR = 0 All OK
*               RVR = 1 Invalid account
*               RVR = 4 Protection exception
*               RVR = 5 Addressing exception
*
*-------------------------------------------------------------------*
#CHKACC  RECORD BEGIN
#CHKACFI DS    X                   FSB id
#CHKACFG DS    CL2                 Group
         END   ,
CHKACC   PROC  @CHKACC,#CHKACC,SCOPE=LOCAL

         CLI   @CHKACCN+3,C'$'     UUU$GG format?
         IF    E,BEGIN             Reformat to GG.UUU
         ICM   R14,B'0111',@CHKACCN
         MVC   @CHKACCG,@CHKACCN+4
         MVI   @CHKACCD,C'.'
         STCM  R14,B'0111',@CHKACCU
         END   ,
         CLI   @CHKACCD,C'.'
         IF    NE,CHKACERR
         LA    RX,@CHKACCG         Point to group
         BAS   RS,CHKACABC         First is alpha
         BAS   RS,CHKAC123         Second is alpha/num
         LA    RX,@CHKACCU         Point to user
         BAS   RS,CHKACABC         First is alpha
         BAS   RS,CHKAC123         Second is alpha/num
         BAS   RS,CHKAC123         Third is alpha/num

         MVC   #CHKACFG,@CHKACCG   Set group
         TR    #CHKACFG,CHKAIDTR   Set group indexes
         LC    RS,#CHKACFG         Get first number
         MH    RS,=Y(26+10)        Calc index
         LC    R15,#CHKACFG+1      Get second number
         AR    RS,R15              Calc some more index

         ADFCB
         A     RS,FILEFSGT         Calculate file id address
         MVC   #CHKACFI,@RS        Get file id
         L     RB,FILEFFSB         Point to first FSB
         L     R0,FILEFSBC         Count of FSB's
         WITH  (FSB,RB)
         LOOP  BEGIN
         IF    (#CHKACFI,EQ,FSBID),EXIT
         L     RB,FSBCHAIN         Next in chain
         UNTIL (BCT,R0),END
         IF    (R0,Z),CHKACER2     File system not available
         ST    RB,@CHKAFSB         Set pointer to FSB

         CLEAR RVR
         EXIT  CHKACC

CHKACERR LABEL ,
         L     RVR,=F'-8'
         EXIT  CHKACC

CHKACER2 LABEL ,
         L     RVR,=F'-12'
         EXIT  CHKACC

CHKAC123 LABEL ,
         CLI   @RX,C'0'
         BL    CHKACABC
         CLI   @RX,C'9'
         BNH   CHKACABE
CHKACABC LABEL ,                   Must be a letter
         CLI   @RX,C'A'
         BL    CHKACERR
         CLI   @RX,C'I'
         BNH   CHKACABE
         CLI   @RX,C'J'
         BL    CHKACERR
         CLI   @RX,C'R'
         BNH   CHKACABE
         CLI   @RX,C'S'
         BL    CHKACERR
         CLI   @RX,C'Z'
         BH    CHKACERR
CHKACABE LABEL ,
         LA    RX,@RX+1
         DECR  RY
         LTR   RY,RY               Set cc
         BR    RS
         PEND  ,
CHKAIDTR EQU   *-C'A'
         ORG   CHKAIDTR+C'A'
         DC    AL1(0,1,2,3,4,5,6,7,8)              A-I
         ORG   CHKAIDTR+C'J'
         DC    AL1(9,10,11,12,13,14,15,16,17)      J-R
         ORG   CHKAIDTR+C'S'
         DC    AL1(18,19,20,21,22,23,24,25)        S-Z
         ORG   CHKAIDTR+C'0'
         DC    AL1(26,27,28,29,30,31,32,33,34,35)  0-9
         ORG   ,
         EJECT ,
*---------------------------------------------------------------------*
*
*  CHKMEM  --  Check user memory.
*
*   Input  --  @CHKMEM
*
*  Output  --  Return code
*               RVR = 0 All OK
*               RVR = 4 Protection exception
*               RVR = 5 Addressing exception
*
*---------------------------------------------------------------------*
CHKMEM   PROC  @CHKMEM,SCOPE=LOCAL
*
* Check out the area
*
         L     R14,@CMEMLOC
         L     R15,@CMEMLEN
         IF    ((R14,Z),OR,(R15,NP)),'LA RVR,6' Specification
         ELSE  BEGIN
         PSET  @PAGE
         MVC   @PAGKEY,@CMEMKEY        Set the key
         MVC   @PAGLOC,@CMEMLOC         the location
         LH    RS,@CMEMLEN
         ST    RS,@PAGLEN                and the length
         VCALL PAGTPROT                Test the protection
         IF    (RVR,NZ),BEGIN
         IF    (RVR,EQ,3),'LA RVR,5'   Addressing exception
         ELSEIF (RVR,EQ,2),'LA RVR,4'   no access
         ELSEIF (@CMEMWRT),'LA RVR,4'   Only read, he wants to write
         ELSE  'CLEAR RVR'             He just wants to look
         END   ,
         END   ,
         IF    (RVR,NZ),'ICM RVR,B"1000",=X"80"' Set panic

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMRANGE - Edit read/write block number and buffer etc.
*
*   Inputs - RA points to the RQWB
*
*   Output - Results in RVR
*---------------------------------------------------------------------*
FMRANGE  PROC  ,
         WITH  (RQWB,RA)
         IF    ^RQRM31,'NC RQIDAT,=X"00FFFFFF"' Non-extended addressing

         IF    ('LT R15,RQILEN',Z),BEGIN Zero length
         IF    RQREAD,FMRANGES     Invalid for read
         END   ,
         ELSE  BEGIN               Some data
         IF    (R15,LT,4),FMRANGES Data length of at least 4
         IF    (R15,GT,8192),FMRANGES Not more than 2 pages
         CLEAR R14
         DECR  R15                 One less
         L     RB,RQFSB
         WITH  (FSB,RB),'LH R0,FSBDSZ' Get block size
         DR    R14,R0              Calc number of blocks - 1
         END   ,                   Some data
         A     R15,RQIBLK          Calc last block number
         ST    R15,RQLBLK

         IF    (RQILEN,NZ),BEGIN
         IF    RQREAD,BEGIN
         CHKMEM RQIDAT,RQILEN,W    Check modify protect
         END   ,
         ELSE  BEGIN
         CHKMEM RQIDAT,RQILEN      Check fetch protect
         END   ,
         IF    (RVR,NZ),'EXIT FMRANGE' Exit if error
         END   ,

         L     R15,RQLBLK
         IF    RQCNIXR,BEGIN
         L     R14,RQBLKC          Get block count
         IF    RQCHYBR,'MH R14,=Y(IXRNT#)' Each block is an IXR
         CR    R15,R14             Check against block count
         END   ,
         ELSE  'C R15,=A(IXRMXNT#)' Max for IXR
         IF    GE,BEGIN
         LA    RVR,1               Out of range
         END   ,
         ELSE  'CLEAR RVR'
         EXIT  FMRANGE             Done

FMRANGES LABEL ,                   Specification error exit
         L     RVR,=X'80000006'    Set panic return

         PEND  ,
         LTORG ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMDELBLK - Called by controls 1 and 2 to delete blocks
*
*   Inputs -  @BLKDEL
*
*   Output -  None
*---------------------------------------------------------------------*
@BLKDEL  RECORD BEGIN
@BLKDRQW DS    A
@BLKDADR DS    A                   MIXR or SIXR address
@BLKDCNT DS    F                   Count of blocks deleted
         END   ,

#BLKDEL  RECORD BEGIN
#BLKDBLF DS    F                   First block number
#BLKDBLL DS    F                   Last block number
#BLKDCNT DS    F                   Count of blocks to delete
#BLKDBUF DS    A                   IXR buffer
#BLKDBUD DS    A                   IXR buffer for dummy IXR
#BLKDBLK DS    F                   Block to release back to file sys
#BLKDRET DS    A                   SIXR file routine return save
#BLKDFLG FLAG  ,
         FLAG  #BLKDMIS            Missing blocks in range
         FLAG  #BLKDD1B            Determine new first block
         FLAG  #BLKDD2B            Determine new last block
         END   ,

FMDELBLK PROC  @BLKDEL,#BLKDEL
         L     RA,@BLKDRQW
         WITH  (RQWB,RA)
         L     RB,RQFSB
         WITH  (FSB,RB)
         L     RX,@BLKDADR
         WITH  (IXR,RX)
         WITH  (IXR,RY),LABEL=S    Super IXR
         WITH  (IXR,RJ),LABEL=J    Save block numbers for delete
         CLEAR #BLKDEL             Clear work area

* Hybrid
         IF    IXRZIXR,BEGIN       Hybrid file
         LR    RY,RX               Get base of first record
         L3    R15,S.IXRLWRF       Get first block in the file
         L3    R14,S.IXRHIRF       Get last block in the file
         IF    (R14,LT,RQICBLK),FMBLKD12 Nothing to do
         IF    (R15,GT,RQICBL2),FMBLKD12 Nothing to do
         IF    (R14,LE,RQICBL2),BEGIN Last block in file le last block
         IF    (R14,LT,RQICBL2),'SET #BLKDMIS' Some are missing
         SET   #BLKDD2B            Determine new last block
         END   ,                   Last block in file le last block
         ELSE  'L R14,RQICBL2'     Get block specified
         IF    (R15,GE,RQICBLK),BEGIN First block in file ge 1st block
         IF    (R15,GT,RQICBLK),'SET #BLKDMIS' Some are missing
         IF    #BLKDD2B,BEGIN      Deleting before first and after last
         CLEAR S.IXRLWRF,S.IXRHIRF,#BLKDD2B Deleting all blocks
         END   ,
         ELSE  'SET #BLKDD1B'      Determine new first block
         END   ,                   First block in file ge 1st block
         ELSE  'L R15,RQICBLK'     Get block specified
         INCR  R14
         SR    R14,R15             Calc count of blocks to delete
         ST    R14,#BLKDCNT        Save
         CLEAR R14
         D     R14,=A(IXRNT#)      Calc IXR/block index
         MH    R14,=Y(L'IXRNT)     Calc block displacement
         LR    RN,R14              Get disp
         LR    RM,R15              Start IXR number
         ST    RM,#BLKDBLK         Save for later
         LOOP  BEGIN               Until no next to process
         IF    (RM,NZ),BEGIN       Not the first record
         L     R15,RQFBLK
         AR    R15,RM              Calc IXR block number
         BAS   RS,FMBLKDE5         Get the IXR
         END   ,                   Not the first record
         ELSE  'ST RX,#BLKDBUF'    Save buffer address temporarily
         LA    R15,IXR+(IXRNT#*L'IXRNT) Point to end
         LA    RX,IXR(RN)          Point to start block
         SR    R15,RX              Calc
         CLEAR R14
         D     R14,=A(L'IXRNT)
         C     R15,#BLKDCNT        Are the rest in this IXR?
         IF    GE,BEGIN            Yes
         L     RN,#BLKDCNT         Get count to delete
         CLEAR #BLKDCNT
         END   ,
         ELSE  BEGIN
         L     R14,#BLKDCNT
         SR    R14,R15
         ST    R14,#BLKDCNT        Set new count
         LR    RN,R15              Get count for this IXR
         END   ,
         BAS   RS,FMBLKDE6         Just do it!
         IF    (RM,Z),BEGIN        First IXR
         CLEAR #BLKDBUF            Clear temporary buff save
         END   ,                   First IXR
         IF    (RK,NZ),BEGIN       Some deleted
         L     R14,S.IXRNRCS       Number of blocks
         SR    R14,RK
         ST    R14,S.IXRNRCS       Update
         L     R14,S.IXRRRCS       Number of blocks
         SR    R14,RK
         ST    R14,S.IXRRRCS       Update
         A     RK,@BLKDCNT         Calc number deleted so far
         ST    RK,@BLKDCNT         Save
         BAS   RS,FMBLKDE4         File the IXR
         IF    #BLKDD2B,BEGIN      Determining new last block?
         LR    RJ,RM               Get current IXR block number
         LOOP  BEGIN               Loop forever
         IF    (RJ,Z),EXIT         It must be here
         IF    (IXRHIRC,NZ),EXIT   Here it is
         IF    (IXRNT,NZ),EXIT     The high one is the zero one
         DECR  RJ                  Back up one IXR
         LR    R15,RJ
         A     R15,RQFBLK          Calc IXR block number
         BAS   RS,FMBLKDE5         Get the IXR
         END   ,                   Loop forever
         MH    RJ,=Y(IXRNT#)       Calc last block number
         L3    R15,IXRHIRC
         AR    RJ,R15
         ST3   RJ,S.IXRHIRF        Save new last block numberr
         LR    RX,RY
         BAS   RS,FMBLKDE4         File the first IXR
         CLEAR #BLKDD2B            Don't do it again
         END   ,                   Determining new last block?
         IF    (RM,NZ),BEGIN       Not the first record
         LR    RX,RY
         BAS   RS,FMBLKDE4         File the first IXR
         END   ,
         BAS   RS,FMBLKDE9         Return the block numbers
         END   ,                   Some deleted
         INCR  RM                  Next IXR
         CLEAR RN                  Start with first block from now on
         UNTIL (#BLKDCNT,Z),END    Until no next to process
         IF    #BLKDD1B,BEGIN      New first block
         DECR  RM                  Reset to current
         IF    (RM,Z),'LR RX,RY'   Point to first IXR
         ELSE  'L RX,#BLKDBUF'     Point to current IXR
         LR    RJ,RM               Get current IXR block number
         LOOP  BEGIN               Loop forever
         IF    (IXRLWRC,NZ),EXIT   Here it is
         IF    (IXRNT,NZ),EXIT     The low one is the zero one
         INCR  RJ                  Go to the next IXR
         IF    (RJ,GE,RQBLKC),EXIT Can't go beyond the end
         LR    R15,RJ
         A     R15,RQFBLK          Calc IXR block number
         BAS   RS,FMBLKDE5         Get the IXR
         END   ,                   Loop forever
         MH    RJ,=Y(IXRNT#)       Calc first block number
         L3    R15,IXRLWRC
         AR    RJ,R15
         ST3   RJ,S.IXRLWRF        Save new first block number
         LR    RX,RY
         BAS   RS,FMBLKDE4         File the first IXR
         END   ,                   New first block
         END   ,                   Hybrid file
* SIXR
         ELSEIF IXRSIXR,BEGIN      Super IXR
         L     RN,RQICBL2          Get end block number
         CLEAR RM
         D     RM,=A(IXRNT#)       Calc IXR/block number
         IF    (RN,LT,IXRLWXR),FMBLKD12 Last does not exist
         IF    (RN,GT,IXRHIXR),BEGIN End block greater than last
         SET   #BLKDMIS            Indicate some are missing
         LH    RN,IXRHIXR          Go to last IXR
         LA    RM,IXRNT#-1         Go to last record
         MH    RN,=Y(IXRNT#)       Calc last block number
         AR    RN,RM               In last IXR record
         ST    RN,#BLKDBLL         Set last block number
         END   ,                   End block greater than last
         ELSE  'MVC #BLKDBLL,RQICBL2' Set last block number
         L     RN,RQICBLK          Get start block number
         CLEAR RM
         D     RM,=A(IXRNT#)       Calc IXR/block number
         IF    (RN,GT,IXRHIXR),FMBLKD12 First does not exist
         IF    (RN,LT,IXRLWXR),BEGIN Start block less than first
         SET   #BLKDMIS            Indicate some are missing
         LH    RN,IXRLWXR          Start with first IXR
         MH    RN,=Y(IXRNT#)       Calc first block number
         ST    RN,#BLKDBLF         Set first block number
         END   ,                   Start block less than first
         ELSE  'MVC #BLKDBLF,RQICBLK' Set first block number
         L     RN,#BLKDBLF
         L     RM,#BLKDBLL
         INCR  RM
         SR    RM,RN               Calc count of blocks to delete
         ST    RM,#BLKDCNT         Save
         CLEAR RM
         D     RM,=A(IXRNT#)       Calc IXR and block number
         MH    RN,=Y(L'IXRNT)      Calc SIXR displacement
         LA    RY,IXR(RN)          Point IXR block number
         LOOP  BEGIN               Until no next to process
         LA    R15,IXRNT#          Count of blocks in IXR
         SR    R15,RM              Calc count to end
         L     R14,#BLKDCNT        Get count to delete
         IF    (R14,GT,R15),BEGIN
         LR    RN,R15              Get count to delete this IXR
         SR    R14,R15             Calc count left afterwards
         ST    R14,#BLKDCNT        Set count left
         END   ,
         ELSE  BEGIN
         LR    RN,R14              Get count left
         CLEAR #BLKDCNT            None left afterwards
         END   ,
         IF    (S.IXRNT,Z),'SET #BLKDMIS' Indicate blocks missing
         ELSE  BEGIN               Process IXR
         L3    R15,S.IXRNT         Get IXR block number
         BAS   RS,FMBLKDE5         Get the IXR
         MH    RM,=Y(L'IXRNT)      Calc displacement
         LA    RX,IXR(RM)          Point to start block
         BAS   RS,FMBLKDE6         Just do it!
         IF    (RK,NZ),BEGIN       Some blocks deleted
         IF    (IXRNRCS,Z),BEGIN   IXR empty
         L3    R15,S.IXRNT         Get block number
         ST    R15,#BLKDBLK        Save
         CLEAR S.IXRNT             Clear block
         L     RX,@BLKDADR         Get SIXR address
         DECR  R14,IXRNIXR         One less IXR
         DECR  R14,IXRRRCS         One less total blocks
         END   ,                   IXR empty
         ELSE  'BAS RS,FMBLKDE4'   File the IXR
         L     RX,@BLKDADR         Get SIXR address
         L     R14,IXRNRCS         Number of blocks
         SR    R14,RK
         ST    R14,IXRNRCS         Update
         L     R14,IXRRRCS         Number of blocks
         SR    R14,RK
         ST    R14,IXRRRCS         Update
         A     RK,@BLKDCNT         Calc number deleted so far
         ST    RK,@BLKDCNT         Save
         BAS   RS,FMBLKDE2         Save the SIXR
         BAS   RS,FMBLKDE9         Return the block numbers
         BAS   RS,FMBLKDE8         Return block number if needed
         END   ,                   Some blocks deleted
         END   ,                   Process IXR
         LA    RY,S.IXR+L'IXRNT    Point to next IXR block
         CLEAR RM                  Start at beginning of next IXR
         UNTIL (#BLKDCNT,Z),END    Until no next to process
         END   ,                   Super IXR
* MIXR
         ELSE  BEGIN               MIXR record
         ST    RX,#BLKDBUF         Save IXR address
         L     RM,RQICBLK          Get start block number
         IF    (RM,GT,IXRHIRC),FMBLKD12 Start does not exist
         IF    (RM,LT,IXRLWRC),BEGIN Start lower than real start
         L3    RM,IXRLWRC          Get real start
         SET   #BLKDMIS            Indicate some are missing
         END   ,
         L     RN,RQICBL2          Get end block number
         IF    (RN,LT,IXRLWRC),FMBLKD12 End does not exist
         IF    (RN,GT,IXRHIRC),BEGIN End higher that real end
         L3    RN,IXRHIRC          Get real end
         SET   #BLKDMIS            Indicate some are missing
         END   ,
         INCR  RN
         SR    RN,RM               Calc number of blocks
         MH    RM,=Y(L'IXRNT)      Calc displacement
         LA    RX,IXR(RM)          Point to first to delete
         BAS   RS,FMBLKDE6         Just do it!
         ST    RK,@BLKDCNT         Set count deleted
         IF    (RK,Z),FMBLKD12     None deleted
         L     R15,IXRNRCS         Get count of user blocks
         INCR  R15                 Count the MIXR
         ST    R15,IXRRRCS         Set total number of blocks
         BAS   RS,FMBLKDE4         File the IXR
         BAS   RS,FMBLKDE9         Return the block numbers
         CLEAR #BLKDBUF            Don't release this buffer
         END   ,                   MIXR record
         IF    (#BLKDBUF,NZ),BEGIN Free IO buffer
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,#BLKDBUF
         VCALL SBUFREE             Free IO buffer
         END   ,                   Free IO buffer
         IF    #BLKDMIS,FMBLKD12   Some missing
         CLEAR RN                  Set return code
         B     FMBLKDEX

FMBLKD12 LABEL ,
         LA    RN,12               Some blocks are missing
         B     FMBLKDEX

FMBLKDEX LABEL ,
         IF    (#BLKDBUD,NZ),BEGIN Free IO buffer
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,#BLKDBUD
         VCALL SBUFREE             Free IO buffer
         END   ,                   Free IO buffer
         LR    RVR,RN              Get return code
         EXIT  FMDELBLK            Done

FMBLKDE2 LABEL ,                   Save SIXR
         ST    RS,#BLKDRET         Save return address
         L     RX,@BLKDADR         Reset SIXR base
         IF    (IXRNRCS,Z),BEGIN   No more user blocks
         CLEAR IXRLWXR,IXRHIXR     Clear low and high
         END   ,                   No more user blocks
         ELSE  BEGIN               Determine low and high
         LA    R14,IXRIXNT#        Get count of IXRs in SIXR
         LOOP  BEGIN
         IF    (IXRNT,NZ),EXIT     First existing block
         LA    RX,IXR+L'IXRNT      Increment pointer
         UNTIL (BCT,R14),END
         L     RX,@BLKDADR         Reset SIXR base
         LA    R15,IXRIXNT#        Get count of IXRs in SIXR
         SR    R15,R14             Calc block number
         STH   R15,IXRLWXR         Set first record number
         LA    RX,IXR+(L'IXRNT*IXRIXNT#)-L'IXRNT Point to the last one
         LA    R14,IXRIXNT#        Get count of IXRs in SIXR
         DECR  R14                 Rel zero
         LOOP  BEGIN
         IF    (IXRNT,NZ),EXIT     Last existing block
         SH    RX,=Y(L'IXRNT)      Back up one
         UNTIL (BCT,R14),END
         L     RX,@BLKDADR         Reset SIXR base
         STH   R14,IXRHIXR         Set last record number
         END   ,                   Determine low and high
         IF    (IXRHIXR,Z),BEGIN   Convert SIXR to MIXR
         CLEAR IXRSIXR,IXRLWRC,IXRHIRC,IXRNIXR
         IF    (IXRNT,NZ),BEGIN    Get blocks from first IXR
         LR    RY,RX               Get old SIXR address
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,#BLKDBUF   Set buffer address
         PMOV  @IXRGBNO,S.IXRNT    Set block number
         ACALL FMIXRGET            Get IXR
         L     RX,@IXRGADR         Get IXR base
         MVC   S.IXRLWRC,IXRLWRC   Get low block
         MVC   S.IXRHIRC,IXRHIRC   Get high block
         LA    R0,S.IXRNT          Point to first source block number
         LA    R1,L'IXRNT*IXRNT#   Get length of move
         LA    R14,IXRNT           Point to first dest block number
         LR    R15,R1              Same length
         MVCL  R0,R14              Get the block numbers
         DECR  R14,S.IXRRRCS       One less block in file
         L3    R14,IXRECNO         Save record number
         ST    R14,#BLKDBLK        Set
         LR    RX,RY               Set new MIXR address
         END   ,                   Get blocks from first IXR
         END   ,                   Convert SIXR to MIXR
         BAS   RS,FMBLKDE4         File SIXR
         BAS   RS,FMBLKDE8         Release block number if necessary
         L     RS,#BLKDRET         Get return address
         BR    RS                  Return to caller

FMBLKDE4 LABEL ,                   Save IXR
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,LA:IXR     Set IXR address
         ACALL FMIXRPUT            File the IXR away
         BR    RS

FMBLKDE5 LABEL ,                   Get IXR
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,#BLKDBUF   Set buffer address
         PMOV  @IXRGBNO,(R15)      Set block number
         ACALL FMIXRGET            Get IXR record
         L     RX,@IXRGADR         Get IXR base
         ST    RX,#BLKDBUF         Save buffer address
         BR    RS

FMBLKDE6 LABEL ,                   Get blocks to delete
         LT    RJ,#BLKDBUD         Get dummy ixr address
         IF    Z,BEGIN
         PSET  @SBGET
         PMOV  @SBGPOO,FSBRBT      Get an io buffer
         VCALL SBUFGET
         L     RJ,@SBGADR          Get dummy ixr address
         ST    RJ,#BLKDBUD
         END   ,
         LH    RK,FSBDSZ           Get length
         CLEAR R15
         MVCL  RJ,R14              Clear buffer
         L     RJ,#BLKDBUD         Set base
         CLEAR RK                  Clear kount of blocks deleted
         LOOP  BEGIN
         IF    (IXRNT,NZ),BEGIN
         MVC   J.IXRNT,IXRNT       Save block number
         LA    RJ,J.IXR+L'IXRNT    Increment dummy pointer
         CLEAR IXRNT               Clear the block number
         INCR  RK                  Increment count of released
         END   ,
         ELSE  'SET #BLKDMIS'      Indicate some missing from range
         LA    RX,IXR+L'IXRNT      Increment pointer
         UNTIL (BCT,RN),END
         L     RX,#BLKDBUF         Reset IXR base
         IF    (RK,NZ),BEGIN       Something was deleted
         IF    ^IXRZIXR,BEGIN      Not used for hybrid file
         L     R15,IXRNRCS         Get count of blocks
         SR    R15,RK              Calc count remaining
         ST    R15,IXRNRCS         Set count left
         END   ,
         CLEAR IXRHIRC,IXRLWRC     Clear high low blocks
         LA    R14,IXRNT#          Get count of blocks in IXR
         LOOP  BEGIN
         IF    (IXRNT,NZ),EXIT     First existing block
         LA    RX,IXR+L'IXRNT      Increment pointer
         UNTIL (BCT,R14),END
         L     RX,#BLKDBUF         Reset IXR base
         IF    (R14,NZ),BEGIN      Set hilo block numbers
         LA    R15,IXRNT#          Get count of blocks in IXR
         SR    R15,R14             Calc block number
         ST3   R15,IXRLWRC         Set first record number
         LA    RX,IXR+(L'IXRNT*IXRNT#)-L'IXRNT Point to the last one
         LA    R14,IXRNT#          Get count of blocks in IXR
         DECR  R14                 Rel zero
         LOOP  BEGIN
         IF    (IXRNT,NZ),EXIT     Last existing block
         SH    RX,=Y(L'IXRNT)      Back up one
         UNTIL (BCT,R14),END
         L     RX,#BLKDBUF         Reset IXR base
         ST3   R14,IXRHIRC         Set last record number
         END   ,                   Set hilo block numbers
         END   ,                   Something was deleted
         BR    RS                  Return

FMBLKDE8 LABEL ,                   Release block number
         LT    RVR,#BLKDBLK        Get block to return
         IF    NZ,BEGIN
         PSET  @FMFSB
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITREL             Release back to the file system
         CLEAR #BLKDBLK
         END   ,
         BR    RS                  Return

FMBLKDE9 LABEL ,                   Release a dummy full of blocks
         L     RJ,#BLKDBUD         Reset dummy base
         IF    (J.IXRNT,NZ),BEGIN  Any to release
         PSET  @DELIXR
         PMOV  @IXRDFSB,LA:FSB
         PMOV  @IXRDADR,LA:J.IXR
         ACALL FMDELIXR            Release all the blocks
         END   ,                   Any to release
         BR    RS                  Return

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMDELIXR - Release IXR block numbers back to the system
*
*   Inputs -  @DELIXR
*
*   Output -  None
*
* Note: all block numbers referenced are release back to the system
*       and all IO buffers obtained by this routine are released back
*       to the system. The input buffer referenced by @IXRDADR is NOT
*       released by this routine and must be by the caller.
*
*---------------------------------------------------------------------*
@DELIXR  RECORD BEGIN
@IXRDFSB DS    A
@IXRDADR DS    A
         END   ,

FMDELIXR PROC  @DELIXR
         L     RB,@IXRDFSB
         WITH  (FSB,RB)
         L     RX,@IXRDADR
         WITH  (IXR,RX)
         WITH  (IXR,RY),LABEL=S    Super IXR
         IF    IXRSIXR,BEGIN       Super IXR
         LR    RY,RX               Set SIXR address
         CLEAR RK                  Clear work block pointer
         LA    RJ,IXRIXNT#         Count of IXRs in super IXR
         LOOP  BEGIN
         IF    (S.IXRNT,NZ),BEGIN  IXR exists
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,(RK)       Set block pointer
         PMOV  @IXRGBNO,S.IXRNT    Set block number
         ACALL FMIXRGET            Get IXR
         L     RX,@IXRGADR
         LR    RK,RX               Save buffer address
         BAS   RS,FMIXRDE4         Just do it!
         END   ,                   IXR exists
         LA    RY,S.IXR+L'IXRNT    Increment SIXR pointer
         UNTIL (BCT,RJ),END        Get all the IXRs
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,(RK)
         VCALL SBUFREE             Free buffer
         L     RX,@IXRDADR         Set SIXR address again
         END   ,                   Super IXR

         L3    RY,IXRECNO          Save record number this block
         BAS   RS,FMIXRDE4         Just do it!

         IF    (RY,NZ),BEGIN       Not called by CONTROL code
         PSET  @FMFSB              Release bit numbers
         PMOV  @FMFSBP,LA:FSB
         LR    RVR,RY
         VCALL FBITREL             Release back to the system
         END   ,                   Not called by CONTROL code

         CLEAR RVR
         EXIT  FMDELIXR

FMIXRDE4 LABEL ,
         PSET  @FMFSB              Release bit numbers
         PMOV  @FMFSBP,LA:FSB
         IF    IXRSIXR,'LA RN,IXRIXNT#'
         ELSE  'LA RN,IXRNT#'      Get count of blocks in IXR
         LOOP  BEGIN
         IF    (IXRNT,NZ),BEGIN
         L3    RVR,IXRNT
         VCALL FBITREL             Release back to the system
         END   ,
         LA    RX,IXR+L'IXRNT      Increment pointer
         UNTIL (BCT,RN),END
         BR    RS

         PEND  ,
         EJECT
*---------------------------------------------------------------------*
*  FMIXRGET - Get IXR from the file
*
*   Inputs -  @IXRGEPU
*
*   Output -  None
*---------------------------------------------------------------------*
FMIXRGET PROC  @IXRGEPU
         L     RB,@IXRGFSB         Address FSB
         WITH  (FSB,RB)
         WITH  (ATFB,RN)
         WITH  (IXR,RX)
         WITH  (IXR,RM),LABEL=W

         IF    (@IXRGBNO,Z),'ABORT IXRGET_INV_BLKNO'

         PSET  @FDOIODO            Get IXR from file
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDOBLK,@IXRGBNO    Block number
         PMOV  @FDODATA,@IXRGADR   Block address
         PMOV  @FDODATL,FSBDSZ     Data length
         SET   @FDOFR              Indicate read IXR
         VCALL FDOIODO             Read IXR record
         MVC   @IXRGADR,@FDODATA   Set block address

         PEND  ,
         EJECT
*---------------------------------------------------------------------*
*  FMIXRPUT - Put IXR into the file
*
*   Inputs -  @IXRGEPU
*
*   Output -  None
*---------------------------------------------------------------------*
FMIXRPUT PROC  @IXRGEPU
         L     RB,@IXRGFSB         Address FSB
         WITH  (FSB,RB)
         L     RX,@IXRGADR         IXR address
         WITH  (IXR,RX)

         IF    (IXRECNO,Z),'ABORT IXRPUT_INV_BLKNO'

         PSET  @FDOIODO
         PMOV  @FDOFSB,LA:FSB      FSB ptr
         PMOV  @FDOBLK,IXRECNO     Block number
         PMOV  @FDODATA,LA:IXR     Block address
         PMOV  @FDODATL,LA:L'IXR   Data length
         SET   @FDOFW              Indicate write IXR

         LA    R15,FBHTIXR         Assume IXR
         IF    IXRZIXR,'LA R15,FBHTZIXR' ZIXR
         ELSEIF IXRSIXR,'LA R15,FBHTSIXR' SIXR
         ELSEIF IXRMIXR,'LA R15,FBHTMIXR' MIXR
         PMOV  @FDOTYPE,(R15)

         VCALL FDOIODO             Write IXR record

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMIXRADD - Add first IXR to the file - called by FILECAT for
*             new file processing
*
*   Inputs - @FMIXIL
*
*   Output - RVR contains the return code
*---------------------------------------------------------------------*
FMIXRADD PROC  @FMIXRAD,SCOPE=GLOBAL
         L     RB,@FMIXFSB         Address FSB
         WITH  (FSB,RB)

         PSET  @FMFSB
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITGET
         IF    (RVR,Z),BEGIN       No more blocks
         LA    RVR,28              No more room
         EXIT  FMIXRADD
         END   ,
         ST    RVR,@FMIXBLK        Save block number
         PSET  @SBGET
         PMOV  @SBGPOO,FSBRBT      Get an io buffer
         VCALL SBUFGET
         L     RM,@SBGADR          Get buffer address
         WITH  (IXR,RM)
         MVC   IXRNAME+L'IXRNAME-4(4),=CL4' '
         MVC   IXRNAME(L'IXRNAME-4),@FMIXNAM File name
         MVC   IXRECNO,@FMIXBLK+1  Set record number
***** Eventially do not maintain file mask in IXRSTATE
* Removed in spring of 2002
*         OI    IXRSTATE,FPALL      All permits for owner
*****************************
         MVI   IXRRRCS+3,1         This is the only record for now
         SET   IXRMIXR             Set to master IXR

         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,LA:IXR     Set IXR address
         ACALL FMIXRPUT            File the IXR away


         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,LA:IXR
         VCALL SBUFREE             Put buffer back

         CLEAR RVR

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMHYINIT - Initialize a hybrid file - called by FILECAT for
*             new file processing
*
*   Inputs - @FMIXIL
*
*   Output - RVR contains the return code
*---------------------------------------------------------------------*
FMHYINIT PROC  @FMIXRAD,SCOPE=GLOBAL
         L     RB,@FMIXFSB         Address FSB
         WITH  (FSB,RB)

         PSET  @SBGET
         PMOV  @SBGPOO,FSBRBT      Get an io buffer
         VCALL SBUFGET
         L     RX,@SBGADR          Get buffer address
         WITH  (IXR,RX)

         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGADR,LA:IXR     Set IXR address

         L     RM,@FMIXBLK         First block number
         L     RN,@FMIXCNT         Count of blocks
         IF    (@FMIXEXT,NZ),BEGIN Extend existing file
         PMOV  @IXRGBNO,(RM)       Set first block number
         ACALL FMIXRGET            Get the first IXR
         LR    R14,RN              Get extend count
         A     R14,IXRRRCS         Add to total
         ST    R14,IXRRRCS         Set
         ACALL FMIXRPUT            Update
         LA    R0,IXR
         LH    R1,FSBDSZ
         CLEAR R15
         MVCL  R0,R14              Clear IXR
         L     RM,@FMIXEXT         Init from here
         END   ,                   Extend existing file
         ELSE  'ST RN,IXRRRCS'     Count of IXRs in the file

         SET   IXRZIXR             Indicate hybrid IXR
         SET   IXRFIXR             Indicate first one
         MVC   IXRNAME+L'IXRNAME-4(4),=CL4' '
         MVC   IXRNAME(L'IXRNAME-4),@FMIXNAM File name

         LOOP  BEGIN
         ST3   RM,IXRECNO
         ACALL FMIXRPUT            File the IXR away
         CLEAR IXRRRCS,IXRFIXR     Only in the first one
         INCR  RM                  Next record in the range
         UNTIL (BCT,RN),END

         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,LA:IXR
         VCALL SBUFREE             Put buffer back

         CLEAR RVR

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMSETSOU - Set signed-on user in the address space file block.
*
*   Inputs - None
*
*   Output - signed-on user set/reset in ASFB
*---------------------------------------------------------------------*
FMSETSOU PROC  ,
         L     RS,PZCURASB
         WITH  (ASB,RS)
         WITH  (ASFB,RJ)
         IF    ('LT RJ,ASBASFB',NZ),BEGIN
         PSET  @ACAINFO
         PMOV  @ACAASB,LA:ASB      Current ASB
         VCALL ACAINFO             Get logged on account
         MVC   ASFBSAGR,@ACAUID+3  Get group
         MVI   ASFBSADO,C'.'        Set dot
         MVC   ASFBSAUS,@ACAUID    Get user
         END   ,
         CLEAR RVR
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMCLSUDO - Clear pseudo user in the address space file block
*
*   Inputs - none
*
*   Output - none
*---------------------------------------------------------------------*
FMCLSUDO PROC  SCOPE=GLOBAL        Clear pseudo user
         L     RS,PZCURASB
         WITH  (ASB,RS)
         WITH  (ASFB,RJ)
         IF    ('LT RJ,ASBASFB',NZ),'CLEAR ASFBPACC'
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMANFINF - Provide various file system information
*
*   Inputs - @FMFINFO
*
*   Output - @FMFINFO
*---------------------------------------------------------------------*
FMANFINF PROC  @FMFINFO,SCOPE=GLOBAL
         WITH  (FSB,RB)
         WITH  (ATFB,RJ)
         WITH  (RQFB,RK)
         WITH  (RQATTF,RQFBASV)    Map RQWB saved fields in RQFB
         WITH  (IXR,RX)
         IF    ('LT RK,@FMFIDID',Z),BEGIN
         MVC   @FMFINAM,=CL(L'@FMFINAM)'*** File being detached ***'
         END   ,
         ELSEIF RQASTAT,BEGIN      Status SVC in progress
         MVC   @FMFINAM,=CL(L'@FMFINAM)'*** STATUS in progress ***'
         END   ,
         ELSE  BEGIN               Got the RQFB
         L     RJ,RQATFB           Point to the attached file block
         MVC   @FMFINAM(4),=C'ORV.' Set file name
         MVC   @FMFINAM+4(L'ATFBNAME),ATFBNAME
         IF    RQASHR,'SET @FMFISHR'
         IF    RQARES,'SET @FMFIRSV'
         IF    RQATMP,'SET @FMFITMP'
         IF    RQCHYBR,'SET @FMFIHYB'
         ELSEIF RQCNIXR,'SET @FMFINIX'
         IF    ^RQADONE,'SET @FMFIATT'
         MVC   @FMFIPRI,RQAPERM      Get attach permits
         NC    @FMFIPRI,ATFBMASK     Limit with file mask
         IF    RQCNIXR,'MVC @FMFIBLK,ATFBBLKC' Set block count
         ELSE  BEGIN               IXR file
         L     RB,ATFBFSB          Set FSB pointer
         PSET  @IXRGEPU
         PMOV  @IXRGFSB,LA:FSB
         PMOV  @IXRGBNO,ATFBFBLK   Set first block number
         ACALL FMIXRGET            Get IXR record
         L     RX,@IXRGADR         Set IXR pointer
         MVC   @FMFIBLK,IXRNRCS    Number of user blocks
         PSET  @SBFREE
         PMOV  @SBFPOO,FSBRBT
         PMOV  @SBFADR,LA:IXR
         VCALL SBUFREE             Give back IXR buffer
         END   ,                   IXR file
         END   ,                   Got the RQFB

         CLEAR RVR
         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMANINIT - Initalize file system
*
*   Inputs - FSB pointer
*
*   Output - None
*---------------------------------------------------------------------*
FMANINIT PROC  @FMFSB,SCOPE=GLOBAL
         L     RB,@FMFSBP
         WITH  (FSB,RB)
*
* Allocate attached files hash table
*
         L     RK,=A(AHFBLEN)
         VMGET (RK),LOC=GLOBHI,FIX=YES,PAGE=YES
         IF    ('LTR RJ,RVR',Z),'ABORT NOAHFBMEM'
         ST    RJ,FSBAHFB          Set pointer
         CLEAR RN
         MVCL  RJ,RM               Clear
         L     RJ,FSBAHFB          Set pointer
         WITH  (AHFB,RJ),BEGIN
         MVC   AHFBID,=C'AHFB'     Set block id
         ST    RB,AHFBFSB          Set back pointer to FSB
         GRCRE CID=(RJ)            Create a general resource
         ST    RVR,AHFBGRID        Set resource id
         L     RK,=A(AHFBCNT)      Count of hash lists
         LOOP  BEGIN
         LA    RM,AHFBLFP
         ST    RM,AHFBLFP          Init
         ST    RM,AHFBLBP
         LA    RJ,AHFB+L'AHFBL     Increment pointer
         UNTIL (BCT,RK),END
         END   ,                   End with

         PEND  ,
         EJECT ,
*---------------------------------------------------------------------*
*  FMANTERM - Terminate file services
*               o Set each file system to unavailable
*               o Wait while the file activity finishes
*               o Deactivate bitmap processing (give all buffered
*                 blocks numbers back to the system)
*
*   Inputs - None
*
*   Output - None
*---------------------------------------------------------------------*
FMANTERM PROC  SCOPE=GLOBAL
         ADFCB ,
         L     RB,FILEFFSB         Point to first FSB
         WITH  (FSB,RB)
         WHILE (RB,NZ),BEGIN
         SET   FSBANAVL+FSBCLOSE   Set to not available
         L     RB,FSBCHAIN         Point to next one
         END   ,
         LA    R0,50               50 * 0.1 = 5 seconds
         VCALL M1GOWAIT            Wait for things to finish

         L     RB,FILEFFSB         Point to first FSB
         PSET  @FMFSB
         WHILE (RB,NZ),BEGIN
         PMOV  @FMFSBP,LA:FSB
         VCALL FBITDEA             Deactivate bitmap processing
         L     RB,FSBCHAIN         Point to next one
         END   ,

         PEND  ,
         EJECT ,
         LTORG ,
         END   .
