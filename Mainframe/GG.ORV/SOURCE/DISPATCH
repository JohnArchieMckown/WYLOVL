DISPATCH TITLE 'Orvyl Dispatcher and Supervisor'
         COPY  HEADER
         EJECT ,
DISPATCH MODULE TRCNUM=1
         TITLE 'Global Control Blocks'
         COPY  PZERO
         USING (PZERO,R0)
         EJECT ,
         COPY  MAT
         EJECT ,
         COPY  ASB
         EJECT ,
         COPY  SIGPARM
         EJECT ,
         COPY  DISPPARM
         EJECT ,
         COPY  TIMEPARM
         EJECT ,
         COPY  LOCKPARM
         EJECT ,
         COPY  IOSIPARM
         EJECT ,
         COPY  VMPARM
         EJECT ,
         COPY  VMIPARM
         EJECT ,
         COPY  IPLPARM
         EJECT ,
         COPY  PAGEPARM
         EJECT ,
         COPY  PARMPARM
         EJECT ,
         COPY  XITPARM
         EJECT ,
         COPY  SEXIPARM
         TITLE 'Local Macros'
*
* Priority queue functions.
*
         MACRO
&L       PQFUNC &Q,&A,&AR,&T
.*
.* Q  -- Queue parm
.* A  -- ASDB parm
.* AR -- null means that the A parm is not required
.* T  -- type of call
.*
         AIF   ('&Q' EQ '').NOQ
&L       PSET  PQPARM,CLEAR=NO
         PMOV  PQQUEUE,&Q,OP=LA
         AIF   ('&AR' EQ '').NOAR
         AIF   ('&A' EQ '').NOA
         PMOV  PQASDB,&A,OP=LA
.NOAR    ANOP
         ACALL PQ&T
         MEXIT
.NOQ     MNOTE 8,'Queue pointer missing'
         MEXIT
.NOA     MNOTE 8,'ASDB pointer missing'
         MEND
*
         MACRO
&L       PQHIGH &QUEUE
&L       PQFUNC &QUEUE,,,HIGH
         MEND
*
         MACRO
&L       PQLOW  &QUEUE
&L       PQFUNC &QUEUE,,,LOW
         MEND
*
         MACRO
&L       PQPRIO &QUEUE
&L       PQFUNC &QUEUE,,,PRIO
         MEND
*
         MACRO
&L       PQHPFN &QUEUE
&L       PQFUNC &QUEUE,,,HPFN
         MEND
*
         MACRO
&L       PQADD  &QUEUE,&ASDB
&L       PQFUNC &QUEUE,&ASDB,Y,ADD
         MEND
*
         MACRO
&L       PQREQ  &QUEUE,&ASDB
&L       PQFUNC &QUEUE,&ASDB,Y,REQ
         MEND
*
         MACRO
&L       PQDEL  &QUEUE,&ASDB
&L       PQFUNC &QUEUE,&ASDB,Y,DEL
         MEND
         EJECT ,
         MACRO
&L       TQADD &TDB
&L       PSET  TQPARM,CLEAR=NO
         PMOV  TQPTDB,&TDB,OP=LA
         ACALL TSKADD
         MEND  ,
         MACRO
&L       TQREQ &TDB
&L       PSET  TQPARM,CLEAR=NO
         PMOV  TQPTDB,&TDB,OP=LA
         ACALL TSKREQ
         MEND  ,
         EJECT ,
         MACRO
&L       CLOCK &CLK
&L       LH    EPAR,PSAKCUR            Get the current clock offset
         CH    EPAR,=Y(PSAK&CLK-PSA+L'PZERO)
         IF    NE,BEGIN                Some different clock
         STPT  @EPAR                   Save the current clock
         LA    EPAR,PSAK&CLK-PSA+L'PZERO         New clock offset
         STH   EPAR,PSAKCUR            Save the Current clock id
         SPT   PSAK&CLK                Set the new timer
         END   ,
         MEND  ,
         SPACE 2
         MACRO
&L       UPDCLOCK &CLK
&L       LA    EPAR,PSAK&CLK-PSA+L'PZERO         Clock offset
         IF    (EPAR,EQ,PSAKCUR),BEGIN           We're using it
         STPT  @EPAR
         END   ,
         MEND  ,
         SPACE 3
         MACRO
&L       DISABLE &LBL
         LCLC  &STORAGE
&STORAGE SETC  'PSASMASK'
         AIF   ('&LBL' EQ '').LBLDONE
&STORAGE SETC  '&LBL'
.LBLDONE ANOP  ,
&L       STNSM &STORAGE,X'04'
         MEND
         SPACE
         MACRO
&L       ENABLE &LBL
         LCLC  &STORAGE
&STORAGE SETC  'PSASMASK'
         AIF   ('&LBL' EQ '').LBLDONE
&STORAGE SETC  '&LBL'
.LBLDONE ANOP  ,
&L       SSM   &STORAGE
         MEND
         TITLE 'Local Control Blocks'
*****************************************************************
*                                                               *
*     PSA  --  Prefixed Storage Area.  This area immediately    *
*              follows PZERO on real page zero of every CPU.    *
*              It contains CPU related things for the           *
*              the dispatcher and areas that are needed without *
*              having a base register available.                *
*              It is addressed using the associated using       *
*              capability of the SLAC assembler.                *
*                                                               *
*****************************************************************
         SPACE 2
PSA      RECORD BEGIN
PSAPSW   DS    D             PSW to be loaded to return from int
PSAGPRS  DS    16F           General purpose register save area
PSAFPRS  DS    4D            Floating point register save area
PSASTATE EQU   PSAPSW,*-PSAPSW,C'X'    State of the user
*
* CPU timer slots
*
PSATCHG  DS    D             Total User CPU time charged
PSAKUSER DS    D             User clock
PSAKDISP DS    D             Dispatch clock
PSAKIOSV DS    D             I/O Service clock
PSAKCUR  DS    H             Offset of the current CPU timer
*
* Information about this CPU
*
PSACPUA  DS    H             CPU Address of this CPU
PSACPUID DS    D             CPU id
PSAPRFXR DS    A             Prefix value for this CPU
PSAPRFXV DS    A             Virtual prefix address for this CPU
PSAIPCB  DS    A             Address of the IPCB for this CPU
*
* Dispatching information
*
PSAASDB  DS    A             Address of the current ASDB
PSATDB   DS    A             Address of the current TDB
PSADCT   DS    A             Address of the DCT
PSADSTK  DS    A             Address of the dispatcher stack
PSACPLK  DS    A             CPU dispatching lock
PSADFLG1 FLAG  ,             Dispatcher flags
         FLAG  DISPSTK         Running off the dispatcher stack
         FLAG  DISPGRD         Global Re-dispatch needed
         FLAG  DISPLTD         Long term dispatch needed
         FLAG  DISPSYSR        Executing system routine
PSASMASK DS    X             System mask area for disabling
PSATRMLK DS    X             Termination lock
         DS    0F            Alignment for the PI info
PSAPIILC DS    H             Program interrupt ILC
PSAPIIC  DS    H             Program interrupt code
*
* Trace information
*
PSATRB0  DS    A             Virt addr of current trace buffer
PSATRB1  DS    A             Virt addr of previous trace buffer
PSATRWK  DS    A             Work area for trace interrupt
PSATRGRS DS    16F           Save area for the GPRs
TRCBRANCH EQU  X'80000000'   CR mask for branch tracing
TRCASN   EQU   X'00000002'   CR mask for ASN tracing
TRCEXPL  EQU   X'00000001'   CR mask for explicit tracing
TRCALL   EQU   TRCBRANCH+TRCASN+TRCEXPL
*
* Initialization/Termination information
*
PSASPSW  DS    D             Save area for restart PSW
PSASGPRS DS    16A           Save area for restart GPRs
PSACTRS  DS    16A           Initial control registers
*
* Work areas
*
PSADWK1  DS    D             Double word areas
PSADWK2  DS    D
PSADWK3  DS    D
         END   ,
         $$USING PSA,PZERO+L'PZERO
         EJECT ,
*****************************************************************
*                                                               *
*     DCT  --  Dispatcher Control Table.  This global area is   *
*              used by the dispatcher on each of the CPUs to    *
*              determine who will be run next                   *
*                                                               *
*****************************************************************
         SPACE 2
DCT      RECORD BEGIN
         DC    C'DCT '       Control block ID
DCTLOCK  DS    A             Lock ID for the DCT
*
* Fixed parm values
*
STKSIZE  EQU   2048          Size of supervisor stacks
*
* Global info
*
DCTGASB  DS    A             Address of the 'global' ASB
DCTASDBS DS    A             Queue of all the ASDBs in the system
DCTRTCQ  DS    A             Real time clock queue pointer
DCTWSLM  DS    A             Limit on the working set size
DCTWSIN  DS    D             Time between WS manager calls (CPU time)
DCTSTIME DS    D             Time when the system was started (TOD)
*
* Queues of free global control blocks
*
         DS    0D
DCTFASB  DS    A             Available ASB entries
         DS    A             Control Word
DCTFASDB DS    A             Available ASDB entries
         DS    A             Control Word
DCTFTDB  DS    A             Available global TDB entries
         DS    A             Control Word
DCTFRTCQ DS    A             Available RTCQ entries
         DS    A             Control Word
DCTFSTBQ DS    A             Available STDB entries
         DS    A             Control Word
DCTFSTK  DS    A             Available Global stacks
         DS    A             Control Word
*
* Queue pointers --
*
MAXPRIO  EQU   3             Maximum user task priority level
SYSPRIO  EQU   MAXPRIO+1     System task priority level
NUMPRIO  EQU   SYSPRIO+1     Number of priority levels
*
DCTACTIV DS    (NUMPRIO*2)A  Active set queue header
DCTSWAIT DS    (NUMPRIO*2)A  STW set queue header
DCTREADY DS    (NUMPRIO*2)A  Ready set queue header
DCTLWAIT DS    (NUMPRIO*2)A  LTW set queue header
*
* Swapping information
*
DCTSWOUT DS    A             Total PF of outgoing AS's
DCTSWPRI DS    H             Prio of 1st S/O AS not yet provided for
DCTSLPF  DS    A             PF low limit (before LTDISP called)
DCTSHPF  DS    A             PF high limit (before LTDISP called)
DCTSPFCT DS    (NUMPRIO)A    RD PF count totals by priority level
*
* Time Slice Values
*
DCTSLICE DS    (NUMPRIO)D    Time slices at each level
DCTSLCWT DS    (NUMPRIO)D    Wait times at each level
*
* CPU information
*
DCTIPCBS DS    A             Queue of the IPCBs
DCTIPCBT DS    16A           Table of IPCB addresses for each CPU
DCTTRMSK DS    A             Mask for trace control register
*
* Other information
*
DCTVRST  DS    A             Location of available V=R area
DCTVRLEN DS    A             Length of available V=R area
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    IPCB  --  Inter-processor communication block.  This       *
*              Global control block is used to aid in the       *
*              communication between processors.  It is chained *
*              off the DCT.  Each PSA also points at the IPCB   *
*              for that CPU.  Fields marked with an '*' should  *
*              only be updated via an interlocked update.       *
*                                                               *
*****************************************************************
         SPACE 2
IPCB     RECORD BEGIN
         DC    C'IPCB'       Control block ID
IPCBNEXT DS    A             Next IPCB in the chain
IPCBPZ   DS    A             Address PZERO for this CPU
IPCBCPUA DS    H             CPU address
IPCBPRIO DS    H             Priority of Current ASDB on this CPU
IPCBFL   FLAG  ,           * Communication flags
         FLAG  IPFLGRD         Global re-dispatch
         FLAG  IPFLRCC         Reset the clock comparator
         FLAG  IPFLPTLB        Purge the TLB
         END   ,
         EJECT ,
         COPY  ASDB          Address Space Dispatch Blk - Local DSECT
         EJECT ,
         COPY  TDB           Task Dispatch Block - Local DSECT
         EJECT ,
*****************************************************************
*                                                               *
*    STDB  --  System Task Dispatching block.  This control     *
*              block represents requests from one address space *
*              to run a routine in another address space.  It   *
*              is queued off the ASDB until it is needed.  A    *
*              pool of free ones is kept in the DCT.            *
*                                                               *
*****************************************************************
         SPACE 2
STDB     RECORD BEGIN
         DC    C'STDB'       Control block ID
STDBNEXT DS    A             Address of the next one in the list
STDBASDB DS    A             Address of ASDB where scheduled
STDBADDR DS    A             Address of the requested routine
STDBPARM DS    4A            Parameters for the routine
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*     ESB  --  Exit specification block.  This control block    *
*              represents an exit routine that has been         *
*              specified.  These are task associated.           *
*                                                               *
*****************************************************************
         SPACE 2
ESB      RECORD BEGIN
         DC    C'ESB '       Control block ID
ESBNEXT  DS    A             Address of the next in the list
ESBTDB   DS    A             Pointer to the owning TDB
*
* Exit information
*
ESBTYPE  DS    A             Exit types handled by this routine
ESBPSW   DS    D             New PSW for the exit
ESBSTACK DS    A             Address of a stack (if ESBFSTK set)
ESBQUAL  DS    A             Exit Qualifier
ESBPARM  DS    A             Parm for the exit routine
ESBFLGS  FLAG  ,             Exit flags
         FLAG  ESBFSTK        Enter the exit with a stack
         FLAG  ESBFENCE       Limit search for exit manipulation
         FLAG  ESBFQUAL       This exit limited to matching quals
         FLAG  ESBFDIS        This exit is disabled
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*     ERB  --  Exit request block.  This control block          *
*              represents a request for an exit routine to be   *
*              entered.  It also serves as an information       *
*              repository while the exit routine is running.    *
*                                                               *
*****************************************************************
         SPACE 2
ERB      RECORD BEGIN
         DC    C'ERB '       Control block ID
ERBNEXT  DS    A             Next ERB in queue
ERBCHN   DS    A             Chain of the ERB's off the ASDB
ERBASDB  DS    A             Address of the owning ASDB
ERBTDB   DS    A             Address of the TDB it is queued on
ERBESB   DS    A             Address of the associated exit routine
ERBSTFL  FLAG  ,             Exit request status
         FLAG  (ERBSFREE,0,EQ)   Exit request is available
         FLAG  (ERBSPEND,1,EQ)   Exit request is pending
         FLAG  (ERBSACT,2,EQ)    Exit request is active
ERBFL    FLAG  ,             Exit request flags
         FLAG  ERBFDEL           This one has been deleted
ERBMTYPE DS    A             Type of the exit (bit mask)
*
* The address of the following area is passed to the exit routine
* and is mapped by the dsect XITSAREA
*
         DS    0D            Make it so alignment is same as dsect
ERBRPARM DS    A             Exit routine parm (from the ESB)
ERBTYPE  DS    X             Type of the exit (integer)
         DS    3X
ERBQUAL  DS    A             Qualifier for the exit
ERBPARM  DS    4A            Exit parms
*
* Information about the interrupted level of control
*
         DS    0D
ERBSTAT  DS    XL(L'TDBESTAT)          Saved status area
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    RTCQ  --  Real Time Clock Queue element.  This control     *
*              block represents real time timer requests.       *
*                                                               *
*****************************************************************
         SPACE 2
RTCQ     RECORD BEGIN
         DC    C'RTCQ'       Control block id
RTCQNEXT DS    A             Next RTCQ in the queue
RTCQTOD  DS    D             TOD clock when this RTCQ expires
RTCQASB  DS    A             Pointer to the owning ASB
RTCQTDB  DS    A             Pointer to the owning TDB
RTCQSYSR DS    A             ID of a SYSR
RTCQXID  DS    A             User's exit ID
RTCQPARM DS    2A            User's parms
RTCQFLGS FLAG  ,             Timer flags
         FLAG  RTINTVL        This is an interval timer
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*    CPTQ  --  CPU Time timer Queue element.  This control      *
*              block represents CPU time timer requests.        *
*                                                               *
*****************************************************************
         SPACE 2
CPTQ     RECORD BEGIN
         DC    C'CPTQ'       Control block id
CPTQNEXT DS    A             Next CPTQ in the queue
CPTQTOD  DS    D             TOD clock when this CPTQ expires
CPTQTDB  DS    A             Pointer to the owning TDB
CPTQXID  DS    A             User's exit ID
CPTQPARM DS    2A            User's parms
         END   ,
         TITLE 'Dispatching'
*****************************************************************
*                                                               *
*  ASDISP  --  This is the address space dispatcher.  It is     *
*              entered off the dispatcher stack and makes sure  *
*              that the highest priority ready address space is *
*              the one selected by this CPU.                    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ASDISP   PROC  SCOPE=LOCAL
*
* See if an Address space level dispatch is needed before a local one
*
         CLOCK DISP                    Put it on our nickel
         IF    PZATERM,BEGIN
         TS    PSATRMLK                Get the term lock
         IF    Z,BEGIN
         CLEAR PZATERM                 Not again
         L     RA,PZMATP               Get the mat pointer
         WITH  (MAT,RA),BEGIN
         SIGNL MATTECB,TYPE=AS         Wakeup termination processing
         END   ,
         END   ,
         END   ,

         IF    ^DISPGRD,LOCDISP        Go directly to the local one
*
* Turn off the request(s) to re-dispatch
*
ASDLP    CLEAR DISPGRD                 No need to do this now
         L     RN,PSAIPCB
         WITH  (IPCB,RN),BEGIN
         IF    IPFLGRD,BEGIN
         CLEAR IPFLGRD,MODE=LOCKED,REF=IPCB
         END   ,
         END   ,
*
* Get the dispatcher lock
*
         L     RX,PSADCT               Get the DCT pointer
         WITH  (DCT,RX)
         LKOB  DCTLOCK                 Get the DCT lock
*
* Take care of the long term dispatching before all else
*
         L     RA,PZMATP               Get the mat pointer
         WITH  (MAT,RA),BEGIN
         L     RS,MATPAGFN             Current paging function num
         IF    (DISPLTD,OR,                                            *
               (RS,GE,DCTSHPF),OR,                                     *
               (RS,LT,DCTSLPF)),BEGIN
         CLEAR DISPLTD
         ACALL LTDISP                  Do the long term disp
         END   ,
         END   ,
*
* Get the current ASDB
*
         L     RY,PSAASDB
         WITH  (ASDB,RY)
*
* If there is no current ASDB, get one
*
         IF    (RY,Z),BEGIN
GETNASDB PQHIGH DCTACTIV               Remove the top one
         LTR   RY,RVR
         IF    Z,BEGIN                 None there either
         LCALL IDLE                    Set up to do nothing
         LKREL DCTLOCK                 Free the lock
         EXIT  ASDISP                  Then bag out of this joint
         END   ,
         END   ,
         EJECT ,
*
* We have the current executing ASDB now. Lets take a look at it.
*
         SPACE ,
*
* Check to see whether the current address space is outranked by
* an address space that is swapped out but ready.  If it is, and
* it is also swapable, we take care of that matter here and now.
*
         LH    RS,ASDBSPRI             Get the Priority
         IF    ((RS,LE,DCTSWPRI),AND,('LT RS,ASDBSHCT',Z)),BEGIN
         IF    (RY,EQ,PSAASDB),'LCALL DISMASDB'  Clean up the AS
         PSET  @DEMOTE,CLEAR=NO
         ST    RY,@DEMASDB             ASDB to demote
         ACALL DEMOTE                  Demote it
         IF    (RVR,Z),BEGIN           It went ok, been put on LTW
         STCK  ASDBWTST                It has been put in wait
         B     GETNASDB                Try for another
         END   ,
*
* If we couldn't swap it out, we just pretend we didn't try
*
         END   ,
         EJECT ,
*
* Take care of the suspended address space case
*
         IF    ('LT RS,ASDBSUSP',NZ),BEGIN    It is suspended
         IF    (RY,EQ,PSAASDB),'LCALL DISMASDB'  Clean it up
         STCK  ASDBWTST                Start of the wait time
         PQADD DCTSWAIT,(RY)           Put it on the STW queue
         B     GETNASDB                Go back for another one
         END   ,
         EJECT ,
*
* If the current Address space has no ready tasks, we can move on
* to another.
*
         IF    (('LT RS,ASDBCTDB',Z),AND,('LT RS,ASDBSTDB',Z),AND,     *
               ('LT RS,ASDBATDB',Z)),BEGIN
         IF    (RY,EQ,PSAASDB),'LCALL DISMASDB'  Clean up the AS
         STCK  ASDBWTST                Save the wait time start
         IF    (ASDBNTDB,EQ,ASDBNLTW),BEGIN      Long term wait
*
* If all the tasks are in long term wait, we try to swap it right
* now, even if it has not been in for a whole time slice.
*
         IF    ^ASDBSWTS,BEGIN         Hasn't been in one slice
         SET   ASDBSWTS                Pretend it has
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the count value
         SH    RS,=Y(1)                Decrement the count
         IF    NEG,'ABORT SWAPHREL'    Not too far though
         CS    RA,RS,ASDBSHCT          Update the count
         UNTIL Z,END                   Release one swap hold
         END   ,
*
* If there are no holds, swap it out
*
         IF    ('LT RS,ASDBSHCT',Z),BEGIN
         PSET  @DEMOTE,CLEAR=NO
         ST    RY,@DEMASDB             ASDB to demote
         ACALL DEMOTE                  Demote it
         IF    (RVR,Z),GETNASDB        Swap went ok.
*
* If the swap didn't go, pretend we didn't try
*
         END   ,
         END   ,
*
* In other cases, just move it to the short term wait queue
*
         PQADD DCTSWAIT,(RY)           Put it on the STW queue
         B     GETNASDB                Done with this one
         END   ,
         EJECT ,
*
* Check to see whether the current address space is outranked
* by any on the active queue.
*
         PQPRIO DCTACTIV               Get the highest ready prio
         IF    (RVR,GT,ASDBSPRI),BEGIN We are outranked
         IF    (RY,EQ,PSAASDB),BEGIN
         LCALL DISMASDB                Clean up the Address space
         END   ,
         PQREQ DCTACTIV,(RY)           Re-queue our boy
         B     GETNASDB                And try out the next one
         END   ,
*
* If we have run one time slice at zero priority, and the next guy
* also has zero priority, then we let him run.
*
         IF    (ASDBPZTS,AND,(RVR,Z)),BEGIN
         IF    (RY,EQ,PSAASDB),BEGIN
         LCALL DISMASDB                Clean up the Address space
         END   ,
         PQADD DCTACTIV,(RY)           Add our boy at the end
         B     GETNASDB                And try out the next one
         END   ,
*
* We are ready to start up this address space
*
         IF    (RY,NE,PSAASDB),BEGIN   If it's not all set up
         ST    RY,PSAASDB              Mark it in the PSA
         LCALL ACTASDB                 Set up the PSA
         END
         LKREL DCTLOCK                 Free the dispatcher lock
*
* Take care of the local dispatching now
*
LOCDISP  IF    (ASDBTDSP,OR,('LT RS,PSATDB',Z)),BEGIN   Dispatch needed
         LCALL TKDISP                           Re-dispatch locally
         IF    ('LT RS,PSATDB',Z),ASDLP         Try again from the top
         END   ,
         CLOCK USER                    And back at the user
*
* All done... All the user info is now in the PSA
*
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  TKDISP  --  This is the local task dispatcher.  It makes     *
*              sure that the highest priority TDB in the        *
*              current ASDB is the current TDB.                 *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TKDISP   PROC  SCOPE=LOCAL
         IF    ^DISPSTK,'ABORT NODISP' Must be off dispatch stack
*
* Get the current control blocks
*
         L     RY,PSAASDB              Get the ASDB pointer
         WITH  (ASDB,RY)
*
* If the local lock is held, we don't re-dispatch here
*
         IF    ('LT RX,ASDBLOCK',NZ),EXIT       It is held here
*
* If the re-dispatch flag is set, clear it (interlocked)
*
         IF    ASDBTDSP,BEGIN
         CLEAR ASDBTDSP,MODE=LOCKED,REF=ASDB
         END   ,
*
* Take care of any queued system TDBs (STDBs)
*
         IF    ('LT RS,ASDBSTDB',NZ),BEGIN   Some STDB's are queued
         CLOCK USER                    Address space work
         LCALL SYSTDBS                 Take care of them
         CLOCK DISP                    Put it on our nickel
         END   ,
*
* Get the current TDB or a new one if we don't have one
*
TKDLP    LT    RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
         IF    Z,BEGIN                 Don't have one
         LT    RX,ASDBATDB             Get the first one on the queue
         IF    Z,EXIT,TKDISP           No work to do here
         MVC   ASDBATDB,TDBNEXT        Remove this one from the list
         ST    RX,ASDBCTDB             New current one
         END   ,
*
* Make sure it is the highest priority ready task
*
         LT    RS,ASDBATDB             Get top TDB addr
         IF    NZ,BEGIN
         CLC   TDBPRIO,TDBPRIO-TDB(RS) Compare priorities
         IF    LT,BEGIN                It must be switched
         IF    (RX,EQ,PSATDB),'LCALL DISMTDB'
         MVC   ASDBATDB,TDBNEXT-TDB(RS)    Remove Highest prio
         CLEAR TDBFACT                 Mark it inactive for a moment
         TQREQ TDB                     Then Re-queue it
         LR    RX,RS                   And use the new one
         ST    RX,ASDBCTDB             It is the current one
         END   ,
         END   ,
*
* Check for any exits that may be taken
*
         L     RVR,TDBEMASK            Get the exit mask
         N     RVR,TDBXRMAP            Any of those want in?
         IF    NZ,BEGIN
         CLOCK USER                    Use the user clock
         ACALL EXSCHED                 Schedule the exit(s)
         CLOCK DISP                    Turn on the dispatcher clock
         END
*
* Check to see whether this task is suspended.
*
         IF    TDBSUSP,BEGIN           It is suspended.
         IF    TDBLONG,'INCR RVR,ASDBNLTW'     Count the long wait
         ELSE  'INCR RVR,ASDBNSTW'             Or short term wait
         IF    (RX,EQ,PSATDB),'LCALL DISMTDB'  Clean up the TDB
         CLEAR TDBFACT                 It's not active
         CLEAR ASDBCTDB                Nor current anymore
         B     TKDLP                   Try for another one
         END   ,
*
* Make sure the TDB is set up now and return
*
         IF    (RX,NE,PSATDB),'LCALL ACTTDB'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  ACTASDB --  This routine takes the information in the ASDB   *
*              whose address is in PSAASDB and moves all the    *
*              other info into the PSA.  It makes use of the    *
*              current TDB.                                     *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ACTASDB  PROC  SCOPE=LOCAL
*
* Get the current pointers
*
         LT    RY,PSAASDB              Get the current ASDB
         IF    Z,EXIT                  Ignore the null one
         WITH  (ASDB,RY)
         L     RM,ASDBASB              Get the ASB associated
         WITH  (ASB,RM)
*
* Fix up the user clock
*
         MVC   PSAKUSER,ASDBCCPT       Move the user's clock in
*
* Move info about the current ASDB into the IPCB
*
         L     RN,PSAIPCB              Get the IPCB address
         WITH  (IPCB,RN),BEGIN
         MVC   IPCBPRIO,ASDBSPRI        Move in the priority
         END   ,
*
* Make sure we are in the right address space
*
         ST    RM,PZCURASB             It is now the current
         LASP  ASBLASP,0
         IF    NZ,'ABORT BADLASP'      HUH?!!
         MVC   ASDBCCPU,PZLCPUA        Move in the current CPU addr
*
* Get the current TDB pointer
*
         LT    RX,ASDBCTDB             Current TDB pointer
         XTRC  RX,RY,ACTASDB           Trace the new TDB, ASDB
         IF    Z,EXIT                  Nothing to set up
         WITH  (TDB,RX)
*
* Move the Task status to the PSA
*
         IF    ('LT RS,PSATDB',NZ),                                    *
               'ABORT UNCLEAN'         Make sure it's clean
         MVC   PSASTATE,TDBISTAT       PSW, GPRs, FPRs
         LCTL  8,11,TDBMON             Load Mon and PER
         ST    RX,PSATDB               Save the TDB pointer
         ST    RX,PZCURTSK             And the task ID
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* DISMASDB --  This routine packages up the information in the  *
*              PSA and stores it in the the ASDB.  It does not  *
*              change the current task.  It Clears the ASDB and *
*              TDB pointers in PSA.                             *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISMASDB PROC  SCOPE=LOCAL
*
* Since we are now the dispatcher update the priority in the IPCB
*
         L     RN,PSAIPCB
         WITH  (IPCB,RN),BEGIN
         MVC   IPCBPRIO,=Y(NUMPRIO)    Always higher than highest
         END   ,
*
* Get the current pointers
*
         LT    RY,PSAASDB              Get the current ASDB
         IF    Z,EXIT                  Ignore the null one
         WITH  (ASDB,RY)
         XTRC  RY,RY,DISMASDB          Trace ending ASDB
         MVC   ASDBCCPT,PSAKUSER       Save the user Clock
         CLEAR ASDBPZTS                No time slices at Prio lvl 0
         CLEAR ASDBCCPU                No current CPU
         CLEAR PSAASDB                 And no current ASDB
*
* Get the current TDB pointer
*
         LT    RX,PSATDB               Current TDB pointer
         IF    Z,EXIT                  Nothing to dismiss
         WITH  (TDB,RX)
*
* Move the task status from PSA to the current TDB
*
         MVC   TDBISTAT,PSASTATE       PSW, GPRs, FPRs
         CLEAR PSATDB                  No TDB now
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   ACTTDB --  This routine makes the TDB whose address in      *
*              ASDBCTDB the current TDB.  It assumes that the   *
*              ASDB has been all set up to be the current one.  *
*              It moves data into the PSA.                      *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ACTTDB   PROC  SCOPE=LOCAL
         IF    ('LT RS,PSATDB',NZ),'ABORT UNCLEAN'
*
* Get the current pointers
*
         LT    RY,PSAASDB              Get the current ASDB
         IF    Z,EXIT                  Ignore the null one
         WITH  (ASDB,RY)
*
* Get the current TDB pointer
*
         LT    RX,ASDBCTDB             Current TDB pointer
         IF    Z,EXIT                  Nothing to set up
         WITH  (TDB,RX)
         XTRC  RX,RX,ACTTDB            Trace the new TDB
*
* Take care of the CPU time clock
*
         MVC   TDBCPUST,ASDBTCPU       Save the starting clock val
*
* Move the task info to the PSA
*
         MVC   PSASTATE,TDBISTAT       PSW, GPRs, FPRs
         LCTL  8,11,TDBMON             Load Mon and PER
         ST    RX,PSATDB               Save the TDB pointer
         ST    RX,PZCURTSK             And the task ID
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  DISMTDB --  This routine packages up the information in the  *
*              PSA and ASDB and socks it away in the TDB.  It   *
*              is called when the current TDB will not be the   *
*              current much longer.  It clears the ASDBCTDB     *
*              field.  The current ASDB better be set up.       *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISMTDB  PROC  SCOPE=LOCAL
*
* Get the current pointers
*
         LT    RY,PSAASDB              Get the current ASDB
         IF    Z,EXIT                  Ignore the null one
         WITH  (ASDB,RY)
*
* Get the current TDB pointer
*
         LT    RX,ASDBCTDB             Current TDB pointer
         IF    Z,EXIT                  Nothing to dismiss
         WITH  (TDB,RX)
*
* Move the task status from PSA to the current TDB
*
         IF    (RX,EQ,PSATDB),BEGIN
         MVC   TDBISTAT,PSASTATE       PSW, GPRs, FPRs
         END   ,
*
* Handle the clock
*
         LD    0,ASDBTCPU              Get current total CPU time
         SW    0,TDBCPUST              Less when it became active
         AW    0,TDBTCPU               Plus the previous amount
         STD   0,TDBTCPU               Gives the new total
*
* Clean up the ASDB and the PSA
*
         CLEAR TDBFACT                 Not active anymore
         CLEAR ASDBCTDB                Current TDB pointer
         CLEAR PSATDB                  No current TDB now
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  SYSTDBS --  This routine takes care of any System TDBs       *
*              (STDB) that have been queued to the current      *
*              ASDB.  It takes them off en mass and calls each  *
*              routine off the dispatcher stack.                *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
SYSTDBS  PROC  SCOPE=LOCAL
*
* Get the current pointers
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
*
* Process the STDBs
*
         WHILE ('LT RA,ASDBSTDB',NZ),BEGIN
*
* Remove the whole queue
*
         CLEAR RS                      New value
         LOOP  BEGIN
         CS    RA,RS,ASDBSTDB          Out with the old
         UNTIL Z,END
*
* Loop through the list and call each routine in turn.
*
         WHILE (RA,NZ),BEGIN           While we still have some left
         WITH  (STDB,RA)
         L     RB,STDBNEXT             Address of the next one
         PSET  @SYSRTN,CLEAR=NO        Setup the parm area
         MVC   @SYSPARS(16),STDBPARM   Move in the parms
         L     RJ,STDBADDR             Get the routine address
*
* Free the STDB
*
         ST    RS,STDBNEXT             Clear the next pointer
         ST    RS,STDBASDB             And the ASDB pointer
*
* Call the system routine, then go on to the next in the queue
*
         SET   DISPSYSR                Set us into system task mode
         ACALL (RJ)                    Call the routine
         CLEAR DISPSYSR                Not in STDB mode any more
         IF    ('LT RA,ASDBLOCK',NZ),'ABORT STMDLOCK'
         LR    RA,RB                   Get to the next in the queue
         END   ,
         END   ,                       Continue while there are STDBs
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*****************************************************************
*                                                               *
*  ASLOCK  --  This routine obtains the local address space     *
*              lock.  This lock will prevent any other unit of  *
*              work from running in this address space as long  *
*              as it is held.  It can be held across address    *
*              space suspends, but obviously not during a task  *
*              suspend.                                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ASLOCK   PROC  SCOPE=GLOBAL
         IF    (DISPSTK,AND,^DISPSYSR),'ABORT DISLOCK'
*
* Get our bearings
*
         L     RY,PSAASDB              Get the current ASDB pointer
         WITH  (ASDB,RY)
         INCR  RVR,ASDBLOCK            Set the lock
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* ASULOCK  --  This routine releases the local address space    *
*              lock.  A re-dispatch will be done if it is       *
*              needed.                                          *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ASULOCK  PROC  SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB pointer
         WITH  (ASDB,RY)
         IF    ('LT RS,ASDBLOCK',Z),'ABORT ASLKBAL'     Don't have it
         DECR  RS                      Remove one lock
         ST    RS,ASDBLOCK             |
         IF    (RS,Z),BEGIN            We are free to dispatch
         IF    ASDBTDSP,'ACALL DISPRD' If a dispatch is needed
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  CPLOCK  --  This routine obtains the CPU lock for the        *
*              current CPU.  It will prevent any re-dispatch    *
*              as long as no SVC or PI's occur.  It must        *
*              obviously be released before any useful work     *
*              can be done.  The CPU should be disabled while   *
*              holding this lock.                               *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CPLOCK   PROC  SCOPE=GLOBAL
         INCR  RVR,PSACPLK             Set the lock
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* CPULOCK  --  This routine releases the CPU lock.  If it goes  *
*              to zero, a re-dispatch will be done if it is     *
*              needed.                                          *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CPULOCK  PROC  SCOPE=GLOBAL
         L     RS,PSACPLK              Get the current count
         SH    RS,=Y(1)                Decrement it
         ST    RS,PSACPLK              Update the count
         IF    POS,EXIT                Still held
         IF    (NEG,OR,DISPSTK),'ABORT CPLOCK' This ain't right
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  ASWAKE  --  This routine moves an address space from a       *
*              waiting queue to a ready queue. ed when the ASDB *
*              would not normally be dispatched.                *
*                                                               *
*    Input --  @ASWAKE                                          *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
#ASWAKE  RECORD BEGIN
#ASPSWM  DS    X             A place to save PSW mask during disable
         END   ,
         SPACE ,
@ASWAKE  RECORD BEGIN
@ASWASDB DS    A             Address of the ASDB to wake
         END   ,
         SPACE 2
ASWAKE   PROC  @ASWAKE,#ASWAKE,SCOPE=LOCAL
*
* Get the desired ASDB
*
         L     RY,@ASWASDB   Get the desired ASDB
         IF    (@RY,NE,'ASDB'),'ABORT BADASDB'
         WITH  (ASDB,RY)
*
* Is it the current one?
*
         IF    (RY,EQ,PSAASDB),EXIT    If so, don't bother
*
* Put it on either the active or the ready queue, depending on
* whether it is currently swapped out.
*
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         DISABLE #ASPSWM               Must be disabled
         LKOB  DCTLOCK                 Get the dispatching lock
AWLK     BEGIN                         Block holding the lock
*
* See if we gain anything by waking this ASDB up
*
         IF    (('LT RS,ASDBSUSP',NZ),OR,                  Suspended   *
               (('LT RS,ASDBSTDB',Z),AND,('LT RS,ASDBCTDB',Z),AND,     *
               ('LT RS,ASDBATDB',Z))),EXIT No work
         EJECT ,
*
* A S D B   O N   S H O R T   T E R M   W A I T   Q U E U E
*
         SPACE 2
         LA    RS,DCTSWAIT             Address of the STW queue
         IF    (RS,EQ,ASDBQADD),BEGIN  It is on this queue
*
* Take it off the list where it now resides
*
         PQDEL (RS),ASDB               Remove it from the STW queue
*
* Update the priority based on the time spent waiting
*
         PSET  @UPDPRIO
         PMOV  @UPPASDB,ASDB,OP=LA     Move in the ASDB address
         LCALL UPDPRIO                 Call the local routine
*
* Put it on the Active queue
*
         PQADD DCTACTIV,ASDB           Add it to the active queue
*
* Find the CPU running the lowest priority ASDB
*
         CLEAR RS                      Saved IPCB address
         LA    RA,NUMPRIO              Priority of that CPU
         L     RN,DCTIPCBS             Get the first in the queue
         WITH  (IPCB,RN)
         WHILE (RN,NZ),BEGIN           Loop through all the CPUs
         IF    (RA,GE,IPCBPRIO),BEGIN
         LH    RA,IPCBPRIO             Load the priority
         LR    RS,RN                   Keep track of which CPU
         END   ,
         L     RN,IPCBNEXT             Get to the next
         END   ,
         LR    RN,RS                   Get it into RN
*
* We now have the IPCB address of the CPU running the lowest priority
* ASDB.  We have to see whether it deserves to be awakened.
*
         IF    (RA,LT,ASDBSPRI),BEGIN  Someone needs to wake up
         IF    (RN,EQ,PSAIPCB),BEGIN   It is this CPU
         SET   DISPGRD                 Mark the re-dispatch
         END   ELSE,BEGIN              It is another CPU
         IF    ^IPFLGRD,BEGIN          Flag not set now
         SET   IPFLGRD,MODE=LOCKED,REF=IPCB
*
* Signal the other processor
*
         LH    RS,IPCBCPUA             Get the CPU address
         SIGP  RS,RS,X'02'             Wake up that CPU
         END   ,
         END   ,
         END   ,
         EXIT  AWLK                    STW case done
         END   ,                       Of the STW
         EJECT ,
*
* A S D B   O N   L O N G   T E R M   W A I T   Q U E U E
*
         SPACE 2
         LA    RS,DCTLWAIT             Address of the LTW queue
         IF    (RS,EQ,ASDBQADD),BEGIN  It is on this queue
*
* Take it off the queue where it now lives
*
         PQDEL (RS),ASDB               Remove it
*
* Update the priority based on the wait time
*
         PSET  @UPDPRIO
         PMOV  @UPPASDB,ASDB,OP=LA     Move in the ASDB address
         LCALL UPDPRIO                 Call the local routine
*
* Put it on the READY queue
*
         PQADD DCTREADY,ASDB           Add it to the queue
         LH    RA,ASDBSPRI             Get the priority
         SLL   RA,2                    times 4
         L     RS,DCTSPFCT(RA)         Get the current count there
         A     RS,ASDBPAGN             Add the value for this AS
         ST    RS,DCTSPFCT(RA)         Update the value
         LH    RS,ASDBSPRI             Get the dispatching priority
         IF    (RS,GE,DCTSWPRI),'SET DISPGRD+DISPLTD'
*
*  Advise the Swap manager of upgrade to ready queue
*
         PSET  @PAGSWADV
         MVC   @ADVASB,ASDBASB
         VCALL PAGSWADV                Tell swap manager
*
* Update the upper page frame limit
*
         PQHPFN DCTREADY               Get the number needed
         ST    RVR,DCTSHPF             Save it
         L     RS,PZMATP               Get the mat pointer
         WITH  (MAT,RS),BEGIN
         L     R15,MATPAGFN            Current paging function num
         IF    ((R15,GE,DCTSHPF),OR,                                   *
               (R15,LT,DCTSLPF)),'SET DISPGRD+DISPLTD'
         END   ,
         END   ,                       Of the long term wait
         END   ,                       Of the locked portion
         LKREL DCTLOCK                 Release the lock
         ENABLE #ASPSWM                Get back our PSW flags
         IF    DISPGRD,BEGIN
         IF    ('LT RS,PSACPLK',Z),'ACALL DISPRD'       Re-dispatch
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  UPDPRIO --  This routine updates the dispatching priority    *
*              of the ASDB whose address is passed.  It may     *
*              update the time-slice end time as well as the    *
*              dispatching priority.  The ASDB should not be on *
*              any of the dispatcher queues.                    *
*                                                               *
*   Input  --  @UPDPRIO                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@UPDPRIO RECORD BEGIN
@UPPASDB DS    A             Address of the ASDB to update
@UPPFL   FLAG  ,
         FLAG  @UPPTSE       This is a time-slice end call
         END   ,
         SPACE 2
UPPWA    RECORD BEGIN        Work area for UPDPRIO
UPPSTCK  DS    D             Store clock area
UPPOTIM  DS    D             Store clock at wait time
UPPSFPR  DS    D             Save area for FPR
         END   ,
         SPACE 2
UPDPRIO  PROC  @UPDPRIO,UPPWA,SCOPE=LOCAL
*
* Get our control blocks
*
         L     RY,@UPPASDB   Get the ASDB address
         WITH  (ASDB,RY)
         IF    ('LT RX,ASDBQADD',NZ),'ABORT ONQUEUE'
         L     RX,PSADCT     Get the DCT pointer
         WITH  (DCT,RX)
*
* Take care of the time-slice end case
*
         IF    @UPPTSE,BEGIN
*
* Set new priority level
*
         LH    RS,ASDBTPRI             Get the Current TS priority
         SH    RS,=H'1'                Less one
         IF    NEG,BEGIN
         SET   ASDBPZTS                Make it lower prio than zero
         CLEAR RS                      But set the prio to zero
         END   ,
         STH   RS,ASDBTPRI             We have the new slice prio
*
* Calculate the time of the end of the next time slice
*
         LR    RA,RS                   Copy it for a second
         SLL   RA,3                    Size of the slice entries
         STD   4,UPPSFPR               Save FPR 4
         LD    4,DCTSLICE(RA)          Get the new slice value
         AW    4,ASDBTCPU              Get the new slice end time
         STD   4,ASDBSLC               Save it
         LD    4,UPPSFPR               Restore FPR 4
         END   ELSE,BEGIN
*
* An address space is waking up and needs to have it's time in
* wait evaluated to see if it merits an increase in priority
*
*  Get the time it has been waiting
*
         STD   4,UPPSFPR               Save the floating register
         STCK  UPPSTCK                 Get the current time
         MVC   UPPOTIM,ASDBWTST        And the start of the wait
         MVI   UPPSTCK,0
         MVI   UPPOTIM,0               Clear high bytes of the times
         LD    4,UPPSTCK               Get the current time
         SW    4,UPPOTIM               Less the previous time
         LPDR  4,4                     Get the positive value
*
* Find out which priority level it qualifies for
*
         LH    RA,ASDBTPRI             Get the time-slice prio
         WHILE (RA,LT,MAXPRIO),BEGIN   Loop through the levels
         LR    RS,RA                   Copy the priority level
         SLL   RS,3                    Times 8; size of wait entry
         CD    4,DCTSLCWT(RS)          Enough to merit a raise?
         IF    LT,EXIT                 Nope.. Enough of this circus
         LA    RA,@RA+1                Bump up the priority
         END   ,
         STH   RA,ASDBTPRI             New slice priority
*
* Decide on the new time slice value
*
         SLL   RA,3                    Offset into the time
         LD    4,DCTSLICE(RA)          Get the new slice value
         AW    4,ASDBTCPU              Get the new slice end time
         STD   4,ASDBSLC               Save it
         LD    4,UPPSFPR               Restore the register
         END   ,
*
* Apply the ASDB priority limits to the time slice priority to
* obtain the dispatching priority
*
         LH    RS,ASDBTPRI             Get the slice priority
         FLOOR RS,ASDBLPRI             Minimum dispatching prio
         CEIL  RS,ASDBHPRI             Maximum dispatching prio
         STH   RS,ASDBSPRI             Save the dispatching prio
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*    IDLE  --  This routine sets up the PSW and registers to    *
*              put the CPU into a wait state.  It is called     *
*              when there is no work for this CPU to do.        *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
IDLE     PROC  SCOPE=LOCAL
*
* Make sure that there is no task active
*
         IF    ('LT RN,PSAASDB',NZ),BEGIN       Whoa!
         ABORT  BADASDB
         END   ,
*
* Update the IPCB to show us having VERY low priority
*
         L     RN,PSAIPCB
         WITH  (IPCB,RN),BEGIN
         MVC   IPCBPRIO,=H'-1'         Lower than lowest
         END   ,
*
* Clean up the rest of the stuff from the PSA
*
         CLEAR PZCURASB
         MVC   PSAKUSER,=X'00FFFFFFFFFFFFFF'     No clock things
         L     RX,PSADCT               Get the DCT pointer
         WITH  (DCT,RX)
*
* Establish the global address space
*
         L     RS,DCTGASB              Get the global ASB
         WITH  (ASB,RS),BEGIN
         LASP  ASBLASP,3               Load up the parms
         END   ,
*
* Setup a new PSW
*
         MVC   PSAPSW,=X'070F0000C9C4D3C5'       IDLE PSW
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* SUSPEND  --  This routine causes the current TDB/ASDB to be   *
*              marked as suspended until it is awakened by a    *
*              call to RESUME.  The suspension does not         *
*              actually take place until the next dispatch. It  *
*              sets flags to make sure that this re-dispatch    *
*              does, in fact, occur.                            *
*                                                               *
*    Input --  @SUSPEND                                         *
*                                                               *
*   Output --  Updated fields in @SUSPEND                       *
*                                                               *
*****************************************************************
         SPACE 2
SUSPEND  PROC  @SUSPEND,SCOPE=GLOBAL
*
* Get the control blocks
*
         L     RY,PSAASDB              Get the current ASDB addr
         WITH  (ASDB,RY)
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
*
* Handle the Address space level suspension
*
         IF    @SUSPAS,BEGIN           It is at the AS level
*
* Update the suspend count
*
         L     RA,ASDBSUSP             Get the current count
         LOOP  BEGIN
         LA    RB,@RA+1                Count one more suspension
         CS    RA,RB,ASDBSUSP          Update the count
         UNTIL Z,END
*
* Mark it for a re-dispatch
*
         SET   DISPGRD                 Global re-dispatch flag
         MVC   @SUSPID,ASDBASB         Move in the suspended ID
         END   ELSE,BEGIN
*
* Handle the Task level suspension
*
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
         IF    ^@SUSPPLC,BEGIN         It's for us, highest level
*
* Turn on the suspend flags
*
         SET   TDBSUSP                 Mark it as suspended
         IF    @SUSPLNG,'SET TDBLONG'  Mark it as long term
*
* Set up for the re-dispatch
*
         IF    ^ASDBTDSP,BEGIN
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB
         END   ,
         ST    RX,@SUSPID              Save the task ID
         MVC   @SUSPLC,TDBCLCN         Tell about the control level
         END   ELSE,BEGIN
*
* It is for the previous level of control, so we set the bit
* in the ERB and no redispatch is needed.
*
         ACALL ASLOCK                  Lock up the chain
         L     RJ,TDBISTK              Get the previous level
         WITH  (ERB,RJ),'LA RJ,ERBSTAT'
         WITH  (TDBESTAT,RJ),BEGIN
         SET   TDBSUSP                 Suspend it
         IF    @SUSPLNG,'SET TDBLONG'  Long time
         ST    RX,@SUSPID              Save the Task ID
         MVC   @SUSPLC,TDBCLCN         And the level of control
         END   ,
         ACALL ASULOCK                 Free the lock
         END   ,
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  DISPRD  --  This routine calls the dispatcher if some        *
*              re-dispatch needs to be done.  It puts the       *
*              caller into dispatch mode as well, saving the    *
*              registers and PSW info in PSA and using the      *
*              dispatcher stack.                                *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPRD   PROC  SCOPE=GLOBAL
*
* First make sure that we are allowed to cause a re-dispatch.
* Then do all that is required to get us to the state where we
* are running off the dispatcher stack.
*
         IF    ('LT RY,PSACPLK',NZ),EXIT
*
* See if there is any possible reason we would want to re-dispatch
*
         L     RY,PSAASDB
         WITH  (ASDB,RY)
*
* Make sure it doesn't hold a lock
*
         IF    (^DISPGRD,AND,^ASDBTDSP),EXIT     No need to continue
         L     RX,PSATDB               Get the current TDB
         WITH  (TDB,RX),BEGIN
         IF    (TDBSUSP,AND,('LT RS,ASDBLOCK',NZ)),'ABORT SUSPWLOCK'
         END   ,
*
* Get us to the dispatcher stack
*
         STNSM PSAPSW,X'04'            Save mask and disable
         SET   DISPSTK                 Turn on the tattle tail
         MVC   PSACPLK,=A(1)           Lock up this CPU
         STM   R0,R15,PSAGPRS          Save GPRs
         STD   0,PSAFPRS+0*4           FPR 0
         STD   2,PSAFPRS+2*4           FPR 2
         STD   4,PSAFPRS+4*4           FPR 4
         STD   6,PSAFPRS+6*4           FPR 6
*
* Save any other bits in the PSW that might have changed since the
* last dispatch.
*
         NC    PSAPSW(4),=X'FF0F0000'  Turn off changeable bits
         CLEAR RA                      Construct high order PSW word
         IPK   ,                       PSW key to RA
         SLL   RA,16                   Get it to proper spot
*
* Program mask
*
         CLEAR RB
         IPM   RB                      Get the program mask
         SRL   RB,23                   Shift to the right spot
*
* Secondary space bit
*
         IAC   RB                      Put the addr control bit
         SLL   RB,7                    Move bits to the right spot
*
* Construct the composite
*
         OR    RA,RB
         O     RA,PSAPSW               Get a composite
         ST    RA,PSAPSW               And save it for him
*
* Setup a new PC as well
*
         LA    RA,DISPRDRT             Get the new program address
         BSM   RA,0                    Insert the addressing mode
         ST    RA,PSAPSW+4             Put it in the PSW
*
* Setup a stack to use
*
         L     WAR,PSADSTK             Get the current location ptr
         LA    SPR,@WAR+8              And the new stack pointer
*
*
* Now we pretend that we were entered just like any good interrupt
* routine and we act accordingly.
*
         LM    R0,R1,PSAPSW            Get the current PSW
         XTRC  R0,R1,DISPRD            Trace that
*
* Return to the user
*
         IF    (DISPGRD,OR,ASDBTDSP),'ACALL ASDISP'
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW            Get the PSW
         XTRC  R0,R1,RUNUSER1          Trace the PSW
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
DISPRDRT PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
* DISPSHLD --  This routine cases the current address space     *
*              to become non-swappable.  It increments the      *
*              count of holds on the address space.             *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPSHLD PROC  SCOPE=GLOBAL
*
* Locate the control blocks
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
*
* Get and update the values
*
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the current value
         LA    RS,@RS+1                Increment the hold count
         CS    RA,RS,ASDBSHCT          Replace it
         UNTIL Z,END                   Loop it up
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
* DISPSREL --  This routine cancels the effect of a DISPSHLD.   *
*              It decrements the swap hold count.  It won't     *
*              decrement the count below zero.                  *
*                                                               *
*    Input --  @DISPSWP                                         *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPSREL PROC  @DISPSWP,SCOPE=GLOBAL
*
* Locate all the control blocks
*
         L     RS,@DISPSAS             Get the ASB address
         WITH  (ASB,RS),'L RY,ASBASDB' Get the ASDB address
         WITH  (ASDB,RY)
         IF    (ASDB,NE,'ASDB'),'ABORT BADASDB'
*
* Get and update them values
*
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the count value
         SH    RS,=Y(1)                Decrement the count
         IF    NEG,'ABORT SWAPHREL'    Not too far though
         CS    RA,RS,ASDBSHCT          Update the count
         UNTIL Z,END                   Release one swap hold
*
* Check and see if this one is below the magic swap value
*
         IF    (RS,Z),BEGIN            It is now swapable
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         LH    RA,ASDBSPRI             Get the priority
         IF    (RA,LE,DCTSWPRI),'SET DISPGRD'  Re-dispatch
         L     RA,PZMATP               Get the MAT pointer
         WITH  (MAT,RA)
         L     RS,MATPAGFN             Current paging function num
         IF    ((RS,GE,DCTSHPF),OR,                                    *
               (RS,LT,DCTSLPF)),'SET DISPGRD+DISPLTD'
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* ASSYSTSK --  This routine causes the current address space    *
*              to be marked as a system task.  System tasks     *
*              are always queued at the highest priority.       *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ASSYSTSK PROC  SCOPE=GLOBAL
*
* Locate the control blocks
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
*
* Set system task mode
*
         MVC   ASDBHPRI,=Y(SYSPRIO)    Top it out at the max
         MVC   ASDBLPRI,=Y(SYSPRIO)    Bottom out at the max
         MVC   ASDBSPRI,=Y(SYSPRIO)    Current priority is highest
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
* RESUMAS  --  This routine wakes up an ASDB that has been      *
*              previously put to sleep with a SUSPEND.          *
*                                                               *
*                                                               *
*    Input --  @RESUME                                          *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RESUMAS  PROC  @RESUME,SCOPE=GLOBAL
*
* Get the desired ASDB
*
         L     RY,@RESUNIT             Get the ASB address
         IF    (@RY,NE,'ASB '),'ABORT BADASB'
         WITH  (ASB,RY),'L RY,ASBASDB' Get the ASDB address
         IF    (@RY,NE,'ASDB'),'ABORT BADASDB'
         WITH  (ASDB,RY)
*
* Remove one suspension from the ASDB
*
         L     RA,ASDBSUSP             Get the current count
         LOOP  BEGIN
         LR    RB,RA                   Copy the current
         SH    RB,=H'1'                Reduce it by one
         IF    NEG,'ABORT RESUMERR'
*         IF    NEG,'CLEAR RB'          But not less than zero
         CS    RA,RB,ASDBSUSP          Replace it
         UNTIL Z,END
*
* If the count is now zero, wake it up
*
         IF    (RB,Z),BEGIN
         PSET  @ASWAKE,CLEAR=NO
         ST    RY,@ASWASDB             Save the ASDB address
         ACALL ASWAKE                  Wake up the ASDB
         END   ,
         LR    RVR,RB                  Return current suspend count
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* RESUMTS  --  This routine wakes up a TDB that has been        *
*              previously put to sleep with a SUSPEND.          *
*                                                               *
*                                                               *
*    Input --  @RESUME                                          *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RESUMTS  PROC  @RESUME,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         LT    RX,@RESUNIT             Get the TDB address
         IF    (NP,OR,(@RX,NE,'TDB ')),'ABORT BADTID'
         WITH  (TDB,RX)
*
* Find the level of control desired
*
         L     RA,@RESLC               Get the level of control
         ACALL ASLOCK                  Lock up local dispatching
*
* If it is the top level task, it changes the dispatchablitiy
*
         IF    (RA,EQ,TDBCLCN),BEGIN   It is the top level of control
         IF    TDBSUSP,BEGIN           Only update if it's suspended
         CLEAR TDBSUSP                 Clear the suspend
*
* Make it active if it is not already
*
         IF    ^TDBFACT,BEGIN          Not currently active
*
* Fix up the ASDB suspend counts
*
         IF    TDBLONG,BEGIN
         DECR  RS,ASDBNLTW             Update long term wait count
         CLEAR TDBLONG
         END   ELSE,'DECR RS,ASDBNSTW' Or the short term wait count
*
* Add the task to the active list
*
         TQADD TDB                     Add the TDB to the queue
         L     RS,TDBPRIO              Get the prio of the new one
         L     RX,ASDBCTDB             Get the current TDB address
         IF    (RS,GT,TDBPRIO),BEGIN   Need to re-dispatch
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB     Set the flag
         END   ,
         END   ,
         END   ,
         END   ELSE,BEGIN
*
* It is not the top level of control.  Find and modify the correct
* ERB.
*
         L     RJ,TDBISTK              Get the first one
ERRLP    WHILE (RJ,NZ),BEGIN
         WITH  (ERB,RJ)
         LA    RS,ERBSTAT              Address of the status area
         WITH  (TDBESTAT,RS)
         IF    (RA,EQ,TDBCLCN),BEGIN   We have the level
         CLEAR TDBSUSP+TDBLONG         Clear the suspend flags
         EXIT  ERRLP                   Then get out of this rut
         END   ,
         L     RJ,ERBNEXT              Get the next ERB
         END   ,                       End of the loop
         END   ,
         ACALL ASULOCK                 Free up the AS lock
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Interrupt Handling'
*****************************************************************
*                                                               *
*  RSFLIH  --  This is where restart interrups are taken.  It   *
*              is not in the form of a procedure.               *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RSFLIH   BEGIN
         MVC   PSASPSW,PZRSOPSW        Save the calling area
         STM   0,15,PSASGPRS           Save the registers
         BASE  ,
*
         IF    PZABORT,BEGIN       ABORT macro issued...
         L     RA,PSASPSW+4        Addr of 16 char ABORT id...
*  Avoid oper confusion...
         IF    ((@RA,EQ,'MILSTOP'),OR,(@RA,EQ,'MILGONE')),BEGIN
         ORVWTO 'Milten closed connection'
         END
*
         ELSE  BEGIN               Standard message...
         ORVWTO 'Abort Code ID = ',MODE=SYSLOG
         ORVWTO @RA,16,MODE=SYSLOG
         END
*
         MVC   PSASPSW(1),PZABSM       Restore the system mask
         MVC   PSASGPRS+4*15(4),PZABR15   Restore R15
         END   ,
         SYSCTL TYPE=ABEND             Whoa!!!
         END   ,
         DROP  BR
         EJECT ,
*****************************************************************
*                                                               *
*  INFLIH  --  This is the initial restart interrupt is taken.  *
*              It is done when this CPU is being initialized.   *
*              This routine finishes the intialization and      *
*              starts into the dispatching of work. It          *
*              is not in the form of a procedure.               *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
INFLIH   BEGIN
         BASE  ,                       Set up local addressablity
         MVC   PSACPLK,=A(1)
         SET   DISPSTK                 We are now in SUP routine
         L     WAR,PSADSTK             Get the stack for this CPU
         LA    SPR,@WAR+8              Get a location for Save area
         LCTL  0,15,PSACTRS            Copy the initial CTR's
         STOSM PSASMASK,X'04'          Turn on DAT
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
*
* Save our CPU id
*
         STIDP PSACPUID                Finish up the PSA
*
* Fix up the Restart PSW
*
         LCTL  0,0,=X'00B00000'        Allow Modification
         MVC   PZRSNPSW(4),=X'040C0000'
         MVC   PZRSNPSW+4(4),=A(X'80000000'+RSFLIH)
         LCTL  0,0,=X'10B06400'        Restore default value
*
* See if this is the the prime CPU
*
         IF    (PSAIPCB,EQ,DCTIPCBS),BEGIN       First on the list
         LCTL  0,0,=X'10B06C40'        Turn on all (including CKC)
         SCKC  =X'FFFFFFFFFFFFFFFF'    But not interrupts for awhile
         LCTL  6,6,=X'FF000000'        And turn on the subclass bits
         END   ,
*
* Start the dispatcher clock up
*
         SPT   PSAKDISP                Load the timer
*
* Set up the trace for this CPU
*
         L     RA,PSATRB0              Get the trace buffer
         STCK  @RA                     Save the clock
         LRA   RA,@RA+8                Get the start of trace
         O     RA,DCTTRMSK             And set the active ones
         ST    RA,PSATRWK              Save the value
         LCTL  12,12,PSATRWK           Then load it into a register
*
* All the initialization is done. Start dispatching.
*
         SET   DISPGRD                 Indicate the need
         ACALL ASDISP                  Do the dispatch
*
* Start the current user
*
         CLOCK USER                    Use the user clock
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         END   ,                       ** End of Initial FLIH **
         DROP  BR
         EJECT ,
*****************************************************************
*                                                               *
*  EXFLIH  --  This is where external interrupts are taken.     *
*              It is not of the form of a procedure.            *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
EXFLIH   BEGIN
*
* Save the state
*
         MVC   PSAPSW,PZEXOPSW         Copy the PSW
         STM   0,15,PSAGPRS            Save GPRs in PSA
         STD   0,PSAFPRS+0*4           FPR 0
         STD   2,PSAFPRS+2*4           FPR 2
         STD   4,PSAFPRS+4*4           FPR 4
         STD   6,PSAFPRS+6*4           FPR 6
         BASE  ,                       Set up addressability
         LM    R0,R1,PSAPSW            Get the PSW
         L     R2,PZEXCPU              CPU and interrupt code
         XTRC  R0,R2,EXTINT            Trace the information
         CLOCK DISP                    Turn on the dispatcher clock
         IF    ('LT RS,PSACPLK',NZ),BEGIN       In a SUP routine...
         ABORT EXINSUP                 That is not good
         END   ,
         MVC   PSACPLK,=A(1)
         SET   DISPSTK                 We are now in SUP routine
*
* set up the stack for the dispatcher
*
         L     WAR,PSADSTK             Get the stack for this CPU
         LA    SPR,@WAR+8              Get a location for Save area
*
* External call interrupt.  Check on the call flags.
*
         IF    (PZEXIC,EQ,X'1202'),BEGIN
         L     RK,PSAIPCB              Get the IPCB address
         WITH  (IPCB,RK)
         IF    IPFLGRD,BEGIN           Global re-dispatch
         SET   DISPGRD                 Set the global flag
         END   ,
         IF    IPFLRCC,BEGIN           Reset the clock comparator
         CLEAR IPFLRCC,MODE=LOCKED,REF=IPCB
         ACALL RTCLOCK                 Re-adjust the Clock comparator
         END   ,
         IF    IPFLPTLB,BEGIN          Purge the TLB
         CLEAR IPFLPTLB,MODE=LOCKED,REF=IPCB
         PTLB  ,
         END   ,
         END   ,
         SPACE 2
*
* CPU timer interrupt.  Handle the timer-up condition.
*
         IF    (PZEXIC,EQ,X'1005'),'ACALL CPUTIMR'
         SPACE 2
*
* Clock comparator interrupt.  Handle the real time timer.
*
         IF    (PZEXIC,EQ,X'1004'),'ACALL RTCLOCK'
         SPACE 2
* Any other external interrupts are just ignored.
         SPACE 2
* If termination processing indicated by host, re-dispatch
* will be needed.
*
         IF    PZATERM,'SET DISPGRD'
*
* Do a re-dispatch if it is needed
*
         IF    DISPGRD,'ACALL ASDISP'
         ELSE  BEGIN
         L     RY,PSAASDB
         WITH  (ASDB,RY)
         IF    ((RY,NZ),AND,ASDBTDSP),'ACALL ASDISP'
         END   ,
*
* Go to the user
*
         CLOCK USER                    Use the user clock
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW            Get the PSW
         XTRC  R0,R1,RUNUSER2          Trace the run
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         END   ,                       ** End of External FLIH **
         DROP  BR
         EJECT ,
*****************************************************************
*                                                               *
*  SVFLIH  --  This is where Supervisor Call interrupts are     *
*              taken.  It is not in the form of a procedure.    *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
SVFLIH   BEGIN
*
* Save the state
*
         STM   0,15,PSAGPRS            Save GPRs in PSA
         STD   0,PSAFPRS+0*4           FPR 0
         STD   2,PSAFPRS+2*4           FPR 2
         STD   4,PSAFPRS+4*4           FPR 4
         STD   6,PSAFPRS+6*4           FPR 6
SVCPER   BASE  ,                       Set up addressability
         MVC   PSAPSW,PZSVOPSW         Copy the PSW
         LM    R0,R1,PSAPSW            Get the PSW
         L     R2,PZSVILC              Get the ILC and IC
         XTRC  R0,R2,SVCINT            Trace it
         IF    ('LT RS,PSACPLK',NZ),BEGIN      In a SUP routine...
         ABORT SVINSUP                 That is not good
         END   ,
         MVC   PSACPLK,=A(1)
         SET   DISPSTK                 We are now in SUP routine
*
* set up the stack for the dispatcher
*
         L     WAR,PSADSTK             Get the stack for this CPU
         LA    SPR,@WAR+8              Get a location for Save area
*
* Make sure he isn't doing SVCs while holding the lock
*
         LT    RY,PSAASDB              Get the current ASDB
         IF    NZ,BEGIN
         WITH  (ASDB,RY)
         IF    ('LT RS,ASDBLOCK',NZ),'ABORT SVCLOCK'
         END   ,
*
* Call the SVC router
*
         ACALL SVCROUTE
*
* Do a re-dispatch if it is needed
*
         IF    DISPGRD,'ACALL ASDISP'
         ELSE  BEGIN
         L     RY,PSAASDB
         WITH  (ASDB,RY)
         IF    ((RY,NZ),AND,ASDBTDSP),'ACALL ASDISP'
         END   ,
*
* Return to the user
*
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW            Get the PSW
         XTRC  R0,R1,RUNUSER3          Trace the run
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         END   ,                       ** End of Supervisor FLIH **
         DROP  BR
         EJECT ,
*****************************************************************
*                                                               *
*  PIFLIH  --  This is where Program interrupts are taken.      *
*              It is not in the form of a procedure.            *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PIFLIH   BEGIN
         STM   R0,R15,PSATRGRS         Save trace registers
         BASE  ,                       Set up the base register
         LA    RA,X'7F'                Get a mask
         N     RA,PZPIIC-2             Get the interrupt code
         EJECT ,
*
* TRACE TABLE -- If the interrupt is for trace table then
*                it must be handled in a special way.  First
*                the new trace table is set up and then a quick
*                return to the interrupted program is made.
*
         IF    (RA,EQ,X'16'),BEGIN     Trace table exception
         LM    RJ,RK,PSATRB0           Get the two trace pointers
         LR    RB,RK
         STM   RB,RJ,PSATRB0           Swap the two pointers
         STCK  @RB                     Save the time of the start
         LRA   RS,@RB+8                Get real addr of new trace tab
         L     RK,PSADCT
         WITH  (DCT,RK),BEGIN
         O     RS,DCTTRMSK             OR in the trace bits
         END   ,
         ST    RS,PSATRWK              Save the new value
         LCTL  12,12,PSATRWK           Load the control register
*
* Make a quick getaway
*
         LM    R0,R15,PSATRGRS         Load the registers
         LPSW  PZPIOPSW                And the PSW
         END   ,
         EJECT ,
*
* If it was not a trace interrupt we take off from here.  RA
* contains the interupt code less per and monitor bits.
*
*
* Save the state
*
         MVC   PSAPIILC(4),PZPIILC     Copy the ILC and IC
         MVC   PSAPSW,PZPIOPSW         Copy the PSW
         MVC   PSAGPRS(16*4),PSATRGRS  Take user regs from trace
         STD   0,PSAFPRS+0*4           FPR 0
         STD   2,PSAFPRS+2*4           FPR 2
         STD   4,PSAFPRS+4*4           FPR 4
         STD   6,PSAFPRS+6*4           FPR 6
         LM    R3,R4,PSAPSW            Get the PSW
         L     R5,PSAPIILC             Copy of the ILC/IC
         LM    R6,R9,PZTREXA           Get the other codes
         XTRC  R3,R9,PIINT             Trace all that info
*
         IF    ('LT RS,PSACPLK',NZ),BEGIN      In a SUP routine...
         ABORT PIINSUP                 That is not good
         END   ,
         MVC   PSACPLK,=A(1)
         SET   DISPSTK                 We are now in SUP routine
*
* Don't allow any program checks while disabled
*
         IF    (RA,NZ),BEGIN           Any real interrupt?
         TM    PSAPSW,B'00000011'      External & I/O on?
         IF    ^ON,'ABORT PIDISAB'     If not... bag it
         END   ,
*
* Set up the stack for the dispatcher
*
         L     WAR,PSADSTK             Get the stack for this CPU
         LA    SPR,@WAR+8              Get a location for Save area
*
         IF    ((RA,EQ,X'11'),OR,(RA,EQ,X'10')),BEGIN
*
* Call the page/segment fault processing routine.  This returns
* a zero if the rest of the processing may be skipped and non-zero
* if the page/segment is not available.
*
         ACALL PFLT                    Process fault
         IF    (RVR,Z),PIEND           Complete the interrupt
         END   ,
*
* Make sure he isn't program checking while holding the lock
*
         LT    RY,PSAASDB              Get the current ASDB
         IF    NZ,BEGIN
         WITH  (ASDB,RY)
         IF    ('LT RS,ASDBLOCK',NZ),'ABORT PILOCK'
         END   ,
*
* Take care of the stand alone PER
*
         IF    (PSAPIIC+1,EQ,X'80'),BEGIN
*
* Check for a PER on an SVC
*
         IF    (PSAPSW,EQ,PZSVNPSW),BEGIN  Yep, It was an SVC
         LCALL PERROUTE                Handle the PER
         CLEAR DISPSTK                 Clear dispatch flag
         CLEAR PSACPLK                 And CPU lock
         L     RS,=A(SVCPER)           Get the branch address
         BR    RS                      And go do it
         END   ,
*
* Machine better not be disabled otherwize
*
         TM    PSAPSW,B'00000011'      External & I/O on?
         IF    ^ON,'ABORT PERDISAB'    If not... bag it
         LCALL PERROUTE                Handle the PER
         B     PIEND                   Done with stand alone PER
         END   ,
*
* Take Care of Monitor Call
*
         IF    (RA,EQ,X'40'),BEGIN     Monitor Call interrupt
*        IF    PSAPIIC+1.X'80','LCALL PERROUTE' No per on MON for now
         LCALL MONROUTE                Take care of the MON Call
         END   ELSE,BEGIN
*
* Take care of the rest of the possible interrupt conditions
*
*
         LCALL PIROUTE                 And take care of the PI
         END   ,
*
* Do a re-dispatch if it is needed
*
PIEND    LABEL ,
         IF    DISPGRD,'ACALL ASDISP'
         ELSE  BEGIN
         L     RY,PSAASDB
         WITH  (ASDB,RY)
         IF    ((RY,NZ),AND,ASDBTDSP),'ACALL ASDISP'
         END   ,
*
* Return to the user
*
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW            Get the location
         XTRC  R0,R1,RUNUSER4          Trace the run
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         END   ,                       ** End of Program FLIH **
         DROP  BR
         EJECT ,
*****************************************************************
*                                                               *
*  MCFLIH  --  This is where Machine Check interrupts are       *
*              taken.  It is not in the form of a procedure.    *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MCFLIH   BEGIN
         ABORT  MCHECK                 Whoa!!!
         END   ,
         EJECT ,
*****************************************************************
*                                                               *
*  IOFLIH  --  This is where I/O interrupts are taken.  It is   *
*              NOT in the form of a procedure.                  *
*                                                               *
*    Input --  none                                             *
*                                                               *
*   Output --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
IOFLIH   BEGIN
*
* Save the state
*
         MVC   PSAPSW,PZIOOPSW         Copy the PSW
         STM   0,15,PSAGPRS            Save GPRs in PSA
         STD   0,PSAFPRS+0*4           FPR 0
         STD   2,PSAFPRS+2*4           FPR 2
         STD   4,PSAFPRS+4*4           FPR 4
         STD   6,PSAFPRS+6*4           FPR 6
         BASE  ,                       Set up addressability
         LM    R0,R1,PSAPSW            Get the PSW
         LM    R2,R4,PZIOSID           Get the I/O info
         XTRC  R0,R4,IOINT             Trace the interrupt
         CLOCK IOSV                    I/O service clock
         IF    ('LT RS,PSACPLK',NZ),BEGIN      In a SUP routine...
         ABORT IOINSUP                 That is not good
         END   ,
         MVC   PSACPLK,=A(1)
         SET   DISPSTK                 We are now in SUP routine
*
* set up the stack for the dispatcher
*
         L     WAR,PSADSTK             Get the stack for this CPU
         LA    SPR,@WAR+8              Get a location for Save area
*
* Call the I/O supervisor
*
         VCALL IOSINTER                I/O supervisor interrupt entry
*
* Do a re-dispatch if it is needed
*
         IF    DISPGRD,'ACALL ASDISP'
         ELSE  BEGIN
         L     RY,PSAASDB
         WITH  (ASDB,RY)
         IF    ((RY,NZ),AND,ASDBTDSP),'ACALL ASDISP'
         END   ,
*
* Re-start the current user
*
         CLOCK USER                    Use the user clock
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW
         XTRC  R0,R1,RUNUSER5          Trace the run
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         END   ,                       ** End of I/O FLIH **
         DROP  BR
         EJECT ,
*****************************************************************
*                                                               *
*    PFLT  --  This is called when a page or segment fault      *
*              occurs.  It calls the real storage manager and   *
*              handles the response.  It returns a zero in RVR  *
*              if everything was handled correctly and non-zero *
*              if program interrupt processing should continue. *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PFLT     PROC  SCOPE=LOCAL
*
* Assume that the real storage manager will process the page fault
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
         IF    ASDBPFLT,'ABORT TWOPFLT'
         SET   ASDBPFLT,MODE=LOCKED,REF=ASDB   Mark it as in progress
*
* Update the suspend count
*
         L     RA,ASDBSUSP             Get the current count
         LOOP  BEGIN
         LA    RB,@RA+1                Count one more suspension
         CS    RA,RB,ASDBSUSP          Update the count
         UNTIL Z,END
*
* Make us non-swapable for the duration of the page fault
*
         L     RS,ASDBSHCT             Get the hold count
         LOOP  BEGIN
         LA    RVR,@RS+1               Increment the count
         CS    RS,RVR,ASDBSHCT         Update the value
         UNTIL Z,END
*
* Call the Real storage manager
*
         VCALL PAGFAULT                Let him try it
         LR    RS,RVR                  Get the return info
         B     PFRET(RS)               And go to it
*
PFRET    B     PFINPRO                 0 -- Fault in progress
         B     PFBAD                   4 -- Page no good
         B     PFOK                    8 -- Page fault resolved
         B     PFWAIT                 12 -- Must wait for something
         SPACE 2
*
* Page fault resolution is in progress; we were right
*
PFINPRO  SET   DISPGRD                 Make sure the suspend takes
         CLEAR RVR                     Signal good return
         B     PFEND                   Return to the caller
         SPACE
*
* The real storage manager is unable to handle the page fault at this
* time.  He is supposed to queue it up and return OK, however there
* is always the possiblitiy that he cannot even do that.  In that
* case, we just pretend it didn't happen, drop the priority and let
* this address space run again.
*
PFWAIT   CLEAR ASDBSPRI                Lowest possible priority
         CLEAR RVR                     Good return
         B     NOTINP
*
PFBAD    LA    RVR,4                   The page is no good
         B     NOTINP
*
PFOK     CLEAR RVR                     The page fault resolved
         SPACE 2
*
* If the page I/O is not in progress we have to un-do what we did
* at the start.  First remove the suspension.
*
NOTINP   L     RA,ASDBSUSP             Get the current value
         LOOP  BEGIN
         LR    RS,RA                   Copy the current value
         SH    RS,=Y(1)
         IF    NEG,'CLEAR RS'          not less than zero
         CS    RA,RS,ASDBSUSP          Update the suspend count
         UNTIL Z,END
*
* Clear the in progress flag
*
         CLEAR ASDBPFLT,MODE=LOCKED,REF=ASDB,REGS=(EPAR,RA,RS)
*
* Remove the swap hold
*
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the count value
         SH    RS,=Y(1)                Decrement the count
         IF    NEG,'ABORT SWAPHREL'    Not too far though
         CS    RA,RS,ASDBSHCT          Update the count
         UNTIL Z,END                   Release one swap hold
*
* Check to see if a re-dispatch is needed to handle the new paging
* numbers
*
         L     RA,PSADCT               Get the DCT pointer
         WITH  (DCT,RA)
         L     RB,PZMATP               Get the MAT pointer
         WITH  (MAT,RB)
         L     RS,MATPAGFN             Current paging function num
         IF    ((RS,GE,DCTSHPF),OR,                                    *
               (RS,LT,DCTSLPF)),'SET DISPGRD+DISPLTD'
PFEND    PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* PERROUTE --  This routine is entered when a PER condition is  *
*              sensed.  It schedule a PER exit.                 *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PERROUTE PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
*
* Set up to call the Exit
*
         PSET  @XITDO                  Address the parm area
         PMOV  @XITRQID,TDBPEERQ       Move in the request ID
         PMOV  @XITTSK,LA:TDB          Task ID
         MVI   @XITTYPE,XITTPER        Exit type
         WITH  (SEXITPER,@XITPARM),BEGIN
         MVC   SXIEILC,PSAPIILC        Instruction length
         MVC   SXIECODE,PZPERCD        PER code
         MVC   SXIEPERA,PZPERA         PER Address
         END   ,
         ACALL XITDO                   Cause the exit to take place
         IF    (RVR,NZ),'ABORT BADPER'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* PIROUTE  --  Program Interrupt router.  This routine causes   *
*              an exit to be scheduled.                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PIROUTE  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
*
* Set up to call the Exit
*
         PSET  @XITDO                  Address the parm area
         PMOV  @XITRQID,TDBPIERQ       Move in the request ID
         PMOV  @XITTSK,LA:TDB          Task ID
         MVI   @XITTYPE,XITTPI         Exit type
         WITH  (SEXITPI,@XITPARM),BEGIN
         MVC   SEXITPI,PSAPIILC        Move the interrupt info in
         NI    SXIPCODE+1,X'7F'        Turn off the the PER bit
         END   ,
         ACALL XITDO                   Cause the exit to take place
         IF    (RVR,NZ),'ABORT BADPI'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* SVCROUTE --  This is the SVC router.  It schedules an SVC     *
*              exit routine.                                    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
SVCROUTE PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
*
* Set up to call the Exit
*
         PSET  @XITDO                  Address the parm area
         PMOV  @XITRQID,TDBSVERQ       Move in the request ID
         PMOV  @XITTSK,LA:TDB          Task ID
         MVI   @XITTYPE,XITTSVC        Exit type
         WITH  (SEXITSVC,@XITPARM),BEGIN
         MVC   SEXITSVC,PZSVILC        Move the interrupt info in
         END   ,
         ACALL XITDO                   Cause the exit to take place
         IF    (RVR,NZ),'ABORT BADSVC'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* MONROUTE --  This is the Monitor Call Router.  It schedules   *
*              a Monitor Call exit.                             *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MONROUTE PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
*
* Set up to call the Exit
*
         PSET  @XITDO                  Address the parm area
         PMOV  @XITRQID,TDBMCERQ       Move in the request ID
         PMOV  @XITTSK,LA:TDB          Task ID
         MVI   @XITTYPE,XITTMON        Exit type
         WITH  (SEXITMC,@XITPARM),BEGIN
         MVC   SXIMILC,PSAPIILC        Move the interrupt info in
         MVC   SXIMCLA,PZMONCL         Monitor Class
         MVC   SXIMCODE,PZMONCD        Monitor Code
         END   ,
         ACALL XITDO                   Cause the exit to take place
         IF    (RVR,NZ),'ABORT BADMON'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* CPUTIMR  --  This routine is entered when a CPU timer expires *
*              for a user.  It takes care of all the stuff that *
*              has to happen when a time slice expires and also *
*              the implementation of user CPU timers.           *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CPWA     RECORD BEGIN
CPWINTC  DS    D             Current number of WS intervals
CPWEINT  DS    D             Number of elapsed intervals
         END   ,
         SPACE 2
CPUTIMR  PROC  ,CPWA,SCOPE=LOCAL
*
* Get the current ASDB
*
         L     RY,PSAASDB              Current ASDB pointer
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB pointer
         WITH  (TDB,RX)
         L     RJ,PSADCT               DCT pointer
         WITH  (DCT,RJ)
*
* Calculate the elapsed time Since the timer was loaded
*
         XC    PSAKUSER,=X'FFFFFFFFFFFFFFFF'  Complement the value
         LD    0,PSAKUSER              Load that value
         AW    0,=X'0000000000000001'  Get twos complement of time
         AW    0,ASDBSCPU              Add the starting CPU time
*
* Update the various clocks
*
         IF    ASDBACCT,BEGIN          This ASDB is charged
         LD    2,PSATCHG               Get the total time charged
         AWR   2,0                     Add this bit
         STD   2,PSATCHG               Update the value
         END   ,
*
         LD    2,ASDBTCPU              Get the ASDB total CPU time
         AWR   2,0                     Add in this iteration
         STD   2,ASDBTCPU              Then update the value
*
         CD    2,ASDBTIMR              We at the appointed time yet?
         IF    GE,BEGIN                Yep, we have to take the exit
         ACALL CPTIMER                 Take care of the timers
         END   ,
*
         CD    2,ASDBWSNC              Is it time for more WS man.
         IF    GE,BEGIN                It is...
*
* Calculate the number of working set intervals have passed
*
         LDR   4,2                     Get the total CPU time
         DD    4,ASDBWSIN              Get the number of intervals
         AW    4,=X'4E00000000000000'  Get integral number
         STD   4,CPWINTC               Save the current number
         SW    4,ASDBWSLC              Get the difference
         STD   4,CPWEINT               Save the elapsed interval
         MVC   ASDBWSLC,CPWINTC        Save the new value
*
* Calculate the time at which we must go through this again
*
         LD    4,ASDBWSIN              Get the interval
         AWR   4,2                     Get the time of the next call
         STD   4,ASDBWSNC              Save that time for later
*
* Call the paging supervisor
*
         IF    ^ASDBTERM,BEGIN         But not during termination
         PSET  @PAGWSMA
         MVC   @WSASB,ASDBASB          ASB address
         MVC   @WSINT,CPWEINT+4        Move in the count of intervals
         MVC   @WSLIMIT,ASDBWSLM       Move in the working set limit
         VCALL PAGWSMAN                Call the paging supervisor
         END   ,
*
* See if that changes the global situation
*
         L     RA,PZMATP               Get the MAT address
         WITH  (MAT,RA)
         L     RS,MATPAGFN             Current paging function num
         IF    ((RS,GE,DCTSHPF),OR,                                    *
               (RS,LT,DCTSLPF)),'SET DISPGRD+DISPLTD'
         END   ,
*
* Check the slice timer.  If it has expired, we  update the priority
* of this AS
*
         CD    2,ASDBSLC               Has it expired
         IF    GE,BEGIN                Yep...modify the priorities
         SET   DISPGRD                 We will need to re-dispatch
         PSET  @UPDPRIO
         PMOV  @UPPASDB,ASDB,OP=LA     Move the ASDB pointer in
         SET   @UPPTSE                 Indicate time slice end
         ACALL UPDPRIO                 Update the priority
*
* See if this is the first time slice since this AS was swapped in.
*
         IF    ^ASDBSWTS,BEGIN         Yep.
         SET   ASDBSWTS                Mark it as getting one
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the count value
         SH    RS,=Y(1)                Decrement the count
         IF    NEG,'ABORT SWAPHREL'    Not too far though
         CS    RA,RS,ASDBSHCT          Update the count
         UNTIL Z,END                   Release one swap hold
         END   ,
         END   ,
*
* Calculate the next value of the CPU timer
*
         LD    0,ASDBSLC               Get the slice end time
         SWR   0,2                     Interval from now
         LD    4,ASDBTIMR              Get the CPU timer value
         SWR   4,2                     Interval from now
         CDR   0,4
         IF    GT,'LDR 0,4'            Get the smaller
*
* Update the user clock
*
         STD   0,ASDBSCPU              Starting clock value
         STD   0,PSAKUSER              And put it in the user area
*
* If our priority changed, do a dispatch
*
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* RTCLOCK  --  This routine is called when the Real-time clock  *
*              queue neede to be modified.  It will handle      *
*              expired timers and reset the clock comparator.   *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RTCLOCK  PROC  SCOPE=LOCAL
         L     RX,PSADCT               Get the DCT pointer
         WITH  (DCT,RX)                And address it
         LKOB  DCTLOCK                 Get the lock
*
* Check each one in the real time clock queue to see if it has
* expired yet
*
         L     RA,DCTRTCQ              And of the real current
         WITH  (RTCQ,RA)               Address the area
         STCK  PSADWK1                 And also the current time
RTQLOOP  WHILE (RA,NZ),BEGIN           We have a pointer
         CLC   PSADWK1,RTCQTOD         Has this one arrived yet?
         IF    LT,EXIT                 If not then no more to wake up
*
* The first one in the list has expired.  Remove it from the list,
* and schedule the SYSR.
*
         MVC   DCTRTCQ,RTCQNEXT        Remove this element
         PSET  @SYSRDO
         MVC   @SYSRID,RTCQSYSR        Move in the SYSR ID
         MVC   @SYSRASB,RTCQASB        Get the ASB address
         MVC   @SYSRLOC,=A(RTSYSR)     Where to do it
         ST    RA,@SYSRPRM             Parm for the SYSR routine
         ACALL SYSRDO                  Schedule the SYSR
         L     RA,DCTRTCQ              Get the first in line again
         END   ,
*
* There are no more expired timers.  We set the clock comparator from
* the first in the list if there is one and some very large value
* if there is not.
*
         IF    (RA,Z),BEGIN
         SCKC  =X'FFFFFFFFFFFFFFFF'    Far into the future
         END   ELSE,BEGIN
         SCKC  RTCQTOD                 Set the new timer
         END   ,
         LKREL DCTLOCK                 Free the lock
         PEND  ,                       Return to the current user
         EJECT ,
         LTORG
         TITLE 'Timer Management'
*****************************************************************
*                                                               *
*   RTSET  --  This routine starts a real-time timer for the    *
*              calling task.  It allocates a new RTCQ and       *
*              queues it to the timer queue.  It then wakes up  *
*              the CPU controlling the real time clocks.        *
*                                                               *
*   Input  --  @RTSET                                           *
*                                                               *
*  Output  --  RVR contains the timer ID                        *
*                                                               *
*****************************************************************
         SPACE 2
RTSET    PROC  @RTSET,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,PSADCT               DCT Address
         WITH  (DCT,RX)
*
* Allocate a new RTCQ entry
*
         ACALL NEWRTCQ                 Get a new RTCQ entry
         LR    RA,RVR                  Copy the address
         WITH  (RTCQ,RA)
*
* Format the RTCQ
*
         MVC   RTCQASB,ASDBASB         Save the Current ASB
         MVC   RTCQTDB,ASDBCTDB        And the current TDB
         PSET  @SYSRNEW
         ACALL SYSRNEW                 Get a new SYSR
         ST    RVR,RTCQSYSR            Save the ID
         MVC   RTCQXID,@RTSXIT         User's Exit ID
         MVC   RTCQPARM(8),@RTSPARM    Move in the user exit parms
*
* Figure out what time this timer will expire
*
         IF    @RTSFINT,BEGIN          Interval timer
         SET   RTINTVL                 Mark it as an interval timer
         STCK  RTCQTOD                 Get the current time
         LM    RJ,RK,RTCQTOD           Load into regs
         ADL   RJ,@RTSCLK              Get the TOD of the end
         STM   RJ,RK,RTCQTOD           Save it in the Clock
         END   ELSE,BEGIN              It is a TOD clock
         MVC   RTCQTOD,@RTSCLK         Caller passes the TOD clock
         END   ,
*
* Now we have to add it to the timer queue
*
         DISABLE ,                     We can't afford interrupts
         LKOB  DCTLOCK                 Get the disp lock
         LA    RJ,DCTRTCQ              Address of first pointer
         WHILE ('LT RK,@RJ',NZ),BEGIN  Insert loop
         WITH  (RTCQ,RK),LABEL=Q       Address it
         IF    (RTCQTOD,LT,Q.RTCQTOD),EXIT  Found the spot
         LA    RJ,Q.RTCQNEXT           Address of pointer to next
         END   ,
*
* We've found the insertion point, add it to the list
*
         MVC   RTCQNEXT,@RJ            Point this at the rest
         ST    RA,@RJ                  And add this to the list
         LKREL DCTLOCK                 Free the dispatch lock
*
* Update the clock comparator if we need to do so.
*
         IF    (RA,EQ,DCTRTCQ),BEGIN   Ours is first in line
         L     RB,DCTIPCBS             Get the first IPCB in system
         WITH  (IPCB,RB),BEGIN
         SET   IPFLRCC,MODE=LOCKED,REF=IPCB
         LH    RS,IPCBCPUA             Get the CPU address
         SIGP  RS,RS,X'02'             Signal the external call
         END   ,
         END   ,
         ENABLE ,                      Get our system mask back
         LR    RVR,RA                  Return the timer ID
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   RTCHK  --  This routine returns the time remaining on a     *
*              given Real-time timer.                           *
*                                                               *
*   Input  --  @RTCNCK                                          *
*                                                               *
*  Output  --  RVR=0, Data is ok; RVR^=0, Bad ID passed.        *
*                                                               *
*****************************************************************
         SPACE 2
RTCHK    PROC  @RTCNCK,SCOPE=GLOBAL
         WITH  (RTEXIT,@RTCPARM)
*
* Verify the identity of the RTCQ he is passing
*
         ACALL ASLOCK                  Make sure the SYSR doesn't run
RTKLK    BEGIN
         LA    RA,4                    Default return code
         L     RX,@RTCID               Get the ID of the timer
         WITH  (RTCQ,RX)
         IF    (RTCQ,NE,'RTCQ'),EXIT   Not a timer ID
         IF    (RTCQASB,NE,PZCURASB),EXIT  Not our Address space
         IF    (RTCQTDB,NE,PSATDB),EXIT    Or our task
*
* Get the time remaining
*
         STCK  @RTCCLK                 Get the current time
         IF    (@RTCCLK,GE,RTCQTOD),BEGIN  Expired already
         CLEAR @RTCCLK                 No time left
         END   ELSE,BEGIN
         LM    RA,RB,RTCQTOD           Get the expiration time
         SDL   RA,@RTCCLK              Get the remaining interval
         STM   RA,RB,@RTCCLK           Save the interval left
         END   ,
*
* Fill in the other parms
*
         ST    RX,RTXTID               Save the timer ID
         MVC   RTXXID,RTCQXID          Exit ID
         MVC   RTXPARM(8),RTCQPARM     And the parms
         CLEAR RA                      Signal good return
         END   ,
         ACALL ASULOCK                 Free the lock
         LR    RVR,RA                  Copy the return code
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   RTCAN  --  This routine Cancel's the timer and returns the  *
*              time remaining on it.                            *
*                                                               *
*   Input  --  @RTCNCK                                          *
*                                                               *
*  Output  --  RVR=0, Data is ok; RVR^=0, Bad ID passed.        *
*                                                               *
*****************************************************************
         SPACE 2
RTCAN    PROC  @RTCNCK,SCOPE=GLOBAL
         WITH  (RTEXIT,@RTCPARM)       Map the parm area
*
* Get our bearings
*
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         L     RJ,@RTCID               Get the RTCQ address (ID)
         WITH  (RTCQ,RJ)
*
* Check out the ID
*
         DISABLE ,                     Turn off interrupts
         LKOB  DCTLOCK                 Get the DCT lock
RTCTLK   BEGIN
         LA    RN,4                     efault return code
         IF    (RTCQ,NE,'RTCQ'),EXIT   Not a timer ID
         IF    (RTCQASB,NE,PZCURASB),EXIT  Not our Address space
         IF    (RTCQTDB,NE,PSATDB),EXIT    Not our task
*
* Find it on the RT timer queue
*
         LA    RS,DCTRTCQ              Address of the queue head
         WHILE (@RS,NZ),BEGIN          Loop to the end of the queue
         IF    (RJ,EQ,@RS),EXIT        Found the pointer to ours
         L     RS,@RS                  Get the address of next in q
         WITH  (RTCQ,RS),'LA RS,RTCQNEXT'  And the addr of the ptr
         END   ,
         IF    (@RS,EQ,=A(0)),EXIT     Not found
*
* Remove it from the queue
*
         MVC   @RS(4),RTCQNEXT         Remove this one from the list
         CLEAR RN                      Clear the return code
         END   ,                       End of the locked area
         LKREL DCTLOCK                 Free the dispatch lock
         ENABLE ,                      And restore system flags
*
         IF    (RN,Z),BEGIN            The ID is good, and removed
*
* Get the time remaining
*
         STCK  @RTCCLK                 Get the current time
         IF    (@RTCCLK,GE,RTCQTOD),BEGIN  Expired already
         CLEAR @RTCCLK                 No time left
         END   ELSE,BEGIN
         LM    RA,RB,RTCQTOD           Get the expiration time
         SDL   RA,@RTCCLK              Get the remaining interval
         STM   RA,RB,@RTCCLK           Save the interval left
         END   ,
*
* Fill in the other parms
*
         ST    RJ,RTXTID               Save the timer ID
         MVC   RTXXID,RTCQXID          Exit ID
         MVC   RTXPARM(8),RTCQPARM     And the parms
*
* Free the SYSR id
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,RTCQSYSR       Move in the ID
         ACALL SYSRDEL                 Free that up
*
* Now free the RTCQ
*
         PSET  @GCBDEL
         ST    RJ,@GCBDLOC             Address of the RTCQ
         ACALL DELRTCQ                 Free it up
         END   ,
         LR    RVR,RN                  Copy the return code
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  RTSYSR  --  This is the real-time timer complete routine.    *
*              It frees the RTCQ and schedules the timer exit   *
*              routine.                                         *
*                                                               *
*   Input  --  @SYSRTN                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RTSYSR   PROC  @SYSRTN,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PSADCT               Get the DCT pointer
         WITH  (DCT,RX)
         L     RA,@SYSPARS             Get the RTCQ pointer
         WITH  (RTCQ,RA)
*
* Schedule the timer exit
*
         PSET  @XITDO
         MVC   @XITRQID,RTCQXID        Exit ID
         MVC   @XITTSK,RTCQTDB         Task ID
         MVI   @XITTYPE,XITTRTC        Real time Clock exit
         WITH  (RTEXIT,@XITPARM)
         ST    RA,RTXTID               Save the timer id
         MVC   RTXXID,RTCQXID          And the Exit it
         MVC   RTXPARM(8),RTCQPARM     And the user parms
         ACALL XITDO                   Schedule the exit
*
* Free the SYSR id
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,RTCQSYSR       Move in the ID
         ACALL SYSRDEL                 Free that up
*
* Now free the RTCQ
*
         PSET  @GCBDEL
         ST    RA,@GCBDLOC             Address of the RTCQ
         ACALL DELRTCQ                 Free it up
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  RTTERM  --  This routine is called when an address space     *
*              is terminating.  It removes any outstanding      *
*              real time timers for the current address space.  *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RTTERM   PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PSADCT               Get the DCT pointer
         WITH  (DCT,RX)
         LKOB  DCTLOCK                 Lock up the chain
         LA    RS,DCTRTCQ              Addr of first pointer
*
* Loop through the queue, removeing elements for this ASB
*
         WHILE ('LT RA,@RS',NZ),BEGIN
         WITH  (RTCQ,RA)
         IF    (RTCQASB,NE,PZCURASB),BEGIN    Not ours
         LA    RS,RTCQNEXT             Addr of next pointer
         END   ELSE,BEGIN              If it is ours...
         MVC   @RS(4),RTCQNEXT         Remove it from the queue
*
* Free the associated SYSR
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,RTCQSYSR
         ACALL SYSRDEL                 Remove the SYSR
*
* Free the RTCQ
*
         PSET  @GCBDEL
         ST    RA,@GCBDLOC             Address of the RTCQ
         ACALL DELRTCQ                 Free it up
         END   ,                       Loop to the end of the list
         END   ,
         LKREL DCTLOCK                 Free the lock
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   CPSET  --  This routine starts a CPU-time timer for the     *
*              calling task.  It allocates a new CPTQ and       *
*              queues it to the timer queue.                    *
*                                                               *
*   Input  --  @CPSET                                           *
*                                                               *
*  Output  --  RVR contains the timer ID                        *
*                                                               *
*****************************************************************
         SPACE 2
CPSET    PROC  @CPSET,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
*
* Allocate a new CPTQ entry
*
         DISABLE ,                     Eliminate the competition
         L     RA,ASDBFCPQ             Get the first free one
         WITH  (CPTQ,RA)
         IF    (RA,Z),BEGIN            No free ones
         ENABLE ,
         VMGET L'CPTQ,LOC=LOCSYS,FIX=YES
         LR    RA,RVR                  Copy the address
         END   ELSE,BEGIN
         MVC   ASDBFCPQ,CPTQNEXT       Remove it from the list
         ENABLE ,                      Then enable again
         END   ,
*
* Format the CPTQ
*
         CLEAR CPTQ                    Make it all zero
         MVC   CPTQ(4),=C'CPTQ'        Move in the ID
         MVC   CPTQTDB,ASDBCTDB        And the current TDB
         MVC   CPTQXID,@CPSXIT         User's Exit ID
         MVC   CPTQPARM(8),@CPSPARM    Move in the user exit parms
*
* Figure out what time this timer will expire
*
         ACALL ACPUTIME                Returns the value in F0
         AW    0,@CPSCLK               Get the ending time
         STD   0,CPTQTOD               Save it in the Clock
*
* Now we have to add it to the timer queue
*
         DISABLE ,                     We can't afford interrupts
         LA    RJ,ASDBCPTQ             Address of first pointer
         WHILE ('LT RK,@RJ',NZ),BEGIN  Insert loop
         WITH  (CPTQ,RK),LABEL=Q       Address it
         IF    (CPTQTOD,LT,Q.CPTQTOD),EXIT  Found the spot
         LA    RJ,Q.CPTQNEXT           Address of pointer to next
         END   ,
*
* We've found the insertion point, add it to the list
*
         MVC   CPTQNEXT,@RJ            Point this at the rest
         ST    RA,@RJ                  And add this to the list
*
* If this is the first, we update the time in the ASDB
*
         IF    (RA,EQ,ASDBCPTQ),BEGIN  It is the first
         MVC   ASDBTIMR,CPTQTOD        Update the time
         END   ,
         ENABLE ,                      Get our system mask back
         LR    RVR,RA                  Return the timer ID
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   CPCHK  --  This routine returns the time remaining on a     *
*              given CPU-time timer.                            *
*                                                               *
*   Input  --  @CPCNCK                                          *
*                                                               *
*  Output  --  RVR=0, Data is ok; RVR^=0, Bad ID passed.        *
*                                                               *
*****************************************************************
         SPACE 2
CPCHK    PROC  @CPCNCK,SCOPE=GLOBAL
         WITH  (CPEXIT,@CPCPARM)
*
* Verify the identity of the CPTQ he is passing
*
CPCLK    BEGIN
         ACALL ASLOCK                  Make sure no-one else grabs it
         LA    RA,4                    Default return code
         L     RX,@CPCID               Get the ID of the timer
         WITH  (CPTQ,RX)
         IF    (CPTQ,NE,'CPTQ'),EXIT   Not a timer ID
         IF    (CPTQTDB,NE,PSATDB),EXIT Or our task
*
* Get the time remaining
*
         ACALL ACPUTIME                Get the current time
         CD    0,CPTQTOD               Compare the time
         IF    GE,BEGIN
         SDR   0,0                     No time left
         END   ELSE,BEGIN
         SW    0,CPTQTOD               Get the difference
         LCDR  0,0                     In positive terms
         END   ,
         STD   0,@CPCCLK
*
* Fill in the other parms
*
         ST    RX,CPXTID               Save the timer ID
         MVC   CPXXID,CPTQXID          Exit ID
         MVC   CPXPARM(8),CPTQPARM     And the parms
         CLEAR RA                      Signal good return
         END   ,
         ACALL ASULOCK                 Free the lock
         LR    RVR,RA                  Copy the return code
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   CPCAN  --  This routine Cancels the timer and returns the   *
*              time remaining on it.                            *
*                                                               *
*   Input  --  @CPCNCK                                          *
*                                                               *
*  Output  --  RVR=0, Data is ok; RVR^=0, Bad ID passed.        *
*                                                               *
*****************************************************************
         SPACE 2
CPCAN    PROC  @CPCNCK,SCOPE=GLOBAL
         WITH  (CPEXIT,@CPCPARM)       Map the parm area
*
* Get our bearings
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
         L     RJ,@CPCID               Get the CPTQ address (ID)
         WITH  (CPTQ,RJ)
*
* Check out the ID
*
         DISABLE ,                     Turn off interrupts
CPCTLK   BEGIN
         LA    RN,4                    Default return code
         IF    (CPTQ,NE,'CPTQ'),EXIT   Not a timer ID
         IF    (CPTQTDB,NE,ASDBCTDB),EXIT  Not our task
*
* Find it on the CP timer queue
*
         LA    RS,ASDBCPTQ             Address of the queue head
         WHILE (@RS,NZ),BEGIN          Loop to the end of the queue
         IF    (RJ,EQ,@RS),EXIT        Found the pointer to ours
         L     RS,@RS                  Get the address of next in q
         WITH  (CPTQ,RS),'LA RS,CPTQNEXT'  And the addr of the ptr
         END   ,
         IF    (@RS,EQ,=A(0)),EXIT     Not found
*
* Remove it from the queue
*
         MVC   @RS(4),CPTQNEXT         Remove this one from the list
         CLEAR RN                      Clear the return code
         END   ,                       End of the locked area
         ENABLE ,                      And restore system flags
*
         IF    (RN,Z),BEGIN            The ID is good, and removed
*
* Get the time remaining
*
         ACALL ACPUTIME                Get the current time
         CD    0,CPTQTOD               Expired already?
         IF    GE,BEGIN                Then no time left
         SDR   0,0
         END   ELSE,BEGIN
         SW    0,CPTQTOD               Get the expiration time
         LCDR  0,0                     In positive terms
         END   ,
         STD   0,@CPCCLK               Tell the caller how much
*
* Fill in the other parms
*
         ST    RJ,CPXTID               Save the timer ID
         MVC   CPXXID,CPTQXID          Exit ID
         MVC   CPXPARM(8),CPTQPARM     And the parms
*
* Now free the CPTQ
*
         MVI   CPTQ+3,C'q'             Blitz the ID
         DISABLE ,                     Everything out
         MVC   CPTQNEXT,ASDBFCPQ       Point this at the free list
         ST    RJ,ASDBFCPQ             Point the queue at this one
         ENABLE ,
         END   ,
         LR    RVR,RN                  Copy the return code
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* CPTIMER  --  This routine is called when some CPU timer has   *
*              expired and must be taken care of.  It also      *
*              updates the time of the next timer expiration.   *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CPTIMER  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
*
* Handle all the expired timers
*
         L     RA,ASDBCPTQ             Get the first timer
         WITH  (CPTQ,RA)
         WHILE (RA,NZ),BEGIN
         IF    (ASDBTCPU,LT,CPTQTOD),EXIT        No more expired
*
* The first in the list has expired, remove it and schedule the
* timer exit.
*
         MVC   ASDBCPTQ,CPTQNEXT       Remove it
         PSET  @XITDO
         MVC   @XITRQID,CPTQXID        ExitID
         MVC   @XITTSK,CPTQTDB         Task ID
         MVI   @XITTYPE,XITTCTC        CPU timer
         WITH  (CPEXIT,@XITPARM)
         ST    RA,CPXTID               Save the timer ID
         MVC   CPXXID,CPTQXID          The exit id
         MVC   CPXPARM(8),CPTQPARM     And the parms
         ACALL XITDO                   Schedule the exit
*
* Put the CPTQ on the free list
*
         MVC   CPTQNEXT,ASDBFCPQ       Point this at the list
         ST    RA,ASDBFCPQ             And the list at this one
         L     RA,ASDBCPTQ             Get first in list again
         END   ,                       And keep looking
*
* There are no more expired timers
*
         IF    (RA,Z),BEGIN
         MVC   ASDBTIMR,=X'00FFFFFFFFFFFFFFFF'   No active timers
         END   ELSE,BEGIN
         MVC   ASDBTIMR,CPTQTOD        Next wakeup time
         END   ,
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Address Space Management'
*****************************************************************
*                                                               *
* ACREATE  --  This routine creates a new address space.  It    *
*              does all the creation that can be done under     *
*              another task.  The creation will continue under  *
*              the control of the ASDB created here.  It        *
*              returns the address of the ASB created.          *
*                                                               *
*   Input  --  @ACREATE                                         *
*                                                               *
*  Output  --  RVR contains the address of the ASB created      *
*                                                               *
*****************************************************************
         SPACE 2
ACREATE  PROC  @ACREATE,SCOPE=GLOBAL
*
* Get the DCT pointer.  Use the MAT in case the PSA is not set up yet.
*
         L     RN,PZMATP               Get the MAT pointer
         WITH  (MAT,RN),'L RN,MATDCT'  Get the pointer
         WITH  (DCT,RN)                Address it
*
* Allocate an ASB
*
         ACALL NEWASB                  Get a new one
         LR    RM,RVR                  ASB address
         WITH  (ASB,RM)
*
* Call the 1st part of the Paging supervisor initialization
*
         PSET  @PAGASC1
         ST    RM,@ASCASB              Save the ASB address
         MVC   @ASCWSLM,DCTWSLM        Working set maximum
         VCALL PAGASC1
*
*  Global init for address space
*
         VCALL ASMGBLIN
*
* Allocate an ASDB
*
         ACALL NEWASDB                 Get an ASDB
         LR    RY,RVR                  ASDB address
         WITH  (ASDB,RY)
         ST    RM,ASDBASB              ASB address
         ST    RY,ASBASDB              ASDB address in the ASB
*
* Set up the priority
*
         MVC   ASDBHPRI,=Y(MAXPRIO)    Top it out at the max
         MVC   ASDBTPRI,=Y(MAXPRIO)    Time slice is highest
         MVC   ASDBSPRI,=Y(MAXPRIO)    Current priority is highest
*
* Timing information
*
         MVC   ASDBCCPT,DCTSLICE+8*MAXPRIO       Slice timer
         MVC   ASDBSCPU,ASDBCCPT       Starting timer
         MVC   ASDBSLC,ASDBCCPT        Slice end cpu time
         MVC   ASDBWSIN,DCTWSIN        Working set interval
         MVC   ASDBWSNC,ASDBWSIN       CPU time at next WS call
         MVC   ASDBTIMR,=X'00FFFFFFFFFFFFFF' Time for the CPU timer
*
* Other global dispatching things
*
         MVC   ASDBWSLM,DCTWSLM        Maximum size of the working set
         MVC   ASDBSHCT,=A(2)          Two swap holds (ignore ts)
         MVC   ASDBLOCK,=A(1)          Shut out competition
*
* Set up a TDB to run in the Address space
*
         ACALL NEWGTDB                 Get new global TDB
         LR    RX,RVR                  Copy the address
         WITH  (TDB,RX)
*
* Reflect this new TDB
*
         ST    RX,ASDBCTDB             It is the current one
         MVC   ASDBNTDB,=Y(1)          Count it as in there
         SET   TDBFACT                 And mark it as active
*
* Fill in some of the TDB fields
*
         ST    RY,TDBASDB              Pointer to the ASDB
         SET   TDBFGLOB                Just so we know it's global
         MVC   TDBPSW(4),=X'070C0000'  High part of the PSW
         MVC   TDBPSW+4(4),=A(X'80000000'+ASCRE2)
         MVC   TDBTCLK,=X'00FFFFFFFFFFFFFF'      Task timeout
*
* Get a stack for it
*
         ACALL GGSTK                   Get a global stack
         LR    RA,RVR                  Copy the address
         ST    RA,TDBSTACK             Save the stack location
         ST    RA,TDBGPRS+4*WAR        Put it in his Regs too
         LA    RA,@RA+8                Get to a double word
         ST    RA,TDBGPRS+4*SPR        Set up his stack pointer
         MVC   TDBGPRS+4*EPAR(4),TDBPSW+4        Entry point address
         MVC   @RA+72(L'@ACREATE),@ACREATE       Move parms in
*
* Now the ASDB needs to be added to the system
*
         LT    RA,DCTLOCK              Get the lock pointer
         IF    NZ,BEGIN                We have a lock pointer
         DISABLE ,
         LKOB  (RA)                    Get the chain locks
         MVC   ASDBCHN,DCTASDBS        Point this at the list
         ST    RY,DCTASDBS             Make the header point here
         PQADD DCTACTIV,(RY)           Queue it up (no preempt)
         LKREL (RA)                    Free the lock
         ENABLE ,
         END   ELSE,BEGIN              Initialization
         MVC   ASDBCHN,DCTASDBS        Point this at the list
         ST    RY,DCTASDBS             Make the header point here
         PQADD DCTACTIV,(RY)           Queue it up (no preempt)
         END   ,
*
* Return the ASB pointer to the caller
*
         LR    RVR,RM                  Copy it in
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  ASCRE2  --  This routine picks up where ACREATE leaves off.  *
*              It is run under the local ASDB, but the TDB and  *
*              stack are still global.  It converts those to    *
*              local and creates the main task of the address   *
*              space.                                           *
*                                                               *
*   Input  --  @ACREATE                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ASCRE2   PROC  @ACREATE,SCOPE=LOCAL
*
* First get our bearings
*
         L     RY,PSAASDB              Get the ASDB pointer
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the global TDB
         WITH  (TDB,RX)
*
* Create the new address space
*
         PSET  @VMCRAS
         MVC   @VMCASB,ASDBASB         Pass the ASB address
         VCALL VMCRAS1                 Create the address space
*
* Replace the global TDB with a local one
*
         VMGET L'TDB,LOC=LOCSYS,FIX=YES
         LTR   RK,RVR                  Copy the address
         IF    NP,'ABORT NO-TMEM'
         MVC   @RK(L'TDB),TDB          Copy the TDB info
         DISABLE ,
         ST    RK,ASDBCTDB             Make this the current one
         ST    RK,PSATDB               Here too
         ST    RK,PZCURTSK             Here too
         ST    RK,ASDBTDBS             And finally here
         ENABLE ,
         WITH  (TDB,RK)                Use the new one now
         CLEAR TDBFGLOB                It is not global either
*
* Get a stack for the address space
*
         ACALL STKNEW                  Get a stack
         ST    RVR,ASDBSTK             ASDB stack
*
* Call initialization routines for other task based functions
*
         VCALL ASMLCLIN
*
* Create the main task for the address space
*
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000' The PSW
         MVC   @TCRPSW+4(4),=V(ASMTASK)  starting in master task
         OI    @TCRPSW+4,X'80'             with 31 bit amode
         MVC   @TCRPARM(8),@ACRPSW     Parm is PSW for next task
         SET   @TCRFSTK                Make it with a stack
         MVC   @TCRPRIO,=A(100)        Set task priority
         SET   @TCRFPABS                 it's absolute
         ACALL TCREATE                 Create the main task
*
* Switch stacks
*
         L     WAR,ASDBSTK             Use the address space stack
         LA    SPR,8(,WAR)             Stack top pointer
*
* Free the global storage
*
         PSET  @GCBDEL
         MVC   @GCBDLOC,TDBSTACK
         ACALL FGSTK                   Free the global stack
         CLEAR TDBSTACK                This stack not there now
         ST    RX,@GCBDLOC             Location of the TDB
         ACALL DELGTDB                 Free the Global TDB
*
* This address space is all started up now, we add its ASB to the
* global chain.
*
         L     RB,ASDBASB              Get the ASB pointer
         WITH  (ASB,RB),BEGIN
         L     RA,PZMATP               Get the MAT pointer
         WITH  (MAT,RA)
         LT    RS,MATASBL              Get the lock id
         IF    NZ,'LKOB (RS)'          Get the lock
         MVC   ASBNEXT,MATASBS         Point this at chain
         ST    RB,MATASBS              And the chain at this one
         IF    (RS,NZ),'LKREL (RS)'    Free the lock
         END   ,
*
* Remove the swap hold
*
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the count value
         SH    RS,=Y(1)                Decrement the count
         IF    NEG,'ABORT SWAPHREL'    Not too far though
         CS    RA,RS,ASDBSHCT          Update the count
         UNTIL Z,END                   Release one swap hold
*
* Then exit from this task
*
         ACALL TEXIT                   Finished (Frees local lock)
         PEND
         EJECT ,
*****************************************************************
*                                                               *
*  ASEXIT  --  This routine is called when an address space     *
*              wishes to terminate.  It cleans up related       *
*              control blocks and causes the address space to   *
*              end.                                             *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
ASEXIT   PROC  SCOPE=GLOBAL
*
* First get our bearings
*
         L     RY,PSAASDB              Get the ASDB pointer
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the TDB address
         WITH  (TDB,RX)
         L     RN,ASDBASB              Current ASB
         WITH  (ASB,RN)
         XTRC  RX,RY,ASEXIT            Trace the call
*
* Mark us as going away
*
         LA    RS,120                  Loop count, two minutes total
         LOOP  BEGIN
         IF    (ASDBNTDB,EQ,1),EXIT
         LA    R0,10                   10 * 0.1 = 1 second
         VCALL M1GOWAIT                Wait for outstanding tasks
         UNTIL (BCT,RS),END
         IF    (ASDBNTDB,NE,1),'ABORT NOTALONE'
         SET   ASDBTERM                Set the flag
         CLEAR TDBEMASK                Don't take any exits
         VCALL PAGAST1                 Setup for freeing the AS
         ACALL DISPSHLD                Don't swap us out
         MVC   ASDBTIMR,=X'00FFFFFFFFFFFFFF' Ignore user CPU timer
         MVC   ASDBSLC,=X'00FFFFFFFFFFFFFF'  Bypass slice timer
*
* Get us onto a global stack
*
         ACALL GGSTK                   Get a global stack
         LR    WAR,RVR                 Copy the address
         LA    SPR,@WAR+8              Setup the stack
*
* And a global TDB
*
         ACALL NEWGTDB                 Get a new one
         LR    RA,RVR                  Copy the address
         DISABLE ,                     Disable for just a second
         MVC   @RA(L'TDB),TDB          Make a copy the TDB
         LR    RX,RA                   Make it ours
         SET   TDBFGLOB                Mark it global
         ST    RX,ASDBTDBS             List of all
         ST    RX,ASDBCTDB             And it is current
         ST    RX,PZCURTSK             And there too
         ST    RX,PSATDB               And there
         ENABLE ,
*
* De-Queue the ASB
*
         L     RM,PZMATP               Get the MAT pointer
         WITH  (MAT,RM),BEGIN
         LKOB  MATASBL                 Get the lock
*
* Find where this ASB is on the queue
*
         LA    RA,MATASBS              Address of first pointer
         WITH  (ASB,RB),LABEL=S
         WHILE ('LT RB,@RA',NZ),BEGIN  Get next ASB address
         IF    (RB,EQ,RN),EXIT         Same as ours: found it
         LA    RA,S.ASBNEXT            Address of next pointer
         END   ,
*
* We have the spot, Remove the ASB
*
         IF    (RB,Z),'ABORT ASBDEQ'   What?!! Not on the list
         MVC   @RA(4),ASBNEXT          Remove it from the list
         CLEAR ASBNEXT                 Make sure
*
* Free the queue
*
         LKREL MATASBL                 Free the lock
         END   ,
*
* Call local termination routines
*
         VCALL ASMLCLX
*
* Eliminate the local area
*
         VCALL PAGAST2                 Remove it. Leave us global.
*
* Get to the dispatcher stack
*
         SSM   =X'04'                  Disable everything
         SET   DISPSTK                 On the dispatcher stack
         MVC   PSACPLK,=A(1)           Holding the lock
         LR    RA,WAR                  Copy our stack pointer
         L     WAR,PSADSTK
         LA    SPR,@WAR+8              Setup the stack
*
* Free the global areas we got
*
         PSET  @GCBDEL
         ST    RX,@GCBDLOC             Location of the TDB
         ACALL DELGTDB                 Free that up
         PSET  @GCBDEL
         ST    RA,@GCBDLOC             Global stack address
         ACALL FGSTK                   Free the stack
         L     RX,PSADCT               DCT address
         WITH  (DCT,RX)
*
* Remove all associated Real-time timers
*
         ACALL RTTERM                  Go remove them all
*
* Free the ASB
*
         PSET  @GCBDEL
         ST    RN,@GCBDLOC             Location of the ASB
         ACALL DELASB                  Free it
*
* Dequeue the ASDB and free it
*
         LKOB  DCTLOCK
         LA    RA,DCTASDBS
         WHILE ('LT RB,@RA',NZ),BEGIN
         IF    (RB,EQ,RY),EXIT
         WITH  (ASDB,RB),'LA RA,ASDBCHN'
         END   ,
         IF    (RB,Z),'ABORT ASDBNOTQ'
         MVC   @RA(4),ASDBCHN          Remove it from the chain
         LKREL DCTLOCK                 Free the lock
*
* Free it
*
         PSET  @GCBDEL
         ST    RY,@GCBDLOC             Location of the ASDB
         ACALL DELASDB                 Free it
         CLEAR PSAASDB                 Free the ASDB pointer too
         CLEAR PSATDB                  No TDB active
         CLEAR PZCURPID                Clear out the PZ too
*
* Start up the next ready Address space
*
         SET   DISPGRD
         ACALL ASDISP
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW            Get the PSW
         XTRC  R0,R1,RUNUSER6          Trace the PSW
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  LTDISP  --  This is the long term dispatcher.  It tries to   *
*              keep the highest priority ready tasks in the     *
*              active set.                                      *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
LTDWA    RECORD BEGIN
         END   ,
         SPACE 2
LTDISP   PROC  ,LTDWA,SCOPE=LOCAL
*
* Get our bearings
*
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         L     RN,PZMATP               Get the MAT pointer
         WITH  (MAT,RN)
*
* First, promote all the AS's we can
*
LTPRO    LOOP  BEGIN                   Promotion phase
         L     RS,MATPAGFN             Paging function value
         IF    (RS,LT,DCTSHPF),EXIT
* Get the highest priority AS in the RD queue
*
         PQHIGH DCTREADY               Get the highest prio AS
         LTR   RY,RVR                  Get the location
         IF    Z,BEGIN                 None to promote, how nice
         MVC   DCTSHPF,=X'7FFFFFFF'    Don't bother us about pages
         EXIT  LTPRO                   Then go on to better things
         END   ,
         WITH  (ASDB,RY)
*
* There should be enough room, we will try to swap it in
*
         PSET  @PAGSWAP
         MVC   @SWASB,ASDBASB          Tell paging manager which
         VCALL PAGISWAP                Swap the AS in
         LC    RA,@SWFLG               Get the flag value
         B     *+4(RA)                 Take care of the return
         B     LTPINP                  In progress
         B     LTPOK                   Done already
*        Drop through to ...           Wait
*
* If the swap couldn't be done, we are done promoting
*
         PQREQ DCTREADY,(RY)           Put it back on the queue
         EXIT  ,                       Done promoting
         SPACE 2
*
* If the swap is in progress, we mark it suspended and put it on
* the STW queue
*
LTPINP   L     RA,ASDBSUSP             Current suspend count
         LOOP  BEGIN
         LA    RS,@RA+1                Increment the suspend count
         CS    RA,RS,ASDBSUSP          Update the suspend count
         UNTIL Z,END
         PQADD DCTSWAIT,(RY)           Add it to the queue
         CLEAR ASDBSWTS                It gets a new start
         MVC   ASDBSHCT,=A(1)          Count of swap holds
         B     LTPFUPD                 Go update the PF counters
         EJECT
*
* Whoa nellie, that swap we asked for is already done!!! We move
* the AS to the ACTIVE queue.  We DO NOT however preempt AS on
* other CPUs.  We will cause a re-dispatch on this CPU though.
*
LTPOK    PQADD DCTACTIV,(RY)           Add it to the queue
         CLEAR ASDBSWTS                Give a chance for 1 Time slice
         MVC   ASDBSHCT,=A(1)          Count of swap holds
         SET   DISPGRD                 See that we do a global Disp
         SPACE 2
*
* Update the PF priority counters in the DCT
*
LTPFUPD  LH    RA,ASDBSPRI             Get the current priority
         SLL   RA,2                    Times 4
         L     RS,DCTSPFCT(RA)         Get the correct priority
         S     RS,ASDBPAGN             Remove this one from the count
         ST    RS,DCTSPFCT(RA)         Update the value
*
* Update the PFN high limit
*
         PQHPFN DCTREADY               Get the higest number
         ST    RVR,DCTSHPF             Update the number
         END   ,                       End of the promotion phase
*
* Update the Swap priority
*
         L     RS,DCTSWOUT             Count of outgoing
         L     RB,MATPAGFN             Get current paging function
         AR    RS,RB                   Add it to the pool
         LA    RA,(NUMPRIO-1)*4        Offset of highest prio count
LTPSLP   WHILE (RA,NM),BEGIN           Loop through the levels
         S     RS,DCTSPFCT(RA)         Less those at this prio level
         IF    NEG,BEGIN               We have run out of gas
         SR    RB,RS
         S     RB,DCTSPFCT(RA)         Compute low sensitivity
         ST    RB,DCTSLPF              Save as the low Paging func
         EXIT  LTPSLP                  Done here
         END   ,
         SH    RA,=Y(4)                Move to lower priority level
         END   ,
         SRL   RA,2                    Get the actual priority level
         IF    (RA,LE,DCTSWPRI),EXIT   If less or the same we're done
         STH   RA,DCTSWPRI             New swap priority level
         EJECT ,
*
* Since the swap priority has gotten higher we need to re-search the
* ACT and STW queues.
*
         CLEAR RM                      Current priority level
LTDDEM   WHILE (RM,LE,DCTSWPRI),BEGIN  Demotion phase
         LR    RA,RM                   Get the priority level
         SLL   RA,3                    times 8
*
* Start with those on the short term wait queue at this priority
*
         L     RJ,DCTSWAIT+4(RA)       Get the tail AS at this level
         WHILE ((RJ,NZ),AND,(RM,LE,DCTSWPRI)),BEGIN    Loop through
         WITH  (ASDB,RJ)
         L     RB,ASDBPREV             Keep a pointer to previous one
*
* Check out the current ASDB.  If it is swapable, we swap it.
*
         IF    ('LT RS,ASDBSHCT',Z),BEGIN    This AS is swapable
         PSET  @DEMOTE,CLEAR=NO
         ST    RJ,@DEMASDB             Save the AS to be swapped
         LCALL DEMOTE                  Demote it (RC unimportant)
         END   ,
         LR    RJ,RB                   Get to the previous
         END   ,                       End of the STW loop
*
* Continue with those on the Active queue at this priority
*
         L     RJ,DCTACTIV+4(RA)       Get the tail AS at this level
         WHILE ((RJ,NZ),AND,(RM,LE,DCTSWPRI)),BEGIN    Loop through
         WITH  (ASDB,RJ)
         L     RB,ASDBPREV             Keep a pointer to previous one
*
* Check out the current ASDB.  If it is swapable, we swap it.
*
         IF    ('LT RS,ASDBSHCT',Z),BEGIN      This AS is swapable
         PSET  @DEMOTE,CLEAR=NO
         ST    RJ,@DEMASDB             Save the AS to be swapped
         LCALL DEMOTE                  Demote it (RC unimportant)
         END   ,
         LR    RJ,RB                   Get to the previous one
         END   ,                       End of the ACT loop
*
* Get us to the next priority level
*
         LA    RM,@RM+1                Get the next level
         END   ,                       End of the demotion phase
         PEND  ,                       Return home
         EJECT ,
*****************************************************************
*                                                               *
*  DEMOTE  --  This routine will request that the specified     *
*              address space be swapped out.  It is passed the  *
*              ASDB of the desired address space.  It first     *
*              tries to swap out the ASDB.  If it is not        *
*              sucessful, it returns 4 in RVR. Otherwize, if    *
*              the ASDB is on a queue, it removes it.  Then it  *
*              puts the ASDB on the LTW queue.  It also updates *
*              the swap information in the DCT.                 *
*                                                               *
*              *** THE DISPATCH LOCK MUST BE HELD ***           *
*                                                               *
*   Input  --  @DEMOTE                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@DEMOTE  RECORD BEGIN
@DEMASDB DS    A             ASDB to swap
         END   ,
         SPACE 2
DEMOTE   PROC  @DEMOTE,SCOPE=LOCAL
*
* First get the control blocks we need
*
         L     RY,@DEMASDB             The ASDB to swap
         WITH  (ASDB,RY)
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
*
* Make sure it can be swapped out
*
         IF    ('LT RS,ASDBSHCT',NZ),BEGIN
         LA    RVR,4                   Non-swapable
         EXIT  DEMOTE                  All done
         END   ,
*
* Then we try to swap the bugger out
*
         PSET  @PAGSWAP                Setup the parm area
         MVC   @SWASB,ASDBASB          Move in the ASB address
         VCALL PAGOSWAP                Call the swap out routine
         LC    RA,@SWFLG               Get the flag value
         B     *+4(RA)                 Take care of the return
         B     DMSINP                  In progress
         B     DMSOK                   Done already
*        Drop through to ...           Wait
*
*  Swap couldn't be done
*
         LA    RVR,4                   Signal the result
         EXIT  DEMOTE
*
* Swap is in progress
*
DMSINP   ST    RVR,ASDBPAGN            Save the paging number
         SET   ASDBSOIP                Set the indicator
         IF    ('LT RS,ASDBQADD',NZ),BEGIN      Currently on a queue
         PQDEL L:ASDBQADD,(RY)         Remove it from the queue
         END   ,
         PQADD DCTLWAIT,(RY)           Add it to the LTW queue
*
* Suspend that address space
*
         L     RS,ASDBSUSP             Get the suspend count
         LOOP  BEGIN
         LA    RA,@RS+1                Increment the count
         CS    RS,RA,ASDBSUSP          Update it
         UNTIL Z,END                   If at first you don't succeed
*
* Update the DCT counts
*
         L     RA,DCTSWOUT             Count of outgoing
         LOOP  BEGIN
         LR    RS,RA                   Copy the count
         A     RS,ASDBPAGN             Add this one
         CS    RA,RS,DCTSWOUT          Update the count
         UNTIL Z,END
         L     RA,PZMATP               Get the MAT address
         WITH  (MAT,RA),'L RB,MATPAGFN'  Get the current paging func
         AR    RS,RB                   Add it into our pool
         LA    RA,(NUMPRIO-1)*4        Offset of highest prio count
DMSLP    WHILE (RA,POS),BEGIN          Loop through the levels
         S     RS,DCTSPFCT(RA)         Less those at this prio level
         IF    NEG,BEGIN               We have run out of gas
         SR    RB,RS
         S     RB,DCTSPFCT(RA)         Compute low sensitivity
         ST    RB,DCTSLPF              Save as the low Paging func
         EXIT  DMSLP                   Done here
         END   ,
         SH    RA,=Y(4)                Move to lower priority level
         END   ,
         SRL   RA,2                    Get the actual priority level
         STH   RA,DCTSWPRI             New swap priority level
*
* Return to the caller
*
         CLEAR RVR                     Good return code
         EXIT  DEMOTE                  Return to caller
*
* The swap is complete
*
DMSOK    ST    RVR,ASDBPAGN            Save the paging number
         IF    ('LT RS,ASDBQADD',NZ),BEGIN      Currently on a queue
         PQDEL L:ASDBQADD,(RY)         Remove it from the queue
         END   ,
         PQADD DCTLWAIT,(RY)           Add it to the LTW queue
*
* Update the Swap priority
*
         L     RS,DCTSWOUT             Count of outgoing
         L     RB,PZMATP               Get the mat pointer
         WITH  (MAT,RB),'L  RB,MATPAGFN'    Paging function value
         AR    RS,RB                   Add it to the pool
         LA    RA,(NUMPRIO-1)*4        Offset of highest prio count
DMQSLP   WHILE (RA,NM),BEGIN           Loop through the levels
         S     RS,DCTSPFCT(RA)         Less those at this prio level
         IF    NEG,BEGIN               We have run out of gas
         SR    RB,RS
         S     RB,DCTSPFCT(RA)         Compute low sensitivity
         ST    RB,DCTSLPF              Save as the low Paging func
         EXIT  DMQSLP                  Done here
         END   ,
         SH    RA,=Y(4)                Move to lower priority level
         END   ,
         SRL   RA,2                    Get the actual priority level
         STH   RA,DCTSWPRI             New swap priority level
*
* Address space is not suspended - try to upgrade it
*
         L     RS,ASDBSUSP             Get the suspend count
         IF    (RS,Z),BEGIN            This AS is ready to go
         PSET  @ASWAKE,CLEAR=NO
         ST    RY,@ASWASDB             Save the ASDB address
         ACALL ASWAKE                  Wake up the ASDB
         END   ,
*
* See if this changed the paging situation
*
         L     RS,PZMATP               Get the mat pointer
         WITH  (MAT,RS),'L  RS,MATPAGFN'    Paging function value
         IF    ((RS,GE,DCTSHPF),OR,                                    *
               (RS,LT,DCTSLPF)),'SET DISPGRD+DISPLTD'
*
* Return to the caller
*
         CLEAR RVR                     Good return code
*        EXIT  DEMOTE                  Return to caller
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* DISPSIOC --  This routine is called by the real storage       *
*              manager when a swap that has been requested is   *
*              finished.  An AS based suspension is lifed and   *
*              the ASDB is awakend if possible.                 *
*                                                               *
*   Input  --  @DISPSIOC                                        *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPSIOC PROC  @DISPSIOC,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RX,PSADCT               Get the DCT pointer
         WITH  (DCT,RX)
         L     RY,@DSIOASB             Get the ASB pointer
         WITH  (ASB,RY),'L RY,ASBASDB' Get the ASDB pointer
         IF    (@RY,NE,'ASDB'),'ABORT BADASDB'
         WITH  (ASDB,RY)
*
* If Swapout, update the count of pages in swap out
*
         IF    ASDBSOIP,BEGIN          Swap out in progress
         CLEAR ASDBSOIP                But its done now
         L     RS,DCTSWOUT             Count of outgoing
         LOOP  BEGIN
         LR    RA,RS                   Copy the count
         S     RA,ASDBPAGN             Less the value of this
         CS    RS,RA,DCTSWOUT          Update the count
         UNTIL Z,END
         END   ,
*
* Remove a suspension from the ASDB
*
         L     RA,ASDBSUSP             Get the current value
         LOOP  BEGIN
         LR    RS,RA                   Copy the current value
         SH    RS,=Y(1)
         IF    NEG,'CLEAR RS'          not less than zero
         CS    RA,RS,ASDBSUSP          Update the suspend count
         UNTIL Z,END
         IF    (RS,Z),BEGIN            This AS is ready to go
         PSET  @ASWAKE,CLEAR=NO
         ST    RY,@ASWASDB             Save the ASDB address
         ACALL ASWAKE                  Wake up the ASDB
         END   ,
*
* See if this changed the paging situation
*
         L     RS,PZMATP               Get the mat pointer
         WITH  (MAT,RS),BEGIN
         L     R15,MATPAGFN            Paging function value
         IF    ((R15,GE,DCTSHPF),OR,                                   *
               (R15,LT,DCTSLPF)),'SET DISPGRD+DISPLTD'
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* DISPPIOC --  This routine is called by the real storage       *
*              manager when a page fault has been resolved.  It *
*              makes the AS swapable, removes a suspension and  *
*              wakes up the ASDB (if possible).                 *
*                                                               *
*   Input  --  @DISPPIOC                                        *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPPIOC PROC  @DISPPIOC,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,@DPIOASB             Get the ASB pointer
         WITH  (ASB,RY),'L RY,ASBASDB' Get the ASDB pointer
         IF    (@RY,NE,'ASDB'),'ABORT BADASDB'
         WITH  (ASDB,RY)
         IF    ^ASDBPFLT,'ABORT NOPFLT'
         CLEAR ASDBPFLT,MODE=LOCKED,REF=ASDB,REGS=(EPAR,RA,RS)
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         LKOB  DCTLOCK                 Get the dispatcher lock
*
* Remove a suspension from the ASDB
*
         L     RA,ASDBSUSP             Get the current value
         LOOP  BEGIN
         LR    RS,RA                   Copy the current value
         SH    RS,=Y(1)
         IF    NEG,'CLEAR RS'          not less than zero
         CS    RA,RS,ASDBSUSP          Update the suspend count
         UNTIL Z,END
*
* Remove a swap hold from the ASDB
*
         L     RA,ASDBSHCT             Get the swap hold count
         LOOP  BEGIN
         LR    RS,RA                   Copy the count value
         SH    RS,=Y(1)                Decrement the count
         IF    NEG,'ABORT SWAPHREL'    Not too far though
         CS    RA,RS,ASDBSHCT          Update the count
         UNTIL Z,END                   Release one swap hold
*
* See if it needs to be swapped out
*
PIOCLK   IF    ('LT  R15,ASDBQADD',NZ),BEGIN    Not active other CPU
         LH    RA,ASDBSPRI             Get the dispatching prio
         IF    ((RS,Z),AND,(RA,LE,DCTSWPRI)),BEGIN
         PSET  @DEMOTE,CLEAR=NO
         ST    RY,@DEMASDB             Which one
         ACALL DEMOTE                  Move this one out
         IF    (RVR,Z),EXIT,PIOCLK     If done, ignore the rest
         END   ,
*
* If it should not, or could not be swapped out, we wake it up
*
         IF    ('LT RS,ASDBSUSP',Z),BEGIN
         PSET  @ASWAKE,CLEAR=NO
         ST    RY,@ASWASDB             Save the ASDB address
         ACALL ASWAKE                  Wake up the ASDB
         END   ,
         END   ,
         LKREL DCTLOCK                 Free up the lock
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Global Control Block Allocation/Deallocation'
*****************************************************************
*                                                               *
*  NEWASDB --  This routine obtains a new ASDB.  It first       *
*              looks to see if there are any free.  If not it   *
*              will allocate a new one.                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains a pointer to the new ASDB           *
*                                                               *
*****************************************************************
         SPACE 2
NEWASDB  PROC  SCOPE=LOCAL
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Look for a pre-existing one
*
         LM    RA,RB,DCTFASDB          Get free queue info
         WITH  (ASDB,RA)
         LOOP  BEGIN
         IF    (RA,Z),EXIT             No free ones left
         L     RJ,ASDBNEXT             Get pointer to the next one
         LR    RK,RB                   Copy the control word
         CDS   RA,RJ,DCTFASDB          Remove it from the queue
         UNTIL Z,END                   Keep on trying
*
* We've got one if any were to be had
*
         IF    (RA,Z),BEGIN            None were to be had
         VMGET L'ASDB,LOC=GLOBHI,FIX=YES ,SP=01  Get a new one
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR                  Copy the Address
         END   ,
*
* Now format it
*
         CLEAR ASDB                    Clear it to zero
         MVC   ASDB(4),=C'ASDB'        Move in the ID
         LR    RVR,RA                  Copy the Location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  DELASDB --  This routine frees an ASDB.  It queues it to the *
*              DCT.                                             *
*                                                               *
*   Input  --  @GCBDEL                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@GCBDEL  RECORD BEGIN        Free a global control block
@GCBDLOC DS    A             Address of the control block being freed
         END   ,
         SPACE 2
DELASDB  PROC  @GCBDEL,SCOPE=LOCAL
*
* Verify the control block ID
*
         L     RJ,@GCBDLOC             Get the ASDB address
         WITH  (ASDB,RJ)
         IF    (ASDB,NE,'ASDB'),'ABORT FREEASDB'
         CLEAR ASDB
         MVC   ASDB(4),=C'asdb'        Free ID
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Add the control block to the queue
*
         LM    RA,RB,DCTFASDB          Get current top,control
         LOOP  BEGIN
         ST    RA,ASDBNEXT             Make ours point at theirs
         LA    RK,@RB+1                Copy and update the control
         CDS   RA,RJ,DCTFASDB          Update the values
         UNTIL Z,END                   Keep on trucking
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  NEWGTDB --  This routine obtains a new Global TDB. First it  *
*              looks to see if there are any free.  If not it   *
*              will allocate a new one.                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains a pointer to the new TDB            *
*                                                               *
*****************************************************************
         SPACE 2
NEWGTDB  PROC  SCOPE=LOCAL
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Look for a pre-existing one
*
         LM    RA,RB,DCTFTDB           Get free queue info
         WITH  (TDB,RA)
         LOOP  BEGIN
         IF    (RA,Z),EXIT             No free ones left
         L     RJ,TDBNEXT              Get pointer to the next one
         LR    RK,RB                   Copy the control word
         CDS   RA,RJ,DCTFTDB           Remove it from the queue
         UNTIL Z,END                   Keep on trying
*
* We've got one if any were to be had
*
         IF    (RA,Z),BEGIN            None were to be had
         VMGET L'TDB,LOC=GLOBHI,FIX=YES ,SP=01   Get a new one
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR                  Copy the Address
         END   ,
*
* Now format it
*
         CLEAR TDB                     Clear it to zero
         MVC   TDB(4),=C'TDB '         Move in the ID
         LR    RVR,RA                  Copy the Location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  DELGTDB --  This routine frees a global TDB. It queues it    *
*              off the DCT.                                     *
*                                                               *
*   Input  --  @GCBDEL                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DELGTDB  PROC  @GCBDEL,SCOPE=LOCAL
*
* Verify the control block ID
*
         L     RJ,@GCBDLOC             Get the ASDB address
         WITH  (TDB,RJ)
         IF    (TDB,NE,'TDB '),'ABORT FREEGTDB'
         CLEAR TDB
         MVC   TDB(4),=C'gtdb'         Free ID
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Add the control block to the queue
*
         LM    RA,RB,DCTFTDB           Get current top,control
         LOOP  BEGIN
         ST    RA,TDBNEXT              Make ours point at theirs
         LA    RK,@RB+1                Copy and update the control
         CDS   RA,RJ,DCTFTDB           Update the values
         UNTIL Z,END                   Keep on trucking
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   NEWASB --  This routine obtains a new ASB.  It first        *
*              looks to see if there are any free.  If not it   *
*              will allocate a new one.                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains a pointer to the new ASB            *
*                                                               *
*****************************************************************
         SPACE 2
NEWASB   PROC  SCOPE=LOCAL
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Look for a pre-existing one
*
         LM    RA,RB,DCTFASB           Get free queue info
         WITH  (ASB,RA)
         LOOP  BEGIN
         IF    (RA,Z),EXIT             No free ones left
         L     RJ,ASBNEXT              Get pointer to the next one
         LR    RK,RB                   Copy the control word
         CDS   RA,RJ,DCTFASB           Remove it from the queue
         UNTIL Z,END                   Keep on trying
*
* We've got one if any were to be had
*
         IF    (RA,Z),BEGIN            None were to be had
         VMGET L'ASB,LOC=GLOBHI,FIX=YES ,SP=01   Get a new one
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR                  Copy the Address
         END   ,
*
* Now format it
*
         CLEAR ASB                     Clear it to zero
         MVC   ASB(4),=C'ASB '         Move in the ID
         LR    RVR,RA                  Copy the Location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   DELASB --  This routine frees an ASB.   It queues it to the *
*              DCT.                                             *
*                                                               *
*   Input  --  @GCBDEL                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DELASB   PROC  @GCBDEL,SCOPE=LOCAL
*
* Verify the control block ID
*
         L     RJ,@GCBDLOC             Get the ASDB address
         WITH  (ASB,RJ)
         IF    (ASB,NE,'ASB '),'ABORT FREEASB'
         CLEAR ASB
         MVC   ASB(4),=C'asb '         Free ID
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Add the control block to the queue
*
         LM    RA,RB,DCTFASB           Get current top,control
         LOOP  BEGIN
         ST    RA,ASBNEXT              Make ours point at theirs
         LA    RK,@RB+1                Copy and update the control
         CDS   RA,RJ,DCTFASB           Update the values
         UNTIL Z,END                   Keep on trucking
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  NEWRTCQ --  This routine obtains a new RTCQ. If first        *
*              looks to see if there are any free.  If not it   *
*              will allocate a new one.                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains a pointer to the new RTCQ           *
*                                                               *
*****************************************************************
         SPACE 2
NEWRTCQ  PROC  SCOPE=LOCAL
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Look for a pre-existing one
*
         LM    RA,RB,DCTFRTCQ          Get free queue info
         WITH  (RTCQ,RA)
         LOOP  BEGIN
         IF    (RA,Z),EXIT             No free ones left
         L     RJ,RTCQNEXT             Get pointer to the next one
         LR    RK,RB                   Copy the control word
         CDS   RA,RJ,DCTFRTCQ          Remove it from the queue
         UNTIL Z,END                   Keep on trying
*
* We've got one if any were to be had
*
         IF    (RA,Z),BEGIN            None were to be had
         VMGET L'RTCQ,LOC=GLOBHI,FIX=YES ,SP=01  Get a new one
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR                  Copy the Address
         END   ,
*
* Now format it
*
         CLEAR RTCQ                    Clear it to zero
         MVC   RTCQ(4),=C'RTCQ'        Move in the ID
         LR    RVR,RA                  Copy the Location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  DELRTCQ --  This routine frees an RTCQ.  It queues it to the *
*              DCT.                                             *
*                                                               *
*   Input  --  @GCBDEL                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DELRTCQ  PROC  @GCBDEL,SCOPE=LOCAL
*
* Verify the control block ID
*
         L     RJ,@GCBDLOC             Get the ASDB address
         WITH  (RTCQ,RJ)
         IF    (RTCQ,NE,'RTCQ'),'ABORT FREERTCQ'
         CLEAR RTCQ
         MVC   RTCQ(4),=C'rtcq'         Free ID
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Add the control block to the queue
*
         LM    RA,RB,DCTFRTCQ          Get current top,control
         LOOP  BEGIN
         ST    RA,RTCQNEXT             Make ours point at theirs
         LA    RK,@RB+1                Copy and update the control
         CDS   RA,RJ,DCTFRTCQ          Update the values
         UNTIL Z,END                   Keep on trucking
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*    GGSTK --  This routine gets a new global fixed stack.  It  *
*              first checks the DCT to see if there is one      *
*              already that can be used.  If not, it allocates  *
*              another one.                                     *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains a pointer to the new stack.         *
*                                                               *
*****************************************************************
         SPACE 2
GGSTK    PROC  SCOPE=LOCAL
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Look for a pre-existing one
*
         LM    RA,RB,DCTFSTK           Get free queue info
         LOOP  BEGIN
         IF    (RA,Z),EXIT             No free ones left
         L     RJ,@RA                  Get pointer to the next one
         LR    RK,RB                   Copy the control word
         CDS   RA,RJ,DCTFSTK           Remove it from the queue
         UNTIL Z,END                   Keep on trying
*
* We've got one if any were to be had
*
         IF    (RA,Z),BEGIN            None were to be had
         VMGET STKSIZE,LOC=GLOBHI,FIX=YES ,SP=01 Get a new one
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR                  Copy the Address
         END   ,
*
* Now format it
*
         ZOT   @RA,STKSIZE             Clear it to zero
         MVC   @RA+4(4),=C'GSTK'       A bit of an ID
         LR    RVR,RA                  Copy the Location
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*    FGSTK --  This routine frees a global stack obtained with  *
*              GGSTK.  It just queues it up to the DCT.         *
*                                                               *
*   Input  --  @GCBDEL                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
FGSTK    PROC  @GCBDEL,SCOPE=LOCAL
*
* Verify the control block ID
*
         L     RJ,@GCBDLOC             Get the stack address
         IF    (@RJ+4,NE,'GSTK'),'ABORT FREEGSTK'
         ZOT   @RJ,STKSIZE             Clear it
         MVC   @RJ+4(4),=C'gstk'       Different ID
*
* Find the DCT
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
*
* Add the stack to the queue
*
         LM    RA,RB,DCTFSTK           Get current top,control
         LOOP  BEGIN
         ST    RA,@RJ                  Make ours point at theirs
         LA    RK,@RB+1                Copy and update the control
         CDS   RA,RJ,DCTFSTK           Update the values
         UNTIL Z,END                   Keep on trucking
         PEND  ,
         EJECT ,
         LTORG
         TITLE 'Priority Queue Management'
*****************************************************************
*                                                               *
*   PQADD  --  This routine adds an ASDB to the priority queue  *
*              whose header is passed.  It puts the ASDB after  *
*              those ASDBs in the queue that have the same      *
*              priority.                                        *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PQPARM   RECORD BEGIN
PQASDB   DS    A             ASDB value
PQQUEUE  DS    A             Address of the header for the queue
         END   ,
         SPACE 2
PQADD    PROC  PQPARM,SCOPE=LOCAL
         L     RY,PQASDB               Addr of ASDB to add
         WITH  (ASDB,RY)
*
* Determine the queue level on which this ASDB will go.
*
         LH    RA,ASDBSPRI             Get the priority
         SLL   RA,3                    Multiply by 8
         A     RA,PQQUEUE              Address of Header/trailer
*
* Add it to the end of the queue at this level
*
         LT    RJ,@RA+4                Get the tail pointer
         IF    Z,BEGIN                 If no one else in the queue
         ST    RY,@RA                  Point the header here
         ST    RY,@RA+4                And the tail as well
         CLEAR (ASDBNEXT,8)            Then clear the pointers
         END   ELSE,BEGIN              At least one in the queue
         CLEAR ASDBNEXT
         ST    RJ,ASDBPREV             Update the previous pointer
         ST    RY,ASDBNEXT-ASDB(,RJ)   Update previous to point here
         ST    RY,@RA+4                Then update tail pointer
         END   ,
         MVC   ASDBQADD,PQQUEUE        Move in the queue address
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   PQDEL  --  This routine removes an ASDB from the priority   *
*              queue, the address of whose header is passed.    *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PQDEL    PROC  PQPARM,SCOPE=LOCAL
         L     RY,PQASDB               Addr of ASDB to add
         WITH  (ASDB,RY)
*
* Determine the queue level on which this ASDB will go.
*
         LH    RA,ASDBSPRI             Get the priority
         SLL   RA,3                    Multiply by 8
         A     RA,PQQUEUE              Address of Header/trailer
         IF    (PQQUEUE,NE,ASDBQADD),'ABORT BADREM'
*
* Delete it from this queue
*
         LT    RJ,ASDBPREV             Address of the previous
         IF    Z,BEGIN                 None before it
         MVC   @RA(4),ASDBNEXT         Update the head pointer
         END   ELSE,BEGIN
         MVC   ASDBNEXT-ASDB(4,RJ),ASDBNEXT      Update prev ASDB
         END   ,
         LT    RK,ASDBNEXT             Address of the next
         IF    Z,BEGIN
         ST    RJ,@RA+4                Update the tail pointer
         END   ELSE,BEGIN
         ST    RJ,ASDBPREV-ASDB(,RK)   Update next ASDB
         END   ,
         CLEAR ASDBQADD                Not on any queue now
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   PQREQ  --  This routine adds an ASDB to the priority queue  *
*              whose header is passed.  It puts the ASDB before *
*              those ASDBs in the queue that have the same      *
*              priority.                                        *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PQREQ    PROC  PQPARM,SCOPE=LOCAL
         L     RY,PQASDB               Addr of ASDB to add
         WITH  (ASDB,RY)
*
* Determine the queue level on which this ASDB will go.
*
         LH    RA,ASDBSPRI             Get the priority
         SLL   RA,3                    Multiply by 8
         A     RA,PQQUEUE              Address of Header/trailer
*
* Add it to the head of the queue at this level
*
         LT    RJ,@RA                  Get the head pointer
         IF    Z,BEGIN                 If no one else in the queue
         ST    RY,@RA                  Point the header here
         ST    RY,@RA+4                And the tail as well
         CLEAR (ASDBNEXT,8)            Then clear the pointers
         END   ELSE,BEGIN              At least one in the queue
         CLEAR ASDBPREV
         ST    RJ,ASDBNEXT             Update the next pointer
         ST    RY,ASDBPREV-ASDB(,RJ)   Update next to point here
         ST    RY,@RA                  Then update tail pointer
         END   ,
         MVC   ASDBQADD,PQQUEUE        Its on this queue now
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  PQHIGH  --  This routine removes the highest priority ASDB   *
*              from the priority queue whose header is passed.  *
*              It returns the address of the ASDB in RVR.  If   *
*              there are no ASDBs in the queue then a zero is   *
*              returned.                                        *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  RVR contains the Address of the ASDB or 0.       *
*                                                               *
*****************************************************************
         SPACE 2
PQHIGH   PROC  PQPARM,SCOPE=LOCAL
         CLEAR RVR
         L     RA,PQQUEUE              Start of the queues
         LH    RB,=H'-8'               Comparand/index
         LA    RS,8*(NUMPRIO-1)        Last one in queue
PQHLP1   LABEL ,
         IF    (RVR,NE,@RA(RS)),PQHFND Found a non-empty queue
         BXH   RS,RB,PQHLP1            Loop through the blocks
         EXIT  PQHIGH                  None found
*
* We found a queue with some object in it.  We have to remove the
* object.
*
PQHFND   L     RY,@RA(RS)              Get the ASDB address
         WITH  (ASDB,RY)
         LT    RJ,ASDBNEXT             Get the next pointer
         IF    Z,BEGIN                 None before it
         ST    RVR,@RA+4(RS)           Clear the tail pointer
         END   ELSE,BEGIN
         ST    RVR,ASDBPREV-ASDB(,RJ)  Clear prev pointer
         END   ,
         ST    RJ,@RA(RS)              Make the head point at next
         CLEAR ASDBQADD                Not on the queue now
         LR    RVR,RY                  Load the return value
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   PQLOW  --  This routine removes the lowest priority ASDB    *
*              from the priority queue whose header address     *
*              is passed.  If there are no ASDBs in the queue   *
*              a zero is returned.                              *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  RVR contains the address of the ASDB or 0.       *
*                                                               *
*****************************************************************
         SPACE 2
PQLOW    PROC  PQPARM,SCOPE=LOCAL
         CLEAR RVR
         L     RA,PQQUEUE              Get the queue start
         LR    RS,RVR                  Get initial value
         LA    RJ,8                    Get increment
         LA    RK,8*(NUMPRIO-1)        Get comparand
PQLLP1   LABEL ,
         IF    (RVR,NE,@RA(RS)),PQLFND This queue isn't empty
         BXLE  RS,RJ,PQLLP1            Look through all the queues
         EXIT  PQLOW                   return 0 if none found
*
* We found a queue with some object in it.  We have to remove the
* object.
*
PQLFND   L     RY,@RA+4(RS)            Get the ASDB address
         WITH  (ASDB,RY)
         LT    RJ,ASDBPREV             Get the prev pointer
         IF    Z,BEGIN                 None before it
         ST    RVR,@RA(RS)             Clear the head pointer
         END   ELSE,BEGIN
         ST    RVR,ASDBNEXT-ASDB(,RJ)  Clear next pointer
         END   ,
         ST    RJ,@RA+4(RS)            Make the tail point at prev
         CLEAR ASDBQADD                Not on the queue now
         LR    RVR,RY                  Load the return value
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  PQPRIO  --  This routine returns the priority of the highest *
*              priority ASDB in the queue.  If there are no     *
*              ASDBs in the queue the lowest priority possible  *
*              will be returned.                                *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  RVR contains prio of highest prio ASDB           *
*                                                               *
*****************************************************************
         SPACE 2
PQPRIO   PROC  PQPARM,SCOPE=LOCAL
         CLEAR RJ
         L     RVR,=F'-1'              Default return
         L     RA,PQQUEUE              Start of the queues
         LH    RB,=H'-8'               Comparand/index
         LA    RS,8*(NUMPRIO-1)        Last one in queue
PQPLP1   LABEL ,
         IF    (RJ,NE,@RA(RS)),PQPFND  Found a non-empty queue
         BXH   RS,RB,PQPLP1            Loop through the blocks
         EXIT  PQPRIO                  None found
*
* We found a queue with some object in it.  We have to return the
* priority.
*
PQPFND   L     RY,@RA(RS)              Get the ASDB address
         WITH  (ASDB,RY)
         LH    RVR,ASDBSPRI            Get the priority
         PEND  ,                       Return it to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  PQHPFN  --  This routine returns the paging function of the  *
*              highest prio ASDB in the queue.  If there is no  *
*              ASDB in the queue, the highest paging function   *
*              number possible will be returned.                *
*                                                               *
*              THE DISPATCH LOCK MUST BE HELD!!!                *
*                                                               *
*   Input  --  PQPARM                                           *
*                                                               *
*  Output  --  RVR contains PFN of highest prio ASDB            *
*                                                               *
*****************************************************************
         SPACE 2
PQHPFN   PROC  PQPARM,SCOPE=LOCAL
         CLEAR RJ
         L     RVR,=X'7FFFFFFF'        Default return
         L     RA,PQQUEUE              Start of the queues
         LH    RB,=H'-8'               Comparand/index
         LA    RS,8*(NUMPRIO-1)        Last one in queue
PQPFLP1  LABEL ,
         IF    (RJ,NE,@RA(RS)),PQPFFND Found a non-empty queue
         IF    (RJ,NE,@RA+4(RS)),'ABORT BADQ'
         BXH   RS,RB,PQPFLP1           Loop through the blocks
         EXIT  PQHPFN                  None found
*
* We found a queue with some object in it.  We have to return the
* paging function number.
*
PQPFFND  L     RY,@RA(RS)              Get the ASDB address
         IF    (RJ,EQ,@RA+4(RS)),'ABORT BADQ'
         WITH  (ASDB,RY)
         L     RVR,ASDBPAGN            Get the paging number
         PEND  ,                       Return it to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  TSKADD  --  This routine adds the passed TDB onto the ready  *
*              queue of the current ASDB after all TDBs of      *
*              equal or higher priority.                        *
*                                                               *
*              The ASDB lock must be held or the CPU disabled.  *
*                                                               *
*   Input  --  TQPARM                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TQPARM   RECORD BEGIN
TQPTDB   DS    A             Address of the TDB to be added/requeued
         END   ,
         SPACE 2
TSKADD   PROC  TQPARM,SCOPE=LOCAL
*
* Get the ASDB pointer
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,TQPTDB               Get te new TDB pointer
         WITH  (TDB,RX)
*
* If it is already active, we're in bad shape.
*
         IF    TDBFACT,'ABORT TDBACT2' Already on the list
         SET   TDBFACT                 Mark it on the list
*
* Search the queue for what we want
*
         LA    RA,ASDBATDB             RA points at prev pointer
         WHILE ('LT RB,@RA',NZ),BEGIN  Until we get to the end
         WITH  (TDB,RB),LABEL=NXT      Identify the TDBs
         IF    (NXT.TDBPRIO,LT,TDBPRIO),EXIT     Found the spot
         LA    RA,NXT.TDBNEXT           Update the pointers
         END   ,
*
* We have the spot now.
*
         ST    RB,TDBNEXT              Update this one
         ST    RX,@RA                  Update previous pointer
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  TSKREQ  --  This routine adds the passed TDB onto the ready  *
*              queue of the current ASDB after all TDBs of      *
*              higher priority.                                 *
*                                                               *
*              The ASDB lock must be held or the CPU disabled.  *
*                                                               *
*   Input  --  TQPARM                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TSKREQ   PROC  TQPARM,SCOPE=LOCAL
*
* Get the ASDB pointer
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,TQPTDB               Get te new TDB pointer
         WITH  (TDB,RX)
*
* If it is already active, we're in bad shape
*
         IF    TDBFACT,'ABORT TDBACT2' Already on the list
         SET   TDBFACT                 Mark it on the list
*
* Search the queue for what we want
*
         LA    RA,ASDBATDB             RA points at prev pointer
         WHILE ('LT RB,@RA',NZ),BEGIN  Until we get to the end
         WITH  (TDB,RB),LABEL=NXT      Identify the TDBs
         IF    (NXT.TDBPRIO,LE,TDBPRIO),EXIT     Found the spot
         LA    RA,NXT.TDBNEXT          Update the pointers
         END   ,
*
* We have the spot now.
*
         ST    RB,TDBNEXT              Update this one
         ST    RX,@RA                  Update previous pointer
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Exit Routine handling and Exits'
*****************************************************************
*                                                               *
*  EXRADD  --  This routine is called to specify a new exit     *
*              routine.  It allocates an ESB and queues it off  *
*              the TDB.  It can't be called from the dispatcher *
*              stack for obvious reasons.                       *
*                                                               *
*   Input  --  @EXRADD                                          *
*                                                               *
*  Output  --  RVR contains an exit routine ID. (ESB addr)      *
*                                                               *
*****************************************************************
         SPACE 2
EXRADD   PROC  @EXRADD,SCOPE=GLOBAL
*
* Get the current control block pointers
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Get a new ESB.  First try to get one from the pool.
*
         ACALL ASLOCK                  Lock up the address space
         LT    RN,ASDBFESB             Get a free one
         IF    NZ,BEGIN
         WITH  (ESB,RN),'MVC ASDBFESB,ESBNEXT'   Remove it
         END   ELSE,BEGIN              No free ones, get another.
         VMGET L'ESB,LOC=LOCSYS,FIX=YES   Get the memory for it
         LR    RN,RVR                  Copy the address
         END   ,
         ACALL ASULOCK                 Unlock the address space
         WITH  (ESB,RN)
*
* Fill it in
*
         CLEAR ESB
         MVC   ESB(4),=C'ESB '         Move in the control block id
         ST    RX,ESBTDB               Save the TDB info
         MVC   ESBTYPE,@EXRTYPE        Save the type bitmap
         MVC   ESBPSW,@EXRPSW          New PSW
         MVC   ESBPARM,@EXRPARM        Exit routine parameter
         IF    @EXRAFQ,BEGIN           Exit is qualified
         SET   ESBFQUAL                Mark it as qualified
         MVC   ESBQUAL,@EXRQUAL        Move in the qualifier
         END   ,
         IF    @EXRAFS,BEGIN           Needs a stack
         SET   ESBFSTK
         ACALL STKNEW                  Get a stack
         ST    RVR,ESBSTACK            Save the address of it
         END   ,
*
* Queue it off the TDB
*
         MVC   ESBNEXT,TDBESBS         Move in the queue list
         ST    RN,TDBESBS              And point the head at this
*
* Return the 'ID' to the caller
*
         LR    RVR,RN                  Address of the ESB
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  EXRDEL  --  This routine is called to remove an exit         *
*              routine.  It makes sure the ESB is not behind a  *
*              fence and then frees it.                         *
*                                                               *
*   Input  --  @EXRDEL                                          *
*                                                               *
*  Output  --  RVR  = 0 if the ESB was removed                  *
*              RVR ^= 0 if the ESB could not be removed         *
*                                                               *
*****************************************************************
         SPACE 2
EXRDEL   PROC  @EXRDEL,SCOPE=GLOBAL
*
* First get the local control blocks
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Start down the ESB queue looking for the one passed
*
         LA    RA,TDBESBS              Address of first pointer
         WHILE ('LT RB,@RA',NZ),BEGIN  Look to the end
         WITH  (ESB,RB)                Address this pointer
*
* If the Fence is turned on we don't look at this one or any
* farther down in the list.
*
         IF    ESBFENCE,BEGIN
         LA    RVR,8                   Behind a fence
         EXIT  EXRDEL                  All fenced in
         END   ,
*
* If we have found the one to be deleted we remove it from the
* list and free the storage
*
         IF    (RB,EQ,@EXRDID),BEGIN
         MVC   @RA(4),ESBNEXT          Remove it from the list
         MVI   ESB+3,C'*'              Make it invalid
         IF    ESBFSTK,BEGIN
         PSET  @STKDEL,CLEAR=NO
         MVC   @STKDLOC,ESBSTACK       Location of the stack
         ACALL STKDEL                  Remove the stack
         END   ,
         ACALL ASLOCK                  Lock up the address space
         MVC   ESBNEXT,ASDBFESB        Point this at the queue
         ST    RB,ASDBFESB             And the queue at this
         ACALL ASULOCK                 Unlock the address space
         CLEAR RVR
         EXIT  EXRDEL                  All done
         END   ,
*
* Get to the next one
*
         LA    RA,ESBNEXT              Point at the next pointer
         END   ,
         LA    RVR,4                   Not found
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
* EXRDELA  --  This routine removes all the exit routine        *
*              definitions up to the fence.                     *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
EXRDELA  PROC  SCOPE=GLOBAL
*
* First get the local control blocks
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Start down the ESB queue, deleting as we go
*
         L     RB,TDBESBS              Get the first ESB
         WHILE (RB,NZ),BEGIN
         WITH  (ESB,RB)
         IF    ESBFENCE,EXIT           All done at the fence
         L     RA,ESBNEXT              Address of the next one
         ST    RA,TDBESBS              Remove it from the queue
         VMFREE L'ESB,A=(RB),LOC=LOCSYS,FIX=YES
         LR    RB,RA                   Get to the next
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* EXRFENCE --  This routine puts up a fence preventing the top  *
*              exit routine definition and all previous ones    *
*              from being modified.                             *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
EXRFENCE PROC  SCOPE=GLOBAL
*
* First get the local control blocks
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Find the first ESB and mark it fenced
*
         LT    RA,TDBESBS              Get the first
         IF    NZ,BEGIN                If there is one
         WITH  (ESB,RA)
         SET   ESBFENCE                Fence it in
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* EXRFDOWN --  This routine takes down a fence on the current   *
*              exit routine definition.                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR  = 0, Fence removed.                         *
*              RVR ^= 0, No fence at the top ESB.               *
*                                                               *
*****************************************************************
         SPACE 2
EXRFDOWN PROC  SCOPE=GLOBAL
*
* First get the local control blocks
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Find the first ESB and mark it unfenced
*
         LA    RVR,4                   Expect a bad return
         LT    RA,TDBESBS              Get the first ESB
         IF    NZ,BEGIN                If there is one
         WITH  (ESB,RA)
         IF    ESBFENCE,BEGIN
         CLEAR RVR                     Good return
         CLEAR ESBFENCE                Dont fence me in
         END   ,
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  XITNEW  --  This routine allocates a new ERB and returns     *
*              an ID of that exit request to the caller.  The   *
*              ERB is also chained off the ASDB so we can keep  *
*              track of them.                                   *
*                                                               *
*   Input  --  @XITNEW                                          *
*                                                               *
*  Output  --  RVR contains the Exit request ID                 *
*                                                               *
*****************************************************************
         SPACE 2
XITNEW   PROC  @XITNEW,SCOPE=GLOBAL
*
* Find out where we are
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
*
* Allocate a new ERB. First try the free pool.
*
         ACALL ASLOCK                  Lock up the address space
         LT    RN,ASDBFERB             Head of the free queue
         IF    NZ,BEGIN
         WITH  (ERB,RN),'MVC ASDBFERB,ERBNEXT'   De-queue it
         END   ELSE,BEGIN              If no-free ones
         VMGET L'ERB,LOC=LOCSYS,FIX=YES          Get a new one
         LR    RN,RVR                  Copy the address
         END   ,
         WITH  (ERB,RN)
*
* Fill in the ERB (that which needs to be done now)
*
         CLEAR ERB
         MVC   ERB(4),=C'ERB '         Move in the control block ID
         ST    RY,ERBASDB              ASDB address
*
* Queue it up on the ASDB
*
         MVC   ERBCHN,ASDBERBS         Point this at the queue
         ST    RN,ASDBERBS             And the chain at this
         ACALL ASULOCK                 Unlock the address space
*
* Return the 'ID'
*
         LR    RVR,RN                  Address of the ERB
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  XITDEL  --  This routine is called to delete a previously    *
*              allocated ERB.  It makes sure the ERB is chained *
*              off the ASDB and then frees it.                  *
*                                                               *
*   Input  --  @XITDEL                                          *
*                                                               *
*  Output  --  RVR  = 0 if the ERB was removed                  *
*              RVR ^= 0 if the ERB could not be removed         *
*                                                               *
*****************************************************************
         SPACE 2
XITDEL   PROC  @XITDEL,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
*
* Make sure that the ID points at an ERB
*
         L     RN,@XITDID              ID of the one to go
         IF    (@RN,NE,'ERB '),BEGIN   Not a valid ERB
         LA    RVR,4
         EXIT  XITDEL
         END   ,
         WITH  (ERB,RB)
*
* Scan to find the one we want
*
         ACALL ASLOCK                  Lock up the address space
         LA    RA,ASDBERBS             Address of the pointer
XDSRCH   WHILE ('LT RB,@RA',NZ),BEGIN  Loop to the end
*
* When we find it, we remove it from the list and free it
* (if possible).
*
         IF    (RB,EQ,RN),BEGIN        This is the one
         MVC   @RA(4),ERBCHN           Remove it from the chain
         CLEAR ERBCHN                  And clear the chain pointer
         IF    ^ERBSFREE,BEGIN         We can't delete it now
         SET   ERBFDEL                 Mark it as deletion desired
         END   ELSE,BEGIN
         MVI   ERB+3,C'*'              Blitz the ID
         MVC   ERBNEXT,ASDBFERB        Point this at the list
         ST    RN,ASDBFERB             And the list at this
         END   ,
         ACALL ASULOCK                 Unlock the address space
         CLEAR RVR
         EXIT  XITDEL
         END   ,
*
* Update the search pointers
*
         LA    RA,ERBCHN               Address of the next one
         END   ,                       end of the search
*
* It was not found on the list...bad return
*
         ACALL ASULOCK                 Unlock the address space
         LA    RVR,4                   Return code for not found
         PEND  ,                       Return to the user
         EJECT ,
*****************************************************************
*                                                               *
*   XITDO  --  This routine is called to schedule an exit.  The *
*              ERB must have been allocated previously and its  *
*              id is passed in.                                 *
*                                                               *
*   Input  --  @XITDO                                           *
*                                                               *
*  Output  --  RVR  = 0 if the Exit was scheduled.              *
*              RVR ^= 0 if the Exit could not be scheduled.     *
*                                                               *
*****************************************************************
         SPACE 2
XITDO    PROC  @XITDO,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              get the current ASDB pointer
         WITH  (ASDB,RY)
*
* Validate and fill in the ERB passed
*
         DISABLE ,                     Make us the only one to run
XDLCK    BEGIN                         Block of the locked up code
         LA    RM,4                    Assume a bad return
         L     RN,@XITRQID
         IF    (@RN,NE,'ERB '),EXIT    Bad ID
         WITH  (ERB,RN)
         IF    (RY,NE,ERBASDB),EXIT    It's not ours
         L     RX,@XITTSK              Get the Task ID
         IF    (@RX,NE,'TDB '),EXIT    If it's not a task
         WITH  (TDB,RX)
         LC    RS,@XITTYPE             Get the exit type
         IF    (RS,GT,31),EXIT         Bad type
*
* We know we're going to take it now.  Reserve the ERB.
*
         IF    ^ERBSFREE,EXIT          The ERB isn't free, bug out
         SET   ERBSPEND                Exit is now pending
*
* Fill in the exit type
*
         STC   RS,ERBTYPE              Save the numerical type
         L     RVR,=X'80000000'        Exit zero
         SRL   RVR,@RS                 Get the mask for the exit
         ST    RVR,ERBMTYPE            Save it
         OC    TDBXRMAP,ERBMTYPE       Indicate it is waiting
*
* And the rest of the info
*
         MVC   ERBQUAL,@XITQUAL        Qualifier
         MVC   ERBPARM(16),@XITPARM    Move in the parameter
         ST    RX,ERBTDB               TDB where this is queued
*
* All filled in.  Now it must be queued off the TDB
*
         IF    ERBMTYPE.XITMPI+XITMSVC+XITMPER+XITMMON+XITMLGO,BEGIN
         MVC   ERBNEXT,TDBERBS
         ST    RN,TDBERBS              Put this at the front
         END
*
*  Asynchronous exits are queued at the end of the queue
*
         ELSE  BEGIN
         CLEAR ERBNEXT                 This is the end of the chain
         LA    RB,TDBERBS-(ERBNEXT-ERB)
         WITH  (ERB,RB)
         WHILE ('LT  RS,ERBNEXT',NZ),'L  RB,ERBNEXT'  Get last one
         ST    RN,ERBNEXT              Put this one at the end
         END
*
* See if the exit situation has changed to where something must
* be done.  If the exit mask will allow an exit to take effect, we
* have to set it up so that will take place.  If the TDB is currently
* suspended, we put in on the ready queue so the dispatcher will
* schedule the exit.  Since a new task has become ready, we call the
* dispatcher to insure that the highest priority task in the AS is
* running.  If the TDB is the current TDB, we also have to call the
* dispatcher to let the exit be scheduled.
*
         L     RS,TDBEMASK             Get the Exit mask
         N     RS,TDBXRMAP
         IF    NZ,BEGIN                It needs to take an exit
*
* If this will wake up that TDB we have to do it here
*
         IF    TDBSUSP,BEGIN           It is suspended
         IF    ^TDBFACT,BEGIN          Not already active
         IF    TDBLONG,'DECR RS,ASDBNLTW'
         ELSE  'DECR RS,ASDBNSTW'      Short term wait
         TQADD TDB                     Add it to the active queue
         END   ,
         END   ,
*
* Signal a re-dispatch if it is needed
*
         IF    (TDBSUSP,OR,(RX,EQ,PSATDB)),BEGIN
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB     Turn it on
         END   ,
         END   ,                       If no new exits, just enable
         CLEAR RM
         END   ,                       End of the locked up code
         ENABLE ,                      Unlock it all
         LR    RVR,RM                  Copy the return code
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  XITGST  --  This routine returns information about the       *
*              previous level of control.  It is called from    *
*              an exit routine.  The information obtained can   *
*              be updated with the routine XITPST.              *
*                                                               *
*   Input  --  @XITGPST                                         *
*                                                               *
*  Output  --  Updated info in the calling parm area.           *
*                                                               *
*****************************************************************
         SPACE 2
XITGST   PROC  @XITGPST,SCOPE=GLOBAL
*
* Find out where we are
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
         LT    RN,TDBISTK              Get the previous ERB
         IF    Z,EXIT                  Exit if there isn't one
         WITH  (ERB,RN)
*
* Move the info into the parm area
*
         WITH  (TDBESTAT,ERBSTAT),LABEL=E
         MVC   @XITGPST,E.TDBISTAT     Update the info
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  XITPST  --  This routine updates information about the       *
*              previous level of control.  It is called from    *
*              an exit routine.  The information to be updated  *
*              can be obtained using the routine XITGST.        *
*                                                               *
*   Input  --  @XITGPST                                         *
*                                                               *
*  Output  --  None                                             *
*                                                               *
*****************************************************************
         SPACE 2
XITPST   PROC  @XITGPST,SCOPE=GLOBAL
*
* Find out where we are
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
         LT    RN,TDBISTK              Get the previous ERB
         IF    Z,EXIT                  Exit if there isn't one
         WITH  (ERB,RN)
*
* Move the info from the parm area
*
         WITH  (TDBESTAT,ERBSTAT),LABEL=E
         MVC   E.TDBISTAT,@XITGPST     Update the info
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  XITFPR  --  Thir routine flushes pending exit request that   *
*              of the types specified in the mask.              *
*                                                               *
*   Input  --  @XITMASK                                         *
*                                                               *
*  Output  --  RVR contains mask before the modification        *
*                                                               *
*****************************************************************
         SPACE 2
XITFPR   PROC  @XITMASK,SCOPE=GLOBAL
*
* Find out where we are
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Scan the pending queue, removing any matching types
*
         L     RS,@XITMSK              Get the desired mask
         N     RS,TDBXRMAP             Any queued like this?
         IF    Z,EXIT                  If not, bypass all this junk
*
         DISABLE ,                     Lock up the address space
         LA    RJ,TDBERBS              Address of the pointer
         L     RK,TDBERBS              Get the first in the list
         WITH  (ERB,RK)
         CLEAR TDBXRMAP                Clear the request map
         WHILE (RK,NZ),BEGIN
         L     RVR,@XITMSK             Get the target mask
         N     RVR,ERBMTYPE            Is this one of them
*
* If this is on the hit list, make it seem as though it was never
* on the queue.
*
         IF    NZ,BEGIN                It is... remove it
         MVC   @RJ(4),ERBNEXT          Take it off the queue
         SET   ERBSFREE                Mark it as free
         L     RK,ERBNEXT              Move on to the next one
         END   ELSE,BEGIN
*
* Not on the hit list
*
         OC    TDBXRMAP,ERBMTYPE       Count this among those pending
         LA    RJ,ERBNEXT              Move on down the road
         L     RK,ERBNEXT              Point at the next one
         END   ,
         END   ,                       all the way to the end
         ENABLE ,                      Unlock the Address space
         PEND
         EJECT ,
*****************************************************************
*                                                               *
* XITMASK  --  This routine enables the caller to modify the    *
*              exit enable mask.  It may be replaced, have bits *
*              added, or bits removed.  The old mask is         *
*              returned in RVR.                                 *
*                                                               *
*   Input  --  @XITMASK                                         *
*                                                               *
*  Output  --  RVR contains mask before the modification        *
*                                                               *
*****************************************************************
         SPACE 2
XITMASK  PROC  @XITMASK,SCOPE=GLOBAL
*
* Find out where we are
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Update the mask
*
         L     RVR,TDBEMASK            Get the current value
         LOOP  BEGIN
         LR    RA,RVR
         IF    @XITMSO,'O RA,@XITMSK'  OR  operation
         IF    @XITMSN,'N RA,@XITMSK'  AND operation
         IF    @XITMSS,'L RA,@XITMSK'  SET operation
         CS    RVR,RA,TDBEMASK         Implement it
         UNTIL Z,END
*
* If this enables an exit we call the dispatcher
*
         N     RA,TDBXRMAP             Request map
         IF    NZ,BEGIN
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB     Local re-dispatch
         ACALL DISPRD                  And call the dispatcher
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* XITRMPLC --  This routine allow a currently running exit      *
*              routine to remove the evidence of a previously   *
*              scheduled exit.  (E.G. A supervisor exit program *
*              checks.  The PI exit can call this routine to    *
*              make it appear that the original program program *
*              checked at the SVC).  After calling this routine *
*              the registers and PSWs accessed will be those of *
*              the lower level routine.  The other information  *
*              in the exit status area will be unchanged after  *
*              the call.                                        *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
XITRMPLC PROC  SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Keep anything from getting at this queue while we're looking
*
         ACALL ASLOCK                  Lock up the address space
XRMIX    BEGIN ,
         LT    RK,TDBISTK              Get the current exit level
         IF    Z,EXIT                  No exit here
         WITH  (ERB,RK),LABEL=CUR      Address it
         LT    RJ,CUR.ERBNEXT          Get the previous one
         IF    Z,EXIT                  No previous one
         WITH  (ERB,RJ),LABEL=PRV      Address it
*
* Remove the previous from the queue
*
         MVC   CUR.ERBNEXT,PRV.ERBNEXT Remove it from the queue
         SET   PRV:ERBSFREE            Mark it as free
         XC    PRV.ERBTDB,PRV.ERBTDB   Clear the TDB field
         MVC   CUR.ERBSTAT,PRV.ERBSTAT Overlay the information
         END   ,
         ACALL ASULOCK                 Free up the address space
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  EXRDONE --  This routine is called to return from and exit   *
*              routine.  It frees the ERB and goes into         *
*              dispatcher mode to cause the task, address space *
*              dispatching to be done.                          *
*                                                               *
*   Input  --  @EXRDONE                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
EXRDONE  PROC  @EXRDONE,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Find the previous level of control
*
         ACALL ASLOCK                  Get the lock
         LT    RK,TDBISTK              Get the previous exit
         IF    Z,BEGIN                 This is the bottom level
         ABORT EXRDBAD                 Very bad
         END   ,
*
* Re-enable the exit routine
*
         WITH  (ERB,RK)                Point to it
         L     RS,ERBESB               Address of the associated ESB
         WITH  (ESB,RS),BEGIN
         IF    ESBFSTK,'CLEAR ESBFDIS' Re-enable the exit routine
         END   ,
*
* Get us to the dispatcher stack
*
         DISABLE ,                     No interrupts
         IF    ('LT WAR,PSACPLK',NZ),'ABORT CPLKBAL'
         L     WAR,PSADSTK             Get the Dispatcher stack
         LA    SPR,8(,WAR)
         SET   DISPSTK                 We are now on it
         MVC   PSACPLK,=A(1)           Lock up the CPU
         CLEAR ASDBLOCK                Free ASDB locks held
         XTRC  RK,RK,EXRDONE           Trace the change
*
* Take the status info out of it
*
         MVC   TDBISTK,ERBNEXT         Remove it from the list
         MVC   TDBESTAT,ERBSTAT        Restore the level of control
         MVC   PSASTATE,TDBISTAT       Update the PSA version too
*
* Free the ERB
*
         CLEAR ERBTDB
         SET   ERBSFREE                Free the ERB
         IF    ERBFDEL,BEGIN           It was previously deleted
         MVI   ERB+3,C'*'              Bliz the ID
         MVC   ERBNEXT,ASDBFERB        Point this at the list
         ST    RK,ASDBFERB             And the list at this
         END   ,
*
* Re-dispatch
*
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB
         ACALL ASDISP
*
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW
         XTRC  R0,R1,RUNUSER7          Trace the run
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 No in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  Return to previous level
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  EXSCHED --  This routine must be called off the dispatcher   *
*              stack.  It scans the list of waiting exit        *
*              requests and shedules the first one that is      *
*              enabled.  It is only called when there is some   *
*              bit on in the exit mask that is also on in the   *
*              exit request map.  This routine, along with      *
*              XITDO, maintains the exit request map.           *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
EXSCHED  PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB
         WITH  (TDB,RX)
*
* Set up for the search
*
         CLEAR TDBXRMAP                Clear the new exit RQ map
         CLEAR RN                      Location for the one we want
         L     RS,TDBEMASK             Copy the mask
         LA    RA,TDBERBS              Point at the pointer
*
* Loop through all the queued exits
*
         WHILE ('LT RB,@RA',NZ),BEGIN  Loop through
         WITH  (ERB,RB)
         LR    RVR,RS                  Copy the Exit mask
         N     RVR,ERBMTYPE            See about the type
         IF    (NZ,AND,(RN,Z)),BEGIN   Remove this one
         LR    RN,RB                   This is ours
         MVC   @RA(4),ERBNEXT          Take it out of the chain
         END   ELSE,BEGIN
*
         OC    TDBXRMAP,ERBMTYPE       Keep track of those we need
         LA    RA,ERBNEXT              Address of the next pointer
         END   ,
         END   ,                       end of the search
*
* At this point, RN should point to an ERB to be scheduled
*
         IF    (RN,Z),EXIT             If not... never mind.
         WITH  (ERB,RN)
*
* Scan to see if there is an exit routine defined to handle it
*
         L     RS,ERBMTYPE             Get the exit type mask
         L     RK,TDBESBS              Get the first of the bunch
         WITH  (ESB,RK)
ESBSRCH  WHILE (RK,NZ),BEGIN           Loop till we find one
         L     RVR,ESBTYPE             Get the exit routine type mask
         NR    RVR,RS                  Compare against the exit
         IF    (NZ,AND,^ESBFDIS),BEGIN Try this one out
         IF    (ESBFQUAL,AND,(ERBQUAL,NE,ESBQUAL)),EXIT Bad Qual
         EXIT  ESBSRCH                 We found one
         END   ,
         L     RK,ESBNEXT              Move to the next one
         END   ,                       End of the search
*
* We have either found the first or not found any.
*
         IF    (RK,Z),BEGIN            We didn't find one
         IF    (ERBTYPE,EQ,XITTPI),BEGIN
         ABORT NOEXIT
         END   ,
         CLEAR ERBTDB                  Clear the TDB address
         SET   ERBSFREE                Change the status
         END   ELSE,BEGIN
*
* We have the ESB and the ERB... Yea!! We get to take an exit.
*
*
* Save the current state
*
         IF    (RX,EQ,PSATDB),BEGIN    The Task has been established
         MVC   TDBISTAT,PSASTATE       Save the PSA info in the TDB
         END   ,
         MVC   ERBSTAT,TDBESTAT        Save the current status
         MVC   ERBNEXT,TDBISTK         Point this to the list
         ST    RN,TDBISTK              Stack this one
*
* Formulate the new state
*
         CLEAR TDBESTAT                Zero the whole thing
         MVC   TDBPSW,ESBPSW           New PSW
         MVC   ERBRPARM,ESBPARM        And the Routine parm
         WITH  (XITMSKD,TDBEMASK)      Refer to the exit map
         SET   XITMPI                  Set the non-maskable ones
*
* For system style exits (those that require a stack), we set
* up the stack that was pre-allocated.  We also disable the exit
* so that the stack won't be used again.
*
         IF    ESBFSTK,BEGIN           System-type exit (with stack)
         SET   ESBFDIS                 Disable it
         MVC   TDBGPRS+15*4(4),TDBPSW+4  Entry point address
         L     RS,ESBSTACK             Get the stack location
         ST    RS,TDBGPRS+WAR*4        Save the frame pointer
         LA    RS,@RS+8
         ST    RS,TDBGPRS+SPR*4        And the stack pointer
         LA    RA,ERBRPARM             Location of the XITSAREA
         ST    RA,@RS+72               Location for the address
         END   ELSE,BEGIN
         LA    RA,ERBRPARM             Location of the XITSAREA
         ST    RA,TDBGPRS+1*4          Put it in R1
         END   ,
*
* If the task was already established, the correct place for the
* PSW and registers is in the PSA.
*
         IF    (RX,EQ,PSATDB),BEGIN    The Task has been established
         MVC   PSASTATE,TDBISTAT       Save the TDB info in the PSA
         END   ,
*
* Setup the exit chaining thing
*
         ST    RK,ERBESB               Save the exit routine
*
* Calculate a new Level of control number
*
         INCR  RS,TDBLCN               Bump up the number
         ST    RS,TDBCLCN              Save the current number
         END   ,
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Task Creation, Deletion, Control'
*****************************************************************
*                                                               *
*  TCREATE --  This routine creates a new task in the current   *
*              address space.  It  ID.  It tries to get one     *
*              that was previously allocated first.  If it      *
*              can't get one of those, it allocates a new one.  *
*                                                               *
*   Input  --  @TCREATE                                         *
*                                                               *
*  Output  --  RVR contains the ID of the new task              *
*                                                               *
*****************************************************************
         SPACE 2
TCREATE  PROC  @TCREATE,SCOPE=GLOBAL
*
* First get the current info
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
         L     RM,ASDBCTDB             Current TDB address
         WITH  (TDB,RM),LABEL=CUR
*
* Try to get a TDB off the free queue
*
         ACALL ASLOCK                  Lock up the dispatching
         LT    RX,ASDBFTDB             Get the Free TDB queue
         WITH  (TDB,RX)
         IF    NZ,BEGIN                We have one
         MVC   ASDBFTDB,TDBNEXT        Remove it from the list
         END   ELSE,BEGIN              There is not one
         VMGET L'TDB,LOC=LOCSYS,FIX=YES
         LR    RX,RVR                  Copy the address
         END   ,
*
* Add the ID and put it on the proper queues
*
         CLEAR TDB
         MVC   TDB(4),=C'TDB '         Move in the ID
         ST    RY,TDBASDB              The ASDB address
         MVC   TDBCHN,ASDBTDBS
         ST    RX,ASDBTDBS             Add to the TDB chain
         INCR  RS,ASDBNTDB             Increment the number of TDBs
*
* Add the system exit routine request ID's
*
         PSET  @XITNEW                 Get the exit requests
         ACALL XITNEW
         ST    RVR,TDBSVERQ            SVC
         ACALL XITNEW
         ST    RVR,TDBPIERQ            PI
         ACALL XITNEW
         ST    RVR,TDBMCERQ            Monitor
         ACALL XITNEW
         ST    RVR,TDBPEERQ            PER
*
* PSW & registers and stack
*
         MVC   TDBPSW,@TCRPSW          New PSW
         IF    @TCRFSTK,BEGIN          Stack based
         ACALL STKNEW                  Get a new Stack
         ST    RVR,TDBSTACK            Save the address
         LR    RA,RVR                  Copy the address
         ST    RA,TDBGPRS+WAR*4        Save the start of the stack
         LA    RA,@RA+8                Top of stack location
         ST    RA,TDBGPRS+SPR*4        Save the top of stack location
         MVC   @RA+72(8),@TCRPARM      Move parm to the stack
         MVC   TDBGPRS+EPAR*4(4),TDBPSW+4  Entry point address
         END   ELSE,BEGIN              Not stack based
         MVC   TDBGPRS+1*4(4),@TCRPARM Parm goes into register 1
         END   ,
*
* Exit mask
*
         WITH  (XITMSKD,TDBEMASK),BEGIN
         SET   XITMPI+XITMSVC          Enable the SVC and PI exits
         END   ,
         MVC   TDBTCLK,=X'00FFFFFFFFFFFFFF'  No timer set
*
* Dispatching priority of the new task
*
         L     RA,@TCRPRIO             Get prio number
         IF    ^@TCRFPABS,BEGIN        Relative prio
         AL    RA,CUR.TDBPRIO          Add the current priority
         END   ,                       OF Relative prio
         ST    RA,TDBPRIO              Gives the new priority
         IF    (RA,GT,CUR.TDBPRIO),BEGIN        New one is higher
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB    Re-dispatch needed
         END   ,
*
* Add it to the ready queue
*
         TQADD TDB                     Add it to the queue
         ACALL ASULOCK                 Free the Local lock
*
* Return the task ID to the caller
*
         LR    RVR,RY
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   TEXIT  --  This routine is called to terminate a task.  It  *
*              causes the TDB and all associated things to be   *
*              deleted.  It exits directly to the dispatcher.   *
*                                                               *
*   Input  --  @TEXIT                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TEXIT    PROC  @TEXIT,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Get the current TDB
         WITH  (TDB,RX)
*
* Lock out the othere tasks in the address space, then start using
* the address space stack.
*
         ACALL ASLOCK                  Lock up the Address space
         L     WAR,ASDBSTK             Get the AS wide stack
         LA    SPR,8(,WAR)             Set up the other register
*
* Clean everything about this TDB
*
         PSET  @TCLUP,CLEAR=NO
         ST    RX,@TCLTDB
         LCALL TCLEANUP                Clean it all up
*
* Disable so no other dispatching goes on, then get the dispatcher
* stack.
*
         IF    ('LT WAR,PSACPLK',NZ),'ABORT CPLKBAL'
         DISABLE ,
         SET   DISPSTK                 Mark us on the disp stack
         MVC   PSACPLK,=A(1)           Lock up the CPU
         L     WAR,PSADSTK             Get the dispatcher stack
         LA    SPR,8(,WAR)             Set up the other stack reg
         XTRC  RX,RX,TEXIT             Trace the exit
*
* Remove this TDB from the ASDB queue
*
         LA    RA,ASDBTDBS             Address of the chain pointer
         L     RB,@RA
         WHILE (RB,NE,RX),BEGIN
         WITH  (TDB,RB)
         LA    RA,TDBCHN               Address of the next pointer
         L     RB,TDBCHN               Address of the next
         END   ,
         MVC   @RA(4),TDBCHN           Remove it from the chain
         DECR  RS,ASDBNTDB             Count one less
         CLEAR PSATDB                  Not current in the PSA
         CLEAR ASDBCTDB                Not the current TDB anymore
         CLEAR ASDBLOCK                Insure the local lock is free
*
* Queue up the TDB on the free queue
*
         MVI   TDB+3,C'*'              Blitz the ID
         MVC   TDBNEXT,ASDBFTDB        Point this at the queue
         ST    RX,ASDBFTDB             And the queue at this
*
* Move the next ready task into the current position
*
         LT    RX,ASDBATDB             Get the first ready one
         IF    NZ,BEGIN
         MVC   ASDBATDB,TDBNEXT        remove it from that queue
         CLEAR TDBNEXT                 No next now
         ST    RX,ASDBCTDB
         END   ,
*
* Re-dispatch
*
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB
         ACALL ASDISP                  Do the complete re-dispatch
*
* Get right back to the proper user
*
         IF    (PSACPLK,NE,1),'ABORT CPLKBAL'
         LM    R0,R1,PSAPSW            Get the new PSW
         XTRC  R0,R1,RUNUSER8          Trace it
         LD    0,PSAFPRS+0*4           FPR 0
         LD    2,PSAFPRS+2*4           FPR 2
         LD    4,PSAFPRS+4*4           FPR 4
         LD    6,PSAFPRS+6*4           FPR 6
         LM    0,15,PSAGPRS            GPRs
         CLEAR DISPSTK                 Not in dispatcher stack now
         CLEAR PSACPLK
         LPSW  PSAPSW                  And off and running
         PEND  ,                       Never executed
         EJECT ,
*****************************************************************
*                                                               *
*  TREMOVE --  This routine removes a task from the current     *
*              address space.  It is passed the ID of the task  *
*              and it frees the TDB and anything else it can    *
*              get it's mitts on.                               *
*                                                               *
*   Input  --  @TREMOVE                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
TREMOVE  PROC  @TREMOVE,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
         ACALL ASLOCK                  Lock the address space
*
* Verify the TDB to be removed
*
         L     RX,@TREID               Get the task ID
         IF    (@RX,NE,'TDB '),EXIT    It isn't a TDB
         WITH  (TDB,RX)
         IF    (RY,NE,TDBASDB),EXIT    It doesn't belong here
         IF    (RX,EQ,ASDBCTDB),'ABORT REMCUR'   Can't remove ours
*
* Clean up the TDB
*
         PSET  @TCLUP,CLEAR=NO
         ST    RX,@TCLTDB
         LCALL TCLEANUP
*
* Free the TDB's stack if it has one
*
         IF    TDBFGLOB,'ABORT GTDBREM' Can't remove a global one
         IF    ('LT RA,TDBSTACK',NZ),BEGIN      There is a stack
         PSET  @STKDEL,CLEAR=NO
         MVC   @STKDLOC,TDBSTACK       Stack address
         LCALL STKDEL                  Remove the stack
         END   ,
*
* Now remove the TDB from all it's queues
*
         LA    RA,ASDBTDBS             Address of the chain pointer
         L     RB,@RA
         WHILE (RB,NE,RX),BEGIN
         WITH  (TDB,RB)
         LA    RA,TDBCHN               Address of the next pointer
         L     RB,TDBCHN               Address of the next
         END   ,
         MVC   @RA(4),TDBCHN           Remove it from the chain
         DECR  RS,ASDBNTDB             Count one less
*
* If it's active remove it from that queue (can't be the current one,
* because we're the current one).
*
         IF    TDBFACT,BEGIN           It's on the active list
         LA    RA,ASDBATDB             Address of the list pointer
         L     RB,@RA
         WHILE (RB,NE,RX),BEGIN
         WITH  (TDB,RB)
         LA    RA,TDBNEXT              Address of the next pointer
         L     RB,TDBNEXT              Address of the next
         END   ,
         MVC   @RA(4),TDBNEXT          Remove it from the chain
         END   ,
*
* If it is suspended, we have to adjust those counts too
*
         IF    TDBSUSP,BEGIN           Handle suspend counts
         IF    TDBLONG,'DECR RS,ASDBNLTW'        Long term waits
         ELSE  'DECR RS,ASDBNSTW'                Short term waits
         END   ,
*
* The TDB is completely disconnected now.  Put the storage on the
* free TDB queue
*
         MVI   TDB+3,C'*'              Blitz the ID
         MVC   TDBNEXT,ASDBFTDB
         ST    RX,ASDBFTDB             Put it on the free queue
         ACALL ASULOCK                 Free the local lock
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* TCLEANUP --  This routine cleans up all the exit routines,    *
*              pending exits, etc from a TDB so that it may be  *
*              removed from the address space.                  *
*                                                               *
*              *** THE LOCAL LOCK MUST BE HELD ***              *
*                                                               *
*   Input  --  @TCLUP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@TCLUP   RECORD BEGIN
@TCLTDB  DS    A             Address of the TDB to be scrubbed
         END   ,
         SPACE 2
TCLEANUP PROC  @TCLUP,SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the ASDB address
         WITH  (ASDB,RY)
*
* Get the TDB to be removed
*
         L     RX,@TCLTDB              Address of the TDB
         WITH  (TDB,RX)
*
* Remove the task stack if there is one
*
         IF    ('LT RA,TDBSTACK',NZ),BEGIN
         PSET  @STKDEL,CLEAR=NO
         MVC   @STKDLOC,TDBSTACK       Location of the stack
         LCALL STKDEL                  Free up the stack
         END   ,
*
* Take care of the pending exit requests
*
         DISABLE ,
         L     RA,TDBERBS              Chain of ERBs
         WHILE (RA,NZ),BEGIN
         WITH  (ERB,RA)
         SET   ERBSFREE                Mark it as free
         CLEAR ERBTDB                  And not on any TDB
         L     RA,ERBNEXT              Get to the next
         END   ,
         ENABLE ,
*
* Take care of the active exit requests
*
         L     RA,TDBISTK              Chain of ERBs
         WHILE (RA,NZ),BEGIN
         WITH  (ERB,RA)
         SET   ERBSFREE                Mark it as free
         CLEAR ERBTDB                  And not on any TDB
         L     RA,ERBNEXT              Get to the next
         END   ,
*
* Take care of the ESB's
*
         L     RA,TDBESBS              Stack of the ESBs
         WHILE (RA,NZ),BEGIN           Loop through
         WITH  (ESB,RA)
         IF    ESBFSTK,BEGIN
         PSET  @STKDEL
         MVC   @STKDLOC,ESBSTACK       Stack address
         LCALL STKDEL                  Remove the stack
         END   ,
         L     RB,ESBNEXT              Get the address of the next
         MVI   ESB+3,C'*'              Blitz the ID
         MVC   ESBNEXT,ASDBFESB
         ST    RA,ASDBFESB             Add it to the free queue
         LR    RA,RB                   Get to the next one
         END   ,
*
* Free the ERBs for the system exits
*
         PSET  @XITDEL
         LT    RS,TDBSVERQ             SVC Exit request
         IF    NZ,BEGIN
         ST    RS,@XITDID
         ACALL XITDEL                  Delete it
         END   ,
         LT    RS,TDBPIERQ             PI Exit request
         IF    NZ,BEGIN
         ST    RS,@XITDID
         ACALL XITDEL                  Delete it
         END   ,
         LT    RS,TDBMCERQ             Monitor Call Exit request
         IF    NZ,BEGIN
         ST    RS,@XITDID
         ACALL XITDEL                  Delete it
         END   ,
         LT    RS,TDBPEERQ             PER Exit request
         IF    NZ,BEGIN
         ST    RS,@XITDID
         ACALL XITDEL                  Delete it
         END   ,
*
* Free the timer queue entries
*
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  SYSRNEW --  This routine allocates an STDB and returns the   *
*              address as the SYSR ID.  It tries to get one     *
*              that was previously allocated first.  If it      *
*              can't get one of those, it allocates a new one.  *
*                                                               *
*   Input  --  @SYSRNEW                                         *
*                                                               *
*  Output  --  RVR contains the SYSR ID.                        *
*                                                               *
*****************************************************************
         SPACE 2
SYSRNEW  PROC  @SYSRNEW,SCOPE=GLOBAL
*
* Try to get one off the free queue
*
         L     RX,PZMATP               MAT pointer
         WITH  (MAT,RX),'L RX,MATDCT'  DCT pointer
         WITH  (DCT,RX)
         LM    RA,RB,DCTFSTBQ          Get the first one
         WITH  (STDB,RA)               Address it
*
* Remove it from the chain
*
         LOOP  BEGIN
         IF    (RA,Z),EXIT             Not there, don't remove it
         L     RJ,STDBNEXT             Point at the next one
         LR    RK,RB                   Copy the control value
         CDS   RA,RJ,DCTFSTBQ          Update the values
         UNTIL Z,END                   Until the swap goes
*
* If we didn't get an old one, we have to get a new one.
*
         IF    (RA,Z),BEGIN
         VMGET L'STDB,LOC=GLOBHI,FIX=YES ,SP=01
         LR    RA,RVR                  Copy the address
         END   ,
*
* Initialize it in any case
*
         CLEAR STDB                    Zero it all out
         MVC   STDB(4),=C'STDB'        Set up the ID
         LR    RVR,RA                  Copy the 'ID'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  SYSRDEL --  This routine deletes an STDB previously obtained *
*              with SYSRNEW.  This just queues them up off the  *
*              DCT for future use.                              *
*                                                               *
*   Input  --  @SYSRDEL                                         *
*                                                               *
*  Output  --  RVR ^= 0:  It could not be freed.                *
*                                                               *
*****************************************************************
         SPACE 2
SYSRDEL  PROC  @SYSRDEL,SCOPE=GLOBAL
*
* Validate the parm
*
         LA    RVR,4                   Assume failure
         L     RJ,@SYSRDID             Get the STDB address
         IF    (@RJ,NE,'STDB'),EXIT
         WITH  (STDB,RJ)
         L     RA,=A(C'FREE')          Get an ASDB address for us
         CLEAR RS
         CS    RS,RA,STDBASDB          Mark it for ourselves
         IF    NZ,EXIT                 It is in use
*
* Mark it as deleted
*
         MVI   STDB,C's'               Change it to an sTDB
*
* Add it to the queue
*
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         LM    RA,RB,DCTFSTBQ          Get the current values
         LOOP  BEGIN
         ST    RA,STDBNEXT             Next points to current head
         LR    RK,RB                   Copy the control value
         DECR  RK                      New control value
         CDS   RA,RJ,DCTFSTBQ          Update the values
         UNTIL Z,END                   Until the swap goes ok
         CLEAR RVR                     Tell the caller it went well
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   SYSRDO --  This routine schedules an STDB previously        *
*              obtained with SYSRNEW.  It adds it to the queue  *
*              for the Address space whose ASB addr is passed.  *
*                                                               *
*   Input  --  @SYSRDO                                          *
*                                                               *
*  Output  --  RVR ^= 0:  It could not be scheduled.            *
*                                                               *
*****************************************************************
         SPACE 2
SYSRDO   PROC  @SYSRDO,SCOPE=GLOBAL
*
* Validate the parms
*
         LA    RVR,4                   Assume failure
         L     RY,@SYSRASB             Get the ASB pointer
         IF    (@RY,NE,'ASB '),EXIT
         WITH  (ASB,RY),'L RY,ASBASDB' Get the ASDB pointer
         IF    (@RY,NE,'ASDB'),EXIT
         WITH  (ASDB,RY)
         IF    ASDBTERM,EXIT           Termination in progress
         L     RJ,@SYSRID              Get the STDB address
         IF    (@RJ,NE,'STDB'),EXIT
         WITH  (STDB,RJ)
         CLEAR RA
         CS    RA,RY,STDBASDB          Update the ASDB pointer
         IF    NZ,EXIT                 Wasn't free
*
* Move in the information
*
         MVC   STDBADDR,@SYSRLOC       Move in the location
         MVC   STDBPARM(16),@SYSRPRM   And the parms
*
* Add it to the ASDB queue
*
         L     RA,ASDBSTDB             Get the current head of Q
         LOOP  BEGIN
         ST    RA,STDBNEXT             Next points to current head
         CS    RA,RJ,ASDBSTDB          Update the values
         UNTIL Z,END                   Until the swap goes ok
         SET   ASDBTDSP,MODE=LOCKED,REF=ASDB
         IF    ('LT RS,ASDBSUSP',Z),BEGIN
         PSET  @ASWAKE,CLEAR=NO
         ST    RY,@ASWASDB             ASDB to awaken
         ACALL ASWAKE                  Awaken the AS
         END   ,
         CLEAR RVR                     Tell the caller it went well
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   STKNEW --  This routine gets a new fixed stack.  These      *
*              stackes are of size STKSIZE.  It attempts first  *
*              to get one already allocated.  If it can't get   *
*              one of those, it allocates a new page full of    *
*              stacks and adds them all to the list.            *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains a pointer to the new stack          *
*                                                               *
*****************************************************************
         SPACE 2
STKNEW   PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the current ASDB address
         WITH  (ASDB,RY)
*
* Get new ones if there are none available
*
         ACALL ASLOCK                  Lock up the address space
         IF    ('LT RA,ASDBFSTK',Z),BEGIN       Need some more
         VMGET L:=A(4096),LOC=LOCSYS,FIX=YES,PAGE=YES  Get a page
*
* Chain all the stacks there together
*
         LR    RA,RVR                  Copy the Page address
         LR    RB,RA                   Stack pointer
         LA    RJ,@RB+STKSIZE          Address of the next one
         LA    RK,@RA+4095             Point at the last byte
         WHILE (RJ,LT,RK),BEGIN        Loop through
         ST    RJ,@RB                  Point current at next
         LR    RB,RJ                   next becomes current
         LA    RJ,@RB+STKSIZE          Compute new next
         END   ,
*
* Now RA points to the first one and RB to the last of the new ones
*
         MVC   @RB(4),ASDBFSTK         Make this list point at old
         MVC   ASDBFSTK,@RA            Put all but first on queue
         END   ELSE,BEGIN              End of the queue updates
*
* There is one there,  remove it
*
         L     RA,ASDBFSTK             Get the address of first
         MVC   ASDBFSTK,@RA            Remove it
         PSET  @PAGE                   One more fix for the page
         PMOV  @PAGLOC,(RA)            |
         PMOV  @PAGLEN,LA:1            |
         VCALL PAGSFIX                 |
         END   ,
         ACALL ASULOCK                 Unlock the Address space
         LR    RVR,RA                  Copy the 'ID'
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   STKDEL --  This routine frees a stack previously obtained   *
*              with STKNEW.  It just queues it to the ASDB for  *
*              future use.                                      *
*                                                               *
*   Input  --  @STKDEL                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@STKDEL  RECORD BEGIN
@STKDLOC DS    A             Address of the stack being freed
         END   ,
         SPACE 2
STKDEL   PROC  @STKDEL,SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PSAASDB              Get the current ASDB address
         WITH  (ASDB,RY)
         L     RA,@STKDLOC             Get the stack to be removed
         ACALL ASLOCK                  Get the local lock
         PSET  @PAGE                   One less fix for the page
         PMOV  @PAGLOC,(RA)            |
         PMOV  @PAGLEN,LA:1            |
         VCALL PAGUSFIX                |
         MVC   @RA(4),ASDBFSTK         Point this at the queue
         ST    RA,ASDBFSTK             And the queue at this
         ACALL ASULOCK                 Free the local lock
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Miscellaneous Global Info/Control Routines'
*****************************************************************
*                                                               *
* DISPCPTA --  This routine returns an address where a fairly   *
*              up to date CPU time may be obtained.  (It        *
*              returns a pointer to ASDBTCPU).  This is so the  *
*              accounting routines can tell other folks about   *
*              the resource usage in this address space. It     *
*              also marks the address space so that we will     *
*              count the time it uses as 'charged'.             *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR Points at the Address space CPU time.        *
*                                                               *
*****************************************************************
         SPACE 2
DISPCPTA PROC  SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
         SET   ASDBACCT                Turn on accounting
         LA    RVR,ASDBTCPU            Get the address
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  DSPSTAT --  This routine returns statistical information     *
*              about the dispatcher.                            *
*                                                               *
*   Input  --  @DSPSTAT                                         *
*                                                               *
*  Output  --  None                                             *
*                                                               *
*****************************************************************
         SPACE 2
DSPSWA   RECORD BEGIN
DWFSA    DS    4D            Save area for floating point Regs
         END   ,
         SPACE 2
DSPSTAT  PROC  @DSPSTAT,DSPSWA,SCOPE=GLOBAL
*
* Save the Floating point registers
*
         STD   0,DWFSA
         STD   2,DWFSA+2*4
         STD   4,DWFSA+4*4
         STD   6,DWFSA+6*4
         SDR   2,2                     Total charged accumulator
         SDR   4,4                     Dispatch time accumulator
         SDR   6,6                     I/O service time accumulator
*
* Disable and look through the IPCB's
*
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         L     RY,DCTIPCBS             Get the first CPU
         DISABLE ,
         WHILE (RY,NZ),BEGIN           Loop through all the CPUs
         WITH  (IPCB,RY)
*
* Point at the proper PSA
*
         IF    (RY,EQ,PSAIPCB),'CLEAR RJ'
         ELSE  'L RJ,IPCBPZ'
         LA    RJ,@RJ+L'PZERO          Point to the PSA
         WITH  (PSA,RJ),LABEL=X
*
* Accumulate the values
*
         AW    2,X.PSATCHG             Total Charged
         LD    0,ITVAL                 Initial timer value
         SW    0,X.PSAKDISP
         AWR   4,0                     Dispatch time
         LD    0,ITVAL                 Initial timer value
         SW    0,X.PSAKIOSV
         AWR   6,0                     I/O Service time
*
* Go on to the next CPU
*
         L     RY,IPCBNEXT             Get the next one
         END   ,
*
* Enable and return the data
*
         ENABLE ,
         STD   2,@DSPSCHG              Total Charged
         STD   4,@DSPSDSP              Dispatch
         STD   6,@DSPSIOS              I/O service
         MVC   @DSPSST,DCTSTIME        Tell 'em about the start time
         LD    0,DWFSA                 Restore the registers
         LD    2,DWFSA+2*4
         LD    4,DWFSA+4*4
         STD   6,DWFSA+6*4
         PEND  ,                       Return to the caller
         DS    0D
ITVAL    DC    X'00FFFFFFFFFFFFFF'     Initial value of some timers
         EJECT ,
*****************************************************************
*                                                               *
* TCPUTIME --  This routine returns in FPR 0 the unnormalized   *
*              TOD value of the amount of CPU time this task    *
*              has accrued.                                     *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  FPR 0 contains the task CPU time                 *
*                                                               *
*****************************************************************
         SPACE 2
TCPUTIME PROC  SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB address
         WITH  (TDB,RX)
*
* Get the current task amount
*
         DISABLE ,
         LD    0,ASDBTCPU              Total current amount
         SW    0,TDBCPUST              Less that when we became cur
         AW    0,TDBTCPU               Plus the previous amount
         ENABLE ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* ACPUTIME --  This routine returns in FPR 0 the unnormalized   *
*              TOD value of the amount of CPU time this Address *
*              space has accrued.                               *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  FPR 0 contains the address space CPU time        *
*                                                               *
*****************************************************************
         SPACE 2
ACPUTIME PROC  SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
         DISABLE ,                     Turn off interrupts
*
* Get the current value of the user clock
*
         UPDCLOCK USER                 Make sure about user clock
         IF    PSAKUSER.X'80',BEGIN    We've passed the time
         MVC   PSADWK1,PSAKUSER        Copy the clock
         XC    PSADWK1,=X'FFFFFFFFFFFFFFFF'
         LD    0,PSADWK1               Get the complemented value
         AW    0,=X'0000000000000001'  Get the value past zero
         END   ELSE,BEGIN              Not past time yet
         LD    0,PSAKUSER              Get the current value
         LCDR  0,0                     Negate it
         END   ,
*
* Find the total CPU time used
*
         AW    0,ASDBSCPU              Get time since timer loaded
         AW    0,ASDBTCPU              Add the time before that
         ENABLE ,                      Enable for interrupts now
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  PERSET  --  This routine sets the PER info for the current   *
*              task.                                            *
*                                                               *
*   Input  --  @PERSET                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PERSET   PROC  @PERSET,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB address
         WITH  (TDB,RX)
*
* Copy the info into the TDB
*
         MVC   TDBPERIN(3*4),@PERSDAT  Move it in
         LCTL  9,11,TDBPERIN           Then use it
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  MONSET  --  This routine sets the MON info for the current   *
*              task.                                            *
*                                                               *
*   Input  --  @MONSET                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
MONSET   PROC  @MONSET,SCOPE=GLOBAL
*
* Get our bearings
*
         L     RY,PSAASDB              Current ASDB address
         WITH  (ASDB,RY)
         L     RX,ASDBCTDB             Current TDB address
         WITH  (TDB,RX)
*
* Verify the monitor mask
*
         L2    RS,@MONSDAT             Get the Monitor bits
         ST    RS,TDBMON               Save them in the TDB
         LCTL  8,8,TDBMON              Make it active now
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* DISPPTLB --  This routine causes the TLBs of all the CPUs to  *
*              be cleared.  Due to the hardware function, this  *
*              will not happen  on an given CPU until that CPU  *
*              enables for External Interrupts.                 *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPPTLB PROC  SCOPE=GLOBAL
*
* Make sure we stay put on this CPU, then clean our own house
*
         DISABLE ,
         PTLB  ,                       Purge our own TLB
*
* Find and signal the other CPUs
*
         L     RX,PSADCT               Get the DCT address
         WITH  (DCT,RX)
         L     RJ,DCTIPCBS             Get the first in the queue
         WHILE (RJ,NZ),BEGIN           Loop through them
         WITH  (IPCB,RJ)
         IF    (IPCBCPUA,NE,PSACPUA),BEGIN       Anyone else
         SET   IPFLPTLB,MODE=LOCKED,REF=IPCB     Tell them what to do
         LH    RS,IPCBCPUA             Get the CPU address
         SIGP  RS,RS,X'02'             Signal External Call
         END   ,
         L     RJ,IPCBNEXT             Go on to the next one
         END   ,
*
* Get us back to how we were
*
         ENABLE ,
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  RDPARMS --  This routine is called during initialization to  *
*              read the parameters relevent to dispatching.     *
*              It only updates those values for which parms     *
*              were specified, so defaults must be in place.    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RDPWA    RECORD BEGIN        Local Work area
RDPARM   DS    XL(L'PARMIN)
         DS    D             First keyword
         DS    D             Second keyword
RDPSTR   DS    CL20          String return area
         END   ,
         SPACE 2
RDPARMS  PROC  ,RDPWA,SCOPE=LOCAL
*
* Get our bearings
*
         L     RY,PZMATP     Get the mat pointer
         WITH  (MAT,RY)
         L     RX,MATDCT     Get the DCT pointer
         WITH  (DCT,RX)
         WITH  (PARMIN,RDPARM)
*
* Get the system name
*
         GETPARM2 RDPSTR,KEY=(SYSNAME),TYPE=STRING,REGS=(RA,RJ)
         IF    Z,BEGIN                 It was specified
         ICM   RB,B'1000',=C' '        Blank pad it
         LA    RJ,MATSNAME             Location of the name
         LA    RK,L'MATSNAME           Length of the name
         MVCL  RJ,RA                   Move and pad the name
         END   ,
*
* Get the working set interval
*
         GETPARM2 KEY=(DISPATCH,WSINT),REGS=(RA,RJ)
         IF    Z,BEGIN                 It was specified
         LR    RB,RA                   Get the value (in millseconds)
         CLEAR RA
         MH    RB,=Y(1000)             Convert to microseconds
         SLDL  RA,12                   Convert to TOD
         STM   RA,RB,DCTWSIN           Save it away
         END   ,
*
* Get the working set size limit
*
         GETPARM2 KEY=(,WSLIMIT),REGS=(RA,RJ)
         IF    Z,BEGIN                 It was specified
         ST    RA,DCTWSLM              Save the limit
         END   ,
*
*  Read our trace parameters
*
         CLEAR RS                      Default to no tracing
         GETPARM2 RDPSTR,KEY=(,TRACE,BRANCH),TYPE=YESNO,REGS=(RA,RJ)
         IF    Z,BEGIN                 Specified
         IF    ('CLI RDPSTR,C"Y"',EQ),BEGIN
         O     RS,=A(TRCBRANCH)        Branch tracing
         END   ,
         END   ,                       OF Specified
         GETPARM2 RDPSTR,KEY=(,TRACE,EXPLICIT),TYPE=YESNO,REGS=(RA,RJ)
         IF    Z,BEGIN                 Specified
         IF    ('CLI RDPSTR,C"Y"',EQ),BEGIN
         O     RS,=A(TRCEXPL)          Explicit tracing
         END   ,
         END   ,                       OF Specified
         GETPARM2 RDPSTR,KEY=(,TRACE,ASN),TYPE=YESNO,REGS=(RA,RJ)
         IF    Z,BEGIN                 Specified
         IF    ('CLI RDPSTR,C"Y"',EQ),BEGIN
         O     RS,=A(TRCASN)           Branch tracing
         END   ,
         END   ,                       OF Specified
*
         ST    RS,DCTTRMSK             Save mask
         PEND  ,
         EJECT ,
         LTORG ,
         TITLE 'Initialization'
         DROP  R0
IPL      USING PZERO,R0
*****************************************************************
*                                                               *
* DISPINIT --  This routine is the entry point of the guest     *
*              portion of ORVYL.  It is called from the IPL     *
*              text.  It in turn calls those routines necessary *
*              to set up the system for business.               *
*                                                               *
*   Input  --  @IPLPARM                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DISPINIT PROC  @IPLPARM,SCOPE=GLOBAL
*
* Set up the virtual memory. That way when I need to get
* some memory, it will all be accounted for.  We have to inform
* him on the call of things that have already been allocated by
* the ipltext.  It will allocate the master address table (MAT)
* and store its address in PZERO.
*
*        NOTE:  Any interrupts that happen will be handled by the
*               IPLTEXT.  Page faults will be resolved automatically.
*
         PSET  @VMIPARM                Set up the parm area
         MVC   @VMIKLOC,@IPLKLOC       Kernel
         MVC   @VMIKLEN,@IPLKLEN
         MVC   @VMIMLOC,@IPLMLOC       Map
         MVC   @VMIMLEN,@IPLMLEN
         MVC   @VMISLOC,@IPLSLOC       V=R stack area
         VCALL VMINIT1                 Init all that junk
         LR    RA,RVR                  Save the Address space size
         VCALL LKINIT                  Initialize the lock manager
         VCALL IOSINIT                 Initialize the I/O supervisor
*
* Start the initialization of the dispatcher.
*
         ACALL INITDIS1                Allocate CBs, etc.
         LR    RB,RVR                  Address of the Global ASB
*
* Initialize the paging system
*
         PSET  @PAGINIT
         ST    RA,@PAGIMEG             Size of the Workspace
         ST    RB,@PAGIASB             Address of the ASB
         VCALL PAGINIT                 Call the paging system
         VCALL VMINIT2                 Finish the virtual memory
*
** IMPORTANT NOTE :  No page faults must occur after this until the
*                    interrupt PSWs belong to us.
*
* Finish initializing the dispatcher
*
         ACALL INITDIS2                Doesn't return
         PEND                          Never executed
         EJECT ,
*****************************************************************
*                                                               *
* INITDIS1 --  This routine is called to set up the initial     *
*              stuff for the dispatcher.  It allocates all      *
*              storage needed between now and the time the CPU  *
*              is completely set up (PZERO that is).            *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR Contains the address of the Global ASB       *
*                                                               *
*****************************************************************
         SPACE 2
INITDIS1 PROC  SCOPE=LOCAL
*
* Set up a DCT
*
         VMGET L'DCT,LOC=GLOBHI,FIX=YES
         LR    RX,RVR                  Copy the address
         WITH  (DCT,RX)
         CLEAR DCT
         MVC   DCT(4),=CL4'DCT'        Move in the ID
         L     RS,IPL.PZMATP           Get the MAT pointer
         WITH  (MAT,RS),'ST RX,MATDCT' Save the address there
         MVC   DCTSLICE(8*NUMPRIO),DEFSLICE
         MVC   DCTSLCWT(8*NUMPRIO),DEFWAIT
         MVC   DCTWSIN,DEFWSIN         WS interval
         MVC   DCTWSLM,DEFWSLM         WS size limit
         STCK  DCTSTIME                Time we started
         MVC   DCTSWPRI,=H'-1'         Swap priority
*
* Set up some things in the MAT
*
         L     RS,IPL.PZMATP           Get the MAT pointer
         WITH  (MAT,RS),BEGIN
         MVC   MATSNAME,=CL8'TORVYL'   Default name
         END   ,
*
* Read any overriding input parms
*
         ACALL RDPARMS
*
* Set up the System Address space
*
         PSET  @ACREATE
         MVC   @ACRPSW(4),=X'070C0000'
         MVC   @ACRPSW+4(4),=V(SYSTASK)
         OI    @ACRPSW+4,X'80'         Enter in 31 bit mode
         ACALL ACREATE
*
* Special fix up for the System task ASDB
*
         LR    RA,RVR                  ASB pointer is returned
         WITH  (ASB,RA),'L  RA,ASBASDB'    ASDB pointer
         WITH  (ASDB,RA),BEGIN
         MVC   ASDBWSIN,=FL8S12E3'50'  New working set interval
         END   ,
*
* Finally get the dispatch lock
*
         LKCRE DISPATCH,TYPE=SPIN
         ST    RVR,DCTLOCK             Save the lock LOCATION
         EJECT ,
*
* Find out where the V=R stack area is and save the data in the DCT
*
         LR    RB,WAR                  Get our current stack
         N     RB,=X'7FFFF000'         Start of the area
         ST    RB,DCTVRST              Save the location
         MVC   DCTVRLEN,=A(16*4096)    Initial length
*
* Generate the CPU information
*
         LA    RK,16                   Maximum number of CPUs
         WHILE (RK,NZ),BEGIN
         DECR  RK                      CPU address is one less
         CLEAR RA                      Clear status register
         SIGP  RA,RK,1                 Sense the status of the CPU
         IF    O,NEXT                  Next if not op/busy
         N     RA,=X'00000011'         Check stop/receiver check bits
         IF    NZ,NEXT                 If on... don't bother with it
*
* Allocate an IPCB for this processor
*
         VMGET L'IPCB,LOC=GLOBHI,FIX=YES
         LR    RJ,RVR                  Get its address
         WITH  (IPCB,RJ)
         CLEAR IPCB
         MVC   IPCB(4),=C'IPCB'        Move in the IPCB ID
         STH   RK,IPCBCPUA             Save the CPU address
         MVC   IPCBNEXT,DCTIPCBS       Point this one at the queue
         ST    RJ,DCTIPCBS             And the header at this one
         LR    RA,RK                   Copy the CPUA
         SLL   RA,2                    Times 2
         ST    RJ,DCTIPCBT(RA)         Put this IPCB in the table
*
* Allocate and initialize a prefix page for this processor
*
         VMGET LH:=Y(4096),LOC=GLOBHI,FIX=YES
         ST    RVR,IPCBPZ              Save the address
         LR    RM,RVR                  Copy the address
         WITH  (PZERO,RM)
       $$USING PSA,PZERO+L'PZERO       Address it
         ZOT   PZERO,LH:=Y(4096)       Zero the whole page
         MVC   PZERO(L'PZPAT),PZPAT    Move in the interrupt PSWs
         MVC   PSAKDISP,=X'00FFFFFFFFFFFFFF'     Dispatch clock
         MVC   PSAKIOSV,=X'00FFFFFFFFFFFFFF'     I/O service clock
         MVC   PSAKCUR,=Y(PSAKDISP-PSA+L'PZERO)  Set to be dispatch
         STH   RK,PSACPUA              CPU Address
         STH   RK,PZLCPUA+2            Save it in PZ too
         MVI   PZLCPUA,X'80'           Make it a logical address
         L     RA,=X'80000000'         Get a bit for CPU 0
         SRL   RA,@RK                  Move it to get...
         ST    RA,PZCPUMSK             The CPU mask value
         MVC   PZMATP,IPL.PZMATP       Get the MAT pointer
*
* Get this CPU a stack
*
         L     RB,DCTVRST              Get the start of the area
         ST    RB,PSADSTK              One page of V=R stack
         AH    RB,=Y(4096)             Get to the next page
         ST    RB,DCTVRST              Save the new pointer
         L     RB,DCTVRLEN             Get the length
         SH    RB,=Y(4096)             Update it
         ST    RB,DCTVRLEN             And put the pointer back
*
* Save some other values in the page
*
         ST    RX,PSADCT               DCT pointer
         ST    RM,PSAPRFXV             Virtual prefix value
         LRA   RA,PZERO                Get the real address
         ST    RA,PSAPRFXR             Real prefix value
         ST    RJ,PSAIPCB              IPCB address
*
* Allocate some trace buffers
*
         VMGET LH:=Y(4096),LOC=GLOBHI,FIX=YES    First buffer
         LR    RA,RVR
         ZOT   @RA,LH:=Y(4096)
         ST    RA,PSATRB0              Save the address
         VMGET LH:=Y(4096),LOC=GLOBHI,FIX=YES    Second buffer
         LR    RA,RVR
         ZOT   @RA,LH:=Y(4096)
         ST    RA,PSATRB1              Save the address
         END   ,                       End of the CPU loop
*
* Allocate the global ASB
*
         ACALL NEWASB                  Get the ASB
         LR    RJ,RVR
         ST    RJ,DCTGASB              Save it in the DCT
         ST    RJ,IPL.PZCURASB         And, during init, in PZERO
*
* Now that all the memory we will need has been allocated. We
* can try the next stuff.  We'll get back to the dispatcher in
* a few minutes.
*
         LR    RVR,RJ                  Return the global ASB addr
         PEND  ,
         EJECT ,
*
* Default time slices.  The number is in units of 1 millisecond.
*
         DS    0D
DEFSLICE DC    FL8S12E3'100'           Prio 0  100ms
         DC    FL8S12E3'40'            Prio 1   40ms
         DC    FL8S12E3'20'            Prio 2   20ms
         DC    FL8S12E3'10'            Prio 3   10ms
         DC    FL8S12E3'10'            Prio 4   10ms
*
* Default wait values.  The number is in units of .1 second.
*
DEFWAIT  DC    FL8S12E5'1'             Prio 0   0.1s
         DC    FL8S12E5'10'            Prio 1   1.0s
         DC    FL8S12E5'100'           Prio 2  10.0s
         DC    FL8S12E5'0'             Prio 3   0.0s
         DC    FL8S12E5'0'             Prio 4   0.0s
*
* Default process time between working set manager calls (1 ms)
*
DEFWSIN  DC    FL8S12E3'15'            15ms
*
* Default target for maximum working set size
*
DEFWSLM  DC    F'100'                  Maximum working set size
*
* Static layout of PZERO
*
PZPS     DS    0D                      Doubleword align
         DC    X'00080000',A(INFLIH+X'80000000') Initialization
         DC    10D'0.0'
         DC    X'04080000',A(EXFLIH+X'80000000') External
         DC    X'04080000',A(SVFLIH+X'80000000') Supervisor
         DC    X'04080000',A(PIFLIH+X'80000000') Program
         DC    X'04080000',A(MCFLIH+X'80000000') Machine Check
         DC    X'04080000',A(IOFLIH+X'80000000') I/O
PZPAT    EQU   PZPS,*-PZPS,C'X'
         EJECT ,
*****************************************************************
*                                                               *
* INITDIS2 --  This routine finishes up the initialization of   *
*              the dispatcher.  It just makes sure that all     *
*              the necessary info is in each of the PZ's and    *
*              starts up all the CPU's in the configuration.    *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
INITDIS2 PROC  SCOPE=LOCAL
*
* Get our bearings
*
         L     RS,IPL.PZMATP           Get address of the MAT
         WITH  (MAT,RS),'L RX,MATDCT'  Get the DCT address
         WITH  (DCT,RX)
*
* Finish setting up the control blocks for the various CPU's
*
         STAP  IPL.PZLCPUA             Save the CPU address
         LH    RJ,IPL.PZLCPUA          Get the Current CPU address
*
* Loop through all the CPU's, starting them up
*
         L     RA,DCTIPCBS             Get the chain of IPCBs
         WHILE (RA,NZ),BEGIN
         WITH  (IPCB,RA)
         L     RN,IPCBPZ               Get the PZ for that page
         WITH  (PZERO,RN)
       $$USING PSA,PZERO+L'PZERO       Address PSA too
         STCTL 0,15,PSACTRS            Save the control register
         IF    (RJ,NE,IPCBCPUA),BEGIN  It's not this one
         LH    RS,IPCBCPUA             CPU address
         LRA   RB,PZERO                Get it in real mode
         SIGP  RB,RS,X'0D'             Set prefix
         SIGP  RB,RS,X'06'             Then restart it
         END   ,
         L     RA,IPCBNEXT             Get the next CPU
         END   ,                       Of the CPU loop
*
* Do the current CPU
*
         LR    RS,RJ                   Copy the CPU address
         SLL   RS,2                    times 4
         L     RS,DCTIPCBT(RS)         Get the IPCB address
         WITH  (IPCB,RS),BEGIN
         L     RB,IPCBPZ               Get the PZ address
         WITH  (PZERO,RB)
       $$USING PSA,PZERO+L'PZERO       Address PSA too
         SPX   PSAPRFXR                Set the prefix here
         END   ,
         DROP  IPL
         USING PZERO,R0
         LPSW  PZRSNPSW                Go into restart processing
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
* INITDIS3 --  This routine takes care of dispatcher            *
*              initialization that must take place under an     *
*              address space.   It is called first thing from   *
*              SYSTASK.                                         *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
INITDIS3 PROC  SCOPE=GLOBAL
*
* Get the ASB chain lock
*
         L     RY,MATPTR               Get the Mat pointer
         WITH  (MAT,RY)
         LKCRE ASBCHAIN                Create the lock
         ST    RVR,MATASBL             Save the lock id
*
* Free any remaining V=R area so the pages may be reused.
*
         L     RX,MATDCT               Get the DCT address
         WITH  (DCT,RX)
         VMFREE L:DCTVRLEN,A=L:DCTVRST,LOC=GLOBLO,FIX=YES,FETP=YES
         IF    (RVR,NZ),'ABORT FREEVR'
         PEND  ,
         EJECT
         LTORG ,
         XTRCDATA  ,                   Generate the trace info
         END   .
