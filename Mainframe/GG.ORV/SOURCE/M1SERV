M1SERV   TITLE 'ORVYL''S Mode 1 System Services'
         COPY  HEADER
M1SERV   MODULE TRCNUM=9
         SPACE 3
         PRINT OFF                     PSA, CVT, ASCB
         EJECT
         IHAPSA
         EJECT
         IHAASCB
         EJECT
         CVT   DSECT=YES
M1SERV   CSECT
         PRINT ON
         EJECT
SCVT     RECORD BEGIN
         SCIPCVT PFX=SCV
         END   ,
         EJECT
         COPY  PZERO
         USING PZERO,R0
         EJECT
         COPY  MAT
         EJECT
         COPY  ASB
         EJECT
         COPY  PARMPARM
         SPACE 3
         COPY  VMPARM
         EJECT
         COPY  PAGEPARM
         EJECT
         COPY  DISPPARM
         EJECT
         COPY  SEXIPARM
         EJECT
         COPY  XITPARM
         EJECT
         COPY  ENQPARM
         SPACE 4
         COPY  LOCKPARM
         EJECT
         COPY  SEGPARM
         EJECT
         COPY  TIMEPARM
         EJECT
         COPY  ACCTPARM
         EJECT
         COPY  TERMPARM
         EJECT
         COPY  FILEPARM
         EJECT
         COPY  UPTHPARM
         EJECT
         COPY  UJESPARM
         EJECT
         COPY  UNETPARM
         EJECT
         COPY  XASPARM             Cross address space parms
         EJECT
         COPY  CACHPARM            Caching routines parameters
         EJECT ,
         COPY  SBPARM
         EJECT ,
         COPY  SLISTMAC
         EJECT ,
         COPY  SIGPARM
         EJECT
*******************************************************************
*                                                                 *
*     UTRACE -  Mode 1 Trace request                              *
*                                                                 *
*******************************************************************
         SPACE
         MACRO
&L       UTRACE &CLASS=,&CODE=,&PSW=SCPPSW,&DATA=
.*
.* Mode 1 local session trace
.*
         LCLA  &CLSNUM,&DWC,&DWI,&DWL
         PSET  @UTRACE,CLEAR=NO
.*
.* Determine trace class
&CLSNUM  SETA  0
         AIF   ('&CLASS' EQ 'SVC').GOTCLS
&CLSNUM  SETA  1
         AIF   ('&CLASS' EQ 'PI').GOTCLS
&CLSNUM  SETA  2
         AIF   ('&CLASS' EQ 'PER').GOTCLS
&CLSNUM  SETA  3
         AIF   ('&CLASS' EQ 'MON').GOTCLS
&CLSNUM  SETA  4
         AIF   ('&CLASS' EQ 'IO').GOTCLS
&CLSNUM  SETA  5
         AIF   ('&CLASS' EQ 'TIMER').GOTCLS
&CLSNUM  SETA  6
         AIF   ('&CLASS' EQ 'ATTN').GOTCLS
&CLSNUM  SETA  7
         AIF   ('&CLASS' EQ 'RUNCLP').GOTCLS
&CLSNUM  SETA  8
         AIF   ('&CLASS' EQ 'RUNUSER').GOTCLS
&CLSNUM  SETA  9
         AIF   ('&CLASS' EQ 'UXIT').GOTCLS
         MNOTE 8,'INVALID TRACE CLASS'
         MEXIT
.GOTCLS  ANOP
         MVI   @UTCLASS,&CLSNUM
.*
.* Add sub-class
.*
         AIF   (N'&CODE NE 1).NOCODE
         PMOV  @UTCODE,&CODE
         AGO   .CODEOK
.NOCODE  ANOP
         CLEAR @UTCODE
.CODEOK  ANOP
.*
.* Add current PSW
.*
         AIF   (N'&PSW NE 1).NOPSW
         PMOV  @UTPSW,&PSW
         AGO   .PSWOK
.NOPSW   ANOP
         CLEAR @UTPSW
.PSWOK   ANOP
.*
.* Add the data words
.*
&DWC     SETA  0
&DWI     SETA  N'&DATA
.DATLOOP AIF   (&DWC EQ &DWI).DATEND
&DWL     SETA  &DWC*4
         MVC   @UTDATA+&DWL.(4),&DATA(&DWC+1)
&DWC     SETA  &DWC+1
         AGO   .DATLOOP
.DATEND  ANOP
.*
.* Set the number of data words
.*
         MVI   @UTDWC,&DWC
.*
.* Call the trace routine
.*
         ACALL  UTRACE
         MEND
         EJECT
*******************************************************************
*                                                                 *
*     M1CT   -  Mode 1 Control Table                              *
*                                                                 *
*******************************************************************
         SPACE
M1CT     RECORD BEGIN
CTID     DC    CL4'M1CT'               ID
*
*  SHARED PROGRAM CONTROL
*
CTSPBS   DS    A                       SPB CHAIN
CTSPBCLK DS    A                       SPB CHAIN LOCK ID
CTSPBLLK DS    A                       SPB LOADING LOCK ID
CTSPBSIZ DS    A                       SHARED PROGRAM RESERVE SIZE
         DS    A                       Available
*
*  SET 21 CONTROL
*
CTST21LK DS    A                       SET 21 QUEUE LOCK
CTST21QH DS    A                       SET 21 WAIT QUEUE HEAD
CTST21QT DS    A                       SET 21 WAIT QUEUE TAIL
*
*  USER PROGRAM PARAMETERS
*
CTUMORG  DS    A                       USER ADDRESS SPACE ORIGIN
CTUMSIZ  DS    A                       USER ADDRESS SPACE SIZE
CTUMAP   DS    A                       USER MAP SIZE
CTTRCSIZ DS    A                       Size of a trace buffer
CTNTRACE DS    H                       Number of trace buffers
CTUMPGS  DS    H                       MAXIMUM NUMBER OF PAGES
CTNIDT   DS    H                       NUMBER OF IDTS
CTNENQ   DS    H                       NUMBER OF ENQS
CTTRASH  DS    X                       DEFAULT PAGE TRASH BYTE
CTJESR   DS    X                       MAXIMUM JES DEVICES
*
*  JES DISPLAY INFORMATION
*
CTJDCNT  DS    A                       NUMBER OF JES DISPLAYS
CTJDPTRS DS    A                       ADDRESSES AND LENGTHS OF BUFS
*
*  OTHER STUFF
*
CTASCB   DS    A                       MVS ASCB
CTSCVT   DS    A                       POINTER TO SCIP CVT
         DS    A
CTPCAT   DS    A                       PROGRAM CATALOG
         DS    A                       AVAILABLE
*
CTMFL    FLAG  ,                       MORE FLAGS
         FLAG  CTMFPATH                PATHS ARE NOT AVAILABLE
         FLAG  CTMFOSF                 OS FILES ARE NOT AVAILABLE
         FLAG  CTMFKEY                 KEYWORD FILE IS NOT AVAILABLE
         FLAG  CTMFJES                 JES READERS NOT AVAILABLE
         FLAG  CTMFNET                 NETWORK NOT AVAILABLE
*
*  COUNTERS
*
CTPGRELS DS    A                       Number of pages released
CTPGCLRS DS    A                       Number of page "clears"
CTVMSTAT DS    A                       --> VM Statistics
         END   ,
         EJECT ,                       -->
VMSTAT   RECORD BEGIN
VHRTNCNT DS    A                       Number of times through list
VHRTNPTR DS    A                       Routine pointer
VHSTCK   DS    D                       TOD place
VHRTN    DS    (508)A
MXRTN    EQU   (*-VHRTN)-12
         END   ,                       -->
         EJECT
         COPY  SCP
         EJECT
         COPY  SPB
         EJECT
         COPY  SSB
         SPACE 5
         COPY  SSAB
         SPACE 2
*
@SSWA    RECORD BEGIN
@SSNAME  DS    CL(L'SSBNAME)       Working SSB name
@SSWORD  DS    A                   Return value
@SSRV    DS    F                   Return code
         END
         EJECT
*******************************************************************
*                                                                 *
*   @UTRACE  -  Mode 1 Trace Table Entry                          *
*                                                                 *
*******************************************************************
         SPACE
@UTRACE  RECORD BEGIN
@UTCLASS DS    X                       Entry type
*
@UTLSVC  EQU   0                       SVC
@UTLPI   EQU   1                       Program Interrupt
@UTLPER  EQU   2                       PER
@UTLMON  EQU   3                       Monitor
@UTLIO   EQU   4                       I/O
@UTLTIME EQU   5                       Timer
@UTLATTN EQU   6                       Attention
@UTLRCLP EQU   7                       Run Clp
@UTLRUSE EQU   8                       Run User
@UTLUXIT EQU   9                       User exit
*
@UTCODE  DS    XL2                     Code (sub-class)
*
@UTCTIME EQU   0
@UTCWAIT EQU   1
@UTCATTN EQU   2
@UTCPAN  EQU   3
@UTCSVC  EQU   4
*
@UTDWC   DS    X                       Data word count
@UTPSW   DS    XL8                     Interrupt PSW
*
@UTBASIC EQU   @UTCLASS,*-@UTCLASS,C'X'
@UTDATA  DS    4A                      Variable data
         END
         EJECT
*******************************************************************
*                                                                 *
*   UTRHDR  -  Mode 1 Trace Table Buffer header                   *
*                                                                 *
*******************************************************************
         SPACE
UTRHDR   RECORD BEGIN
UTRCHAIN DS    A                       Next buffer in chain
UTRNEXT  DS    A                       Next entry in buffer
UTREND   DS    A                       End of this buffer
UTRSTART DS    0A                      Start of trace entries
         END
         EJECT
         KWREC FLAGS
         EJECT
*******************************************************************
*                                                                 *
*    INITWORK - Mode 1 initialization work area                   *
*                                                                 *
*******************************************************************
         SPACE
M1IWORK  RECORD BEGIN
M1IRDMEM DS    3A                      Area for MVS memory reads
M1IRDPRM DS    XL(L'PARMIN)            Area for PARMIN
         DS    CL8                     Key 1
M1IKEY2  DS    CL8                     Key 2
         DS    CL8                     Key 3
*
M1IPSTR  DS    CL80                String parameter area
*
M1INAME  DS    CL8                 Shared Name
M1IPROG  DS    CL8                 Program name
M1IFILE  DS    CL44                File name
*
M1ICVD   DS    D                   Work area for conversion
*
M1ENDSPB DS    A                   Last SPB created
         END   ,

*******************************************************************
*                                                                 *
*    IDT  - Mode 1 device table entry                             *
*                                                                 *
*******************************************************************
         SPACE
IDT      RECORD BEGIN
         DS    CL4'IDT'
*
IDTFLG   FLAG  ,                       FLAGS
         FLAG  IDTFA                   ATTACHED BY USER
         FLAG  IDTFACL                 ATTACHED BY COMMAND LANGUAGE
         FLAG  IDTFR1                  VALUE FOR REG. 1
         FLAG  IDTFR14                 VALUE FOR REG. 14
         FLAG  IDTFR15                 VALUE FOR REG. 15
*
IDTWFLG  FLAG  ,                       WAIT PROCESSING FLAGS
         FLAG  IDTFWD                  WAIT DONE ON THIS REQUEST
         FLAG  IDTFPOST                REQUEST COMPLETE
         FLAG  IDTFEWX                 ENTER WAIT EXIT ROUTINE
         FLAG  IDTFEAX                 ENTER ATTN EXIT AT WAIT
         FLAG  IDTFFIDT                FREE IDT AT WAIT
*
IDTCLASS FLAG  ,                       DEVICE CLASS
         FLAG  (IDTCTRM,1,EQ)          TERMINAL
         FLAG  (IDTCFIL,2,EQ)          ORVYL FILES
         FLAG  (IDTCOSF,3,EQ)          OS FILES
         FLAG  (IDTCSCM,4,EQ)          PATH
         FLAG  (IDTCENQ,5,EQ)          ENQUEUE/DEQUEUE
         FLAG  (IDTCJES,6,EQ)          JES READER
         FLAG  (IDTCNET,7,EQ)          Network Socket
         FLAG  (IDTCKEY,8,EQ)          KEYWORD FILE
*
IDTID    DS    X                       ID NUMBER
*
*  WAIT RETURN REGISTERS
*
IDTR1    DS    A                       REG. 1 RETURN
IDTR14   DS    A                       REG. 14 RETURN
IDTR15   DS    A                       REG. 15 RETURN
*
*  EXIT INFO
*
IDTAXEP  DS    A                       ATTN EXIT ENTRY POINT
IDTAXI   DS    A                       USER POINTER FOR ATTNTION EXIT
IDTWXEP  DS    A                       WAIT EXIT ENTRY POINT
IDTWXI   DS    A                       USER POINTER FOR WAIT EXIT
*
*  DEVICE INFO
*
IDTDEVID DS    A                       DEVICE ID
*
*  TERMINAL SAVE INFO
*
IDTTRFL  DS    XL1
         DS    0A
IDTTRRG  DS    XL12                     REGISTER SAVE AREA
*
IDTNEXT  DS    0D
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    M1SVINIT - Mode 1 Program Services Initialization            *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1SVINIT PROC  ,M1IWORK,SCOPE=GLOBAL
         WITH  (PARMIN,M1IRDPRM)
*
*  FIRST CREATE THE CT
*
         VMGET L'M1CT,LOC=GLOBHI
         IF    ('LTR  RY,RVR',Z),'ABORT NOCT'
         WITH  (M1CT,RY)
         EJECT
*
*  CLEAR IT AND SET ID
*
         LA    R1,L'M1CT
         CLEAR R15
         MVCL  R0,R14                  CLEAR THE CT
         MVC   CTID(4),=CL4'M1CT'       AND SET ID
*
*  CONNECT CT TO MAT
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'ST  RY,MATM1CT'   CT POINTER
*
*  CREATE SPB CHAIN LOCK
*
         LKCRE SPBCHAIN
         IF    (RVR,Z),'ABORT SPBCLOCK'
         ST    RVR,CTSPBCLK            SAVE LOCK ID
*
*  SET UP SET 21 WAIT CHAIN
*
         LA    R15,CTST21QH            Dummy element
         ST    R15,CTST21QH            Set Queue head
         ST    R15,CTST21QT             and Queue tail
*
*  CREATE SET 21 QUEUE LOCK
*
         LKCRE SET21QUEUE
         IF    (RVR,Z),'ABORT ST21LOCK'
         ST    RVR,CTST21LK            SAVE LOCK ID
*
*  Set maximum program map size
*
         MVC   CTUMAP,=A(192*1024)     MAP SIZE
         GETPARM2 KEY=(MODE1,MAPSIZE),TYPE=INT,REGS=(RA,RJ)
         IF    Z,'ST  RA,CTUMAP'       It was specified
*
*  Get maximum number of IDT's
*
         MVC   CTNIDT,=Y(64)           DEFAULT NUMBER OF IDTS
         GETPARM2 KEY=(,DEVICES),TYPE=INT,REGS=(RA,RJ)
         IF    Z,BEGIN                 It was specified
         CEIL  RA,250                  Not too many
         STH   RA,CTNIDT
         END   ,
*
*  Get maximum number of Enqueues
*
         MVC   CTNENQ,=Y(8)            DEFAULT NUMBER
         GETPARM2 KEY=(,ENQUEUES),TYPE=INT,REGS=(RA,RJ)
         IF    Z,BEGIN                 It was specified
         STH   RA,CTNENQ
         END
*
*  Get Mode 1 trace table size
*
         MVC   CTTRCSIZ,=A(1024)       DEFAULT
         GETPARM2 KEY=(,TRCSIZE),TYPE=INT,REGS=(RA,RJ)
         IF    Z,'ST  RA,CTTRCSIZ'     It was specified
*
*  Get number of trace buffers
*
         MVC   CTNTRACE,=Y(2)          DEFAULT NUMBER
         GETPARM2 KEY=(,TRCBUFF),TYPE=INT,REGS=(RA,RJ)
         IF    Z,'STH  RA,CTNTRACE'    It was specified
*
*  Set up memory values
*
         PSET  @VMINFO
         VCALL VMINFO                  GET SOME NEWS
         MVC   CTUMORG,@VMIUST         USER MEMORY ORIGIN
         MVC   CTUMSIZ,@VMIULEN        USER MEMORY LENGTH
         MVC   CTTRASH,@VMITRSH        SYSTEM TRASH BYTE
*
*  Set maximum user memory
*
         L     RA,CTUMSIZ              Default number
         SRL   RA,12                     of
         STH   RA,CTUMPGS                  pages
         GETPARM2 KEY=(,REGION),TYPE=INT,REGS=(RA,RJ)
         IF    Z,BEGIN                 It was specified
         SRL   RA,2                    Divide by 4
         STH   RA,CTUMPGS              Save specified value
         END   ,
*
*  Default shared memory size
*
         LH    RS,CTUMPGS              Maximum user pages
         S     RS,=A(2)                Less minimum work area
         SLL   RS,12                   Convert to bytes
         CEIL  RS,=A(2*1024*1024)      Max it out
         ST    RS,CTSPBSIZ             SHARED PROGRAM RESERVE
*-
*-       Build shared program list.
*-
         CLEAR M1ENDSPB            Initialize
*
SHPGMKEY RECORD BEGIN
SHBASE   DC    C'SHARED'
SHNUM    DC    C'00'
         END   ,
*
NUMSHARED EQU  99
         WITH  (SHPGMKEY,M1IKEY2),BEGIN
         MVC   SHBASE,=C'SHARED'
         END   ,
         LA    RM,NUMSHARED
         LOOP  BEGIN
         WITH  (SHPGMKEY,M1IKEY2)
         LA    RA,NUMSHARED+1          Convert to number
         SR    RA,RM
         CVD   RA,M1ICVD
         UNPK  SHNUM,M1ICVD
         OI    SHNUM+1,X'F0'
*-
*-       Build an SPB from the 'SHAREDxx' block parameters.
*-
         BEGIN ,                       Try for valid entry
         CLEAR M1INAME             Reset work fields
         CLEAR M1IPROG
         CLEAR M1IFILE
*
*  Name
*
         GETPARM2 M1IPSTR,KEY=(,,NAME),TYPE=STRING,                    *
               REGS=(RA,RJ)
         IF    NZ,EXIT                 This doesn't exist
         IF    (RB,GT,8),EXIT
         MVC   M1INAME,=CL8' '
         DEX   RB,'MVC M1INAME(0),@RA'
*
*  Program name (if different from name)
*
         GETPARM2 M1IPSTR,KEY=(,,PROGNAME),TYPE=STRING,                *
               REGS=(RA,RJ)
         IF    Z,BEGIN             Prog name specified...
         IF    (RB,GT,8),EXIT
         MVC   M1IPROG,=CL8' '
         DEX   RB,'MVC M1IPROG(0),@RA'
         END
*
*  Library name
*
         GETPARM2 M1IPSTR,KEY=(,,LIB),TYPE=STRING,                     *
               REGS=(RA,RJ)
         IF    NZ,EXIT                 This doesn't exist
         IF    (RB,GT,44),EXIT         Invalid
         MVC   M1IFILE,=CL44' '
         DEX   RB,'MVC M1IFILE(0),@RA'
*
*  Build an SPB
*
*         VMGET L'SPB,LOC=GLOBLO,TYPE=DATA
         VMGET L'SPB,LOC=GLOBHI,TYPE=PROG
         IF    ('LTR  RN,RVR',Z),'ABORT SPBMEM'
         WITH  (SPB,RN)
         CLEAR SPB                     Nice and tidy
         MVC   SPBID,=CL4'SPB'
         MVC   SPBNAME,M1INAME     Name
         MVC   SPBPROG,M1IPROG     Program name
         IF    (SPBPROG,Z),'MVC SPBPROG,SPBNAME'
         MVC   SPBFILE,M1IFILE     File name
*
*  Add SPB to end of chain.
*
         IF    (CTSPBS,Z),'ST RN,CTSPBS'  First SPB
*
         LT    RB,M1ENDSPB         Last SPB created
         IF    NZ,'ST RN,SPBNEXT-SPB(,RB)'
         ST    RN,M1ENDSPB
*
*  Read in size of program
*
         MVC   SPBSIZE,CTSPBSIZ
         GETPARM2 KEY=(,,SIZE),REGS=(RA,RJ)
         IF    ZERO,BEGIN
         SLL   RA,10                   K to bytes
         ST    RA,SPBSIZE
         END   ,
*
*  Check for protection
*
         SET   SPBFPRT                 Default is protected
         GETPARM2 M1IPSTR,KEY=(,,PROT),TYPE=YESNO,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         CLI   M1IPSTR,C'N'
         IF    NE,EXIT
         CLEAR SPBFPRT
         END   ,
*
*  Check for AUTHORIZED program
*
         GETPARM2 M1IPSTR,KEY=(,,AUTH),TYPE=YESNO,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         CLI   M1IPSTR,C'Y'
         IF    NE,EXIT
         SET   SPBFAUTH
         END   ,
*
*  Check for load above the 16m line
*
         GETPARM2 M1IPSTR,KEY=(,,LOADHI),TYPE=YESNO,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         CLI   M1IPSTR,C'Y'
         IF    NE,EXIT
         SET   SPBFLHI
         SET   SPBFM31             Has to be started in 31 bit mode
         END   ,
*
*  Check for run in 31 bit mode
*
         GETPARM2 M1IPSTR,KEY=(,,MODE31),TYPE=YESNO,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         CLI   M1IPSTR,C'Y'
         IF    NE,EXIT
         SET   SPBFM31
         END   ,
*-
*-       Check for REFRESH={YES|NO}
*-         This controls what happens when there are no users.
*-
         GETPARM2 M1IPSTR,KEY=(,,PURGABLE),TYPE=YESNO,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         CLI   M1IPSTR,C'Y'
         IF    NE,EXIT
         SET   SPBFPURGABLE
         END   ,
*
*  Check for SPIRES flag
*
         GETPARM2 M1IPSTR,KEY=(,,SPIRES),TYPE=YESNO,REGS=(RA,RJ)
         IF    ZERO,BEGIN
         CLI   M1IPSTR,C'Y'
         IF    NE,EXIT
         SET   SPBFSPI
         END   ,
         END   ,                       OF Try for valid entry
         UNTIL (BCT,RM),END
*
*  INITIALIZE MISCELLANEOUS FIELDS
*
         MVI   CTJESR,1                MAXIMUM ATTACHED JES READERS
         SET   CTMFOSF                 OS FILES ARE NOT AVAILABLE
         SET   CTMFKEY                 KEYWORD FILE IS NOT AVAILABLE
*
*  GET POINTER TO MVS CVT
*
         LA    RA,M1IRDMEM             WORK AREA
         LA    RB,4                    ONE WORD
         LA    R14,CVTPTR              LOCATION
         CLEAR R15                     KEY
         SYSCTL RA,R14,TYPE=MVSMRD     GET ADDRESS
*
*  GET POINTER TO "SCIP" CVT
*
         L     R14,M1IRDMEM            ADDRESS OF MVS CVT
         CLEAR R15                     KEY
         WITH  (CVT,R14),'LA  R14,CVTUSER'   "SCIP" CVT
         LA    RA,M1IRDMEM             WORK AREA
         LA    RB,4                    ONE WORD
         SYSCTL RA,R14,TYPE=MVSMRD     GET ADDRESS
*
*  VALIDATE THE "SCIP" CVT
*
         L     RJ,M1IRDMEM            ADDRESS OF "SCIP" CVT
         IF    (RJ,NZ),BEGIN
         WITH  (SCVT,RJ)
         LA    R14,SCVT                ID FIELD
         CLEAR R15                     KEY
         LA    RA,M1IRDMEM             WORK AREA
         LA    RB,4                    ONE WORD
         SYSCTL RA,R14,TYPE=MVSMRD     GET ID
         IF    (M1IRDMEM,NE,=CL4'SCIP'),EXIT   MUST NOT BE IT
         ST    RJ,CTSCVT               SAVE "SCIP" CVT POINTER
*
*  GET THE JES DISPLAY POINTER
*
         LA    R14,SCVJESDB            JES DISPLAY BUFFER
         CLEAR R15                     KEY
         LA    RA,M1IRDMEM             WORK AREA
         LA    RB,4                    ONE WORD
         SYSCTL RA,R14,TYPE=MVSMRD     GET JES INFO
*
*  GET THE NUMBER OF JES DISPLAYS
*
         IF    ('LT  RK,M1IRDMEM',Z),EXIT   NO JES STUFF
         LR    R14,RK                  JES AREA
         CLEAR R15                     KEY
         LA    RA,M1IRDMEM             WORK AREA
         LA    RB,4                    ONE WORD
         SYSCTL RA,R14,TYPE=MVSMRD     GET JES DISPLAY COUNT
*
*  GET THE JES DISPLAY POINTERS
*
         IF    ('LT  RB,M1IRDMEM',Z),EXIT   NO JES DISPLAYS
         ST    RB,CTJDCNT              SET COUNT IN CT
         SLL   RB,3                    TIMES 8
         VMGET (RB),LOC=GLOBHI
         IF    ('LTR  RA,RVR',Z),'ABORT JDINFO'
         ST    RA,CTJDPTRS             AREA
         LA    R14,@RK+4               JES POINTER AREA
         CLEAR R15                     KEY
         SYSCTL RA,R14,TYPE=MVSMRD     GET JES BUFFER POINTERS
         END   ,
*
*  GET POINTER TO MVS ASCB
*
         LA    RA,CTASCB               PLACE FOR POINTER
         LA    RB,4                    ONE WORD
         PUSH  USING
         USING (PSA,R0)
         LA    R14,PSAAOLD             MVS LOCATION OF ASCB
         POP   USING
         CLEAR R15                     KEY
         SYSCTL RA,R14,TYPE=MVSMRD     GET ADDRESS
*  -->
*  Allocate stats buffer
         VMGET L:=A(4096),LOC=GLOBHI,FIX=YES,PAGE=YES
         ST    RVR,CTVMSTAT
         L     R1,=A(4096)
         CLEAR R15
         MVCL  R0,R14                  -->
*
*  SET UP PROGRAM CATALOG
*
         VMGET L:=A(4096),LOC=GLOBLO   GET THE PROGRAM CATALOG AREA
         IF    (RVR,Z),'ABORT NOPCAT'
         ST    RVR,CTPCAT              SET ADDRESS
         L     R1,=A(4096)             CLEAR
         CLEAR R15                      THE
         MVCL  R0,R14                    AREA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    UTRACE - Mode 1 Services Local Trace Routine                 *
*                                                                 *
*                                                                 *
*     Input - @UTRACE                                             *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
UTRACE   PROC  @UTRACE
         WITH  (SCP,RY)
*
*  Test for tracing active
*
         IF    ('LT  RB,SCPTRACE',Z),EXIT
         WITH  (UTRHDR,RB)
         IF    (SCBFCLP,AND,^SCPFTRC),EXIT
         IF    (^SCBFCLP,AND,^SCPFTRU),EXIT
*
*  Get size of entry
*
         LC    RA,@UTDWC               Get data word count
         SLL   RA,2                     to bytes
         LA    RA,@RA+L'@UTBASIC       Total size of entry
         L     RJ,UTRNEXT              Next entry location
         LA    RS,@RJ(RA)              End of this entry
*
*  If entry won't fit get next buffer
*
         IF    (RS,GT,UTREND),BEGIN
         L     RB,UTRCHAIN             Next buffer on the list
         ST    RB,SCPTRACE
         LA    RJ,UTRSTART             First entry location
         ST    RJ,UTRNEXT
         LA    RS,@RJ(RA)              End of this entry
         END   ,
*
*  Move in data and update pointer if ok
*
         IF    (RS,LT,UTREND),BEGIN
         DEX   RA,'MVC  @RJ(0),@UTRACE'
         ST    RS,UTRNEXT
         END
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1LOGON - Mode 1 Services Logon Processing                   *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1LOGON  PROC  ,SCOPE=GLOBAL
*
*  First get user information
*
         VCALL TERMINUI
*
*  CREATE THE SCP
*
         VMGET L'SCP,LOC=LOCSYS,TYPE=PROG,FIX=YES
         IF    ('LTR  RY,RVR',Z),'ABORT NOSCP'
*
*  CLEAR IT AND SET ID
*
         LA    R1,L'SCP                LENGTH OF THE SCP
         CLEAR R15
         MVCL  R0,R14                  CLEAR THE SCP
         WITH  (SCP,RY)
         MVC   SCPID,=CL4'SCP'         SET ID
*
*  CONNECT SCP TO ASB
*
         L     RA,PZCURASB             CURRENT ASB
         WITH  (ASB,RA),'ST  RY,ASBM1SCP'  SCP POINTER
*
*  INITIALIZE SCP FIELDS
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA),BEGIN
         MVC   SCPRRSEG,CTUMORG        ADDRESS SPACE ORIGIN
         MVC   SCPUMSIZ,CTUMSIZ         AND SIZE
         MVC   SCPUNRSV,CTUMPGS        MAXIMUM NUMBER OF PAGES
         MVC   SCPNIDT,CTNIDT          NUMBER OF IDTS
         MVC   SCPNENQ,CTNENQ          NUMBER OF ENQUEUES
         MVC   SCPTRASH,CTTRASH        DEFAULT TRASH BYTE
         MVC   SCPPCAT,CTPCAT          PROGRAM CATALOG POINTER
         MVC   SCPUMAP,CTUMAP          MAP SIZE
         MVI   SCBUPRI,X'0F'           USER PRIORITY (PHONY)
         SET   SCPFTRU                 Set user trace on
*
*  Set up the trace buffers
*
         IF    ('LTH  RS,CTNTRACE',NZ),BEGIN
         CLEAR RJ
         LOOP  BEGIN
         L     R15,CTTRCSIZ             Size of the trace buffer
         VMGET (R15),LOC=LOCSYS,TYPE=PROG,FIX=YES    Get one
         IF    (RVR,Z),EXIT            No room
         LR    RB,RVR
         IF    (RJ,Z),'LR  RJ,RB'      First buffer address
         WITH  (UTRHDR,RB)
         MVC   UTRCHAIN,SCPTRACE       Set up the chain
         ST    RB,SCPTRACE
         LA    R15,UTRSTART            Start of data
         ST    R15,UTRNEXT             Next entry pointer
         L     R15,CTTRCSIZ
         LA    R15,UTRHDR(R15)         End of data
         ST    R15,UTREND
         UNTIL (BCT,RS),END
         END
         IF    (RJ,NZ),BEGIN
         WITH  (UTRHDR,RJ)
         ST    RB,UTRCHAIN             Make chain circular
         END
         END
*
*  GET LOGGED ON ACCOUNT
*
         PSET  @ACAINFO
         MVC   @ACAASB,PZCURASB        CURRENT ASB
         VCALL ACAINFO                 GET INFO
         MVC   SCPGROUP,@ACAUID+3      GROUP
         MVC   SCPUSER,@ACAUID          USER ID
         MVC   SCPPRIV,MILPRIV           AND PRIVS
         MVI   SCPACCT+2,C'.'          HEY, DON'T FORGET THE DOT
*
*  CREATE THE CLW
*
         L     RS,=A(4096)             LENGTH OF THE CLW
         VMGET (RS),LOC=LOCSYS,TYPE=PROG
         IF    (RVR,Z),'ABORT NOCLW'
         ST    RVR,SCPCLW              SET THE CLW ADDRESS
*
*  CLEAR IT
*
         CLEAR R15
         MVCL  R0,R14                  CLEAR THE CLW
         EJECT
*
*  CREATE THE ENQUEUE ID TABLE
*
         LH    RS,SCPNENQ              NUMBER OF ENQUEUES
         SLL   RS,2                    EACH ENTRY IS 4 BYTES
         VMGET (RS),LOC=LOCSYS,TYPE=PROG,FIX=YES
         IF    (RVR,Z),'ABORT NOENQTAB'
         ST    RVR,SCPENQL             SET THE ADDRESS
         CLEAR R15
         MVCL  R0,R14                  CLEAR THE TABLE
*
* ALLOCATE AND INITIALIZE IDT'S
*
         LH    RS,SCPNIDT              NUMBER OF IDTS
         MH    RS,=Y(L'IDT)            ALLOCATE IDT PAGES
*         VMGET (RS),LOC=LOCSYS,TYPE=PROG,FETP=YES
         VMGET (RS),LOC=LOCSYS,FETP=YES Above the 16 meg line
         IF    ('LTR RS,RVR',Z),'ABORT NOIDTS'
         ST    RS,SCPIDT               SAVE ADDRESS
         CLEAR R14
         LOOP  BEGIN
         WITH  (IDT,RS)
         LA    R14,@R14+1              COUNT THIS IDT
         CLEAR IDT
         STC   R14,IDTID               SAVE THE DEVICE ID
         MVC   IDT(4),=CL4'IDT'        EYE CATCHER
         LA    RS,IDTNEXT              GET TO THE NEXT ONE
         UNTIL (R14,EQ,SCPNIDT),END    TILL NO MORE ARE LEFT
         STH   R14,SCPQIDT             LAST IS FOR ENQ/DEQ
         EJECT
*
*  ESTABLISH PROGRAM INTERRUPT EXIT
*
         PSET  @EXRADD
         WITH  (XITMSKD,@EXRTYPE),'SET  XITMPI+XITMPER+XITMMON'
         MVC   @EXRPSW(4),=X'070C0000'  SET PSW
         MVC   @EXRPSW+4(4),=A(M1PGM+X'80000000')
         SET   @EXRAFS                 THIS IS A SYSTEM EXIT
         ST    RY,@EXRPARM             SCP IS EXIT PARM
         VCALL EXRADD                  CREATE THE EXIT
*
*  ESTABLISH SUPERISOR CALL INTERRUPT EXIT
*
         CLEAR @EXRADD
         WITH  (XITMSKD,@EXRTYPE),'SET  XITMSVC'
         MVC   @EXRPSW(4),=X'070C0000'  SET PSW
         MVC   @EXRPSW+4(4),=A(M1SVC+X'80000000')
         SET   @EXRAFS                 THIS IS A SYSTEM EXIT
         ST    RY,@EXRPARM             SCP IS EXIT PARM
         VCALL EXRADD                  CREATE THE EXIT
*
*  ESTABLISH TIMER COMPLETE EXIT
*
         CLEAR @EXRADD
         WITH  (XITMSKD,@EXRTYPE),'SET  XITMRTC+XITMCTC'
         MVC   @EXRPSW(4),=X'070C0000'  SET PSW
         MVC   @EXRPSW+4(4),=A(M1TMC+X'80000000')
         SET   @EXRAFS                 THIS IS A SYSTEM EXIT
         ST    RY,@EXRPARM             SCP IS EXIT PARM
         VCALL EXRADD                  CREATE THE EXIT
*
*  ESTABLISH I/O COMPLETE EXIT
*
         CLEAR @EXRADD
         WITH  (XITMSKD,@EXRTYPE),'SET  XITMIOCN+XITMIOCA'
         MVC   @EXRPSW(4),=X'070C0000'  SET PSW
         MVC   @EXRPSW+4(4),=A(M1IOC+X'80000000')
         SET   @EXRAFS                 THIS IS A SYSTEM EXIT
         ST    RY,@EXRPARM             SCP IS EXIT PARM
         VCALL EXRADD                  CREATE THE EXIT
         EJECT
*
*  ESTABLISH ATTENTION EXIT
*
         CLEAR @EXRADD
         WITH  (XITMSKD,@EXRTYPE),'SET  XITMATTN'
         MVC   @EXRPSW(4),=X'070C0000'  SET PSW
         MVC   @EXRPSW+4(4),=A(M1ATTN+X'80000000')
         SET   @EXRAFS                 THIS IS A SYSTEM EXIT
         ST    RY,@EXRPARM             SCP IS EXIT PARM
         VCALL EXRADD                  CREATE THE EXIT
*
*  ESTABLISH LOGOFF EXIT
*
         PSET  @EXRADD
         WITH  (XITMSKD,@EXRTYPE),'SET  XITMLGO'
         MVC   @EXRPSW(4),=X'070C0000'  SET PSW
         MVC   @EXRPSW+4(4),=A(M1LGOFF+X'80000000')
         SET   @EXRAFS                 THIS IS A SYSTEM EXIT
         ST    RY,@EXRPARM             SCP IS EXIT PARM
         VCALL EXRADD                  CREATE THE EXIT
*
*  ENABLE EXITS
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMSVC+XITMPI          SVC AND PROGRAM EXITS
         SET   XITMIOCN+XITMIOCA       NORMAL AND ERROR I/O EXITS
         SET   XITMPER+XITMMON         PER AND MONITOR EXITS
         SET   XITMRTC+XITMCTC         REAL AND CPU TIMER EXITS
         SET   XITMATTN                ATTENTION EXITS
         SET   XITMLGO                 LOGOFF EXITS
         VCALL XITMASK
*
*  CREATE USER TIMER EXIT ID
*
         PSET  @XITNEW
         VCALL XITNEW                  CREATE AN EXIT
         ST    RVR,SCPUCXIT            USER CLOCK EXIT ID
         EJECT
*
*  CREATE CLP TIMER EXIT ID
*
         PSET  @XITNEW
         VCALL XITNEW                  CREATE AN EXIT
         ST    RVR,SCPCCXIT            CLP CLOCK EXIT ID
*
*  CREATE ENQUEUE POST EXIT ID
*
         PSET  @XITNEW
         VCALL XITNEW                  CREATE EXIT
         ST    RVR,SCPEPXIT            SAVE EXIT ID
*
*  SET UP ENTRY TO CLP
*
         PSET  @SETCLP,CLEAR=NO
         LA    RS,0                    ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
*
*  SET REGISTERS AND START HIM UP
*
         LM    R0,R1,SCPGPRS+0*4       GENERAL
         LM    R14,R15,SCPGPRS+14*4     REGISTERS
         LD    0,SCPFPRS+0*8           FLOATING
         LD    2,SCPFPRS+1*8            POINT
         LD    4,SCPFPRS+2*8             REGISTERS
         LD    6,SCPFPRS+3*8
         LPSW  SCPPSW                  AND GO
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DUMPWORK - Mode 1 dump work area                             *
*                                                                 *
*******************************************************************
         SPACE
M1DWORK  RECORD BEGIN
M1DUMPCB DS    A                       DUMP CB
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    M1DUMP  - Mode 1 Services Dump Processing                    *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1DUMP   PROC  M1DWORK,SCOPE=GLOBAL
*
*  Get SCP pointer
*
         L     RY,PZCURASB             CURRENT ASB
         WITH  (ASB,RY),'L  RY,ASBM1SCP'  SCP POINTER
         WITH  (SCP,RY)
         SEGEOR '*** MODE 1 SERVICES SCP ***',,M1DUMPCB
         SEGEOR ,
         IF    (RY,Z),BEGIN
         SEGEOR '*** NOT INITIALIZED ***'
         EXIT  M1DUMP
         END   ,
*
*  Dump the SCP
*
         SEG   'SCP at '
         SEGHEX SCP,4
         SEGEOR
         SEGCORE SCP,ID=SCP
         SEGEOR
*
*  DUMP THE IDTS
*
         SEGEOR 'Dump of active IDTs'
         CLEAR RA
         L     RB,SCPIDT
         WHILE (RA,LT,SCPNIDT),BEGIN
         WITH  (IDT,RB)
*
*   ONLY DO ACTIVE IDTS
*
         IF    IDTFA+IDTFACL,BEGIN
         SEGCORE IDT,ID=IDT
         SEGEOR
         END   ,
         LA    RB,IDT+L'IDT
         INCR  RA
         END   ,
         PEND
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    M1TMC  - Mode 1 Timer Completion Processor                   *
*                                                                 *
*                                                                 *
*     Input -  XITSAREA                                           *
*                                                                 *
*    Output -  None                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1TMC    PROC  @XITDATA,SCOPE=LOCAL
         VCALL ASLOCK                  GET AS LOCK
         L     RX,@XITDSA              POINTER TO XITSAREA
         WITH  (XITSAREA,RX)
         L     RY,XITSRPRM             SCP POINTER
         WITH  (SCP,RY)
         WITH  (RTEXIT,XITSXPRM)       EXIT PARM
         L     RS,RTXTID               TIMER ID
         EJECT
*
*  REAL TIME TIMER FIRED
*
         IF    (XITSTYPE.XITTRTC,EQ),BEGIN
         XTRC  RS,RS,RTFIRE
         IF    (RS,EQ,SCPUCLK),BEGIN   USER CLOCK
         UTRACE CLASS=TIMER,CODE==Y(1)
         CLEAR SCBTUTR                 TIMER NO LONGER RUNNING
         CLEAR SCPUCLK                 CLEAR CLOCK ID
         SET   SCBXT                   SET TO ENTER TIMER EXIT
         END   ,
         ELSEIF (RS,EQ,SCPCCLK),BEGIN   CLP CLOCK
         UTRACE CLASS=TIMER,CODE==Y(2)
         IF    SCBTCPTR,'SET  SCBXCPT'     SET TO ENTER TIMER EXIT
         CLEAR SCBTCPTR+SCBTCPQU       CLP TIMERS NO LONGER RUNNING
         CLEAR SCPCCLK                 CLEAR CLOCK ID
         END   ,
         END   ,
         EJECT
*
*  CPU TIMER EXPIRED
*
         ELSE  BEGIN
         XTRC  RS,RS,CPTFIRE
         IF    SCBTUCT,BEGIN           USER CPU TIMER
         UTRACE CLASS=TIMER,CODE==Y(16)
         IF    (RS,NE,SCPUCLK),EXIT    WRONG CLOCK
         CLEAR SCBTUTR+SCBTUCT         TIMER NO LONGER RUNNING
         CLEAR SCPUCLK                 CLEAR CLOCK ID
         SET   SCBXT                   SET TO ENTER TIMER EXIT
         END   ,
         ELSE  BEGIN
         IF    ^SCBTCPCT,EXIT          CLP CPU TIMER
         IF    (RS,NE,SCPCCLK),EXIT    WRONG CLOCK
         UTRACE CLASS=TIMER,CODE==Y(17)
         CLEAR SCBTCPTR+SCBTCPCT       CLP TIMER NO LONGER RUNNING
         CLEAR SCPCCLK                 CLEAR CLOCK ID
         SET   SCBXCPT                 SET TO ENTER TIMER EXIT
         END   ,
         END   ,
         EJECT
*
*  SCHEDULE EXIT IF USER PROGRAM RUNNING
*
         IF    ^SCBFCLP,BEGIN
         IF    ((SCBMB.SCBXT,AND,SCBXT),OR,SCBXCPT),BEGIN
*
*  FIRST GET CURRENT STATE
*
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPPSW,@XITSPSW         COPY PSW
         MVC   SCPGPRS(16*4),@XITSGPR   AND REGISTERS
         MVC   SCPFPRS(4*8),@XITSFPR
*
*  BUILD OLD STYLE PSW
*
         MVC   SCPIPSW+2(1),SCPPSW+2   COPY CC AND PROGRAM MASK
         NI    SCPIPSW+2,X'3F'         CLEAR ILC BITS
         MVC   SCPIPSW+3(1),SCBMB
         CLEAR (SCPIPSW,2)             ZERO INTERRUPT CODE
*
*  SCHEDULE EXIT
*
         IF    SCBXCPT,'ACALL DOCTMR'  Do CLP TIMER
         ELSE  'ACALL DOUTMR'           or USER TIMER
*
*  UPDATE PSW AND REGISTERS
*
         PSET  @XITGPST
         MVC   @XITSPSW,SCPPSW         COPY PSW
         MVC   @XITSGPR(16*4),SCPGPRS   AND REGISTERS
         MVC   @XITSFPR(4*8),SCPFPRS
         VCALL XITPST
         END   ,
         END   ,
         EJECT
*
*  TASK IS SUSPENDED - WAKE IT UP
*
         IF    SCBFWAIT,BEGIN
         CLEAR SCBFWAIT
         PSET  @RESUME
         MVC   @RESCTL,SCPSID          SET SUSPEND ID
         VCALL RESUMTS                START THE TASK GOING
         END   ,
*
*  RETURN TO THE DISPATCHER
*
         VCALL ASULOCK                 RELEASE THE AS LOCK
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DOUTMR  - Schedule pending user timer exit                   *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOUTMR   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR SCBXT                   NOTE TIMER EXIT TAKEN
         IF    ('LT  RS,SCPTXEP',Z),EXIT    NO EXIT SET - IGNORE
         UTRACE CLASS=UXIT,CODE==Y(@UTCTIME),DATA=(SCPTXEP)
         MVC   SCPXPSW+2(2),SCPIPSW+2  SET OLD PSW FIELDS
         MVC   SCPXPSW+4(68),SCPPSW+4  SAVE PSW, GPRS
         ST    RS,SCPPSW+4             SET ENTRY POINT
         CLEAR RS                      ENTRY CODE
         STH   RS,SCPXPSW               TO PSW
         ST    RS,SCPGPRS+1*4            AND REGISTER 1
         MVC   SCPGPRS+14*4(4),SCPTXI  SET USER INFO
         CLEAR SCBMB                   DISABLE EXITS
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DOCTMR  - Schedule pending CLP timer exit                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOCTMR   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR SCBXCPT                 MARK EXIT TAKEN
         PSET  @SETCLP,CLEAR=NO
         L     RS,=A(-4)               ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1IOC  - Mode 1 I/O Completion Processor                     *
*                                                                 *
*                                                                 *
*     Input - XITSAREA                                            *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1IOC    PROC  @XITDATA,SCOPE=LOCAL
         VCALL ASLOCK                  GET AS LOCK
         L     RX,@XITDSA              POINTER TO XITSAREA
         WITH  (XITSAREA,RX)
         L     RY,XITSRPRM             SCP POINTER
         WITH  (SCP,RY)
         L     RK,XITSXPRM             IDT POINTER
         WITH  (IDT,RK)
         IF    (IDT,NE,=CL4'IDT'),'ABORT IDTID'
         L     R1,IDTDEVID             DEVICE ID
         LC    R0,IDTID                IDT NUMBER
         LM    R14,R15,PZCURPID
         XTRC  R14,R1,M1IOCMP
         SET   IDTFPOST                MARK COMPLETE
         EJECT
*
*  UPDATE RETURNS FOR TERMINAL COMPLETIONS
*
         IF    IDTCTRM,BEGIN
         WITH  (@M1TIOCP,XITSXPRM)
         CLEAR IDTFR1+IDTFR14+IDTFR15    CLEAR PREVIOUS
         IF    (@M1TIR01,NE,=X'80000000'),'SET IDTFR1'    NOTE
         IF    (@M1TIR15,NE,=X'80000000'),'SET IDTFR15'    RETURN
         IF    (@M1TIR14,NE,=X'80000000'),'SET IDTFR14'     REGS
         MVC   IDTR1(L'IDTR1+L'IDTR14+L'IDTR15),@M1TIR01   COPY REGS
         END   ,
*
*  UPDATE RETURNS FOR FILE COMPLETIONS
*
         ELSEIF  IDTCFIL,BEGIN
         CLEAR IDTFR1+IDTFR14+IDTFR15    CLEAR PREVIOUS
         WITH  (@M1FPOST,XITSXPRM)
         IF    (@M1FPR14,NE,=X'80000000'),'SET IDTFR14'
         IF    (@M1FPR15,NE,=X'80000000'),'SET IDTFR15'
         IF    (@M1FPR01,NE,=X'80000000'),'SET IDTFR1'
         MVC   IDTR14,@M1FPR14
         MVC   IDTR15,@M1FPR15
         MVC   IDTR1,@M1FPR01
         IF    ('TM @M1FPRQI,@M1FREDV',O),BEGIN
         CLEAR IDTDEVID            Clear device id
         SET   IDTFFIDT            Free IDT at wait
         END   ,
         END   ,
*
*  UPDATE RETURNS FOR SCOM PATH COMPLETIONS
*
         ELSEIF IDTCSCM,BEGIN
         WITH  (@M1PIOCP,XITSXPRM)
         CLEAR IDTFR1+IDTFR14+IDTFR15    CLEAR PREVIOUS
         IF    (@M1PIR01,NE,=X'80000000'),'SET IDTFR1'    NOTE
         IF    (@M1PIR15,NE,=X'80000000'),'SET IDTFR15'    RETURN
         IF    (@M1PIR14,NE,=X'80000000'),'SET IDTFR14'     REGS
         MVC   IDTR1(L'IDTR1+L'IDTR14+L'IDTR15),@M1PIR01   COPY REGS
         END   ,
         EJECT
*
*  UPDATE RETURNS FOR JES COMPLETIONS
*
         ELSEIF IDTCJES,BEGIN
         WITH  (@M1JIOCP,XITSXPRM)
         CLEAR IDTFR1+IDTFR14+IDTFR15    CLEAR PREVIOUS
         IF    (@M1JIR01,NE,=X'80000000'),'SET IDTFR1'    NOTE
         IF    (@M1JIR15,NE,=X'80000000'),'SET IDTFR15'    RETURN
         IF    (@M1JIR14,NE,=X'80000000'),'SET IDTFR14'     REGS
         MVC   IDTR1(L'IDTR1+L'IDTR14+L'IDTR15),@M1JIR01   COPY REGS
         IF    @M1JICRQ.@M1JDONE,BEGIN
         SET   IDTFFIDT                FREE IDT AT WAIT
         DECR  RS,SCPJESR              DECREMENT JES READER COUNT
         END   ,
         END   ,
*
*  UPDATE RETURNS FOR NET COMPLETIONS
*
         ELSEIF IDTCNET,BEGIN
         WITH  (@M1NIOCP,XITSXPRM)
         CLEAR IDTFR1+IDTFR14+IDTFR15    CLEAR PREVIOUS
         IF    (@M1NIR01,NE,=X'80000000'),'SET IDTFR1'    NOTE
         IF    (@M1NIR15,NE,=X'80000000'),'SET IDTFR15'    RETURN
         IF    (@M1NIR14,NE,=X'80000000'),'SET IDTFR14'     REGS
         MVC   IDTR1(L'IDTR1+L'IDTR14+L'IDTR15),@M1NIR01   COPY REGS
         END   ,
*
*  UPDATE RETURNS FOR ENQ/DEQ COMPLETIONS
*
         ELSEIF  IDTCENQ,BEGIN
         WITH  (@M1EIOCP,XITSXPRM)
         IF    (@M1EIR01,NE,=X'80000000'),'SET IDTFR1'    NOTE
         IF    (@M1EIR15,NE,=X'80000000'),'SET IDTFR15'    RETURN
         IF    (@M1EIR14,NE,=X'80000000'),'SET IDTFR14'     REGS
         MVC   IDTR1(L'IDTR1+L'IDTR14+L'IDTR15),@M1EIR01   COPY REGS
         END   ,
         EJECT
*         UTRACE CLASS=IO,CODE=IDTCLASS,DATA=(IDTR15)
*
*  PREPARE TO ENTER USER EXIT - IF THERE IS ONE
*
         IF    ('LT  RS,IDTWXEP',NZ),BEGIN
         IF    SCBMB.SCBXW,BEGIN
*
*  FIRST GET CURRENT STATE
*
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPPSW,@XITSPSW         COPY PSW
         MVC   SCPGPRS(16*4),@XITSGPR   AND REGISTERS
         MVC   SCPFPRS(4*8),@XITSFPR
*
*  BUILD OLD STYLE PSW
*
         MVC   SCPIPSW+2(1),SCPPSW+2   COPY CC AND PROGRAM MASK
         NI    SCPIPSW+2,X'3F'         CLEAR ILC BITS
         MVC   SCPIPSW+3(1),SCBMB
         CLEAR (SCPIPSW,2)             ZERO INTERRUPT CODE
*
*  SCHEDULE EXIT
*
         PSET  @DOWAIT
         ST    RK,@DOWTIDT             IDT TO PARM LIST
         ACALL DOWAIT                  DO IT
*
*  UPDATE PSW AND REGISTERS
*
         PSET  @XITGPST
         MVC   @XITSPSW,SCPPSW         COPY PSW
         MVC   @XITSGPR(16*4),SCPGPRS   AND REGISTERS
         MVC   @XITSFPR(4*8),SCPFPRS
         VCALL XITPST
         END   ,
         EJECT
*
*  EXIT EXISTS BUT IS DISABLED - MARK FOR DEFFERRED ENTRY
*
         ELSE  BEGIN
         SET   IDTFEWX                 MARK WAIT EXIT PENDING
         SET   SCBXW
         END   ,
         END   ,
*
*  TASK IS SUSPENDED - WAKE IT UP
*
         IF    SCBFWAIT,BEGIN
         CLEAR SCBFWAIT
         PSET  @RESUME
         MVC   @RESCTL,SCPSID          SET SUSPEND ID
         VCALL RESUMTS                START THE TASK GOING
         END   ,
*
*  RETURN TO DISPATCHER
*
         VCALL ASULOCK                 RELEASE THE AS LOCK
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   @DOWAIT - Wait exit scheduling parms                          *
*                                                                 *
*******************************************************************
         SPACE
@DOWAIT  RECORD BEGIN
@DOWTIDT DS    A                       IDT POINTER
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    DOWAIT  - Schedule pending wait exits                        *
*                                                                 *
*                                                                 *
*     Input - @DOWAIT                                             *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOWAIT   PROC  @DOWAIT,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RX,@DOWTIDT             IDT POINTER
         WITH  (IDT,RX)
         CLEAR IDTFEWX                 CLEAR WAIT EXIT PENDING
         L     RS,IDTWXEP              ENTRY POINT
         IF    (RS,NZ),BEGIN
         UTRACE CLASS=UXIT,CODE==Y(@UTCWAIT),DATA=(IDTWXEP,IDTFLG)
         MVC   SCPXPSW+4(68),SCPPSW+4  SAVE PSW, GPRS
         MVC   SCPXPSW+2(2),SCPIPSW+2   MASK BYTE
         ST    RS,SCPPSW+4             SET ENTRY POINT
         LC    RS,IDTID                EXIT CODE
         STH   RS,SCPXPSW               TO PSW
         ST    RS,SCPGPRS+1*4            AND REGISTER 1
         MVC   SCPGPRS+14*4(4),IDTWXI  SET USER INFO
         CLEAR SCBMB                   DISABLE EXITS
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1ATTN  - Mode 1 Attention Processor                         *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1ATTN   PROC  @XITDATA,SCOPE=LOCAL
         VCALL ASLOCK                  GET AS LOCK
         L     RX,@XITDSA              POINTER TO XITSAREA
         WITH  (XITSAREA,RX)
*
*  GET IDT AND SCP POINTERS
*
         L     RY,XITSRPRM             SCP POINTER
         WITH  (SCP,RY)
         L     RK,XITSXPRM             IDT POINTER
         WITH  (IDT,RK)
         UTRACE CLASS=ATTN,CODE==Y(0)
         EJECT
*
*  ATTENTION DURING CLP
*
         IF    SCBFCLP,BEGIN
         IF    IDTCTRM,'SET  SCBCFCLA'     MARK CLP ATTN
*
*  NON-TERMINAL ATTENTION - MARK PENDING IF USER HAS CREATED EXIT
*
         ELSE  BEGIN
         IF    ('LT  RS,IDTAXEP',Z),EXIT    IGNORE IF NULL
         SET   IDTFEAX                 MARK ATTN PENDING
         SET   SCBXA
         END   ,
         END   ,
         EJECT
*
*  ATTENTION DURING USER EXECUTION - MARK PENDING IF ON A
*      NON-TERMINAL DEVICE AND USER HAS CREATED, BUT MASKED, EXIT
*
         ELSE  BEGIN
         IF    (^IDTCTRM,AND,('LT  RS,IDTAXEP',Z)),EXIT    IGNORE
         IF    (^IDTCTRM,AND,^SCBMB.SCBXA),BEGIN
         SET   IDTFEAX                 MARK ATTN PENDING
         SET   SCBXA
         END   ,
*
*  ATTENTION EXIT TO BE SCHEDULED - FIRST GET CURRENT STATE
*
         ELSE  BEGIN
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPPSW,@XITSPSW         COPY PSW
         MVC   SCPGPRS(16*4),@XITSGPR   AND REGISTERS
         MVC   SCPFPRS(4*8),@XITSFPR
*
*  BUILD OLD STYLE PSW
*
         MVC   SCPIPSW+2(1),SCPPSW+2   COPY CC AND PROGRAM MASK
         NI    SCPIPSW+2,X'3F'         CLEAR ILC BITS
         MVC   SCPIPSW+3(1),SCBMB
         CLEAR (SCPIPSW,2)             ZERO INTERRUPT CODE
*
*  PROCESS ATTENTION
*
         PSET  @DOATTN
         ST    RK,@DOATIDT             TO PARM LIST
         IF    IDTCTRM,BEGIN
         WITH  (@M1TATP,XITSXPRM)
         L     RS,@M1TATCT             POINTER TO IDLE ATTN COUNT
         MVC   @DOAIAC,@RS             GIVE COUNT
         END   ,
         ACALL DOATTN                  DO IT
         EJECT
*
*  UPDATE PSW AND REGISTERS
*
         PSET  @XITGPST
         MVC   @XITSPSW,SCPPSW         COPY PSW
         MVC   @XITSGPR(16*4),SCPGPRS   AND REGISTERS
         MVC   @XITSFPR(4*8),SCPFPRS
         VCALL XITPST
         END   ,
         END   ,
*
*  TASK IS SUSPENDED - WAKE IT UP
*
         IF    SCBFWAIT,BEGIN
         PSET  @RESUME
         MVC   @RESCTL,SCPSID          SET SUSPEND ID
         VCALL RESUMTS                START THE TASK GOING
         CLEAR SCBFWAIT
         END   ,
*
*  RETURN TO DISPATCHER
*
         VCALL ASULOCK                 RELEASE THE AS LOCK
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   @DOATTN - Attention exit scheduling parms                     *
*                                                                 *
*******************************************************************
         SPACE
@DOATTN  RECORD BEGIN
@DOATIDT DS    A                       IDT POINTER
@DOAIAC  DS    X                       Idle attention count
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    DOATTN  - Schedule pending attention exits                   *
*                                                                 *
*                                                                 *
*     Input - @DOATTN                                             *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOATTN   PROC  @DOATTN,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RX,@DOATIDT             IDT POINTER
         WITH  (IDT,RX)
         L     RS,IDTAXEP              ENTRY POINT
         CLEAR IDTFEAX                 CLEAR EXIT PENDING
         IF    IDTCTRM,BEGIN
*
*  SCHEDULE SESSION BREAK
*
         IF    (^SCBMB.SCBXA,OR,(RS,Z),OR,SCBFNESC,OR,                 *
               ((@DOAIAC,GE,2),AND,^SCBCFNMA)),BEGIN
         PSET  @SETCLP,CLEAR=NO
         LA    RS,16                   ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         EXIT  DOATTN
         END   ,
         END   ,
         EJECT
*
*  SCHEDULE USER EXIT
*
         IF    (RS,NZ),BEGIN           EXIT SET
         UTRACE CLASS=UXIT,CODE==Y(@UTCATTN),DATA=(IDTAXEP,IDTFLG)
         MVC   SCPXPSW+4(68),SCPPSW+4  SAVE PSW, GPRS
         MVC   SCPXPSW+2(2),SCPIPSW+2   ILC, CC, PGM MSK, EXIT MASK
         ST    RS,SCPPSW+4             SET ENTRY POINT
         LC    RS,IDTID                EXIT CODE
         STH   RS,SCPXPSW               TO PSW
         ST    RS,SCPGPRS+1*4            AND REGISTER 1
         MVC   SCPGPRS+14*4(4),IDTAXI  SET USER INFO
         CLEAR SCBMB                   DISABLE EXITS
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1LGOFF - Mode 1 Logoff Processor                            *
*                                                                 *
*                                                                 *
*     Input -  XITSAREA                                           *
*                                                                 *
*    Output -  None                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1LGOFF  PROC  @XITDATA,SCOPE=LOCAL
         VCALL ASLOCK                  GET AS LOCK
         L     RX,@XITDSA              POINTER TO XITSAREA
         WITH  (XITSAREA,RX)
         L     RY,XITSRPRM             SCP POINTER
         WITH  (SCP,RY)

         ACALL M1CANWAI                Cancel any waiting
*
*  FIRST DELETE ALL PENDING EXITS
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMSVC                 SVC
         SET   XITMPI+XITMPER+XITMMON  PROGRAM, PER, AND MONITOR
         SET   XITMRTC+XITMCTC         REAL AND CPU TIMER
         SET   XITMATTN                and ATTENTION
         VCALL XITFPR                  DELETE 'EM
*
*  SCHEDULE EXIT IF LOGOFF NOT ALREADY IN PROGRESS
*
         IF    ^SCBCFALP,BEGIN
         SET   SCBCFALP                MARK LOGOFF IN PROGRESS
         CLEAR SCBFCLP                  AND CLP NOT ACTIVE
         EJECT
*
*  FIRST GET CURRENT STATE
*
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPPSW,@XITSPSW         COPY PSW
         MVC   SCPGPRS(16*4),@XITSGPR   AND REGISTERS
         MVC   SCPFPRS(4*8),@XITSFPR
*
*  BUILD OLD STYLE PSW
*
         MVC   SCPIPSW+2(1),SCPPSW+2   COPY CC AND PROGRAM MASK
         NI    SCPIPSW+2,X'3F'         CLEAR ILC BITS
         MVC   SCPIPSW+3(1),SCBMB
         CLEAR (SCPIPSW,2)             ZERO INTERRUPT CODE
*
*  SCHEDULE EXIT
*
         PSET  @SETCLP,CLEAR=NO
         LA    RS,4                    ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
*
*  UPDATE PSW AND REGISTERS
*
         PSET  @XITGPST
         MVC   @XITSPSW,SCPPSW         COPY PSW
         MVC   @XITSGPR(16*4),SCPGPRS   AND REGISTERS
         MVC   @XITSFPR(4*8),SCPFPRS
         VCALL XITPST
*
*  TASK IS SUSPENDED - WAKE IT UP
*
         IF    SCBFWAIT,BEGIN
         CLEAR SCBFWAIT
         PSET  @RESUME
         MVC   @RESCTL,SCPSID          SET SUSPEND ID
         VCALL RESUMTS                 START THE TASK GOING
         END   ,
         END   ,
*
*  RETURN TO THE DISPATCHER
*
         VCALL ASULOCK                 RELEASE THE AS LOCK
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    M1PGM  - Mode 1 Program Interrupt Processor                  *
*                                                                 *
*                                                                 *
*     Input - XITSAREA                                            *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1PGM    PROC  @XITDATA,SCOPE=LOCAL
         VCALL ASLOCK                  GET AS LOCK
         L     RX,@XITDSA              POINTER TO XITSAREA
         WITH  (XITSAREA,RX)
         L     RY,XITSRPRM             SCP POINTER
         WITH  (SCP,RY)
*
*  ERROR DURING SVC PROCESSING - SAVE STATE
*
         IF    SCBFSVC,BEGIN           SVC IN PROGRESS
         WITH  (SEXITPI,XITSXPRM)
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPSVPSW,@XITSPSW        COPY PSW
         MVC   SCPSVGPR(16*4),@XITSGPR   REGISTERS
         MVC   SCPSVPSW+3(1),SXIPCODE+1   AND INTERRUPT CODE
         ABORT PIINM1S
*
*  NOW DELETE SVC EXIT
*
         VCALL XITRMPLC                DELETE PREVIOUS (SVC) EXIT
         CLEAR SCBFSVC
*
*  DELETE PENDING PER EXIT ALSO
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMPER                 MARK PER EXIT
         VCALL XITFPR                  DELETE IT
         END   ,
*
*  UPDATE USER STATE IF NOT SVC ERROR
*
         ELSE  BEGIN                   SVC NOT IN PROGRESS
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPPSW,@XITSPSW         COPY PSW
         MVC   SCPGPRS(16*4),@XITSGPR   AND REGISTERS
         MVC   SCPFPRS(4*8),@XITSFPR
         IF    ('CLC  SCPPSW+4(4),=V(VCLP)',EQ),'ABORT CLPREENTRY'
         END   ,
*
*  Process PER interrupt
*
         IF    (XITSTYPE.XITTPER,EQ),BEGIN      PER OCCURRED
         WITH  (SEXITPER,XITSXPRM)
         UTRACE CLASS=PER,CODE=SXIECODE,DATA=(SXIEPERA)
         LH    R14,SXIEILC             INSTRUCTION LENGTH
         LA    R15,X'80'               PER INTERRUPT CODE
         MVC   SCPPER,SXIEPERA         SET ADDRESS
         MVC   SCPPER(1),SXIECODE       AND CODE
         END   ,
*
*  Process Monitor interrupt
*
         ELSEIF (XITSTYPE.XITTMON,EQ),BEGIN    MONITOR CALL OCCURRED
         WITH  (SEXITMC,XITSXPRM)
         UTRACE CLASS=MON,CODE=SXIMCLA,DATA=(SXIMCODE)
         LH    R14,SXIMILC             INSTRUCTION LENGTH
         LA    R15,X'40'               MONITOR CALL INTERRUPT CODE
         MVC   SCPMON,SXIMCODE         SET MONITOR CODE
         MVC   SCPMON(1),SXIMCLA+1      AND CLASS
         END   ,
*
*  PROCESS PROGRAM PANICS
*
         ELSE  BEGIN                   PROGRAM INTERRUPT OCCURRED
         WITH  (SEXITPI,XITSXPRM)
         UTRACE CLASS=PI,CODE=SXIPCODE,DATA=(SXIPEXA)
         LH    R14,SXIPILC             INSTRUCTION LENGTH
         LH    R15,SXIPCODE            INTERRUPT CODE
*
*  FIX FOR SSM SUPPRESSION CODE
*
         IF    (R15,EQ,19),'LA  R15,X"02"'   CONVERT TO 2 (PRIVED OP)
*
*  FIX FOR VECTOR OPERATION CODE
*
         IF    (R15,EQ,25),BEGIN
         LA    R15,X'01'               CONVERT TO 1 (OPERATION)
         CLEAR R14                     Set ILC to zero
         END   ,
*
*  Fix up unresolvable page faults
*
         IF    ((R15,EQ,16),OR,(R15,EQ,17)),BEGIN
         MVC   SCPPXA,SXIPEXA          EXCEPTION ADDRESS
         LA    R15,5                   CALL IT ADDRESSING
         CLEAR R14                     Set ILC to zero
         END   ,
*
*  Fix up DAS errors
*
         IF    ((R15,GE,32),AND,(R15,LE,37)),BEGIN
         LA    R15,1                   Call it operation
         CLEAR R14                     Set ILC to zero
         END   ,
         END   ,
*
*  SET OLD STYLE PSW FIELDS
*
         STH   R15,SCPIPSW             SET INTERRUPT CODE
         MVC   SCPIPSW+2(1),SCPPSW+2   COPY CC AND PROGRAM MASK
         NI    SCPIPSW+2,X'3F'         CLEAR ILC BITS
         SLL   R14,5                   ILC TO PROPER POSITION
         EX    R14,'OI  SCPIPSW+2,0'   SET ILC IN PSW
         MVC   SCPIPSW+3(1),SCBMB      ADD MASK BYTE
*
*  SET UP THE EXIT
*
         STH   R15,SCPPAN
         LCALL DOPANIC                 PANIC CODE
*
*  UPDATE PSW AND REGISTERS
*
         PSET  @XITGPST
         MVC   @XITSPSW,SCPPSW         COPY PSW
         MVC   @XITSGPR(16*4),SCPGPRS   AND REGISTERS
         MVC   @XITSFPR(4*8),SCPFPRS
         VCALL XITPST
*
*  RETURN TO DISPATCHER
*
         VCALL ASULOCK                 RELEASE THE AS LOCK
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DOPANIC - Schedule user or CLP PANIC exit                    *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOPANIC  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  SCHEDULE USER'S PANIC EXIT
*
         IF    ('LT RS,SCPPXEP',NZ),BEGIN
         IF    ^SCBMB.SCBXP,EXIT       EXIT NOT ENABLED
         LH    R15,SCPPAN              PANIC CODE
*
*  IF CLP HANDLING PER AND MONITOR, REMOVE FROM INTERRUPT CODE
*
         IF    SCPFPER,'N  R15,=A(255-128)'  CLP<=PER
         IF    SCPFMON,'N  R15,=A(255-64)'   CLP<=MON
         IF    (R15,Z),EXIT            NOTHING LEFT FOR USER
         EJECT
*
*  SET UP TO ENTER USER ROUTINE
*
         STH   R15,SCPXPSW             INTERRUPT CODE
         MVC   SCPXPSW+2(2),SCPIPSW+2  ILC, CC, AND PROGRAM MASK
         MVC   SCPXPSW+4(4),SCPPSW+4   INTERRUPT PSW ADDRESS
         MVC   SCPXGPRS(16*4),SCPGPRS   GPRS
         ST    R15,SCPGPRS+4           SET ENTRY CODE
         UTRACE CLASS=UXIT,CODE==Y(@UTCPAN),DATA=(SCPPXEP,SCPXPSW)
         ST    RS,SCPPSW+4             SET ENTRY POINT
         MVC   SCPGPRS+14*4(4),SCPPXI    AND USER INFO
         IF    SCPXPSW+1.X'80','MVC SCPGPRS+4*15,SCPPER'
         IF    SCPXPSW+1.X'40','MVC SCPGPRS,SCPMON'  USER<=MONITOR
         CLEAR SCBMB                   DISABLE EXITS
         EXIT  DOPANIC                 DONE
         END   ,
*
*  SET UP TO ENTER CLP PANIC ROUTINE
*
         LH    RS,SCPPAN               PANIC CODE
         CLEAR SCPPAN                  CLEAR CODE
         STH   RS,SCPIPSW               TO PSW
         PSET  @SETCLP,CLEAR=NO
         LA    RS,8                    ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         MVC   SCPGPRS,SCPMON          MONITOR INFO IN R0
         MVC   SCPGPRS+15*4,SCPPER     PER INFO IN R15
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    SVC Table for Mode 1                                         *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
SVCTABLE DC    A(256-(SVCTEND-SVCTABLE-4)/4)
         DC    A(QPAUSE)               235
         DC    A(M1HALT)               236 - CLP ONLY
         DC    A(CLPSERV)              237 - CLP ONLY
         DC    A(MILCOM)               238
         DC    A(M1ENQ)                239
         DC    A(SERVICE)              240
         DC    A(M1STATUS)             241
         DC    A(M1WAIT)               242
         DC    A(M1RELSE)              243
         DC    A(M1RESRV)              244
         DC    A(M1CNTRL)              245
         DC    A(M1WRITE)              246
         DC    A(M1READ)               247
         DC    A(M1DETACH)             248
         DC    A(M1ATTACH)             249
         DC    A(SENSE)                250
         DC    A(SET)                  251
         DC    A(PANIC)                252
         DC    A(M1EXIT)               253
         DC    A(COMMAND)              254
         DC    A(PAUSE)                255
SVCTEND  EQU   *
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    M1SVC  - Mode 1 SVC Processor                                *
*                                                                 *
*                                                                 *
*     Input - @SVCM1                                              *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1SVC    PROC  @XITDATA,SCOPE=LOCAL
* -->    VCALL ASLOCK                  GET AS LOCK
         L     RX,@XITDSA              POINTER TO XITSAREA
         WITH  (XITSAREA,RX)
         L     RY,XITSRPRM             SCP POINTER
         WITH  (SCP,RY)
         PSET  @XITGPST
         VCALL XITGST
         MVC   SCPPSW,@XITSPSW         COPY PSW
         MVC   SCPGPRS(16*4),@XITSGPR   AND REGISTERS
         MVC   SCPFPRS(4*8),@XITSFPR
*
*  BUILD OLD STYLE PSW
*
         WITH  (SEXITSVC,XITSXPRM),BEGIN
         UTRACE CLASS=SVC,CODE=SXISNUM,DATA=(SCPGPRS+14*4,             *
               SCPGPRS+15*4,SCPGPRS+0*4,SCPGPRS+1*4)
         MVC   SCPIPSW+2(1),SCPPSW+2   COPY CC AND PROGRAM MASK
         NI    SCPIPSW+2,X'3F'         CLEAR ILC BITS
         LH    R15,SXISILC             INSTRUCTION LENGTH
         SLL   R15,5
         EX    R15,'OI  SCPIPSW+2,0'   SET ILC IN PSW
         MVC   SCPIPSW+3(1),SCBMB
         LH    R15,SXISNUM             SVC CODE
         STH   R15,SCPIPSW
         END   ,
*
*  PROCESS SVC
*
         LA    RA,SVCTABLE             SVC TABLE
         S     R15,@RA                 TABLE INDEX
*
*  INVALID SVC NUMBER AND USER HAS NO SVC EXIT
*
         IF    M,BEGIN                 USER SVC
         L     RS,SCPSXEP              ENTRY POINT OF USER EXIT
         IF    ((RS,Z),OR,('CLI  SCPIPSW+1,128',NL)),BEGIN
         MVI   SCPPANSY,1              SET PANIC CODE
         ACALL DOPANIC                 ENTER PANIC EXIT
*
*  DELETE PENDING PER EXIT
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMPER                 MARK PER EXIT
         VCALL XITFPR                  DELETE IT
         END
*
*  PROCESS USER SVC EXIT
*
         ELSE  BEGIN
         MVC   SCPXPSW(4),SCPIPSW      SET USER TYPE PSW
         MVC   SCPXPSW+4(68),SCPPSW+4    COPY PSW ADDR AND GPRS
         CLEAR SCBMB
         UTRACE CLASS=UXIT,CODE==Y(@UTCSVC),DATA=(SCPSXEP,SCPXPSW)
         LH    R0,SCPIPSW              SVC CODE
         ST    R0,SCPGPRS+1*4          PLANT ENTRY CODE
         ST    RS,SCPPSW+4              AND ENTRY POINT
         MVC   SCPGPRS+4*14(4),SCPSXI    AND USER INFO
         END   ,
         END   ,
*
*  PROCESS ORVYL SVC
*
         ELSE  BEGIN
         SLL   R15,2                   SVC TABLE ENTRY LENGTH
         L     R15,SVCTABLE+4(R15)     SVC ROUTINE ADDRESS
         SET   SCBFSVC
         ACALL (R15)                   CAll SVC ROUTINE
*
*  ERROR RETURN FROM ORVYL SVC
*
         CLEAR SCBFSVC                 NO LONGER IN AN SVC
         IF    SCBXP,BEGIN
         ACALL DOPANIC                 USER PANIC'ED
         CLEAR SCBXP
*
*  DELETE PENDING PER EXIT
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMPER                 MARK PER EXIT
         VCALL XITFPR                  DELETE IT
         END
*
*  NORMAL RETURN FROM ORVYL SVC
*
         ELSE  BEGIN
         IF    SCBFNPUP,EXIT           SKIP PSW UPDATES (SET 10)
         LT    R15,SCPGPRS+15*4        RETURN CODE
         IPM   RA                      CONDITION CODE
         SRL   RA,24                   ISOLATE
         N     RA,=X'00000030'
         NI    SCPPSW+2,X'CF'          CLEAR PREVIOUS CC
         EX    RA,'OI  SCPPSW+2,0'     SET NEW CC
         END   ,
         CLEAR SCBFNPUP
         END   ,
*
*  IF WAIT REQUESTED USER MUST BE SUSPENDED
*
         IF    SCBFWAIT,BEGIN
         PSET  @SUSPEND
         SET   @SUSPLNG+@SUSPPLC       Long suspend user
         VCALL SUSPEND                 SCHEDULE SUSPENSION
         MVC   SCPSID,@SUSPCTL         SAVE SUSPEND ID
         END   ,
         EJECT
*
*  UPDATE PSW AND REGISTERS
*
         PSET  @XITGPST
         MVC   @XITSPSW,SCPPSW         COPY PSW
         MVC   @XITSGPR(16*4),SCPGPRS   AND REGISTERS
         MVC   @XITSFPR(4*8),SCPFPRS
         VCALL XITPST
*
*  RETURN TO DISPATCHER
*
* -->    VCALL ASULOCK                 RELEASE THE AS LOCK
         PSET  @EXRDONE
         VCALL EXRDONE
         PEND
         TITLE 'ORVYL''S Mode 1 Wait SVC'
*******************************************************************
*                                                                 *
*    SVCWAIT  - Mode 1 WAIT SVC                                   *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1WAIT   PROC  SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  CHECK IDT NUMBER
*
         L     RA,SCPGPRS+0*4          IDT NUMBER
         IF    ((RA,NEG),OR,(RA,GT,SCPNIDT)),BEGIN   INVALID
M1WSPEC  MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  M1WAIT                  QUIT
         END   ,
         WITH  (IDT,RA)
         IF    (RA,NZ),BEGIN
         DECR  RA
         MH    RA,=Y(L'IDT)            FORM IDT ADDRESS
         AL    RA,SCPIDT
         IF    (IDTFA+IDTFACL,Z),M1WSPEC   DEVICE NOT ATTACHED
         END   ,
         EJECT
*
*  DEVICE NOT POSTED OR NON-SPECIFIC REQUEST - USER WILL WAIT
*
         IF    ((RA,Z),OR,(^IDTFPOST)),BEGIN
         LH    R14,SCPIPSW+2           GET CURRENT ILC
         SRL   R14,8+6-1               ISOLATE
         N     R14,=X'00000006'         INSTRUCTION LENGTH
         L     R15,SCPPSW+4            GET CURRENT PSW ADDRESS
         SLR   R15,R14                 BACK UP TO SVC INSTRUCTION
         ST    R15,SCPPSW+4            RESET PSW
         CLEAR SCPIPSW+2.X'C0'
         SET   SCBFWAIT                MARK USER AS WAITING
         SET   SCBFNPUP                DON'T CHANGE PSW CC
         END   ,
*
*  IF DEVICE POSTED SET RETURNS
*
         ELSE  BEGIN
         SET   IDTFWD                  MARK WAIT DONE
         IF    IDTFR1,'MVC  SCPGPRS+1*4(4),IDTR1'     RETURN R1
         IF    IDTFR15,'MVC  SCPGPRS+15*4(4),IDTR15'  RETURN R15
         IF    IDTFR14,'MVC  SCPGPRS+14*4(4),IDTR14'  RETURN R14
         CLEAR IDTFEWX                 CLEAR PENDING WAIT EXIT
*
*  IDT TO BE RELEASED - MAKE IT AVAILABLE
*
         IF    IDTFFIDT,BEGIN          FREE IDT
         PSET  @FREEIDT,CLEAR=NO
         ST    RA,@FRIADDR
         ACALL FREEIDT                 FREE IT
         END   ,
         END   ,
         PEND
         TITLE 'ORVYL''S Mode 1 Panic SVC'
*******************************************************************
*                                                                 *
*    PANIC  - Mode 1 PANIC SVC                                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PANIC    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+0*4          GET PANIC CODE
         N     RS,=XL4'7FFF'
         LNR   RS,RS                   USER CODES ARE COMPLEMENTED
         STH   RS,SCPPAN
         SET   SCBXP                   SET PANIC EXIT
         PEND
         TITLE 'ORVYL''S Mode 1 Exit SVC'
*******************************************************************
*                                                                 *
*    EXIT   - Mode 1 EXIT SVC                                     *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1EXIT   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         IF    ^SCBFCLP,BEGIN          USER PROGRAM EXIT
         CLEAR (SCPIPSW,2)
         PSET  @SETCLP,CLEAR=NO
         LA    RS,20                   ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         SET   SCBFNPUP                DON'T SET CC
         END
*
*  CLP EXIT MEANS LOGOFF (SNEAKY)
*
         ELSE  BEGIN
         VCALL XALGOFF                 SAY GOODNIGHT GRACIE
         END
         PEND
         TITLE 'ORVYL''S Mode 1 Command SVC'
*******************************************************************
*                                                                 *
*    COMMAND - Mode 1 COMMAND SVC                                 *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
COMMAND  PROC  SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RA,SCPGPRS+1*4          BUFFER POINTER
         LPR   RA,RA                    FORCE POSITIVE
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         L     RB,SCPGPRS+15*4         LENGTH
         LPR   RB,RB                    ALSO POSITIVE
         IF    (ZERO,OR,(RB,GT,=A(CLWIBUFL))),BEGIN
COMMSPEC MVI   SCPPANSY,PANSPEC        SPEC CODE
         SET   SCBXP
         END
         ELSE  BEGIN
*
*  CHECK MEMORY LEGAL
*
         PSET  @PAGE
         ST    RA,@PAGLOC              LOCATION
         ST    RB,@PAGLEN               LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),COMMSPEC     NO GOOD
         CLEAR (SCPIPSW,2)
         PSET  @SETCLP,CLEAR=NO
         LA    RS,24                   ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         SET   SCBFNPUP                DON'T RESET CC
         END
         PEND
         TITLE 'ORVYL''S Mode 1 Pause SVC'
*******************************************************************
*                                                                 *
*    PAUSE - Mode 1 PAUSE SVC                                     *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PAUSE    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR (SCPIPSW,2)
         PSET  @SETCLP,CLEAR=NO
         LA    RS,12                   ENTRY CODE
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         SET   SCBFNPUP                DON'T RESET CC
         PEND
         TITLE 'ORVYL''S Mode 1 QPause SVC'
*******************************************************************
*                                                                 *
*    PAUSE - Mode 1 QPAUSE SVC                                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
QPAUSE   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR (SCPIPSW,2)
         PSET  @SETCLP,CLEAR=NO
         LA    RS,32               QPAUSE entry code
         ST    RS,@SCCODE              SET
         ACALL SETCLP                  GO TO CLP
         SET   SCBFNPUP                DON'T RESET CC
         PEND
         TITLE 'ORVYL''S Mode 1 Session Break processing'
*******************************************************************
*                                                                 *
*    @SETCLP - Schedule CLP routine parameters                    *
*                                                                 *
*******************************************************************
         SPACE
@SETCLP  RECORD BEGIN
@SCCODE  DS    A                       Entry Code
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SETCLP - Mode 1 SVC Session Break Service                    *
*                                                                 *
*                                                                 *
*     Input - @SETCLP                                             *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SETCLP   PROC  @SETCLP,SCOPE=LOCAL
         WITH  (SCP,RY)
         LA    RB,SCPSBPSW         STANDARD SB PSW,GPRS
*-
*-       Initial CLP error processing.
*-
         IF    SCBFCLP,BEGIN       CLP IN CONTROL...
         L     RA,MATPTR
         WITH  (MAT,RA),'INCR RS,MATNCLPE'  Count the CLP error
         IF    SCPFERR,'ABORT CLPERR'   RECURSIVE CLP ERROR
         SET   SCPFERR             SET ERROR IN CLP
         LA    RB,SCPCLPSW         USE SPECIAL PSW,GPR SAVE
         END
*
         UTRACE CLASS=RUNCLP,CODE=@SCCODE+2
         EJECT
*
*  SAVE CURRENT ENVIRONMENT
*
         MVC   @RB(4),SCPIPSW          SET OLD PSW FIELDS
         MVC   @RB+4(4),SCPPSW+4        PSW ADDRESS
         MVC   @RB+8(16*4),SCPGPRS       AND GPRS
*
*  SET UP CLP ENVIRONMENT
*
         CLEAR SCBMB
         SET   SCBFCLP                 CLP IN CONTROL
         CLEAR (SCPGPRS,64)
         MVC   SCPGPRS+1*4,@SCCODE     ENTRY CODE
         ST    RY,SCPGPRS+14*4         MOVE IN SCP ADDR
         MVC   SCPPSW(4),=X'070C0000'  DAT ON, ENABLED, KEY ZERO
         MVC   SCPPSW+4(4),=V(VCLP)
*
*  DELETE PENDING PER EXIT
*
         PSET  @XITMASK
         WITH  (XITMSKD,@XITMSK)
         SET   XITMPER                 MARK PER EXIT
         VCALL XITFPR                  DELETE IT
         PEND
         TITLE 'ORVYL''S Mode 1 Deferred Exit processing'
*******************************************************************
*                                                                 *
*    DOXWORK - SVC Work area                                      *
*                                                                 *
*******************************************************************
         SPACE
DOXWORK  RECORD BEGIN
DOXFL    DS    X                       EXIT WORK AREA
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    DOEXITS - Schedule deferred exits                            *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOEXITS  PROC  ,DOXWORK,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  CHECK FOR PENDING EXITS
*
         MVC   DOXFL,SCBMB             CURRENT MASK BYTE
         IF    ^SCBFCLP,'SET  DOXFL.SCBXCPT'   IF USER ADD CLP TIMER
         IF    ('NC  DOXFL,SCBXFL',NZ),BEGIN   EXITS TO PROCESS
*
*  USER TIMER EXIT
*
         IF    DOXFL.SCBXT,BEGIN       USER TIMER
         ACALL DOUTMR
         EXIT  DOEXITS
         END   ,
*
*  CLP TIMER EXIT
*
         IF    DOXFL.SCBXCPT,BEGIN     CLP TIMER FIRED
         ACALL DOCTMR
         EXIT  DOEXITS
         END   ,
         EJECT
*
*  ATTENTION EXIT
*
         IF    DOXFL.SCBXA,BEGIN       ATTENTION
         CLEAR RB
         L     RA,SCPIDT               POINTER TO FIRST IDT
         WHILE (RB,LT,SCPNIDT),BEGIN   CHECK ALL IDTS
         WITH  (IDT,RA)
         IF    IDTFEAX,BEGIN           ATTN EXIT SET
         PSET  @DOATTN
         ST    RA,@DOATIDT             TO PARM LIST
         ACALL DOATTN                  DO IT
         EXIT  DOEXITS
         END   ,
         LA    RA,IDT+L'IDT            NEXT IDT
         INCR  RB
         END   ,
         CLEAR SCBXA                   CLEAR ATTENTION EXIT
         END   ,
         EJECT
*
*  WAIT EXIT
*
         IF    DOXFL.SCBXW,BEGIN       WAIT EXIT
         CLEAR RB
         L     RA,SCPIDT               POINTER TO FIRST IDT
         WHILE (RB,LT,SCPNIDT),BEGIN   CHECK ALL IDTS
         WITH  (IDT,RA)
         IF    IDTFEWX,BEGIN           WAIT EXIT SET
         PSET  @DOWAIT
         ST    RA,@DOWTIDT             IDT TO PARM LIST
         ACALL DOWAIT                  DO IT
         END   ,
         LA    RA,IDT+L'IDT            NEXT IDT
         INCR  RB
         END   ,
         CLEAR SCBXW                   CLEAR WAIT EXIT
         END   ,
         END   ,
         PEND
         EJECT
         LTORG
         TITLE 'ORVYL''S Mode 1 I/O SVCs'
*******************************************************************
*                                                                 *
*    M1ATTACH - I/O device ATTACH service                         *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1ATTACH PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     R15,SCPGPRS+0*4         GET REGISTER ZERO
         LPR   R15,R15                 DEVICE ID
*
*  Process terminal ATTACH requests
*
         IF    (R15,EQ,=A(L'IDTCTRM)),BEGIN
         L     RX,SCPIDT               FIRST IDT IS FOR TERMINAL
         WITH  (IDT,RX)
         IF    ('LT  R14,SCPGPRS+1*4',NZ),BEGIN
         MVC   SCPPANSY,6              SPEC ERROR
         SET   SCBXP                   SET PANIC EXIT
         EXIT  M1ATTACH                QUIT
         END   ,
         IF    SCBFCLP,'SET IDTFACL'   ATTACHED BY CLP
         ELSE  'SET IDTFA'             ATTACHED BY USER
         SET   IDTFWD+IDTFPOST         WAIT DONE AND POSTED
         SET   IDTCTRM                 SET TERMINAL CLASS
         ST    R14,IDTR15              WAIT COMPLETION CODE
         SET   IDTFR15                 NOTE REGISTER RETURNED
         CLEAR IDTFR14+IDTFR1
         ST    R15,SCPGPRS+0*4         RETURN PROPER ID NUMBER
         END   ,
         EJECT
*
* PROCESS FILE REQUEST
*
         ELSEIF  (R15,EQ,=A(L'IDTCFIL)),BEGIN
         LCALL ASGNIDT                 GET AN AVAILABLE IDT
         IF    ('LTR  RX,RVR',Z),BEGIN NONE FOUND
         LH    RS,=Y(-4)               TOO MANY DEVICES IN USE
         ST    RS,SCPGPRS+15*4         USER RETURN CODE
         END   ,
         ELSE  BEGIN
         WITH  (IDT,RX),'SET IDTCFIL'  SET FILE CLASS
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FATCH        SET REQUEST TYPE
         ACALL GOFILE
         IF    (RVR,NZ),BEGIN
         PSET  @FREEIDT
         WITH  (IDT,RX),'PMOV @FRIADDR,LA:IDT'
         ACALL FREEIDT
         END   ,
         END   ,
         END   ,
*
*  PROCESS OS FILE REQUEST
*
         ELSEIF (R15,EQ,=A(L'IDTCOSF)),BEGIN
         LH    RS,=Y(-12)              NOT AVAILABLE
         ST    RS,SCPGPRS+15*4          USER RETURN CODE
         EXIT  M1ATTACH                DONE FOR NOW
         END   ,
*
*  SEND PATH REQUEST TO SCOM DRIVER
*
         ELSEIF (R15,EQ,=A(L'IDTCSCM)),BEGIN
         LCALL ASGNIDT                 GET AN AVAILABLE IDT
         IF    ('LTR  RX,RVR',Z),EXIT,M1ATTACH   NONE FOUND
         WITH  (IDT,RX)
         SET   IDTCSCM                 SET TYPE
         PSET  @GORTYPE
         SET   @GRTYPE.@M1PATCH        MARK ATTACH REQUEST
         ACALL GOPATH                  GO DO IT
         END   ,
         EJECT
*
*  PROCESS JES REQUEST
*
         ELSEIF (R15,EQ,=A(L'IDTCJES)),BEGIN
         LCALL ASGNIDT                 GET AN AVAILABLE IDT
         IF    ('LTR  RX,RVR',Z),EXIT,M1ATTACH   NONE FOUND
         WITH  (IDT,RX)
         SET   IDTCJES                 SET TYPE
         PSET  @GORTYPE
         SET   @GRTYPE.@M1JATCH        MARK ATTACH REQUEST
         ACALL GOJES                   GO DO IT
         END   ,
*
*  PROCESS KEYWORD FILE REQUEST
*
         ELSEIF (R15,EQ,=A(L'IDTCKEY)),BEGIN
         LH    RS,=Y(-12)              NOT AVAILABLE
         ST    RS,SCPGPRS+15*4          USER RETURN CODE
         EXIT  M1ATTACH                DONE FOR NOW
         END   ,
*
*  Process Network Request
*
         ELSEIF (R15,EQ,=A(L'IDTCNET)),BEGIN
         LCALL ASGNIDT                 GET AN AVAILABLE IDT
         IF    ('LTR  RX,RVR',Z),EXIT,M1ATTACH   NONE FOUND
         WITH  (IDT,RX)
         SET   IDTCNET                 SET TYPE
         PSET  @GORTYPE
         SET   @GRTYPE.@M1NATCH        MARK ATTACH REQUEST
         ACALL GONET                   GO DO IT
         END   ,
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1DETACH - I/O device DETACH service                         *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1DETACH PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  USER FORGOT TO WAIT ON PREVIOUS I/O
*
         IF    ^IDTFWD,BEGIN           PREVIOUS WAIT NOT DONE
         MVI   SCPPANSY,PANWAIT        ERROR TYPE
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1DETACH                STOP THE MUSIC
         END   ,
*
*  PROCESS TERMINAL DETACH
*
         IF    IDTCTRM,BEGIN
         CLEAR IDTFR15+IDTFR14+IDTFR1
         CLEAR IDTFWD                  CLEAR WAIT DONE FLAG
         SET   IDTFPOST                SET POSTED
         LC    R15,IDTID               RETURN PROPER
         ST    R15,SCPGPRS+0*4          ID NUMBER
         EJECT
*
*  SCHEDULE WAIT EXIT
*
         IF    ('LT  R14,IDTWXEP',NZ),BEGIN      USER WAIT EXIT
         IF    ^SCBMB.SCBXA,BEGIN
         SET   IDTFEWX                 MARK IDT TO ENTER WAIT EXIT
         SET   SCBXW                    SCB ALSO
         END   ,
         ELSE  BEGIN
         PSET  @DOWAIT
         ST    RK,@DOWTIDT             IDT TO PARM LIST
         ACALL DOWAIT                  DO IT
         SET   SCBFNPUP                DON'T CHANGE PSW CC
         END   ,
         END   ,
         END   ,
*
*  SEND FILE REQUESTS TO FILE
*
         ELSEIF IDTCFIL,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FDTCH         SET REQUEST TYPE
         ACALL GOFILE
         END   ,
*
*  SEND PATH REQUESTS TO SCOM DRIVER
*
         ELSEIF IDTCSCM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1PDTCH        MARK DETACH REQUEST
         ACALL GOPATH                  GO DO IT
         IF    (RVR,Z),'SET  IDTFFIDT' FREE IDT AT POST
         END   ,
         EJECT
*
*  SEND REQUESTS TO JES DRIVER
*
         ELSEIF IDTCJES,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1JDTCH        MARK DETACH REQUEST
         ACALL GOJES                   GO DO IT
         IF    (RVR,Z),'SET  IDTFFIDT'    FREE IDT AT POST
         END   ,
*
*  SEND REQUESTS TO NET DRIVER
*
         ELSEIF IDTCNET,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1NDTCH        MARK DETACH REQUEST
         ACALL GONET                   GO DO IT
         IF    (RVR,Z),'SET  IDTFFIDT'    FREE IDT AT POST
         END   ,
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1READ  - I/O device READ service                            *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1READ   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  USER FORGOT TO WAIT ON PREVIOUS I/O
*
         IF    ^IDTFWD,BEGIN           PREVIOUS WAIT NOT DONE
         MVI   SCPPANSY,PANWAIT        ERROR TYPE
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1READ                  STOP THE MUSIC
         END   ,
*
*  SEND REQUEST TO TERMINAL DRIVER
*
         IF    IDTCTRM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1TREAD        MARK READ REQUEST
         ACALL GOTERM                  GO DO IT
         END   ,
         EJECT
*
*  SEND FILE REQUESTS TO FILE
*
         ELSEIF IDTCFIL,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FREAD         SET REQUEST TYPE
         ACALL GOFILE
         END   ,
*
*  SEND PATH REQUEST TO SCOM DRIVER
*
         ELSEIF IDTCSCM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1PREAD        MARK READ REQUEST
         ACALL GOPATH                  GO DO IT
         END   ,
*
*  SEND NETWORK REQUEST TO NETWORK DRIVER
*
         ELSEIF IDTCNET,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1NREAD        MARK READ REQUEST
         ACALL GONET                   GO DO IT
         END   ,
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1WRITE  - I/O device WRITE service                          *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1WRITE  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  USER FORGOT TO WAIT ON PREVIOUS I/O
*
         IF    ^IDTFWD,BEGIN           PREVIOUS WAIT NOT DONE
         MVI   SCPPANSY,PANWAIT        ERROR TYPE
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1WRITE                 STOP THE MUSIC
         END   ,
*
*  SEND REQUEST TO TERMINAL DRIVER
*
         IF    IDTCTRM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1TWRIT        MARK WRITE REQUEST
         ACALL GOTERM                  GO DO IT
         END   ,
         EJECT
*
*  SEND FILE REQUESTS TO FILE
*
         ELSEIF IDTCFIL,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FWRIT        SET REQUEST TYPE
         ACALL GOFILE
         END   ,
*
*  SEND PATH REQUEST TO SCOM DRIVER
*
         ELSEIF IDTCSCM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1PWRIT        MARK WRITE REQUEST
         ACALL GOPATH                  GO DO IT
         END   ,
*
*  SEND REQUEST TO JES DRIVER
*
         ELSEIF IDTCJES,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1JWRIT        MARK WRITE REQUEST
         ACALL GOJES                   GO DO IT
         END   ,
*
*  SEND REQUEST TO NET DRIVER
*
         ELSEIF IDTCNET,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1NWRIT        MARK WRITE REQUEST
         ACALL GONET                   GO DO IT
         END   ,
         EJECT
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1CNTRL  - I/O device CONTROL service                        *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1CNTRL  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  USER FORGOT TO WAIT ON PREVIOUS I/O
*
         IF    ^IDTFWD,BEGIN           PREVIOUS WAIT NOT DONE
         MVI   SCPPANSY,PANWAIT        ERROR TYPE
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1CNTRL                 STOP THE MUSIC
         END   ,
*
*  PROCESS TERMINAL REQUESTS
*
         IF    IDTCTRM,BEGIN
         L     RS,SCPGPRS+1*4          GET REGISTER 1
         EJECT
*
*  PROCESS CONTROLS 22, 23, AND 24 HERE
*
         IF    ((RS,GE,22),AND,(RS,LE,24)),BEGIN
         LA    R15,1                   PRESET WAIT
         ST    R15,SCPGPRS+0*4          DEVICE ID
         CLEAR R15                     PRESET RETURN CODE
         ST    R15,SCPGPRS+15*4         FROM SVC
         IF    (RS,EQ,23),'SET  SCBFNESC'    FORCE SESSION BREAK
         ELSEIF  L,'CLEAR  SCBFNESC'           NORMAL MODE
         ELSE  BEGIN
         IF    ^SCBFNESC,'LA  R15,4'   NORMAL MODE RETURN CODE
         END   ,
         ST    R15,IDTR15              SET RETURN
         CLEAR IDTFR1+IDTFR14+IDTFR15
         SET   IDTFR15                 ONE REGISTER
         CLEAR IDTFWD                  WAIT NOT DONE YET
         SET   IDTFPOST                I/O COMPLETE
         END   ,
*
*  SEND OTHER REQUESTS TO TERMINAL DRIVER
*
         ELSE  BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1TCNTL        MARK CONTROL REQUEST
         ACALL GOTERM                  GO DO IT
         END   ,
         END   ,
         EJECT
*
*  SEND FILE REQUESTS TO FILE
*
         ELSEIF IDTCFIL,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FCONT         SET REQUEST TYPE
         ACALL GOFILE
         END   ,
*
*  SEND REQUEST TO JES DRIVER
*
         ELSEIF IDTCJES,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1JCNTL        MARK CONTROL REQUEST
         ACALL GOJES                   GO DO IT
         END   ,
*
*  SEND REQUEST TO NET DRIVER
*
         ELSEIF IDTCNET,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1NCNTL        MARK CONTROL REQUEST
         ACALL GONET                   GO DO IT
         END   ,
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1RESRV  - I/O device RESERVE service                        *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1RESRV  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  USER FORGOT TO WAIT ON PREVIOUS I/O
*
         IF    ^IDTFWD,BEGIN           PREVIOUS WAIT NOT DONE
         MVI   SCPPANSY,PANWAIT        ERROR TYPE
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1RESRV                 STOP THE MUSIC
         END   ,
*
*  SEND FILE REQUESTS TO FILE
*
         IF    IDTCFIL,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FRSRV        SET REQUEST TYPE
         ACALL GOFILE
*
*  If the RESERVE request is proceeding, disallow attentions
*
         IF    ('LT  RS,SCPGPRS+15*4',Z),BEGIN
         INCR  RS,SCPKLUDG
         SET   SCBCFNMA                Suppress multiple attn
         END
*
*  Reserve SVC return must always be zero
*
         ELSE  'MVC  SCPGPRS+15*4(4),=A(0)'
         END   ,
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1RELSE  - I/O device RELEASE service                        *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1RELSE  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  USER FORGOT TO WAIT ON PREVIOUS I/O
*
         IF    ^IDTFWD,BEGIN           PREVIOUS WAIT NOT DONE
         MVI   SCPPANSY,PANWAIT        ERROR TYPE
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1RELSE                 STOP THE MUSIC
         END   ,
*
*  SEND FILE REQUESTS TO FILE
*
         IF    IDTCFIL,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FRLSE        SET REQUEST TYPE
         ACALL GOFILE
*
*  If the RELEASE request is proceeding, re-enable attentions
*
         IF    ('LT  RS,SCPGPRS+15*4',Z),BEGIN
         DECR  RS,SCPKLUDG
         IF    (RS,Z),'CLEAR SCBCFNMA'   Re-enable multiple attn
         END
*
*  Release SVC return must always be zero
*
         ELSE  'MVC  SCPGPRS+15*4(4),=A(0)'
         END   ,
*
*  ALL OTHERS INVALID
*
         ELSE  BEGIN
         MVI   SCPPANSY,PANSPEC        NO GOOD
         SET   SCBXP                    PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1STATUS  - File system STATUS service                       *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1STATUS PROC  ,SCOPE=LOCAL
*
*  Send requests to FILE
*
         WITH  (IDT,RX)
         WITH  (SCP,RY)
         LCALL ASGNIDT                 GET AN AVAILABLE IDT
         IF    ('LTR  RX,RVR',Z),BEGIN NONE FOUND
         LH    RS,=Y(-4)               TOO MANY DEVICES IN USE
         ST    RS,SCPGPRS+15*4         USER RETURN CODE
         END   ,                       NONE FOUND
         ELSE  BEGIN                   GO DO STATUS
         SET   IDTCFIL                 SET FILE CLASS
         PSET  @GORTYPE
         SET   @GRTYPE.@M1FSTAT        SET REQUEST TYPE
         ACALL GOFILE
* BAD RETURN FROM STATUS OR PANIC
         IF    (SCBXP,OR,('LT RS,SCPGPRS+15*4',NZ)),BEGIN
         PSET  @FREEIDT
         PMOV @FRIADDR,LA:IDT
         ACALL FREEIDT
         END   ,                       BAD RETURN FROM STATUS
         END   ,                       GO DO STATUS
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1HALT  - I/O device HALT service                            *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1HALT   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  ONLY CLP CAN ISSUE HALT
*
         IF    (SCBFCLP+SCBFPCLP,Z),BEGIN
         MVI   SCPPANSY,PANOPER       OPERATION EXCEPTION
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1HALT
         END   ,
*
*  GET IDT POINTER
*
         ACALL FINDIDT
         IF    ('LTR  RX,RVR',Z),EXIT
         WITH  (IDT,RX)
*
*  NO I/O REQUEST IS OUTSTANDING
*
         IF    IDTFPOST,BEGIN
         LC    R15,IDTID               PROPER IDT NUMBER
         ST    R15,SCPGPRS+0*4         RETURN TO USER
         CLEAR RVR
         ST    RVR,SCPGPRS+15*4        SVC RETURN CODE
         ST    RVR,IDTR15              WAIT RETURN CODE
         SET   IDTFR15
         CLEAR IDTFR14+IDTFR1          NO VALUE IN R1 OR R14
         EXIT  M1HALT                  ALL DONE
         END   ,
         EJECT
*
*  SEND REQUEST TO TERMINAL DRIVER
*
         IF    IDTCTRM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1THALT        MARK HALT REQUEST
         ACALL GOTERM                  GO DO IT
         END   ,
*
*  SEND FILE REQUESTS TO FILE DRIVER
*
         ELSEIF IDTCFIL,BEGIN
         PSET  @FILEHALT
         MVC   @FHRQID,IDTDEVID       JONATHAN WANTS RQB POINTER
         VCALL FILEHALT
         CLEAR IDTFR1+IDTFR14+IDTFR15 Clear wait return regs
         SET   IDTFPOST               Set to posted
         SET   IDTFWD                 Wait not necessary
         END   ,
*
*  SEND REQUEST TO SCOM DRIVER
*
         ELSEIF IDTCSCM,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1PHALT        MARK HALT REQUEST
         ACALL GOPATH                  GO DO IT
         END   ,
*
*  SEND REQUEST TO JES DRIVER
*
         ELSEIF IDTCJES,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1JHALT        MARK HALT REQUEST
         ACALL GOJES                   GO DO IT
         END   ,
*
*  SEND REQUEST TO NET DRIVER
*
         ELSEIF IDTCNET,BEGIN
         PSET  @GORTYPE
         SET   @GRTYPE.@M1NHALT        MARK HALT REQUEST
         ACALL GONET                   GO DO IT
         END   ,
*
*  PROCESS REQUESTS FOR ENQ/DEQ
*
         ELSEIF IDTCENQ,BEGIN
         PSET  @M1EQHLT
         MVC   @M1EHDEV,IDTDEVID       PROVIDE THE DEVICE ID
         ACALL M1ENQHLT                HALT THE REQUEST
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    MILCOM - Mode 1 MILTEN Communication SVC                     *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
MILCOM   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  MILCOM NO LONGER USED - RETURN ERROR
*
         MVI   SCPPANSY,PANSPEC       SPEC ERROR
         SET   SCBXP                   ENTER PANIC EXIT
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SERVICE - Mode 1 SERVICE SVC                                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SERVICE  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  SERVICE NO LONGER USED - RETURN ERROR
*
         MVI   SCPPANSY,PANSPEC       SPEC ERROR
         SET   SCBXP                   ENTER PANIC EXIT
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    @GORTYPE - Request type                                     *
*                                                                 *
*******************************************************************
         SPACE
@GORTYPE RECORD BEGIN
@GRTYPE  DS    X                       REQUEST TYPE
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    GTRMWORK - Terminal driver work area                         *
*                                                                 *
*******************************************************************
         SPACE
GTRMWORK RECORD BEGIN
GTRMCLCK DS    D                       CLOCK SAVE
GTRMIOS  DS    A                       I/O COUNT
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @FREEIDT - Free IDT routine parameters                       *
*                                                                 *
*******************************************************************
         SPACE
@FREEIDT RECORD BEGIN
@FRIADDR DS    A                       IDT POINTER
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   FINDIDT - Convert user supplied ID number to                  *
*             IDT pointer for I/O routines                        *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
FINDIDT  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR RVR                     ASSUME ERROR
         L     RX,SCPGPRS+0*4          GET REGISTER ZERO
         LPR   RX,RX                   IDT NUMBER
*
*  Must be in proper range
*
         IF    ((RX,Z),OR,(RX,GT,SCPNIDT)),BEGIN
         MVI   SCPPANSY,PANSPEC        ERROR TYPE
         SET   SCBXP                   ENTER PANIC ROUTINE
         EXIT  FINDIDT
         END   ,
*
*  GET POINTER
*
         DECR  RX
         MH    RX,=Y(L'IDT)
         AL    RX,SCPIDT               FIRST IDT
         WITH  (IDT,RX)
         EJECT
*
*  MAKE SURE DEVICE ATTACHED
*
         IF    (IDTFA+IDTFACL,Z),BEGIN
         MVI   SCPPANSY,PANSPEC        ERROR TYPE
         SET   SCBXP                   ENTER PANIC ROUTINE
         EXIT  FINDIDT
         END   ,
         ELSE  'LR  RVR,RX'
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   ASGNIDT - Find an available IDT for ATTACH                    *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
ASGNIDT  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  SEARCH THROUGH IDT'S
*
         LH    RB,SCPNIDT
         DECR  RB                      LAST IDT
         DECR  RB                      RESERVE LAST ONE FOR ENQ
         MH    RB,=Y(L'IDT)
         AL    RB,SCPIDT               LAST IDT
         L     RA,SCPIDT               FIRST IDT
         WHILE (RA,LT,RB),BEGIN
         WITH  (IDT,RA)
         IF    (IDTFA+IDTFACL,Z),BEGIN   AVAILABLE
*
*  ASSIGN AN AVAILABLE IDT
*
         LC    RS,IDTID                IDT NUMBER
         CLEAR IDT                     MAKE IT LIKE NEW
         MVC   IDT(4),=CL4'IDT'        REPLACE EYE CATCHER
         STC   RS,IDTID                 AND IDT NUMBER
         IF    SCBFCLP,'SET  IDTFACL'   CLP DOING ATTACH
         ELSE  'SET IDTFA'             USER DOING ATTACH
         LR    RVR,RA
         EXIT  ASGNIDT
         END   ,
         LA    RA,IDT+L'IDT            NEXT IDT
         END   ,
         EJECT
*
*  NONE AVAILABLE
*
         MVC   SCPGPRS+15*4(4),=A(-4)  DEVICE TABLE FULL
         CLEAR RVR
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   FREEIDT - Free an IDT                                         *
*                                                                 *
*                                                                 *
*     Input - @FREEIDT                                            *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
FREEIDT  PROC  @FREEIDT,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RX,@FRIADDR             IDT POINTER
         WITH  (IDT,RX)
*
*  MAKE IT AVAILABLE
*
         LC    RS,IDTID                IDT NUMBER
         CLEAR IDT                     MAKE IT LIKE NEW
         MVC   IDT(4),=CL4'IDT'        REPLACE EYE CATCHER
         STC   RS,IDTID                 AND IDT NUMBER
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    GOFILE - Send I/O requests to FILE and device driver         *
*                                                                 *
*                                                                 *
*     Input - @GORTYPE                                             *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GOFILE   PROC  @GORTYPE,SCOPE=LOCAL
         WITH  (SCP,RY)
         WITH  (IDT,RX)

         PSET  @M1FILE
         PMOV  @M1FTYPE,@GRTYPE    Set request type
         MVC   @M1FPKEY,SCPPSW+1   PSW key
         NI    @M1FPKEY,X'F0'      Only first nibble
         PMOV  @M1FPRIV,SCPPRIV    Signed on user privileges
         LM    R0,R1,SCPGPRS+0*4   User input registers
         LM    R14,R15,SCPGPRS+14*4
         STM   R14,R1,@M1FR14      Set
         ST    RX,@M1FRQID         Set request id
         PMOV  @M1FILID,IDTID      Set file id
         PMOV  @M1FDVID,IDTDEVID   Pass this field back and forth
         CLEAR IDTFR1+IDTFR14+IDTFR15 Clear wait return regs
         CLEAR IDTFPOST            Clear IO posted
         CLEAR IDTFWD              Must issue wait SVC
         IF    SCBFCLP+SCBFPCLP,'SET @M1FCLP' Set CLP
         IF    ('LT R14,SCBSPB',NZ),BEGIN
         WITH  (SPB,R14),BEGIN
         IF    SPBFSPI,'SET @M1FSPI' Set spires attach
         END   ,                   With SPB
         END   ,                   If SPB pointer
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    O,'SET @M1FM31'     Yes

         VCALL M1FILE              Call FILEMAN

         IF    (RVR,M),BEGIN
         SET   IDTFPOST            Reset to posted
         SET   IDTFWD              Reset to wait done
         STC   RVR,SCPPANSY        Time to panic
         SET   SCBXP
         END   ,

         ELSE  BEGIN               Don't panic
         MVC   SCPGPRS+0*4(4),@M1FR00 Get return user registers
         MVC   SCPGPRS+1*4(4),@M1FR01
         MVC   SCPGPRS+15*4(4),@M1FR15
         MVC   SCPGPRS+14*4(4),@M1FR14
         MVC   IDTDEVID,@M1FDVID   Pass this field back and forth
         IF    (IDTDEVID,Z),'SET IDTFFIDT' Free IDT at wait

         IF    (@M1FR15,Z),BEGIN   Not error
* Note: IO completion routine will set wait returns when IO necessary
         IF    (RVR,NZ),BEGIN      No IO necessary
         SET   IDTFPOST            Reset to posted
         IF    (@M1FWR14,NE,=X'80000000'),'SET IDTFR14'
         IF    (@M1FWR15,NE,=X'80000000'),'SET IDTFR15'
         IF    (@M1FWR01,NE,=X'80000000'),'SET IDTFR1'
         MVC   IDTR14,@M1FWR14     Set wait return values
         MVC   IDTR15,@M1FWR15
         MVC   IDTR1,@M1FWR01
         END   ,                   No IO necessary
         END   ,                   Not error
         ELSE  BEGIN               Error return
         SET   IDTFPOST            Reset to posted
         SET   IDTFWD              Wait not necessary
         SET   IDTFR15             Set wait return for unnecessry
         CLEAR IDTR15               wait to zero
         END   ,                   Error return
         END   ,                   Don't panic

         PEND
         EJECT
*******************************************************************
*                                                                 *
*    GOTERM - Send I/O requests to Terminal device driver         *
*                                                                 *
*                                                                 *
*     Input - @GORTYPE                                            *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GOTERM   PROC  @GORTYPE,GTRMWORK,SCOPE=LOCAL
         WITH  (SCP,RY)
         WITH  (IDT,RX)
*
*  SET UP REQUEST PARAMETERS
*
         PSET  @M1TERM
         MVC   @M1TR01,SCPGPRS+1*4     SET
         MVC   @M1TR14,SCPGPRS+14*4     USER
         MVC   @M1TR15,SCPGPRS+15*4      REGISTERS
         ST    RX,@M1TRQID             SET IDT AS REQUEST ID
         MVC   @M1TTYPE,@GRTYPE        SET REQUEST TYPE
         MVC   @M1TPKEY,SCPPSW+1       PSW KEY
         NI    @M1TPKEY,X'F0'           KEY ONLY
*
*  AND PROGRAM NAME AND RUN STATUS
*
         MVC   @M1TPGM,=CL8'        '     CLEAR PROGRAM NAME
         LH    RS,SCBPNAML
         IF    (RS,NZ),BEGIN
         DEX   RS,'MVC  @M1TPGM(0),SCBPNAM'   SET PROGRAM NAME
         END   ,
         SET   @M1TFRUN                -->
*        IF    ^SCBFCLP,'SET  @M1TFRUN'    USER IS ACTIVE
         IF    ('LT  R15,SCBSPB',NZ),BEGIN
         WITH  (SPB,R15)
         IF    SPBFAUTH,'SET  @M1TFAUTH'   PROGRAM IS AUTHORIZED
         END   ,
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    O,'SET @M1TFM31'    Yes
*
*  NOW SEND IT ON
*
         VCALL M1TERM                  GO DO IT
*
*  I/O REQUEST ACCEPTED SET SVC RETURNS
*
         IF    (RVR,Z),BEGIN
         ST    RVR,SCPGPRS+15*4        SVC RETURN CODE
         WITH  (IDT,RX)
         LC    R15,IDTID               PROPER IDT NUMBER
         ST    R15,SCPGPRS+0*4         RETURN TO USER
         IF    @GRTYPE.@M1THALT,EXIT   DONE IF HALT
         CLEAR IDTFWD+IDTFPOST         NEW I/O STARTED
         END   ,
*
*  I/O REQUEST CAUSED A SPEC ERROR
*
         ELSE  BEGIN
         STC   RVR,SCPPANSY            PANIC CODE
         SET   SCBXP                   ENTER PANIC EXIT
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    GOPATH - Send I/O requests to SCOM device driver             *
*                                                                 *
*                                                                 *
*     Input - @GORTYPE                                             *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GOPATH   PROC  @GORTYPE,SCOPE=LOCAL
         WITH  (SCP,RY)
         WITH  (IDT,RX)
*
*  CHECK FOR PATHS NOT ALLOWED
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA)
         IF    CTMFPATH,BEGIN
         LH    RVR,=Y(-12)             NOT AVAILABLE RETURN CODE
         ST    RVR,SCPGPRS+15*4
         EXIT  GOPATH
         END   ,
         EJECT
*
*  SET UP REQUEST PARAMETERS
*
         PSET  @M1PATH
         MVC   @M1PR01,SCPGPRS+1*4     SET
         MVC   @M1PR14,SCPGPRS+14*4     USER
         MVC   @M1PR15,SCPGPRS+15*4      REGISTERS
         IF    ('LT  R15,SCPGPRS+0*4',M),'SET  @M1PWAIT'
         ST    RX,@M1PRQID             SET IDT AS REQUEST ID
         MVC   @M1PDVID,IDTDEVID        AND SET DEVICE ID
         MVC   @M1PTYPE,@GRTYPE        SET REQUEST TYPE
         MVC   @M1PPKEY,SCPPSW+1       PSW KEY
         NI    @M1PPKEY,X'F0'           KEY ONLY
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    O,'SET @M1PM31'     Yes
*
*  NOW SEND IT ON
*
         VCALL M1PATH                  GO DO IT
*
*  I/O REQUEST ACCEPTED SET SVC RETURNS
*
         IF    (RVR,Z),BEGIN
         ST    RVR,SCPGPRS+15*4        SVC RETURN CODE
         LC    R15,IDTID               PROPER IDT NUMBER
         ST    R15,SCPGPRS+0*4         RETURN TO USER
         IF    @GRTYPE.@M1PHALT,EXIT   DONE IF HALT
         CLEAR IDTFWD+IDTFPOST         NEW I/O STARTED
         IF    @GRTYPE.@M1PATCH,'MVC  IDTDEVID,@M1PDVID'
         END   ,
*
*  I/O REQUEST CAUSED A SPEC ERROR
*
         ELSE  BEGIN
         STC   RVR,SCPPANSY            PANIC CODE
         SET   SCBXP                   ENTER PANIC EXIT
         IF    @GRTYPE.@M1PATCH,BEGIN     UNSUCCCESSFUL ATTACH
         PSET  @FREEIDT,CLEAR=NO
         ST    RX,@FRIADDR             SET ADDRESS
         ACALL FREEIDT                 FREE IDT
         END   ,
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    GOJES - Send I/O requests to JES device driver               *
*                                                                 *
*                                                                 *
*     Input - @GORTYPE                                              *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GOJES    PROC  @GORTYPE,SCOPE=LOCAL
         WITH  (SCP,RY)
         WITH  (IDT,RX)
*
*  CHECK FOR JES NOT ALLOWED
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA)
         IF    CTMFJES,BEGIN
         LH    RVR,=Y(-12)             NOT AVAILABLE RETURN CODE
         ST    RVR,SCPGPRS+15*4
         EXIT  GOJES
         END   ,
*
*  CHECK FOR JES DEVICE ALREADY IN USE
*
         IF    @GRTYPE.@M1JATCH,BEGIN
         IF    (SCPJESR,LT,CTJESR),EXIT     HASN'T REACHED LIMIT
         LA    RVR,8                   NOT AVAILABLE RETURN CODE
         ST    RVR,SCPGPRS+15*4
         EXIT  GOJES
         END   ,
         EJECT
*
*  SET UP REQUEST PARAMETERS
*
         PSET  @M1JES
         MVC   @M1JR01,SCPGPRS+1*4     SET
         MVC   @M1JR14,SCPGPRS+14*4     USER
         MVC   @M1JR15,SCPGPRS+15*4      REGISTERS
         IF    ('LT  R15,SCPGPRS+0*4',M),'SET  @M1JWAIT'
         ST    RX,@M1JRQID             SET IDT AS REQUEST ID
         MVC   @M1JDVID,IDTDEVID        AND SET DEVICE ID
         MVC   @M1JTYPE,@GRTYPE        SET REQUEST TYPE
         MVC   @M1JPKEY,SCPPSW+1       PSW KEY
         NI    @M1JPKEY,X'F0'           KEY ONLY
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    O,'SET @M1JM31'     Yes
*
*  NOW SEND IT ON
*
         VCALL M1JES                   GO DO IT
*
*  I/O REQUEST ACCEPTED SET SVC RETURNS
*
         IF    (RVR,Z),BEGIN
         ST    RVR,SCPGPRS+15*4        SVC RETURN CODE
         LC    R15,IDTID               PROPER IDT NUMBER
         ST    R15,SCPGPRS+0*4         RETURN TO USER
         IF    @GRTYPE.@M1JHALT,EXIT   DONE IF HALT
         CLEAR IDTFWD+IDTFPOST         NEW I/O STARTED
         IF    @GRTYPE.@M1JATCH,BEGIN
         MVC   IDTDEVID,@M1JDVID       SET DEVICE ID IN IDT
         INCR  RS,SCPJESR              ACTIVE JES DEVICE COUNT
         END   ,
         END   ,
*
*  I/O REQUEST CAUSED A SPEC ERROR
*
         ELSE  BEGIN
         STC   RVR,SCPPANSY            PANIC CODE
         SET   SCBXP                   ENTER PANIC EXIT
         IF    @GRTYPE.@M1JATCH,BEGIN     UNSUCCCESSFUL ATTACH
         PSET  @FREEIDT,CLEAR=NO
         ST    RX,@FRIADDR             SET ADDRESS
         ACALL FREEIDT                 FREE IDT
         END   ,
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    GONET - Send I/O requests to NET device driver               *
*                                                                 *
*                                                                 *
*     Input - @GORTYPE                                              *
*             RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GONET    PROC  @GORTYPE,SCOPE=LOCAL
         WITH  (SCP,RY)
         WITH  (IDT,RX)
*
*  CHECK FOR NET NOT ALLOWED
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA)
         IF    CTMFNET,BEGIN
         LH    RVR,=Y(-12)             NOT AVAILABLE RETURN CODE
         ST    RVR,SCPGPRS+15*4
         EXIT  GONET
         END   ,
*
*  CHECK FOR NET NOT AVAILABLE
*
         L     RA,MATPTR                         MAT pointer
         WITH  (MAT,RA)
         IF    (MATGNCT,Z),BEGIN                 Is it set up?
         LH    RVR,=Y(-12)                       Proper Return Code
         ST    RVR,SCPGPRS+15*4
         EXIT  GONET
         END   ,
         EJECT
*
*  SET UP REQUEST PARAMETERS
*
         PSET  @M1NET
         MVC   @M1NR01,SCPGPRS+1*4     SET
         MVC   @M1NR14,SCPGPRS+14*4     USER
         MVC   @M1NR15,SCPGPRS+15*4      REGISTERS
         IF    ('LT  R15,SCPGPRS+0*4',M),'SET  @M1NWAIT'
         ST    RX,@M1NRQID             SET IDT AS REQUEST ID
         MVC   @M1NDVID,IDTDEVID        AND SET DEVICE ID
         MVC   @M1NTYPE,@GRTYPE        SET REQUEST TYPE
         MVC   @M1NPKEY,SCPPSW+1       PSW KEY
         NI    @M1NPKEY,X'F0'           KEY ONLY
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    O,'SET @M1NM31'     Yes
*
*  NOW SEND IT ON
*
         VCALL M1NET                   GO DO IT
*
*  I/O REQUEST ACCEPTED SET SVC RETURNS
*
         IF    (RVR,Z),BEGIN
         ST    RVR,SCPGPRS+15*4        SVC RETURN CODE
         LC    R15,IDTID               PROPER IDT NUMBER
         ST    R15,SCPGPRS+0*4         RETURN TO USER
         IF    @GRTYPE.@M1NHALT,EXIT   DONE IF HALT
         CLEAR IDTFWD+IDTFPOST         NEW I/O STARTED
         IF    @GRTYPE.@M1NATCH,BEGIN
         MVC   IDTDEVID,@M1NDVID       SET DEVICE ID IN IDT
         END   ,
         END   ,
*
*  I/O REQUEST CAUSED A SPEC ERROR
*
         ELSE  BEGIN
         STC   RVR,SCPPANSY            PANIC CODE
         SET   SCBXP                   ENTER PANIC EXIT
         IF    @GRTYPE.@M1NATCH,BEGIN     UNSUCCCESSFUL ATTACH
         PSET  @FREEIDT,CLEAR=NO
         ST    RX,@FRIADDR             SET ADDRESS
         ACALL FREEIDT                 FREE IDT
         END   ,
         END   ,
         PEND
        EJECT
         LTORG
         TITLE 'ORVYL''S Mode 1 Clpserv SVC'
*******************************************************************
*                                                                 *
*    CSEWORK - CLPSERV SVC Work area                              *
*                                                                 *
*******************************************************************
         SPACE
CSEWORK  RECORD BEGIN
CSENAME  DS    D                       Area for MVS name lookup
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    CSESMF - CLPSERV SMF Record description                      *
*                                                                 *
*******************************************************************
         SPACE
CSESMF   RECORD BEGIN
SMFUSER  DS    CL3                 User id
SMFGRP   DS    CL2                 Group
SMFPRJ   DS    CL2                 Project id
SMFTETYP DS    C                   Terminal connection type
SMFSYSTM DS    CL8                 Subsystem name (e.g., Orvyl)
SMFTACF  DS    X                   Account flags
SMFTRM   DS    CL3                 Terminal id
SMFPROJ  DS    CL8                 Project id
SMFTON   DS    F                   Session start time
SMFDON   DS    F                   Session start date
         DS    XL3                 Unused
SMFBLOCK DS    X                   Current time block
SMFHDR   EQU   SMFUSER,*-SMFUSER,C'X'
SMFDATA  DS    XL80                User data portion
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    CLPSERV -  Mode 1 CLP Service SVC                            *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
CLPSERV  PROC  ,CSEWORK,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  VALID ONLY FOR CLP
*
         IF    (SCBFCLP+SCBFPCLP,Z),BEGIN    CLP NOT IN CONTROL
         MVI   SCPPANSY,PANOPER        OPERATION (INVALID SVC) ERROR
         SET   SCBXP                   SET PANIC
         EXIT  CLPSERV
         END   ,
*
*  ISSUE TRACE
*
         LM    R14,R15,SCPGPRS+14*4    GET REGS
         LM    R0,R1,SCPGPRS+0*4
         XTRC  R14,R1,M1CLPSRV
         L     RA,SCPGPRS+0*4          CLPSERV CODE
         IF    (RA,GT,=A(CLPSMAX)),CSSPEC
         EJECT ,
*******************************************************************
*                                                                 *
*    CLPSERV SVC Branch Table                                     *
*                                                                 *
*******************************************************************
         SPACE
*GEN
CLPSTBL  CLPSERV TABLE,RA
CLPSMAX  EQU   *-CLPSTBL-8
*NOGEN
         EJECT
*
*  GET TOTAL CPU TIME USED BY ORVYL ADDRESS SPACE
*
ORVTIME  LABEL ,
         L     R15,SCPGPRS+15*4        LENGTH
         IF    (R15,LT,=A(5*8)),CSER4   NOT LONG ENOUGH
         BAS   RK,CSCHKADD             CHECK AREA
         L     RA,SCPGPRS+1*4          USER AREA
*
*  GET DISPATHER STATISTICS
*
         PSET  @DSPSTAT
         VCALL DSPSTAT
         MVC   @RA(4*8),@DSPSTAT       MOVE TO CLP AREA
*
*  GET TOTAL MVS CHARGED CPU TIME FROM ASCB
*
         L     RS,MATPTR               MAT POINTER
         WITH  (MAT,RS),'L  RS,MATM1CT'   CT POINTER
         WITH  (M1CT,RS),'L  R14,CTASCB'    ASCB ADDRESS
         WITH  (ASCB,R14),'LA  R14,ASCBEJST'   TOTAL CPU FIELD
         CLEAR R15                     KEY
         LA    RA,@RA+(4*8)            DIRECTLY INTO CLP AREA
         LA    RB,8                    LENGTH OF THE FIELD
         SYSCTL RA,R14,TYPE=MVSMRD     READ THE INFO
         B     CSER0
         EJECT
*
*  READ MVS MEMORY
*
FETCH    LABEL ,
         BAS   RK,CSCHKADD             FIRST CHECK CLP AREA
         IF    (RVR,NZ),CSER8          NO GOOD
         L     RA,SCPGPRS+1*4          CLP ADDRESS
         L     RB,SCPGPRS+15*4         LENGTH
         L     R14,SCPGPRS+14*4        MVS LOCATION
         CLEAR R15                     PROTECT KEY
         SYSCTL RA,R14,TYPE=MVSMRD     GET THE MEMORY
         IF    Z,CSER0                 RETURN OK
         LA    R15,12                  NON ADDRESSABLE
         B     CSEXT                   RETURN
         SPACE 3
*
*  WRITE MVS MEMORY
*
STORE    LABEL ,
         CLEAR RB
         B     CSMCOM
*
OR       LABEL ,
         LA    RB,1*256
         B     CSMCOM
*
AND      LABEL ,
         LA    RB,2*256
*
CSMCOM   LABEL ,
         BAS   RK,CSCHKADD             FIRST CHECK CLP AREA
         IF    (RVR,NZ),CSER8          NO GOOD
         L     R14,SCPGPRS+1*4         CLP ADDRESS
         L     R15,SCPGPRS+15*4         LENGTH
         L     RA,SCPGPRS+14*4         MVS LOCATION
         SYSCTL R14,RA,TYPE=MVSMWR     WRITE THE MEMORY
         IF    Z,CSER0                 RETURN OK
         LA    R15,12                  BAD ADDRESS CODE
         B     CSEXT
         EJECT
*
*  ATTACH A USER TO A SHARED PROGRAM
*
ATTSPB   LABEL ,
         IF    ^SCBFCLP,CSER4          NOT LEGAL FOR PSEUDO CLP
         L     RK,MATPTR               MAT POINTER
         WITH  (MAT,RK),'L  RK,MATM1CT'   CT POINTER
         WITH  (M1CT,RK)
*
*  FIRST GET THE SPB CHAIN LOCK
*
         LKOB  CTSPBCLK
*
*  Search for SPB
*
         L     RA,SCPGPRS+1*4          POINTER TO PROGRAM NAME
         L     RB,SCPGPRS+15*4         POINTER TO FILE NAME
         LA    RJ,CTSPBS               SPB CHAIN POINTER
         SH    RJ,=Y(SPBNEXT-SPB)      OFFSET TO CHAIN
         WITH  (SPB,RJ)
         WHILE ('LT  RJ,SPBNEXT',NZ),BEGIN
         IF    (SPBPROG,NE,@RA),NEXT   NOT A MATCH
         IF    SPBFCORPSE,NEXT     Not a match
         IF    (SPBFILE,EQ,@RB),EXIT   GOT A MATCH
         END   ,
         EJECT
*
*  SPB found - Connect this caller
*
         IF    (RJ,NZ),BEGIN
*
*  PROGRAM NOT YET ACTIVE - GET MEMORY FOR LOADING
*
         IF    ^SPBFACTV,BEGIN
         SET   SPBFLOAD                NOTE LOADING IN PROGRESS
         IF    ^SPBFMEM,BEGIN          We need memory for SPB
         IF    SPBFLHI,BEGIN
         VMGET L:SPBSIZE,LOC=GLOBHI,TYPE=PROG,KEY=USER,FETP=NO
         END   ,
         ELSE  BEGIN
         VMGET L:SPBSIZE,LOC=GLOBLO,TYPE=PROG,KEY=USER  GET MEMORY
         END   ,
         IF    (RVR,NZ),BEGIN
         ST    RVR,SPBORGIN            SAVE PROGRAM ORIGIN
         SET   SPBFMEM                 Set as memory allocated
         END   ,
*
*  NOT ENOUGH MEMORY TO LOAD PROGRAM
*
         ELSE  BEGIN
         CLEAR SPBFLOAD
         CLEAR RJ
         END   ,
         END   ,                       OF We need memory for SPB
         END
*
*  Program already loaded - update number of users
*
         ELSE  BEGIN
         INCR  RS,SPBNU                CURRENT NUMBER OF USERS
         PSET  @ACSPINF                Set name globally
         PMOV  @ACSPASB,PZCURASB       |
         PMOV  @ACSPORG,SPBORGIN       |
         VCALL ACSPINF                 |
         END
         END
         LKREL CTSPBCLK                RELEASE THE CHAIN LOCK
         IF    (RJ,Z),CSER4            NO GO
         ST    RJ,SCBSPB               SET SPB POINTER
         ST    RJ,SCPGPRS+1*4           AND RETURN TO CLP
         B     CSER0                   SUCCESSFUL COMPLETION
         DROP  SPB,M1CT
         EJECT
*
*  ADJUST AN SPB AFTER PROGRAM LOADING
*
ADJSPB   LABEL ,
         IF    ^SCBFCLP,CSSPEC         ONLY REAL CLP
         L     RJ,SCBSPB               SPB POINTER
         IF    (RJ,Z),CSER4            ALL DONE
         WITH  (SPB,RJ)
         L     RK,MATPTR               MAT POINTER
         WITH  (MAT,RK),'L  RK,MATM1CT'   CT POINTER
         WITH  (M1CT,RK)
         LKOB  CTSPBCLK
         CLEAR SPBFLOAD                LOADING COMPLETE
         SET   SPBFACTV                 AND PROGRAM ACTIVE
         INCR  RS,SPBNU                CURRENT NUMBER OF USERS
         PSET  @ACSPINF                Set name globally
         PMOV  @ACSPASB,PZCURASB       |
         PMOV  @ACSPORG,SPBORGIN       |
         VCALL ACSPINF                 |
*
*  PROTECT THE PROGRAM AREA
*
         IF    SPBFPRT,BEGIN
         PSET  @PAGE
         MVC   @PAGLOC,SPBORGIN        SET LOCATION
         MVC   @PAGLEN,SPBSIZE         AND LENGTH
         VCALL PAGPROT                 PROTECT THEM PAGES
         IF    (RVR,NZ),'ABORT SPBPGPRT'   OOPS
         END
         LKREL CTSPBCLK
         B     CSER0                   RETURN TO THE USER
         DROP  SPB,M1CT
         EJECT
*box
*
*        DETACH A USER FROM A SHARED PROGRAM
*
DETSPB   LABEL
         IF    ^SCBFCLP,CSSPEC         NO PSEUDO CLP ALLOWED
         L     RJ,SCBSPB               SPB POINTER
         IF    (RJ,NZ),BEGIN
         L     RM,MATPTR
         WITH  (MAT,RM),'L RM,MATM1CT' CT ptr
         WITH  (M1CT,RM)
         LKOB  CTSPBCLK
*-
*-       Clean up the SPB
*-
         WITH  (SPB,RJ)
         CLEAR SCBSPB                  RESET SPB POINTER
*-
*-       If program loading was interrupted release memory and
*-       reset SPB.
*-
         IF    SPBFLOAD,BEGIN      Interrupted load...
*         IF    SPBFLHI,BEGIN
         IF    ('CLI SPBORGIN,0',NE),BEGIN
      VMFREE L:SPBSIZE,A=SPBORGIN,LOC=GLOBHI,TYPE=PROG,KEY=USER,FETP=NO
         END   ,
         ELSE  BEGIN
         VMFREE L:SPBSIZE,A=SPBORGIN,LOC=GLOBLO,TYPE=PROG,KEY=USER
         END   ,
         CLEAR SPBFLOAD*SPBFMEM
         CLEAR SPBORGIN
         END
         ELSE  'DECR RS,SPBNU'         Otherwise reduce use count
*-
*-       Attempt to purge the program if it is there
*-
         LA    R1,SPB
         ACALL PURSPB                  Try for the purge
         LKREL CTSPBCLK
         END
         PSET  @ACSPINF                Clear name globally
         PMOV  @ACSPASB,PZCURASB       |
         VCALL ACSPINF                 |
         B     CSER0
         EJECT
*box
*
*        Refresh a shared program block.  We create a new one
*        for the program and mark the old one as a corpse.  New
*        calls will get the new version.
*
REFSPB   BEGIN ,                       Refresh SPB
         IF    ^SCBFCLP,CSER4
         L     RM,MATPTR
         WITH  (MAT,RM),'L RM,MATM1CT'
         WITH  (M1CT,RM)
*
*  Get SPB chain lock
*
         LKOB  CTSPBCLK
*
*  Look for specified shared program (program name uniquely quals)
*
         L     RA,SCPGPRS+1*4          Pointer to program name
         LA    RJ,CTSPBS-(SPBNEXT-SPB)
         WITH  (SPB,RJ)
         WHILE ('LT RJ,SPBNEXT',NZ),BEGIN       Look for SPB
         IF    ((SPBNAME,EQ,@RA),AND,^SPBFCORPSE),EXIT
         END   ,                       OF Look for SPB
         IF    (RJ,ZERO),BEGIN         Couldn't find SPB
         LA    R15,4
         B     REFSPBX
         END   ,                       OF Couldn't find SPB
         IF    ^SPBFACTV,BEGIN     Not active, no refresh needed...
         CLEAR R15
         B     REFSPBX
         END
*
*  Allocate new SPB
*
*         VMGET L'SPB,LOC=GLOBLO,TYPE=DATA
         VMGET L'SPB,LOC=GLOBHI,TYPE=PROG
         IF    ('LTR RK,RVR',ZERO),BEGIN        New SPB not avail
         LA    R15,4
         B     REFSPBX
         END   ,                       OF New SPB not avail
         WITH  (SPB,RK),LABEL=NEW
*-
*-       Copy the old SPB into the new SPB, then reset the
*-       information about the loaded program.
*-
         MVC   NEW.SPB,SPB             Copy the whole thing first
         CLEAR NEW.SPBORGIN            No origin yet
         CLEAR NEW.SPBNU               No users
         CLEAR NEW.SPBNREF             No references
         CLEAR NEW.SPBSSB              No symbols yet
         CLEAR NEW.SPBFL2              And these flags get cleared
*-
*-       Insert the new SPB on the queue
*-
         MVC   NEW.SPBNEXT,CTSPBS      Point it at the head
         PMOV  CTSPBS,LA:NEW.SPB       and point the head at it
*-
*-       Mark old SPB as a corpse so it will no longer be used, then
*-       check to see if it can be deleted
*-
         SET   SPBFCORPSE              Don't use this SPB any more
         LA    R1,SPB
         ACALL PURSPB                  Try to clean it up
*
*
         CLEAR R15
REFSPBX  LABEL ,
         LR    RA,R15
         LKREL CTSPBCLK
         LR    R15,RA
         END   ,                       OF Refresh SPB
         B     CSEXT
         EJECT
*box
*
*        Remove all the shared symbol references
*
CLRSSYM  LABEL
         L     RM,MATPTR
         WITH  (MAT,RM),'L RM,MATM1CT' CT ptr
         WITH  (M1CT,RM)
         LKOB  CTSPBCLK
*-
*-       Since the user is exiting the shared program, we can clear
*-       all the symbol access references.
*-
         L     RA,SCBSSAB              Get the head of the chain
         WHILE (RA,NZ),BEGIN
         WITH  (SSAB,RA)
         FAIL  (SSAB,NE,'SSAB'),BADSSABQ
         L     RJ,SSABSPB              Get the SPB location
         WITH  (SPB,RJ)
         FAIL  (SPB,NE,'SPB'),BADSSAB  Only look at good ones
         DECR  RS,SPBNREF              Delete the reference
         LR    R1,RJ                   Attempt to purge and delete it
         ACALL PURSPB                  Try to purge it
         L     RB,SSABNEXT             Address of the next
         VMFREE L'SSAB,A=(RA),LOC=LOCSYS
         LR    RA,RB
         END
         ST    RA,SCBSSAB              Clear the queue header now
         LKREL CTSPBCLK
         B     CSER0
         EJECT ,
*
*  GET USER INFORMATION
*
UINFO    LABEL ,
         BAS   RK,CSCHKADD             CHECK BUFFER
         L     R15,SCPGPRS+15*4        LENGTH
         IF    (R15,LT,40),CSSPEC      NO GOOD
         L     RA,SCPGPRS+1*4          BUFFER AREA
         L     RJ,MATPTR               MAT POINTER
         WITH  (MAT,RJ)
         L     RB,SCPGPRS+14*4         ASB POINTER
         LKOB  MATASBL                 GET THE ASB LOCK
         IF    (RB,Z),'L  RB,MATASBS'  FIRST ASB
         WITH  (ASB,RB)
         IF    ((ASBID,EQ,=CL4'ASB'),AND,(ASBAIB,NZ)),BEGIN
         PSET  @ACINFO
         ST    RB,@ACIASB              SET ASB
         VCALL ACINFO                  GET RESOURCE USAGE
         MVC   @RA+4(4),@ACIIOS        I/O COUNT
         MVC   @RA+8(8),@ACICPU        CPU TIME
         MVC   @RA+24(8),@ACIPGNM      PROGRAM NAME
         MVC   @RA+32(4),@ACITID       TERMINAL ID
         MVC   @RA+36(4),@ACIORG       SHARED PROGRAM ADDRESS
         PSET  @ACAINFO
         ST    RB,@ACAASB              SET ASB
         VCALL ACAINFO                 GET ACCOUNTING INFO
         MVC   @RA+16(8),@ACAUID       USER ID
         STCK  CSENAME
         LM    R14,R15,CSENAME         Get current time
         ADL   R14,PZTZOFF             Add time zone offset
         SLDL  R14,12                  Significance
         LM    R0,R1,@ACALOT           Logon time
         SLDL  R0,12                   Significance
         SLR   R14,R0                  Calc time logged on
         LR    R15,R14
         CLEAR R14
         LM    R0,R1,=FL8S12E5'600'    One minute
         SLDL  R0,12                   Significance
         DR    R14,R0                  Calc number of minutes
         ST    R15,@RA+40              Number of minutes logged on
         WITH  (ASB,RB),'MVC  @RA(4),ASBNEXT'   NEXT ASB
         CLEAR RA
         END   ,
         ELSE  'LA  RA,4'
         LKREL MATASBL                 RELEASE THE ASB LOCK
         LR    R15,RA                  RETURN CODE
         B     CSEXT
         DROP  MAT,ASB
         EJECT
*
*  CHECK ADDRESS FOR CLP
*
CHKADDR  LABEL ,
         BAS   RK,CSCHKADD             GO CHECK ADDRESS
         IF    (RVR,NZ),'LA  RVR,2'    NOTE PROTECTED (READ ONLY)
         ST    RVR,SCPGPRS+0*4         OK ADDRESS
         B     CSER0
         SPACE 3
*
*  GET KERNAL MAP POINTERS
*
GETMAP   LABEL ,
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),BEGIN
         MVC   SCPGPRS+1*4(4),MATKMAP   MAP POINTER
         MVC   SCPGPRS+15*4(4),MATKMAPL   MAP LENGTH
         END   ,
         B     CSEXTGO
*
*  LOCATE COMMUNICATIONS TABLE
*
LOCCT    LABEL ,
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),BEGIN
         MVC   SCPGPRS+1*4(4),MATM1CT   CT POINTER
         END   ,
         LA    R15,L'M1CT              LENGTH
         B     CSEXT
         EJECT
*
*  TURN ON PAGE PROTECTION
*
PGPRTON  LABEL ,
         BAS   RK,CSCHKADD             FIRST CHECK ADDRESS
         PSET  @PAGE
         MVC   @PAGLOC,SCPGPRS+1*4     SET LOCATION
         MVC   @PAGLEN,SCPGPRS+15*4     AND LENGTH
         VCALL PAGPROT                 PROTECT THEM PAGES
         IF    (RVR,NZ),'ABORT CLPGPRT'   OOPS
         B     CSEXTGO
*
*  TURN OFF PAGE PROTECTION
*
PGPRTOFF LABEL ,
         BAS   RK,CSCHKADD             FIRST CHECK ADDRESS
         PSET  @PAGE
         MVC   @PAGLOC,SCPGPRS+1*4     SET LOCATION
         MVC   @PAGLEN,SCPGPRS+15*4     AND LENGTH
         VCALL PAGUPROT                UNPROTECT THEM PAGES
         IF    (RVR,NZ),'ABORT CLPGUPRT'   OOPS
         B     CSEXTGO
         EJECT
*
*  GET CLW MEMORY
*
GETCLW   LABEL
         L     RB,SCPGPRS+1*4          REQUESTED LENGTH
         LA    RB,@RB+4095             ROUND UP TO
         N     RB,=X'00FFF000'          PAGE BOUNDARY
         VMGET (RB),LOC=LOCSYS,TYPE=PROG,FETP=YES
*
*  IF MEMORY RETURNED CLEAR IT - OTHERWISE GIVE ERROR CODE
*
         IF    (RVR,Z),CSER4           ERROR
         ST    RVR,SCPGPRS+1*4         RETURN ADDRESS
         LR    RA,RVR                  LOCATION
         CLEAR RS
         MVCL  RA,R0                   CLEAR
         B     CSER0                   THATS ALL
         EJECT
*
*  FREE CLW MEMORY
*
FREECLW  LABEL ,
         L     RS,SCPGPRS+1*4          LOCATION
         L     R15,SCPGPRS+15*4        LENGTH
         AR    R15,RS                  LAST BYTE
         N     RS,=X'00FFF000'         ROUND TO PAGE BOUNDARY
         SR    R15,RS                  NUMBER OF BYTES
         LA    R15,@R15+4095           ROUND UP TO
         N     R15,=X'00FFF000'         PAGES
         VMFREE (R15),A=(RS),LOC=LOCSYS,TYPE=PROG,FETP=YES
         IF    (RVR,NZ),'ABORT FREECLW'
         B     CSEXTGO                 NOT MUCH TO DO
         EJECT
*
*  TRANSLATE SYMBOLIC NAME INTO AN MVS ADDRESS
*
REGION   LABEL ,
         BAS   RK,CSCHKADD             CHECK NAME FIELD
         MVC   CSENAME(8),=CL8' '
         L     RS,SCPGPRS+1*4          POINTER TO SUPPLIED NAME
         L     R15,SCPGPRS+15*4         LENGTH
         DEX   R15,'MVC CSENAME(0),@RS'   MOVE NAME
         LA    RS,CSENAME
         SYSCTL RS,TYPE=MVSNAM         TRY TO FIND IT
         IF    (RS,Z),CSER4            NOT FOUND
         ST    RS,SCPGPRS+1*4          RETURN ADDRESS
         B     CSER0                   NOT FOUND
         SPACE 3
*
*  UPDATE USER PRIVILEGE BYTE
*
PRIVTST  LABEL ,
         PSET  @ACAINFO
         MVC   @ACAASB,PZCURASB        CURRENT ASB
         VCALL ACAINFO                 GET INFO
         MVC   SCPPRIV,MILPRIV         UPDATE PRIVS
         B     CSER0
         EJECT
*
* SET PSW KEY
*
SETKEY   LABEL ,
         LC    R15,SCPPSW+1            GET CURRENT KEY
         SRL   R15,4
         NI    SCPPSW+1,X'0F'          CLEAR CURRENT KEY
         L     RS,SCPGPRS+1*4          GET NEW KEY
         SLL   RS,4                    SHIFT NEW KEY
         EX    RS,'OI  SCPPSW+1,0'     OR IN NEW KEY
         B     CSEXT
         SPACE 3
*
*  OBTAIN SPB CHAIN POINTER
*
SPBPTR   LABEL ,
         L     R15,MATPTR               MAT POINTER
         WITH  (MAT,R15),'L  R15,MATM1CT'   CT POINTER
         WITH  (M1CT,R15),'L  R15,CTSPBS'    SPB CHAIN
         B     CSEXT
         SPACE 3
*
*  SET/CLEAR PSEUDO CLP STATUS
*
PSEUDO   LABEL ,
         CLEAR SCBFPCLP                ASSUME CLEAR
         L     RS,SCPGPRS+1*4          CODE
         IF    (RS,Z),CSEXTGO          GOOD GUESS
         SET   SCBFPCLP                SET IT
         B     CSEXTGO
         SPACE 3
*
*  ADJUST NUMBER OF PAGE FRAMES
*
SETPF    LABEL ,
         L     RS,SCPGPRS+1*4          CODE
         IF    (RS,NPOS),CSER4         CHECK ARGUMENT
         B     CSEXTGO
         EJECT
*
*  WRITE AN SMF RECORD
*
PUTSMF   LABEL ,
         BAS   RK,CSCHKADD             CHECK USER DATA AREA
         VMGET L'CSESMF,LOC=LOCSYS
         IF    ('LTR  RJ,RVR',Z),CSEXTGO    NOT ENOUGH MEMORY
         WITH  (CSESMF,RJ)
         CLEAR CSESMF                  TIDY UP
*
*  Get caller supplied data
*
         L     R14,SCPGPRS+1*4         USER LOCATION
         L     R15,SCPGPRS+R15*4        AND LENGTH
         CEIL  R15,L'SMFDATA           MAXIMUM DATA LENGTH
         LA    RA,SMFDATA              DATA LOCATION
         LR    RB,R15                   COPY LENGTH
         MVCL  RA,R14                  BRING IN DATA
*
*  FILL IN SMF RECORD
*
         MVC   SMFGRP,SCPGROUP         COPY GROUP
         MVC   SMFUSER,SCPUSER          AND USER
*
*  ADD ORVYL NAME
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA)
         MVC   SMFSYSTM,MATSNAME
*
*  GET TIME BLOCK FROM SCIP CVT
*
         L     R14,MATM1CT             CT POINTER
         DROP  MAT
         WITH  (M1CT,R14),'L  R14,CTSCVT'   "SCIP" CVT POINTER
         WITH  (SCVT,R14),'LA  R14,SCVBLOCK'    BLOCK BYTE
         LA    R15,14                  AVERAGE GUY
         LA    RA,SMFBLOCK             PLACE TO PUT IT
         LA    RB,1                    ONE BYTE IS ALL WE WANT
         SYSCTL RA,R14,TYPE=MVSMRD     GET IT
*
*  GET TIME AND DATE OF LOGON
*
         PSET  @ACAINFO
         MVC   @ACAASB,PZCURASB        CURRENT ASB
         VCALL ACAINFO                 GET INFO
         LM    R14,R15,@ACALOT         CLOCK AT LOGON
         PSET  @TOD
         STM   R14,R15,@TODCLK         TOD FORMAT
         ACALL SENSETD2
         MVC   SMFTON,@TODTIM          SET TIME
         MVC   SMFDON,@TODDAT           AND DATE
*
*  WRITE THE RECORD
*
         L     RS,SCPGPRS+R15*4        USER LENGTH
         CEIL  RS,L'SMFDATA            MAXIMUM DATA LENGTH
         LA    RS,@RS+L'SMFHDR         RECORD LENGTH
         ICM   RS,B'1000',SCPGPRS+14*4+3   RECORD NUMBER
         SYSCTL RJ,RS,TYPE=SMF
         VMFREE  L'CSESMF,A=(RJ),LOC=LOCSYS
         DROP  RJ
         IF    (RVR,NZ),'ABORT FREESMF'
         B     CSEXTGO                 RETURN CODE SET
         EJECT
*
*  RESET THE TRASH BYTE TO THE DEFAULT
*
RSTRASH  LABEL ,
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA),'MVC  SCPTRASH,CTTRASH'    DEFAULT TRASH BYTE
         B     CSEXTGO
         SPACE 3
*
*  Enable/Disable user I/O functions
*
UIOFSET  LABEL ,
         L     RS,SCPGPRS+1*4          Function ID
         L     R15,SCPGPRS+15*4        On/Off indicator
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA)
         IF    (R15,NZ),'EX  0,UIOFDIS(RS)'   Turn it off
         ELSE  'EX  0,UIOFENB(RS)'            Turn it on
         B     CSEXTGO
*
UIOFDIS  SET   CTMFPATH
         SET   CTMFJES
         SET   CTMFOSF
         SET   CTMFKEY
         SET   CTMFNET
*
UIOFENB  CLEAR CTMFPATH
         CLEAR CTMFJES
         CLEAR CTMFOSF
         CLEAR CTMFKEY
         CLEAR CTMFNET
*
         DROP  RA
         EJECT ,
*
*  Scan the device tables
*
DEVSCAN  LABEL ,
*
*  Starting value must be in proper range
*
         L     R15,SCPGPRS+1*4         Starting IDT number
         IF    ((R15,M),OR,(R15,GT,SCPNIDT)),CSER8
         LA    R15,@R15+1              Next IDT
*
*  Loop through the IDTs
*
         WHILE (R15,LE,SCPNIDT),BEGIN
         LR    RA,R15                  COPY NUMBER
         DECR  RA
         MH    RA,=Y(L'IDT)
         AL    RA,SCPIDT               FIRST IDT
         WITH  (IDT,RA)
*
*  If device is active see if it fits the bill
*
         IF    IDTFA+IDTFACL,BEGIN
         L     RS,SCPGPRS+15*4
         IF    (RS,Z),BEGIN
         ST    R15,SCPGPRS+1*4
         B     CSER0
         END
         IF    ((RS,EQ,4),AND,IDTFA),BEGIN
         ST    R15,SCPGPRS+1*4
         B     CSER0
         END
         IF    ((RS,EQ,8),AND,IDTCFIL,AND,(IDTDEVID,NZ)),BEGIN
         ST    R15,SCPGPRS+1*4
         B     CSER0
         END
         END
         LA    R15,@R15+1              Next IDT
         END
         B     CSER4
         SPACE 3
*
*  Obtain device information
*
DEVINFO  LABEL ,
         BAS   RK,CSCHKADD             Check buffer
         L     RJ,SCPGPRS+14*4         Get IDT number
*
*  Must be in proper range
*
         IF    ((RJ,Z),OR,(RJ,GT,SCPNIDT)),CSER8
*
*  Get IDT address
*
         DECR  RJ
         MH    RJ,=Y(L'IDT)
         AL    RJ,SCPIDT               FIRST IDT
         WITH  (IDT,RJ)
*
*  Check that device is active
*
         IF    (IDTFA+IDTFACL,Z),CSER4
*
*  Move data
*
         L     RA,SCPGPRS+1*4          Get location
         L     RB,SCPGPRS+15*4          and length

         IF    IDTCLASS.IDTCFIL,BEGIN
         IF    (RB,LT,L'@FMFINAM+2),CSER8
         PSET  @FMFINFO
         PMOV  @FMFIDID,IDTDEVID
         VCALL FMANFINF
         MVI   @RA,0
         IF    @FMFISHR,'SET  @RA.X"80"'
         IF    @FMFIRSV,'SET  @RA.X"40"'
         MVC   @RA+1(1),@FMFIPRI
         MVC   @RA+2(L'@FMFINAM),@FMFINAM
         B     CSEXTGO
         END
         B     CSER4
         EJECT
*
*  TERMINAL INFO PUSH
*
TERMPUSH LABEL
         L     RA,SCPIDT               FIRST IDT IS TERMINAL
         WITH  (IDT,RA)
         MVC   IDTTRFL,IDTFLG          SAVE FLAGS
         MVC   IDTTRRG(3*4),IDTR1       AND REGS
         B     CSEXTGO
         SPACE 3
*
*  TERMINAL INFO POP
*
TERMPOP  LABEL
         L     RA,SCPIDT               FIRST IDT IS TERMINAL
         WITH  (IDT,RA)
         NI    IDTTRFL,L'IDTFR1+L'IDTFR15+L'IDTFR14
         CLEAR IDTFLG.IDTFR1+IDTFR15+IDTFR14
         OC    IDTFLG(1),IDTTRFL
         MVC   IDTR1(12),IDTTRRG
         B     CSEXTGO
         EJECT
*
*  Do Timing for "Orvyl queued"
*
QTIMER   LABEL
         IF    ^SCBFCLP,CSSPEC         ONLY REAL CLP
         CLEAR SCBXCPT                 CLP TIMER EXIT CANCEL
         IF    SCBTCPTR+SCBTCPCT+SCBTCPQU,BEGIN   TIMER NOW RUNNING
*
*  CPU TIMER IS NOW RUNNING
*
         IF    SCBTCPCT,BEGIN          CURRENT TIMER IS CPU TIME
         PSET  @CPCNCK
         MVC   @CPCID,SCPCCLK          CLOCK ID
         VCALL CPCAN                   CAN IT
         END   ,
*
*  REAL TIMER IS NOW RUNNING
*
         ELSE  BEGIN                   CURRENT TIMER IS REAL TIME
         PSET  @RTCNCK
         MVC   @RTCID,SCPCCLK          CLOCK ID
         VCALL RTCAN                   CAN IT
         END   ,
         CLEAR SCBTCPTR+SCBTCPCT       NOTE CANCELLED
         END   ,
*
*  NOW SET "QUEUED" TIMER
*
         PSET  @RTSET
         MVC   @RTSCLK,=FL8S12E5'10'   1.0 SECONDS
         SET   @RTSFINT                VALUE IS AN INTERVAL
         MVC   @RTSXIT,SCPCCXIT        SET EXIT ID
         VCALL RTSET                   START THE CLOCK
         ST    RVR,SCPCCLK             SAVE ID
         SET   SCBTCPQU
         SET   SCBFWAIT                MARK USER AS WAITING
         B     CSER0
*-
*-       Do cache control operation.
*-
CACTRLX  LABEL
         PSET  @CACTRL
         PMOV  @CACCIT,SCPGPRS+14*4   CIT ptr
         PMOV  @CACCNO,SCPGPRS+1*4    Control number
         PMOV  @CACPARM,SCPGPRS+15*4  Parm
         VCALL CACTRL              Do cache control operation
*
         LR    R15,RVR             Copy return code reg
         B     CSEXT               Scram
         EJECT ,
*
*  Return user region parameters
*
VREGION  LABEL ,
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'    CT POINTER
         WITH  (M1CT,RA),BEGIN
         L     RS,CTUMORG
         ST    RS,SCPGPRS+1*4          Set user memory origin
         L     RS,CTUMSIZ              Get user memory size
         SLL   RS,4                    Convert to pages high order
         ICM   RS,B'0011',CTUMPGS      Get total pages low order
         ST    RS,SCPGPRS+0*4          Set set user memory lengths
         LA    RS,CTUMPGS
         ST    RS,SCPGPRS+14*4         Set region pointer
         END
         CLEAR R15                     Set return
         B     CSEXT               Scram
         EJECT ,
*
*  Add a volume to a file system
*
ADDVOL   LABEL ,
         PSET  @FSADDV
         PMOV  @FSADDVF,SCPGPRS+1*4    File system name
         PMOV  @FSADDVD,SCPGPRS+15*4   Dataset name
         VCALL FSADDVOL
         LR    R15,RVR                 Set return
         B     CSEXT
         EJECT
*******************************************************************
*                                                                 *
*    CSCHKADD - Check user buffer area routine for Clpserv SVC    *
*                                                                 *
*******************************************************************
         SPACE
CSCHKADD LABEL
         L     R15,SCPGPRS+15*4        LENGTH
         IF    (R15,NP),CSSPEC         CHECK VALID
         IF    (R15,GT,8192),CSSPEC
         PSET  @PAGE
         MVC   @PAGLOC,SCPGPRS+1*4     LOCATION
         ST    R15,@PAGLEN              AND LENGTH TO PARM AREA
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),CSER8        NO GOOD
         BR    RK                      RETURN
         EJECT
*******************************************************************
*                                                                 *
*    CLPSERV SVC - return routines                                *
*                                                                 *
*******************************************************************
         SPACE
CSSPEC   MVI   SCPPANSY,PANSPEC        SPECIFICATION ERROR
         B     PANSET
*
PANSET   SET   SCBXP                   SET PANIC
         B     CSEXTGO
*
CSER0    CLEAR R15
         B     CSEXT
*
CSER4    LA    R15,4
         B     CSEXT
*
CSER8    LA    R15,8
         B     CSEXT
*
CSEXT    ST    R15,SCPGPRS+15*4        SET RETURN CODE
*
CSEXTGO  LABEL ,
         PEND
         EJECT
         LTORG
         TITLE 'ORVYL''S Mode 1 Sense SVC'
*******************************************************************
*                                                                 *
*    SENWORK - SENSE SVC Work area                                *
*                                                                 *
*******************************************************************
         SPACE
SENWORK  RECORD BEGIN
SNWCLOK  DS    D                       STORE CLOCK AREA
SNWMEM   DS    A                       MVS MEMORY READ WORK AREA
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SENSE  - Mode 1 SENSE SVC                                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SENSE    PROC  ,SENWORK,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  ISSUE TRACE
*
         LM    R14,R15,SCPGPRS+14*4    GET REGS
         LM    R0,R1,SCPGPRS+0*4
         XTRC  R14,R1,M1SENSE
         L     RA,SCPGPRS+0*4          SENSE CODE
         IF    (RA,GT,=A(MAXPSEN)),'S  RA,=A(HSENBASE-MAXPSEN-1)'
         IF    ((RA,M),OR,(RA,GT,=A(MAXSENSE))),SENSPEC
         SLL   RA,2
         B     SENSEBR(RA)
         EJECT ,
*******************************************************************
*                                                                 *
*    SENSE SVC - Branch Table                                     *
*                                                                 *
*******************************************************************
         SPACE
SENSEBR  B     SENPS             0     PAGE STATUS
         B     SENRASS           1     RESERVED ADDRESS SPACE STATS
         B     SENRASL           2     RESERVED ADDRESS SPACE LIMITS
         B     SENTD             3     TIME AND DATE
         B     SENET             4     ELAPSED TIMES
         B     SENRT             5     REMAINING TIME
         B     SENMB             6     MASK BYTE
         B     SENPR             7     PRIORITY
         B     SENNAT            8     NAME, ACCOUNT, TERMINAL
         B     SENTX             9     TIMER EXIT
         B     SENSX            10     SVC EXIT
         B     SENPX            11     PANIC EXIT
         B     SENAX            12     ATTN EXIT
         B     SENWX            13     WAIT EXIT
         B     SENTC            14     TEST COMPLTETION
         B     SENSA            15     SENSE SAVE AREA
         B     SENPXA           16     SENSE PAGING EXCEPTION ADDR
         B     SENCWA           17     SENSE COMMON WORK AREA
         B     SENCMD           18     SENSE COMMAND
         B     SENPARM          19     SENSE COMMAND PARM
         B     SENCOR           20     SENSE REAL CORE
         B     SENPER           21     SENSE PER CR 9-11
         B     SENMON           22     SENSE MONITOR CR 8
         B     SENFSI           23     SENSE FILE SYSTEM INFO
         B     SENTRASH         24     SENSE TRASH BYTE
         B     SENACCIN         25     SENSE ACCOUNTING INFO
         B     SENTBLOK         26     SENSE TIME BLOCK
         B     SENHASP          27     SENSE HASP DISPLAY DATA
         B     SENONAM          28     SENSE ORVYL NAME
         B     SENPNAM          29     SENSE PROGRAM NAME
         B     SENSYM           30     Locate symbol address
         B     SENUSYM          31     Unreference symbol address
MAXPSEN  EQU   (*-SENSEBR)/4-1         MAXIMUM PUBLIC SENSE
HSENBASE EQU   150                     START OF "HIDDEN" SENSES
         B     SENCOST         150     SENSE SESSION COST
         B     SENFSBS         151     SENSE FILE SYSTEM INFO
         B     SENXASC         152     SENSE cross AS memory
         B     SENGLOBM        153     SENSE global memory
         B     SENOSMEM        154     SENSE OS memory
MAXSENSE EQU   (*-SENSEBR)/4-1
         EJECT ,
*******************************************************************
*                                                                 *
*    SENSE SVC memory services                                    *
*                                                                 *
*******************************************************************
         SPACE
*
*  SENSE PAGE STATUS
*
SENPS    LABEL ,         0
         L     RA,SCPGPRS+1*4          LOCATION
         N     RA,=X'00FFF000'
         L     RB,=A(4096)             LENGTH
         VMCHK (RB),A=(RA),LOC=LOCUSR,KEY=USER     CHECK VALIDITY
         IF    (RVR,NZ),SENR8          INVALID PAGE ADDRESS
*
*  CALL MEMORY PROTECT TESTING SERVICE
*
         PSET  @PAGE,CLEAR=NO
         ST    RA,@PAGLOC              SET ADDRESS
         ST    RB,@PAGLEN               AND LENGTH
         VCALL PAGTPTP                 TEST THE PAGE PROTECTION
         IF    (RVR,NZ),'LA  RVR,2'    PAGE IS PROTECTED
         LRA   RA,@RA                  IS IT IN MEMORY
         IF    Z,'O  RVR,=A(1)'        YES
         ST    RVR,SCPGPRS+0*4         RETURN PROTECT STATUS
         B     SENR0
         EJECT
*
*  SENSE RESERVED ADDRESS SPACE STATISTICS
*
SENRASS  LABEL ,         1
         LH    RS,SCPRESRV             CURRENT RESERVED PAGE COUNT
         LH    R15,SCPUNRSV            UN-RESERVED PAGE COUNT
         AR    RS,R15                  TOTAL RESERVABLE PAGES
         SLL   RS,12                   LENGTH IN BYTES
         ST    RS,SCPGPRS+1*4          RETURN
         SLL   R15,12                  UN-RESERVED ALSO TO BYTES
         B     SENX
         SPACE 3
*
*  SENSE RESERVED ADDRESS SPACE LIMITS
*
SENRASL  LABEL ,         2
         L     RS,SCPRRSEG             WORK AREA START ADDRESS
         ST    RS,SCPGPRS+1*4
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'    CT POINTER
         WITH  (M1CT,RA),BEGIN
         L     R15,CTUMORG             ADDRESS SPACE START
         A     R15,CTUMSIZ             ADDRESS SPACE END
         SR    R15,RS                  LENGTH OF WORK AREA
         END
         B     SENX
         SPACE 3
*
*  SENSE PAGING EXCEPTION ADDR
*
SENPXA   LABEL ,        16
         L     R15,SCPPXA
         B     SENX
         SPACE 3
*
* SENSE TRASH (MEMORY CLEARING) BYTE
*
SENTRASH LABEL ,        24
         LC    R15,SCPTRASH
         B     SENX
         EJECT ,
*******************************************************************
*                                                                 *
*    SENSE SVC time services                                      *
*                                                                 *
*******************************************************************
         SPACE
*
*  SENSE TIME AND DATE
*
SENTD    LABEL ,         3
         PSET  @TOD
         ACALL SENSETD
         LD    R0,@TODTIM              TIME OF DAY
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SNWCLOK              SET TIME
         MVC   SCPGPRS+1*4(4),SNWCLOK+4     RETURN TIME OF DAY
         L     R15,@TODDAT             AND DATE
         B     SENX
         SPACE 3
*
*  SENSE ELAPSED AND CPU TIME
*
SENET    LABEL ,         4
*
*  GET ACCOUNTING INFORMATION
*
         PSET  @ACINFO
         MVC   @ACIASB,PZCURASB        CURRENT ASB
         VCALL ACINFO
         LD    R0,@ACICON              CONNECT TIME
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SNWCLOK              SET TIME
         MVC   SCPGPRS+1*4(4),SNWCLOK+4   RETURN ELAPSED TIME
*
*  NOW GET CPU TIME
*
         VCALL ACPUCHG                 GET CPU TIME
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SNWCLOK
         L     R15,SNWCLOK+4           CPU TIME
         B     SENX
         EJECT
*
*  SENSE REMAINING TIME
*
SENRT    LABEL ,         5
         IF    ^SCBTUTR,SENR0          NOTHING TO REPORT
*
*  CPU TIMER IS SET
*
         IF    SCBTUCT,BEGIN           CURRENT TIMER IS CPU TIME
         PSET  @CPCNCK
         MVC   @CPCID,SCPUCLK          CLOCK ID
         VCALL CPCHK                   GET IT
         LD    R0,@CPCCLK              CURRENT INTERVAL
         END   ,
*
*  REAL TIMER IS SET
*
         ELSE  BEGIN                   CURRENT TIMER IS REAL TIME
         PSET  @RTCNCK
         MVC   @RTCID,SCPUCLK          CLOCK ID
         VCALL RTCHK                   GET IT
         LD    R0,@RTCCLK              CURRENT INTERVAL
         END   ,
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SNWCLOK
         L     R15,SNWCLOK+4           CPU TIME
         B     SENX
         EJECT
*  SENSE MASK BYTE
*
SENMB    LABEL ,         6
         LC    R15,SCBMB
         B     SENX
         SPACE 3
*
*  SENSE PRIORITY
*
SENPR    LABEL ,         7
         LC    R15,SCBUPRI
         B     SENX
         SPACE 3
*
*  SENSE NAME, ACCOUNT, TERMINAL
*
SENNAT   LABEL ,         8
         LA    R15,27                  LENGTH TO CHECK
         BAS   RK,SENCKANL              CHECK IT OUT
         PSET  @TERUINF
         VCALL TERUINF
         MVC   @RS(L'SCPUSER),SCPUSER   SET USER ID
         MVI   @RS+L'SCPUSER,C'$'
         MVC   @RS+L'SCPUSER+1(L'SCPGROUP),SCPGROUP
         MVC   @RS+8(3),@TERUTYP       Terminal type
         MVC   @RS+11(L'SCPACCT),@RS   SET "NAME"
         MVC   @RS+17(10),=CL16' '
         B     SENXGO
         EJECT ,
*******************************************************************
*                                                                 *
*    SENSE SVC exit services                                      *
*                                                                 *
*******************************************************************
         SPACE
*
*  SENSE TIMER EXIT
*
SENTX    LABEL ,         9
         LA    RB,SCPTXEP
         B     SENEXIT
         SPACE 3
*
*  SENSE SVC EXIT
*
SENSX    LABEL ,        10
         LA    RB,SCPSXEP
         B     SENEXIT
         SPACE 3
*
*  SENSE PANIC EXIT
*
SENPX    LABEL ,        11
         LA    RB,SCPPXEP
         B     SENEXIT                 TO COMMON EXIT PROCESS
         SPACE 3
*
*  SENSE ATTN EXIT
*
SENAX    LABEL ,        12
         LA    RB,IDTAXEP-IDT          INDEX TO EXIT INFO
         B     IOSXCOM
         SPACE 3
*
*  SENSE WAIT EXIT
*
SENWX    LABEL ,        13
         LA    RB,IDTWXEP-IDT          INDEX TO EXIT INFO
         B     IOSXCOM
         EJECT ,
*
*  COMMON PROCESSING FOR I/O EXITS
*
IOSXCOM  LABEL
         L     RS,SCPGPRS+1*4          USER SUPPLIED DEVICE NUMBER
         IF    (RS,NP),SENSPEC         MUST BE POSITIVE
         IF    (RS,GT,SCPNIDT),SENSPEC    NOT IN RANGE
         DECR  RS
         MH    RS,=Y(L'IDT)
         AL    RS,SCPIDT               IDT VIRTUAL ADDDRESS
         WITH  (IDT,RS),BEGIN
         IF    (IDTFA+IDTFACL,Z),SENSPEC      NOT ACTIVE
         END
         ALR   RB,RS                   POINTER TO DEVICE EXIT INFO
         SPACE 3
*
*  COMMON PROCESSING FOR ALL EXITS
*
SENEXIT  LABEL ,
         MVC   SCPGPRS+R15*4(4),@RB     EXIT ADDRESS
         MVC   SCPGPRS+R14*4(4),@RB+4   EXIT PARAMETER
         B     SENXGO
         EJECT
*
*  TEST FOR COMPLETION
*
SENTC    LABEL ,        14
         L     RS,SCPGPRS+1*4          USER SUPPLIED DEVICE NUMBER
         IF    (RS,NP),SENSPEC         MUST BE POSITIVE
         IF    (RS,GT,SCPNIDT),SENSPEC    NOT IN RANGE
         DECR  RS
         MH    RS,=Y(L'IDT)
         AL    RS,SCPIDT               IDT VIRTUAL ADDDRESS
         WITH  (IDT,RS),BEGIN
         IF    (IDTFA+IDTFACL,Z),SENSPEC      NOT ACTIVE
         IF    IDTFPOST,SENR0          COMPLETE
         END
         B     SENR4                   NOT DONE YET
         SPACE 3
*
*  SENSE SAVE AREA
*
SENSA    LABEL ,        15
         LA    R15,72                  LENGTH TO CHECK
         BAS   RK,SENCKANL              CHECK IT OUT
         MVC   @RS(8),SCPXPSW          MOVE PSW TO USERS AREA
         MVC   @RS+8(16*4),SCPXPSW+8    AND REGS TOO
         B     SENXGO
         EJECT
*
*  SENSE COMMON WORK AREA
*
SENCWA   LABEL ,        17
         L     RB,SCPGPRS+1*4          DISPLACEMENT
         IF    (RB,M),SENSPEC
         LA    RA,SCPCWASZ             NUMBER OF BYTES AVAILABLE
         IF    (RB,NL,RA),SENSPEC
         SR    RA,RB
         IF    (RA,LT,SCPGPRS+15*4),SENSPEC   GOES PAST THE END
         L     RA,SCPGPRS+15*4         NUMBER OF BYTES TO MOVE
         IF    (RA,NP),SENSPEC
*
*  CHECK MEMORY AREA
*
         PSET  @PAGE
         L     RS,SCPGPRS+14*4         LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RS,=X"00FFFFFF"'
         ST    RS,@PAGLOC              SET LOCATION
         ST    RA,@PAGLEN               AND LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,NZ),SENSPEC        NO GOOD
*
*  NOW MOVE THE DATA
*
         L     RS,SCBSPB               SPB POINTER
         IF    (RS,NZ),BEGIN
         WITH  (SPB,RS),'LA  RB,SPBCWA(RB)'
         END   ,
         ELSE  'LA  RB,SCPCWA(RB)'
         L     R14,SCPGPRS+14*4        USER DATA POINTER
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N R14,=X"00FFFFFF"'
         DEX   RA,'MVC  @R14(0),@RB'
         B     SENXGO
         EJECT ,
*
*  SENSE COMMAND
*
SENCMD   LABEL ,        18
         L     RA,SCPCMDP              ADDRESS
         B     SEN1819
*
*  SENSE COMMAND PARM
*
SENPARM  LABEL ,        19
         L     RA,SCPPARMP             ADDRESS
*
*  SENSE COMMAND OR PARM - COMMON PROCESSING
*
SEN1819  LABEL ,
         L     R15,SCPGPRS+15*4        USER AREA LENGTH
         CEIL  R15,=A(133)             --> fix stupid compatibility
         ST    R15,SCPGPRS+15*4        --> aargh!
         BAS   RK,SENCKADD             CHECK DATA ADDRESSABILITY
         L     R15,SCPGPRS+15*4        USER AREA LENGTH
         LH    R14,@RA                 ACTUAL COMMAND LENGTH
         IF    ('LPR  R14,R14',NZ),BEGIN
         CEIL  R15,R14                 USE LESSER OF LENGTHS
         LR    R14,R15                 TO RETURN LENGTH
         DEX   R15,'MVC  @RS(0),@RA+2'   MOVE IN COMMAND
         CLEAR R15                     SET TYPE CODE
         IF    @RA.X'80','LA R15,4'
         END
         ELSE  'CLEAR R15'
         ST    R14,SCPGPRS+1*4         RETURN LENGTH
         B     SENX
         EJECT ,
*
*   SENSE MVS MEMORY
*
SENCOR   LABEL ,        20
         IF    ('CLI  SCPGROUP,C"G"',NE),BEGIN       INTERNAL OK
         TM    SCPPRIV,KWRIFSPR+KWRIFOPR   SYSTEM OR OPER PRIVS?
         BZ    SENSPEC                 NO, SORRY
         END   ,
         IF    ('LT  RS,SCPGPRS+1*4',NZ),BEGIN
         BAS   RK,SENCKADD             CHECK DATA ADDRESSABILITY
         LR    RA,RS                   STARTING ADDRESS
         L     RB,SCPGPRS+15*4         LENGTH
         L     R14,SCPGPRS+14*4        MVS LOCATION
         IF    SCBFCLP,'CLEAR R15'     CLP'S PROTECT KEY
         ELSE  'LA  R15,14'            EVERYBODY ELSE'S
         SYSCTL RA,R14,TYPE=MVSMRD     GET THE MEMORY
         END   ,
         L     RS,MATPTR               MAT POINTER
         WITH  (MAT,RS),'L  RS,MATM1CT'   CT POINTER
         ST    RS,SCPGPRS+0*4          RETURN AS A BONUS
         B     SENR0                   RETURN OK
         EJECT ,
*
*  SENSE PROGRAM EVENT INFO
*
SENPER   LABEL ,        21
         LA    R15,12                  LENGTH TO CHECK
         BAS   RK,SENCKANL              CHECK IT OUT
         MVC   @RS(3*4),SCPCTL9        MOVE CONTROL REGISTERS
         IF    SCPFPER,BEGIN           CLP SET PER
         IF    SCBFCLP,SENR0           SET BY CLP - CLP IN CONTROL
         B     SENR4                   SET BY CLP - USER IN CONTROL
         END
         ELSE  BEGIN
         IF    ^SCBFCLP,SENR0          SET BY USER - USER IN CONTROL
         B     SENR4                   SET BY USER - CLP IN CONTROL
         END
         SPACE 3
*
*  SENSE MONITOR CALL INFO
*
SENMON   LABEL ,        22
         LA    R15,4                   LENGTH TO CHECK
         BAS   RK,SENCKANL              CHECK IT OUT
         MVC   @RS(4),SCPCTL8          PICK UP MONITOR MASKS
         IF    SCPFMON,BEGIN           CLP SET MONITOR
         IF    SCBFCLP,SENR0           SET BY CLP - CLP IN CONTROL
         B     SENR4                   SET BY CLP - USER IN CONTROL
         END
         ELSE  BEGIN
         IF    ^SCBFCLP,SENR0          SET BY USER - USER IN CONTROL
         B     SENR4                   SET BY USER - CLP IN CONTROL
         END
         EJECT
*
*  SENSE FILE SYSTEM INFORMATION
*
SENFSI   LABEL ,        23
         PSET  @FILEBLKI
         MVC   @FILFSID,SCPGPRS+1*4    FILE SYSTEM ID
         VCALL FILEBLKI
         IF    (RVR,NZ),SENR4          NOT AVAILABLE
         MVC   SCPGPRS+1*4,@FILTBLK    TOTAL BLOCKS
         MVC   SCPGPRS+0*4,@FILABLK    AVAILABLE BLOCKS
         MVC   SCPGPRS+14*4,@FILUMAX   MAX NUMBER OF BLOCKS
         IF    @FILFNA,SENR4           RETURN 4: UNAVAILABLE
         IF    @FILFRO,SENR8           RETURN 8: MAINTENANCE
         B     SENR0                   RETURN 0: AVAILABLE
         EJECT
*
*  SENSE SESSION USAGE INFORMATION
*
SENACCIN LABEL ,        25
*
*  GET ACCOUNTING INFORMATION
*
         PSET  @ACINFO
         MVC   @ACIASB,PZCURASB        CURRENT ASB
         VCALL ACINFO
*
*  ELAPSED TIME
*
         LD    R0,@ACICON              CONNECT TIME
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SNWCLOK
         MVC   SCPGPRS+14*4(4),SNWCLOK+4    RETURN ELAPSED TIME
*
*  I/O COUNTS
*
         MVC   SCPGPRS+0*4(4),@ACIIOS     RETURN I/O COUNT
*
*  CPU TIME
*
         VCALL ACPUCHG                 GET CPU TIME
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SNWCLOK
         MVC   SCPGPRS+1*4(4),SNWCLOK+4     RETURN CPU TIME
*
*  FINALLY SET VM CHARGES
*
         CLEAR RS                      SET
         ST    RS,SCPGPRS+15*4         RETURN CPU TIME
         B     SENXGO
         EJECT
*
*  SENSE TIME BLOCK
*
SENTBLOK LABEL ,        26
*
*  GET POINTER TO CT
*
         L     R14,MATPTR               MAT POINTER
         WITH  (MAT,R14),'L  R14,MATM1CT'   CT POINTER
         WITH  (M1CT,R14),'L  R14,CTSCVT'   "SCIP" CVT POINTER
         WITH  (SCVT,R14),'LA  R14,SCVBLOCK'    BLOCK BYTE
         LA    R15,14                  AVERAGE GUY
         LA    RA,SNWMEM               PLACE TO PUT IT
         LA    RB,1                    ONE BYTE IS ALL WE WANT
         SYSCTL RA,R14,TYPE=MVSMRD     GET IT
         LC    RS,SNWMEM                AND RETURN
         ST    RS,SCPGPRS+1*4            IT TO USER
         B     SENR0                   DONE
         EJECT
*
*  SENSE HASP DISPLAY DATA
*
SENHASP  LABEL ,        27
*
*  GET POINTER TO CT
*
         L     RS,MATPTR               MAT POINTER
         WITH  (MAT,RS),'L  RJ,MATM1CT'   CT POINTER
         WITH  (M1CT,RJ)
         L     RA,SCPGPRS+14*4         GET BUFFER NUMBER REQUESTED
         IF    (RA,NL,CTJDCNT),SENR4
         BAS   RK,SENCKADD             CHECK USER ADDRESSABILITY
         CLEAR RK                      ASSUME GOOD RESULTS
         L     R14,CTJDPTRS            LIST OF BUFFER ENTRIES
         SLL   RA,3                    BUFFER ENTRIES ARE 8 BYTES
         L     RB,@R14+4(RA)           GET LENGTH OF BUFFER
         IF    (RB,GT,SCPGPRS+15*4),BEGIN
         LA    RK,8                    DATA TRUNCATION OCCURRED
         CEIL  RB,SCPGPRS+0*4          LIMIT TO REQUEST SIZE
         END   ,
         L     R14,@R14(RA)            GET BUFFER ADDRESS
         LR    RA,RS                   USER LOCATION
         ST    RB,SCPGPRS+1*4          RETURN LENGTH OF DATA
         SYSCTL RA,R14,TYPE=MVSMRD
         LR    R15,RK                  USER RETURN CODE
         B     SENX
         EJECT ,
*
*  SENSE ORVYL NAME
*
SENONAM  LABEL ,        28             SENSE ORVYL NAME
         LA    R15,8                   LENGTH REQUIRED FOR MOVE
         BAS   RK,SENCKANL             CHECK DATA ADDRESSABILITY
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'MVC  @RS(8),MATSNAME'   NAME TO USER'S AREA
         B     SENR0                   RETURN OK
         SPACE 3
*
*  SENSE THE PROGRAM NAME
*
SENPNAM  LABEL ,        29             SENSE PROGRAM NAME
         BAS   RK,SENCKADD             CHECK DATA ADDRESSABILITY
         L     R15,SCPGPRS+15*4         AND LENGTH
         CEIL  R15,SCBPNAML            MAX LENGTH TO MOVE
         ST    R15,SCPGPRS+1*4          RETURN LENGTH OF NAME
         DEX   R15,'MVC  @RS(0),SCBPNAM'    MOVE PROGRAM NAME
         B     SENR0                   THEN RETURN TO THE USER
         EJECT
*box
*
*  Sense 30 -- Get symbol address.
*
*     Macro format:
*         SENSE  30,symbol-location,symbol-length
*                (0) (1)            (15)
*
*         Returns in R15:
*            -4 = already referenced;    R14 = return value
*             0 = successful completion; R14 = return value
*             4 = symbol not found
*
SENSYM   LABEL ,  SENSE 30         Sense symbol address
         BAS   RK,SENCKREF         Check for valid addr,length
*
         PSET  @SSWA
         MVI   @SSNAME,C' '
         MVC   @SSNAME+1(L'@SSNAME-1),@SSNAME  Pre-blank
         L     R15,SCPGPRS+15*4    Symbol length
         CEIL  R15,L'@SSNAME       Not too much
         MOVE  R15,@SSNAME,@RS     Copy symbol name into area
         ACALL GETSSYM             Get shared symbol value
         MVC   SCPGPRS+14*4(4),@SSWORD  Return value
         LR    R15,RVR             Copy return code
         B     SENX                Return
         EJECT
*box
*
*  Sense 31 -- Unreference symbol.
*
*     Macro format:
*         SENSE  31,symbol-location,symbol-length
*                (0) (1)            (15)
*
*         Note:
*           If R1=0 then all of this user's symbols are
*                   unreferenced.  CLP issues this form to
*                   cleanup on exit.
*
*         Returns in R15:
*             0 = successful completion (symbol unreferenced)
*             4 = symbol not previously referenced
*             8 = symbol not found
*
SENUSYM  LABEL ,  SENSE 31         Unreference symbol
*-
*-       Not implemented.
*-
         LA    R15,12              Not implemented
         B     SENX                Return
         EJECT
*
*  SENSE SESSION COST
*
SENCOST  LABEL ,        150
         B     SENR4
         SPACE 3
*
*  SENSE FILE SYSTEM INFO
*
SENFSBS  LABEL ,        151
         L     R15,SCPGPRS+15*4        LENGTH PROVIDED
         IF    (R15,LT,16),SENSPEC     NOT ENOUGH
         BAS   RK,SENCKADD             CHECK DATA ADDRESSABILITY
*
         PSET  @FILEBLKI
         MVC   @FILFSID,SCPGPRS+14*4   FILE SYSTEM ID
         VCALL FILEBLKI
         IF    (RVR,NZ),BEGIN          NOT AVAILABLE
         LH    R15,=Y(-4)              ERROR RETURN
         B     SENX
         END
*-
*-       Move info to caller's area.
*-
         LR    RA,RS               LOCATION
         MVC   @RA(8),@FILNAME
         MVC   @RA+8(4),@FILABLK   AVAILABLE BLOCKS
         MVC   @RA+12(4),@FILTBLK  TOTAL BLOCKS
         MVC   SCPGPRS+0*4,=A(16)  Old style length
*
         L     R15,SCPGPRS+15*4    Get parameter block length
         IF    (R15,GE,28),BEGIN   Room for extended information...
         CLEAR (@RA+16,12)         Initialize extended area
         IF    @FILFCACHE,'MVC @RA+16(4),=F"1"'  File caching
         MVC   @RA+20(4),@FILIOCT  I/O count
         MVC   @RA+24(4),@FILCACT+4 Cache read count
         MVC   SCPGPRS+0*4,=A(28)  Extended length
         END
         IF    (R15,GE,36),BEGIN   Room for extended information...
         CLEAR (@RA+28,8)          Initialize extended area
         MVC   @RA+24(8),@FILCACT  Cache read count
         IF    @FILF4K,'MVC @RA+32(4),=F"1"' 4K file
         MVC   SCPGPRS+0*4,=A(36)  Extended length
         END
*
         IF    @FILFNA,SENR4           RETURN 4: UNAVAILABLE
         IF    @FILFRO,SENR8           RETURN 8: MAINTENANCE
         B     SENR0                   RETURN 0: AVAILABLE
         EJECT ,
*
*  Sense cross address space memory
*
SXASCPRM RECORD BEGIN
SXAASB   DS    A                       ASB of other AS
SXASLOC  DS    A                       Source address
SXADLOC  DS    A                       Destination address
SXADLEN  DS    A                         and length
SXATOD   DS    D                       Time for waiting (TOD fmt)
         END   ,
         SPACE ,
SENXASC  LABEL ,        152
         L     RK,SCPGPRS+1*4
         WITH  (SXASCPRM,RK)
         L     RB,SXADLEN              Check length validity
         IF    ((RB,NPOS),OR,(RB,GT,8192)),SENSPEC
*
         PSET  @PAGE                   Check memory
         PMOV  @PAGLOC,SXADLOC
         PMOV  @PAGLEN,(RB)
         MVC   @PAGKEY,SCPPSW+1
         NI    @PAGKEY,X'F0'
         VCALL PAGTPROT
         IF    (RVR,NZ),SENSPEC
*
         VMGET (RB),LOC=GLOBHI,FIX=YES
         IF    ('LTR RA,RVR',ZERO),BEGIN        No memory
         LA    R15,XARCSETUP
         B     SENX
         END   ,                                OF No memory
*
*
*  Make call to cross address space
*
         PSET  @XAMEM
         PMOV  @XAMASB,SXAASB          ASB of other guy
         PMOV  @XAMSLOC,SXASLOC          remote location (source)
         PMOV  @XAMDLOC,(RA)               global mem buffer
         PMOV  @XAMDLEN,SXADLEN              and length
         PMOV  @XAMTIME,SXATOD                 plus wait time
         VCALL XARMEM
         LR    RX,RVR                  Save return code
         IF    ((RX,EQ,XARCOK),OR,(RX,EQ,XARCFAIL)),BEGIN Mem to copy
         L     RS,@XAMDLEN             Set length moved in ret area
         ST    RS,SXADLEN
*
*  Move memory to local area
*
         REGCH (RVR,R0),(RS,R1)
         LR    RVR,RA                  Source (global mem)
         L     RM,SXADLOC              Dest (local mem)
         LR    RN,RS
         MVCL  RM,RVR
         END   ,                       OF Memory to copy
*
*  Release global memory
*
         VMFREE (RB),A=(RA),LOC=GLOBHI,FIX=YES
*
         LR    R15,RX                  Set return code
         B     SENX
         EJECT ,
*
*   SENSE ORVYL GLOBAL MEMORY
*
SENGLOBM LABEL ,        153
         IF    ('LT  RS,SCPGPRS+1*4',Z),SENSPEC
         BAS   RK,SENCKADD             Check for write access
         LR    RA,RS                   Starting address of user area
         L     RB,SCPGPRS+15*4         Length of user area
         PSET  @PAGE
         MVC   @PAGLOC,SCPGPRS+14*4    Location of global memory
         ST    RB,@PAGLEN              Length wanted
         VCALL PAGTPROT                Make sure it exists
         IF    (RVR,GE,2),SENR8
         L     R14,SCPGPRS+14*4        Location of global memory
         LR    R15,RB                  Length wanted
         MVCL  RA,R14                  Give them a copy of memory
         B     SENR0                   Return ok
*
*   SENSE OS MEMORY
*
SENOSMEM LABEL ,        154
         IF    ('LT  RS,SCPGPRS+1*4',Z),SENSPEC
         BAS   RK,SENCKADD             Check for write access
         LR    RA,RS                   Starting address of user area
         L     RB,SCPGPRS+15*4         Length of user area
         L     R14,SCPGPRS+14*4        MVS LOCATION
         CLEAR R15                     PROTECT KEY
         SYSCTL RA,R14,TYPE=MVSMRD     GET THE MEMORY
         IF    NZ,SENR8
         B     SENR0                   Return ok
         EJECT ,
*******************************************************************
*                                                                 *
*    SENCKADD - Check user buffer area routine for Sense SVC      *
*                                                                 *
*******************************************************************
         SPACE
*-
*-       Check to see if we can store into the area.
*-
SENCKADD LABEL
         L     R15,SCPGPRS+15*4        LENGTH
         IF    (R15,NP),SENSPEC        CHECK VALID
         IF    (R15,GT,8192),SENSPEC
*
SENCKANL LABEL ,
         PSET  @PAGE
         L     RS,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RS,=X"00FFFFFF"'
         ST    RS,@PAGLOC              PROVIDE LOCATION
         ST    R15,@PAGLEN              AND LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,NZ),SENSPEC        NO GOOD
         L     RS,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RS,=X"00FFFFFF"'   FOR CALLER
         BR    RK                      RETURN
*-
*-       Check to see if we can reference the area.
*-
SENCKREF L     R15,SCPGPRS+15*4        LENGTH
         IF    (R15,NP),SENSPEC        CHECK VALID
         IF    (R15,GT,8192),SENSPEC
*
         PSET  @PAGE
         L     RS,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RS,=X"00FFFFFF"'
         ST    RS,@PAGLOC              PROVIDE LOCATION
         ST    R15,@PAGLEN              AND LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    ((RVR,NZ),AND,(RVR,NE,1)),SENSPEC  No good
         L     RS,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RS,=X"00FFFFFF"'
         BR    RK                      RETURN
         EJECT
*******************************************************************
*                                                                 *
*    SENSE SVC - return routines                                  *
*                                                                 *
*******************************************************************
         SPACE
SENSPEC  MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         B     SENX
*
SENR0    CLEAR R15
         B     SENX
*
SENR4    LA    R15,4
         B     SENX
*
SENR8    LA    R15,8
         B     SENX
*
SENX     ST    R15,SCPGPRS+15*4        SET RETURN CODE
*
SENXGO   LABEL ,
         PEND
*
         LTORG
         EJECT
*box
*
*  GETSSYM -- Routine to get a shared symbol value given it's name.
*
*    On entry:
*      @SSNAME - symbol name
*      RY -- SCP address
*
*    On exit, RVR:
*      0 - got it;  @SSWORD = value
*
GETSSYM  PROC  @SSWA
         WITH  (SCP,RY)
         CLEAR @SSWORD,@SSRV           Initialize return values
         MVC   @SSRV,=F'4'             Assume that it is not found
*
         L     RS,MATPTR               MAT ptr
         WITH  (MAT,RS),'L RJ,MATM1CT' CT ptr
         WITH  (M1CT,RJ)
*
         LKOB  CTSPBCLK                Get lock on the SPB's
*-
*-       Search first the SPBs which have already been referenced
*-       by this user.  This keeps references consistent.
*-
         WITH  (SPB,RK)
         WITH  (SSB,RB)
         L     RA,SCBSSAB              Try Access blocks first
         WHILE (RA,NZ),BEGIN
         WITH  (SSAB,RA)
         L     RK,SSABSPB              Get the SPB Address
         L     RB,SPBSSB               Head of the symbol list
         WHILE (RB,NZ),BEGIN           Loop through the symbols
         IF    (SSBNAME,EQ,@SSNAME),BEGIN
         MVC   @SSWORD,SSBWORD         Copy the symbol value
         CLEAR @SSRV                   Signal a good return
         B     SSYMEXIT                Then return to the caller
         END
         L     RB,SSBNEXT              Otherwize continue
         END
         L     RA,SSABNEXT             Point at the next access block
         END
*-
*-       If we haven't found it yet, then we go through the valid
*-       SPB's.  This may mean that some SPB's get searched twice.
*-       The overhead should be minimal, since normally symbols will
*-       all come from one or two SPB's which have already been
*-       referenced. If we find it at this point, we must also insert
*-       an SSAB pointer to the SPB.
*-
         L     RK,CTSPBS               First SPB in the system
         WHILE (RK,NZ),BEGIN           Loop through them
         IF    ^SPBFCORPSE,BEGIN       Don't look at dead things
         L     RB,SPBSSB               Head of the symbol list
         WHILE (RB,NZ),BEGIN           Loop through the symbols
         IF    (SSBNAME,EQ,@SSNAME),BEGIN
         MVC   @SSWORD,SSBWORD         Copy the symbol value
         CLEAR @SSRV                   Signal a good return
*-
*-       Allocate an SSAB and add it to the queue from the SCB
*-
         VMGET L'SSAB,LOC=LOCSYS       Get memory for it
         IF    (RVR,Z),SSYMNF          No memory, don't give symbol
         LR    RA,RVR                  Get the address of the block
         WITH  (SSAB,RA)
         MVC   SSABID,=C'SSAB'         Move in the ID
         MVC   SSABNEXT,SCBSSAB        copy the head of the list
         ST    RA,SCBSSAB              Add it at the head
         ST    RK,SSABSPB              Put the SPB pointer here
         INCR  RS,SPBNREF              Update the reference count
         B     SSYMEXIT                Then return to the caller
         END
         L     RB,SSBNEXT              Otherwize continue
         END
         END
         L     RK,SPBNEXT              Point at the next SPB
         END
*
SSYMNF   MVC   @SSRV,=F'4'         Symbol not found
SSYMEXIT LKREL CTSPBCLK            Release queue lock
         L     RVR,@SSRV           Pick up return value
         PEND
         EJECT
*box
*        PURSPB -- This routine purges the program described in the
*                  SPB passed if possible.  It frees the memory and
*                  returns the SPB to its initial state, removing
*                  any shared symbols the program defined.  This may
*                  only be done if all the following conditions are
*                  met:
*
*                  1) The program is either purgeable or is a
*                     corpse.
*
*                  2) There are no current users of the program
*
*
*                  3) There are no users referring to shared symbols
*                     of the program.
*
*                  4) The program had not already been purged.
*
*              On Entry:
*                  R1 -- Address of the SPB
*
PURSPB   PROC
         LR    RJ,R1                   Copy the SPB address
         WITH  (SPB,RJ)
         IF    ^SPBFACTV,EXIT          No program loaded
         IF    (^SPBFPURGABLE,AND,^SPBFCORPSE),EXIT
         IF    (SPBNU,NZ),EXIT         Some users
         IF    (SPBNREF,NZ),EXIT       Some references
*-
*-       All conditions have been met
*-
         CLEAR SPBFACTV                No longer active
*-
*-       Unprotect the memory.
*-
         PSET  @PAGE
         PMOV  @PAGLOC,SPBORGIN
         PMOV  @PAGLEN,SPBSIZE
         VCALL PAGUPROT
*-
*-       Free the memory.
*-
*         IF    SPBFLHI,BEGIN
         IF    ('CLI SPBORGIN,0',NE),BEGIN
      VMFREE L:SPBSIZE,A=SPBORGIN,LOC=GLOBHI,TYPE=PROG,KEY=USER,FETP=NO
         END   ,
         ELSE  BEGIN
         VMFREE L:SPBSIZE,A=SPBORGIN,LOC=GLOBLO,TYPE=PROG,KEY=USER
         END   ,
         CLEAR SPBFMEM
         CLEAR SPBORGIN
*-
*-       Remove any shared symbols
*-
         L     RA,SPBSSB               Address of first one
         WHILE (RA,NZ),BEGIN
         LR    RB,RA                   Point at the new SSB
         WITH  (SSB,RB)
         FAIL  (SSB,NE,'SSB'),DELSSBQ
         L     RA,SSBNEXT              Dequeue this entry
         MVC   SSB(4),=C'ssb'          Change the ID
         MVC   SSBNEXT,=F'-1'          Zap link ptr
*         VMFREE L'SSB,A=LA:SSB,LOC=GLOBLO,TYPE=DATA
         VMFREE L'SSB,A=LA:SSB,LOC=GLOBHI,TYPE=PROG
         END
         ST    RA,SPBSSB               Clear the header
*-
*-       If the SPB is a corpse, we can go ahead and delete it now.
*-
         IF    SPBFCORPSE,BEGIN
         L     RK,MATPTR               Get CT Addressability
         WITH  (MAT,RK),'L  RK,MATM1CT'
         WITH  (M1CT,RK)
*-
*-       Look for SPB that points at this one.
*-
         LA    RA,CTSPBS-(SPBNEXT-SPB)
         LOOP  BEGIN
         WITH  (SPB,RA)
         IF    (SPBNEXT,ZERO),SPBBADDET
         L     RB,SPBNEXT
         IF    (RB,EQ,RJ),EXIT
         LR    RA,RB                   Link to next SPB
         END
*-
*-       Delete this SPB from the chain.
*-
         WITH  (SPB,RA),LABEL=PREV
         PMOV  PREV.SPBNEXT,SPBNEXT    Take out of list
*-
*-       Free this SPBs memory.
*-
*         VMFREE L'SPB,A=LA:SPB,LOC=GLOBLO,TYPE=DATA
         VMFREE L'SPB,A=LA:SPB,LOC=GLOBHI,TYPE=PROG
         END
         PEND
*
SPBBADDET ABORT SPBBADDET              Bad detatch
         TITLE 'ORVYL''S Mode 1 Set SVC'
*******************************************************************
*                                                                 *
*    SETCLK - Work area for clock setting SET SVC's               *
*                                                                 *
*******************************************************************
         SPACE
SETCLK   RECORD BEGIN
SWCLOCK  DS    D                       CLOCK WORK AREA
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    SET SVC Branch Table                                         *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
SETBR    DC    A(SET0)           0     SET KEEP
         DC    A(SET0)           1     DISCARD
         DC    A(SET0)           2     SET HOLD
         DC    A(SET3)           3     REAL INTERVAL
         DC    A(SET4)           4     COMPUTE INTERVAL
         DC    A(SET5)           5     TIMER EXIT
         DC    A(SET5)           6     SVC EXIT
         DC    A(SET5)           7     PANIC EXIT
         DC    A(SET8)           8     ATTN EXIT
         DC    A(SET8)           9     WAIT EXIT
         DC    A(SET10)         10     LOAD FROM AREA
         DC    A(SET11)         11     MASK BYTE
         DC    A(SET12)         12     PRIORITY
         DC    A(SET13)         13     SET COMMON WORK AREA
         DC    A(SET14)         14     ALLOCATE USER WORK SPACE
         DC    A(SET15)         15     RELEASE USER WORK SPACE
         DC    A(SET16)         16     ALLOCATE WORK SPACE AT ADDRESS
         DC    A(SET17)         17     SET PER CR 9-11
         DC    A(SET18)         18     SET MONITOR CR 8
         DC    A(SET19)         19     SET PROTECT
         DC    A(SET20)         20     SET UNPROTECT
         DC    A(SET21)         21     ENQUEUE
         DC    A(SET22)         22     DEQUEUE
         DC    A(SET23)         23     SET TRASH BYTE
         DC    A(SET24)         24     SET THE PROGRAM NAME
         DC    A(SETUNDEF)      25     (Unused)
         DC    A(SETUNDEF)      26     (Unused)
         DC    A(SETUNDEF)      27     (Unused)
         DC    A(SETUNDEF)      28     (Unused)
         DC    A(SET29)         29     Suspend
         DC    A(SET30)         30     Define new symbol entry
         DC    A(SET31)         31     Delete existing symbol entry
MAXPSET  EQU   (*-SETBR)/4-1           MAXIMUM PUBLIC SET
HSETBASE EQU   150                     START OF "HIDDEN" SETS
         DC    A(SET150)       150     TURN OFF PSEUDO USER
         DC    A(SET151)       151     SET NO MULTIPLE ATTENTIONS
         DC    A(SET152)       152     SET CLP CPU TIMER
         DC    A(SET153)       153     SET CLP REAL TIMER
         DC    A(SET154)       154     WRITE AN SMF RECORD
         DC    A(SET155)       155     SET PSW KEY MASK
MAXSET   EQU   (*-SETBR)/4-1
         END
         EJECT
*******************************************************************
*                                                                 *
*    SET  - Mode 1 SET SVC                                        *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET      PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  ISSUE TRACE
*
         LM    R14,R15,SCPGPRS+14*4    GET REGS
         LM    R0,R1,SCPGPRS+0*4
         LM    RA,RB,PZCURPID          GET CURRENT PROCESS ID
         XTRC  R14,RB,M1SET
         L     RA,SCPGPRS+0*4          SET CODE
         IF    (RA,GT,=A(MAXPSET)),'S  RA,=A(HSETBASE-MAXPSET-1)'
*
*  Validate Set number then call appropriate routine
*
         IF    ((RA,M),OR,(RA,GT,=A(MAXSET))),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         END   ,
         ELSE  BEGIN
         SLL   RA,2
         ACALL SETBR(RA)           Call appropriate SET routine
         END   ,
         PEND
*box
*
*  Undefined SET code, generate SPEC error.
*
SETUNDEF PROC  SCOPE=LOCAL
         WITH  (SCP,RY)
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         PEND
         EJECT ,
*******************************************************************
*                                                                 *
*    SET0 (1 and 2) - Simulate keep, discard, and hold            *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET0     PROC  ,SETCLK,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  KEEP, DISCARD, AND HOLD ARE NO LONGER USED, HOWEVER THE
*    PARAMETERS ARE VALIDATED TO MAKE IT APPEAR CONSISTENT
*
         L     RA,SCPGPRS+1*4          STARTING ADDRESS
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         IF    (RA,LT,SCPRRSEG),BEGIN     INVALID
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET0
         END   ,
*
*  ROUND UP LENGTH TO 4K INCREMENT
*
         L     RB,SCPGPRS+15*4         LENGTH
         IF    (RB,Z),BEGIN
         MVC   SCPGPRS+15*4,=A(0)      NULL REQUEST
         EXIT  SET0
         END   ,
         IF    M,BEGIN
         MVC   SCPGPRS+15*4,=A(4)      INVALID REQUEST
         EXIT  SET0
         END   ,
         LA    RB,@RB+4095             ROUND UP
         N     RB,=X'00FFF000'          TO PAGE LENGTH
*
*  IF KEEP SET MAXIMUM AMOUNT
*
         L     RK,SCPGPRS+0*4          GET SET CODE
         IF    (RK,Z),'CEIL  RB,=A(16*1024)'    16K MAXIMUM FOR KEEP
*
*  CHECK THAT MEMORY HAS BEEN ALLOCATED
*
         VMCHK (RB),A=(RA),LOC=LOCUSR    CHECK VALIDITY
         IF    (RVR,NZ),BEGIN          INVALID ADDRESS
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET0
         END   ,
*
*  IF DISCARD - INITIALIZE THE AREA
*
         IF    (RK,EQ,1),BEGIN
         PSET  @PAGE
         PMOV  @PAGLOC,(RA)            Un-reference pages
         PMOV  @PAGLEN,(RB)
         VCALL PAGUREF
*        LCM   R15,B'1000',SCPTRASH    TRASH BYTE
*        MVCL  RA,R14                  INITIALIZE THE PAGES
         END   ,
         MVC   SCPGPRS+15*4,=A(0)      ALL'S WELL
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 3 - Set user real time (interval) timer                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET3     PROC  ,SETCLK,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR SCBXT                   CANCEL PENDING EXIT
         CLEAR RJ                      PREVIOUS INTERVAL
*
*  A TIMER IS NOW RUNNING SO CANCEL IT
*
         IF    SCBTUTR,BEGIN           A TIMER NOW RUNNING
*
*  CPU TIMER IS RUNNING
*
         IF    SCBTUCT,BEGIN           CURRENT TIMER IS CPU TIME
         PSET  @CPCNCK
         MVC   @CPCID,SCPUCLK           CLOCK ID
         VCALL CPCAN                   CAN IT
         LD    R0,@CPCCLK              PREVIOUS INTERVAL
         END   ,
*
*  REAL TIMER IS RUNNING
*
         ELSE  BEGIN                   CURRENT TIMER IS REAL TIME
         PSET  @RTCNCK
         MVC   @RTCID,SCPUCLK          CLOCK ID
         VCALL RTCAN                   CAN IT
         LD    R0,@RTCCLK              PREVIOUS INTERVAL
         END   ,
*
*  Convert interval and mark timer cancelled
*
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SWCLOCK
         L     RJ,SWCLOCK+4            PREVIOUS TIMER
         CLEAR SCPUCLK                 NOTE
         CLEAR SCBTUTR+SCBTUCT          CANCELLED
         END   ,
*
*  NOW SET NEW TIMER IF SO REQUESTED
*
         L     RB,SCPGPRS+1*4          SUPPLIED TIME VALUE
         IF    (RB,NZ),BEGIN
         PSET  @RTSET
         MVC   @RTSCLK(4),=XL8'4E00000000000000'
         ST    RB,@RTSCLK+4            NORMALIZED TIME VALUE
         LD    R0,@RTSCLK
         MD    R0,=D'106667'           TO USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,@RTSCLK
         MVI   @RTSCLK,0               REMOVE EXPONENT
         SET   @RTSFINT                VALUE IS AN INTERVAL
         MVC   @RTSXIT,SCPUCXIT        SET EXIT ID
         VCALL RTSET                   START THE CLOCK
         ST    RVR,SCPUCLK             SAVE ID
         SET   SCBTUTR
         END
         ST    RJ,SCPGPRS+15*4         RETURN VALUE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 4 - Set user CPU time timer                              *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET4     PROC  ,SETCLK,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR RJ                      OLD INTERVAL
         CLEAR SCBXT                   CANCEL PENDING EXIT
*
*  A TIMER IS NOW RUNNING SO CANCEL IT
*
         IF    SCBTUTR,BEGIN           A TIMER NOW RUNNING
*
*  CPU TIMER IS RUNNING
*
         IF    SCBTUCT,BEGIN           CURRENT TIMER IS CPU TIME
         PSET  @CPCNCK
         MVC   @CPCID,SCPUCLK          CLOCK ID
         VCALL CPCAN                   CAN IT
         LD    R0,@CPCCLK              PREVIOUS INTERVAL
         END   ,
*
*  REAL TIMER IS RUNNING
*
         ELSE  BEGIN                   CURRENT TIMER IS REAL TIME
         PSET  @RTCNCK
         MVC   @RTCID,SCPUCLK          CLOCK ID
         VCALL RTCAN                   CAN IT
         LD    R0,@RTCCLK              PREVIOUS INTERVAL
         END   ,
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SWCLOCK
         L     RJ,SWCLOCK+4            PREVIOUS TIMER
         CLEAR SCPUCLK                 NOTE
         CLEAR SCBTUTR+SCBTUCT          CANCELLED
         END   ,
*
*  NOW SET CPU TIMER IF SO REQUESTED
*
         L     RB,SCPGPRS+1*4          SUPPLIED TIME VALUE
         IF    (RB,NZ),BEGIN
         PSET  @CPSET
         MVC   @CPSCLK(4),=XL8'4E00000000000000'
         ST    RB,@CPSCLK+4            NORMALIZED TIME VALUE
         LD    R0,@CPSCLK
         MD    R0,=D'106667'            TO USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,@CPSCLK
         MVI   @CPSCLK,0               REMOVE EXPONENT
         MVC   @CPSXIT,SCPUCXIT        SET EXIT ID
         VCALL CPSET                   START THE CLOCK
         ST    RVR,SCPUCLK             SAVE ID
         SET   SCBTUTR+SCBTUCT         MARK USER CPU CLOCK RUNNING
         END   ,
         ST    RJ,SCPGPRS+15*4         RETURN VALUE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET5 (6 and 7) - Set timer, SVC, and PANIC exits             *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET5     PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+0*0          SET REQUEST NUMBER
*
*  SET TIMER EXIT
*
         IF    (RS,EQ,5),'LA  RB,SCPTXEP'    TIMER EXIT
*
*  SET SVC EXIT
*
         ELSEIF (RS,EQ,6),'LA  RB,SCPSXEP'   SVC EXIT
*
*  SET PANIC EXIT
*
         ELSE  'LA  RB,SCPPXEP'              PANIC EXIT
*
*  SET UP EXIT
*
         PSET  @SETEXIT
         ST    RB,@SETEXL              EXIT BLOCK LOCATION
         ACALL SETEXIT
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET8 (and 9) - Set I/O attention and wait exits              *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET8     PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+0*0          SET REQUEST NUMBER
*
*  SET ATTN EXIT
*
         IF    (RS,EQ,8),'LA  RB,IDTAXEP-IDT'     INDEX TO EXIT INFO
*
*  SET WAIT EXIT
*
         ELSE  'LA  RB,IDTWXEP-IDT'    INDEX TO EXIT INFO
*
*  Find device table
*
         L     RS,SCPGPRS+15*4         USER SUPPLIED DEVICE NUMBER
         IF    ((RS,NP),OR,(RS,GT,SCPNIDT)),BEGIN    NOT IN RANGE
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET8
         END   ,
         DECR  RS
         MH    RS,=Y(L'IDT)
         AL    RS,SCPIDT               IDT VIRTUAL ADDDRESS
         WITH  (IDT,RS)
         IF    (IDTFA+IDTFACL,Z),BEGIN  NOT ACTIVE
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET8
         END   ,
         ALR   RB,RS                   POINTER TO DEVICE EXIT INFO
         PSET  @SETEXIT
         ST    RB,@SETEXL
         ACALL SETEXIT
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 10 - Set program environment                             *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET10    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RA,SCPGPRS+1*4          AREA CONTAINING PSW AND REGS
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         IF    (RA,Z),'LA RA,SCPXPSW'  EXIT GPRS
         ELSE  BEGIN
         PSET  @PAGE
         ST    RA,@PAGLOC              SET LOCATION
         MVC   @PAGLEN,=A(72)          LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT               CHECK IT OUT
         IF    (RVR,GE,2),BEGIN          NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET10
         END   ,
         END   ,
         MVC   SCPGPRS(16*4),@RA+8     UPDATE REGS
         MVC   SCPPSW+4(4),@RA+4        AND PSW ADDRESS
*         MVC   SCPPSW+5(3),@RA+5        AND PSW ADDRESS
*         MVI   SCPPSW+4,0              24 BIT MODE ONLY
         IC    R15,@RA+2               UPDATE
         N     R15,=X'0000003F'         CC AND PROG MASK
         CLEAR SCPPSW+2.X'3F'
         EX    R15,'OI  SCPPSW+2,0'
         SET   SCBMB.SCBDEFMB          AVAILABLE MASKS
         NC    SCBMB(1),@RA+3          SET MASK BYTE
         EJECT
*
*  CLP IS TRANSFERING CONTROL - SET USER ENVIRONMENT
*
         IF    SCBFCLP,BEGIN           IF CLP TRANSFERRING CONTROL
         CLEAR SCBFCLP                 SET CLP NOT IN CONTROL
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'OC  SCPPSW+1(1),MATUKEY'   USER KEY
         SET   SCPPSW+1.X'01'          SET PROBLEM STATE
         IF    SCBCFAX,BEGIN           ENTER ATTENTION EXIT?
         CLEAR SCBCFAX                 YES
         L     RS,SCPIDT               TERMINAL IDT
         WITH  (IDT,RS),'SET  IDTFEAX'   MARK IDT
         SET   SCBXA                   MARK USER
         END   ,
         UTRACE CLASS=RUNUSER,CODE=SCBMB
         END   ,
         SET   SCBFNPUP                NO PSW UPDATES
         ACALL PERCHECK                SET UP PER
         ACALL DOEXITS                 CHECK FOR EXITS
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 11 - Set mask byte                                       *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET11    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         LC    RS,SCBMB                OLD MASK BYTE
         ST    RS,SCPGPRS+15*4         RETURN
         L     RS,SCPGPRS+1*4
         SET   SCBMB.SCBDEFMB          AVAILABLE MASKS
         EX    RS,'NI  SCBMB,0'        SET NEW MASK BYTE
         ACALL PERCHECK                SET UP PER
         ACALL DOEXITS                 CHECK FOR EXITS
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 12 - Put data into common work area                      *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET12    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+1*4
         IF    (RS,GT,15),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET12
         END   ,
         LC    R15,SCBUPRI             Return previous
         ST    R15,SCPGPRS+15*4         priority
         STC   RS,SCBUPRI
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 13 - Put data into common work area                      *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET13    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Check displacement
*
         LA    RA,SCPCWASZ             NUMBER OF BYTES AVAILABLE
         L     RB,SCPGPRS+1*4          DISPLACEMENT
         IF    ((RB,M),OR,(RB,NL,RA)),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET13
         END   ,
*
*  Check field within bounds
*
         SR    RA,RB
         IF    ((RA,LT,SCPGPRS+15*4),OR,    GOES PAST THE END          *
               ('LT  RA,SCPGPRS+15*4',NP)),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET13
         END   ,
*
*  CHECK MEMORY AREA
*
         PSET  @PAGE
         L     R15,SCPGPRS+14*4        LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N R15,=X"00FFFFFF"'
         ST    R15,@PAGLOC             SET LOCATION
         ST    RA,@PAGLEN               AND LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN        NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET13
         END   ,
*
*  NOW MOVE THE DATA
*
         L     RS,SCBSPB               SPB POINTER
         IF    (RS,NZ),BEGIN
         WITH  (SPB,RS),'LA  RB,SPBCWA(RB)'
         END   ,
         ELSE  'LA  RB,SCPCWA(RB)'
         L     R14,SCPGPRS+14*4        USER DATA POINTER
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N R14,=X"00FFFFFF"'
         DEX   RA,'MVC  @RB(0),@R14'
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 14 - Reserve memory                                      *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET14    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Check caller's parameters
*
         L     RA,SCPGPRS+1*4          MINIMUM VALUE
         IF    (RA,M),BEGIN            CHECK MINIMUM VALUE
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET14
         END   ,
*
*  Check minimum value
*
         LA    RA,@RA+4095             ROUND UP
         N     RA,=X'00FFF000'          TO 4K INCREMENT
         SRL   RA,12                   TO PAGE COUNT
         IF    (RA,GT,SCPUNRSV),BEGIN
         MVC   SCPGPRS+15*4,=A(4)      NOT ENOUGH AVAILABLE
         EXIT  SET14
         END   ,
*
*  Check maximum value
*
         L     RB,SCPGPRS+15*4         MAXIMUM NEEDED
         IF    (RB,M),BEGIN            CHECK MAXIMUM VALUE
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET14
         END   ,
         IF    Z,'LH  RB,SCPUNRSV'     ZERO GETS MAXIMUM
*
* Validate minimum and maximum values
*
         ELSE  BEGIN
         LA    RB,@RB+4095             ROUND MAXIMUM UP
         N     RB,=X'00FFF000'          TO 4K INCREMENT
         SRL   RB,12                   TO PAGE COUNT
         IF    (RA,GT,RB),BEGIN        MIN GREATER THAN MAX
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET14
         END   ,
         CEIL  RB,SCPUNRSV             NEVER MORE THAN AVAILABLE
         END    ,
         IF    (RB,Z),BEGIN
         MVC   SCPGPRS+15*4,=A(4)      NOT ENOUGH AVAILABLE
         EXIT  SET14
         END   ,
*
*  Parameters ok - request the memory
*
         SLL   RA,12                   BACK TO BYTES
         SLL   RB,12                   DITTO
         VMGET (RA),MAX=(RB),LOC=LOCUSR,KEY=USER,PAGE=YES
         IF    ('LTR  RA,RVR',Z),BEGIN
         MVC   SCPGPRS+15*4,=A(4)      NOT ENOUGH AVAILABLE
         EXIT  SET14
         END   ,
* -->
*  Do stats here
         L     RM,MATPTR
         WITH  (MAT,RM),'L RM,MATM1CT'
         WITH  (M1CT,RM),'L RM,CTVMSTAT'
         L     R15,@VMGLEN             --> len
         LR    R0,RA                   --> loc
         BAS   RN,VMRTNLOG             -->
*
*  Set returns and fix up reserve counts
*
         ST    RA,SCPGPRS+1*4          SET LOCATION
         MVC   SCPGPRS+0*4(4),@VMGLEN   ACTUAL LENGTH
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         ACALL VMUPDAT
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 15 - Release memory                                      *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET15    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Check parameters
*
         L     RA,SCPGPRS+1*4          STARTING ADDRESS
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         IF    (RA,LT,SCPRRSEG),BEGIN  CAN CALLER RESERVE/RELEASE?
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET15
         END   ,
*
*  Check length
*
         L     RB,SCPGPRS+15*4         LENGTH
         LTR   RB,RB
         IF    Z,BEGIN
         MVC   SCPGPRS+15*4,=A(0)      NULL REQUEST
         EXIT  SET15
         END   ,
         IF    M,BEGIN                 INVALID REQUEST
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET15
         END   ,
*
*  Do stats
*
         L     RM,MATPTR
         WITH  (MAT,RM),'L RM,MATM1CT'
         WITH  (M1CT,RM),'L RM,CTVMSTAT'
         LA    RM,2048(,RM)
         L     R15,SCPGPRS+15*4        --> length
         LR    R0,RA                   --> location
         BAS   RN,VMRTNLOG             -->
*
         AR    RB,RA                   LAST ADDRESS+1
         CEIL  RB,=A(X'01000000')
         N     RA,=XL4'FFF000'         ROUND TO PAGE BOUNDARY
         LR    RJ,RB                   LENGTH
         DECR  RJ                        last byte becomes
         N     RJ,=XL4'FFF000'             start of last page
         AL    RJ,=XL4'001000'               start of last pg + 1 pg
         SLR   RJ,RA                           and now for the length
*
*  CALL RELEASE MEMORY SERVICE
*
         VMFREE (RJ),A=(RA),LOC=LOCUSR,KEY=USER
         IF    (RVR,ZERO),BEGIN        One big free went ok
         SRL   RJ,12                   Convert length to pages
         LH    R0,SCPUNRSV             Up Unreserved count
         ALR   R0,RJ
         STH   R0,SCPUNRSV
         LH    R0,SCPRESRV             Lower Reserved Count
         SLR   R0,RJ
         STH   R0,SCPRESRV
         END   ,
         ELSE  BEGIN                   One big free not ok
*
*  Now we must do the free piecemeal to see which page is really
*  not reserved.  Must act like old Orvyl you know.
*
         WHILE (RA,LT,RB),BEGIN        PARAMETER FOR PAGE CALL
         L     RS,=A(4096)             LENGTH TO FREE
         VMFREE (RS),A=(RA),LOC=LOCUSR,KEY=USER
         IF    (RVR,NZ),BEGIN          AREA NOT RESERVED
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET15
         END   ,
         INCR  R0,SCPUNRSV             UP UNRESERVED COUNT
         DECR  R0,SCPRESRV             LOWER RESERVED COUNT
         A     RA,=A(4096)             NEXT PAGE
         END
         END   ,                       OF One big free not ok
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         PEND
         EJECT ,                       -->
*  -->
*  Uses RJ & RK
*  RM points @ stat blk
*  RN is return addr ptr for this temp rtn
*  R15 is length of request
*  R0  is location of request
*
VMRTNLOG LABEL ,                       -->
         BEGIN ,
         BASE  RJ
         WITH  (SCP,RY)
         WITH  (VMSTAT,RM)
*
*  Circular list of return addr, len, loc
*
         L     RK,VHRTNPTR             Offset to last slot
         IF    (RK,GT,MXRTN),BEGIN     If it overflows, reset it
         STCK  VHSTCK
         INCR  RK,VHRTNCNT
         CLEAR RK
         END   ,
         LA    R14,VHRTN(RK)
         MVC   @R14(4),SCPPSW+4        return addr
         STM   R15,R0,4(R14)           len, loc
         LA    RK,@RK+12
         ST    RK,VHRTNPTR             Reset offset
         BR    RN                      Return from whence called
         END   ,
         DROP  RJ                      -->
         EJECT
*******************************************************************
*                                                                 *
*    SET 16 - Reserve memory at specific address                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET16    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Check parameters
*
         L     RA,SCPGPRS+1*4          ADDRESS
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
*
*  Invalid address
*
         IF    (RA,LT,SCPRRSEG),BEGIN  INVALID LOCATION
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET16
         END   ,
*
*  Invalid length
*
         L     RB,SCPGPRS+15*4         LENGTH
         IF    (RB,NP),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET16
         END   ,
*
*  Check area boundaries
*
         AR    RB,RA
         DECR  RB                      LAST BYTE OF AREA
         N     RA,=XL4'FFF000'         ROUND TO PAGE BOUNDARY
         SR    RB,RA                   BYTE COUNT WANTED
         LA    RB,@RB+4095             ROUND UP TO PAGES
         SRL   RB,12                   TO NUMBER OF 4K INCREMENTS
         IF    (RB,GT,SCPUNRSV),BEGIN
         MVC   SCPGPRS+15*4,=A(4)      GREATER THAN RESERVE LIMIT
         EXIT  SET16
         END   ,
*
*  Request memory
*
         SLL   RB,12                   BACK TO BYTES
         VMGET (RB),A=(RA),LOC=LOCUSR,KEY=USER,PAGE=YES
         IF    (RVR,Z),BEGIN
         MVC   SCPGPRS+15*4,=A(4)      NOT AVAILABLE
         EXIT  SET16
         END   ,
*
*  Set returns and fix up reserve counts
*
         ST    RA,SCPGPRS+1*4          SET LOCATION
         MVC   SCPGPRS+0*4(4),@VMGLEN   ACTUAL LENGTH
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         ACALL VMUPDAT
         PEND
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    SET 17 - Set PER parameters                                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET17    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+1*4          GET PER PARM POINTER
*
*  PER already set
*
         IF    (SCPCTL9.B'11110000',NZ),BEGIN   PER SET NOW
         IF    SCBFCLP,BEGIN           CLP IN CONTROL
         IF    (RS,Z),EXIT             UNCONDITIONAL CLEAR
         IF    ^SCPFPER,BEGIN
         MVC   SCPGPRS+15*4,=A(4)      PER OWNED BY USER
         EXIT  SET17
         END   ,
         END
         ELSE BEGIN
         IF    SCPFPER,BEGIN
         MVC   SCPGPRS+15*4,=A(4)      PER OWNED BY CLP
         EXIT  SET17
         END   ,
         END   ,
         END
*
*  OBTAIN CALLER SUPPLIED PER PARAMETERS
*
         IF    (RS,NZ),BEGIN
         PSET  @PAGE
         L     RA,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         ST    RA,@PAGLOC              SET LOCATION
         MVC   @PAGLEN,=A(12)          LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN        NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET17
         END   ,
         MVC   SCPCTL9(3*4),@RA        COPY USER CONTROL REGS
         LH    RS,SCPCTL9+2            TEST REG MASKS
         IF    (RS,Z),'CLEAR SCPCTL9.B"00010000"'   CANCEL REG PER
         END   ,
*
*  Process clear request
*
         ELSE  'CLEAR (SCPCTL9,12)'            CLEAR CTL 9,10,11
*
*  Establish new PER parameters
*
         PSET  @PERSET
         MVC   @PERSDAT(3*4),SCPCTL9
         VCALL PERSET
         CLEAR SCPFPER                 ASSUME PER CLEARED
         IF    (SCPCTL9.B'11110000',NZ),BEGIN
         IF    SCBFCLP,'SET  SCPFPER'   CLP CONTROLS PER NOW
         ELSE  'ACALL PERCHECK'        SET UP PER
         END   ,
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 18 - Set Monitor parameters                              *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET18    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+1*4          GET PER PARM POINTER
*
*  Monitor already set
*
         IF    ('LT RA,SCPCTL8',NZ),BEGIN
         IF    SCBFCLP,BEGIN           CLP IN CONTROL
         IF    (RS,Z),EXIT              UNCONDITIONAL CLEAR
         IF    ^SCPFMON,BEGIN
         MVC   SCPGPRS+15*4,=A(4)      MONITOR OWNED BY USER
         EXIT  SET18
         END   ,
         END
         ELSE  BEGIN
         IF    SCPFMON,BEGIN
         MVC   SCPGPRS+15*4,=A(4)      MONITOR OWNED BY CLP
         EXIT  SET18
         END   ,
         END   ,
         END
*
*  Process clear request
*
         IF    (RS,Z),'STH  RS,SCPCTL8+2'   CLEAR MONITOR CONTROL
*
*  Obtain caller supplied monitor parameters
*
         ELSE  BEGIN
         PSET  @PAGE
         L     RA,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         ST    RA,@PAGLOC              SET LOCATION
         MVC   @PAGLEN,=A(4)           LENGTH OF PARM AREA
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN          NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET18
         END   ,
         MVC   SCPCTL8+2(2),@RA+2      MOVE IN USER DATA
         END
*
*  SET NEW MONITOR INFORMATION
*
         PSET  @MONSET
         MVC   @MONSDAT,SCPCTL8+2
         VCALL MONSET
         CLEAR SCPFMON                 ASSUME WE JUST CLEARED IT
         LH    R15,SCPCTL8+2           GET MONITOR MASK
         IF    ((R15,NZ),AND,SCBFCLP),'SET  SCPFMON'    CLP IS OWNER
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 19 - Protect memory area                                 *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET19    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Check parameters
*
         L     RA,SCPGPRS+1*4          STARTING ADDRESS
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         L     RB,SCPGPRS+15*4         LENGTH
         IF    (RB,Z),BEGIN
         MVC   SCPGPRS+15*4,=A(0)      NULL REQUEST
         EXIT  SET19
         END   ,
         IF    M,BEGIN                 INVALID REQUEST
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET19
         END   ,
         LA    R15,@RB(RA)             LAST ADDRESS+1
         N     RA,=X'7FFFF000'         ROUND TO PAGE BOUNDARY
*
*  DO SHARED PROGRAM PROTECTION
*
         WITH  (SCP,RY)
         L     RJ,SCBSPB               IS THERE AN SPB?
         IF    (RJ,NZ),BEGIN
         WITH  (SPB,RJ)
         IF    SPBFPRT,EXIT            PROTECTED PROGRAM
         IF    (RA,LT,SPBORGIN),EXIT   BEGINNING NOT IN RANGE
         L     RS,SPBSIZE              PROGRAM SIZE
         A     RS,SPBORGIN             END OF PROGRAM AREA
         IF    (R15,GT,RS),EXIT         ENDING NOT IN RANGE
*         IF    SPBFLHI,BEGIN
         IF    ('CLI SPBORGIN,0',NE),BEGIN
         VMCHK (RB),A=(RA),LOC=GLOBHI,TYPE=PROG,KEY=USER,FETP=NO
         END   ,
         ELSE  BEGIN
         VMCHK (RB),A=(RA),LOC=GLOBLO,TYPE=PROG,KEY=USER   VALIDATE
         END   ,
         IF    (RVR,NZ),BEGIN          INVALID ADDRESS
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET19
         END   ,
         PSET  @PAGE,CLEAR=NO
         ST    RA,@PAGLOC              SET ADDRESS
         ST    RB,@PAGLEN               AND LENGTH
         VCALL PAGPROT                 PROTECT THE PAGE
         IF    (RVR,NZ),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET19
         END   ,
         END
         EJECT
*
*  DO USER PROGRAM/WORKSPACE PROTECTION
*
         ELSE  BEGIN
         IF    SCPFPRT,BEGIN           USER PROGRAM PROTECTED
         IF    (RA,LT,SCPRRSEG),BEGIN  INVALID
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET19
         END   ,
         END
         VMCHK (RB),A=(RA),LOC=LOCUSR,FETP=NO,TYPE=PROG    VALIDATE
         IF    (RVR,NZ),BEGIN          INVALID ADDRESS
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET19
         END   ,
         PSET  @PAGE,CLEAR=NO
         ST    RA,@PAGLOC              SET ADDRESS
         ST    RB,@PAGLEN               AND LENGTH
         VCALL PAGPROT                 PROTECT THE PAGE
         IF    (RVR,NZ),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET19
         END   ,
         END   ,
         MVC   SCPGPRS+15*4,=A(0)     Good return
         PEND
*
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    SET 20 - Un-protect memory area                              *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET20    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Check parameters
*
         L     RA,SCPGPRS+1*4          STARTING ADDRESS
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         L     RB,SCPGPRS+15*4         LENGTH
         IF    (RB,M),BEGIN            INVALID REQUEST
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET20
         END   ,
         IF    (RB,Z),BEGIN            NULL REQUEST
         MVC   SCPGPRS+15*4,=A(0)      NULL REQUEST
         EXIT  SET20
         END   ,
         LA    R15,@RA(RB)              LAST ADDRESS+1
         N     RA,=X'7FFFF000'         ROUND TO PAGE BOUNDARY
*
*  DO SHARED PROGRAM UN-PROTECTION
*
         L     RJ,SCBSPB               IS THERE AN SPB?
         IF    (RJ,NZ),BEGIN
         WITH  (SPB,RJ)
         IF    SPBFPRT,EXIT            PROTECTED PROGRAM
         IF    (RA,LT,SPBORGIN),EXIT   BEGINNING NOT IN RANGE
         L     RS,SPBSIZE              PROGRAM SIZE
         A     RS,SPBORGIN             END OF PROGRAM AREA
         IF    (R15,GT,RS),EXIT        ENDING NOT IN RANGE
*         IF    SPBFLHI,BEGIN
         IF    ('CLI SPBORGIN,0',NE),BEGIN
         VMCHK (RB),A=(RA),LOC=GLOBHI,TYPE=PROG,KEY=USER,FETP=NO
         END   ,
         ELSE  BEGIN
         VMCHK (RB),A=(RA),LOC=GLOBLO,TYPE=PROG,KEY=USER   VALIDATE
         END   ,
         IF    (RVR,NZ),BEGIN          INVALID ADDRESS
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET20
         END   ,
         PSET  @PAGE,CLEAR=NO
         ST    RA,@PAGLOC              SET ADDRESS
         ST    RB,@PAGLEN               AND LENGTH
         VCALL PAGUPROT                 UN-PROTECT THE PAGES
         IF    (RVR,NZ),BEGIN          INVALID ADDRESS
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET20
         END   ,
         END   ,
         EJECT
*
*  DO USER PROGRAM/WORKSPACE UN-PROTECTION
*
         ELSE  BEGIN
         IF    SCPFPRT,BEGIN           USER PROGRAM PROTECTED
         IF    (RA,LT,SCPRRSEG),BEGIN   INVALID
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET20
         END   ,
         END
         VMCHK (RB),A=(RA),LOC=LOCUSR,FETP=NO,TYPE=PROG    VALIDATE
         IF    (RVR,NZ),BEGIN          INVALID ADDRESS
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET20
         END   ,
         PSET  @PAGE,CLEAR=NO
         ST    RA,@PAGLOC              SET ADDRESS
         ST    RB,@PAGLEN               AND LENGTH
         VCALL PAGUPROT                PROTECT THE PAGE
         IF    (RVR,NZ),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET20
         END   ,
         END   ,
         MVC   SCPGPRS+15*4,=A(0)      Good return
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    S21WORK - SET 21 work area                                   *
*                                                                 *
*******************************************************************
         SPACE
S21WORK  RECORD BEGIN
S21NAME  DS    CL128                   Enqueue resource name
S21OPTS  FLAG  ,
         FLAG  S21OTEST                Test mode request
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    S21WAIT - SET 21 Wait element                                *
*                                                                 *
*******************************************************************
         SPACE
S21WAIT  RECORD BEGIN
S21WFP   DS    A                       Forward pointer
S21WBP   DS    A                       Back pointer
S21WID   DS    CL4'S21W'               Id
S21ADDR  DS    A                       Address of SET 21 SVC
S21ASB   DS    A                       ASB pointer
S21SCP   DS    A                       SCP pointer
S21SYSR  DS    A                       SYSR Id
S21FLAG  FLAG  ,
         FLAG  S21FPOST                Element posted
         FLAG  S21FSYSD                SYSR deleted
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SET 21 - Enqueue resource                                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET21    PROC  ,S21WORK,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR S21WORK
*
*  Get resource name length
*
         L     RB,SCPGPRS+15*4         CALLER PARM LENGTH
         IF    (RB,M),BEGIN
         SET   S21OTEST                Note test mode
         LPR   RB,RB                   Make positive
         END   ,
*
*  Validate caller's parameters
*
         IF    ((RB,NP),OR,            MUST BE POSITIVE                *
               (RB,GT,128),OR,          AND LESS THAN 128              *
               ('LT  RS,SCBENQ',P)),BEGIN  AND NO OTHER ENQUEUES
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET21
         END   ,
*
*  Check area containing resource name
*
         PSET  @PAGE
         L     RA,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         ST    RA,@PAGLOC              SET LOCATION
         ST    RB,@PAGLEN               LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN         NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET21
         END   ,
*
*  Copy name to work area
*
         MVC   S21NAME,=CL44' '        CLEAR
         DEX   RB,'MVC  S21NAME(0),@RA'   GET USER ENQ ID
*
*  HASH PORTION OF ENQ NAME OVER 44 BYTES INTO A FOUR-BYTE VALUE
*
         IF    (RB,GE,44),BEGIN
         LA    R15,@RB+4
         S     R15,=A(40)              NUMBER OF BYTES OVER 40
         SRL   R15,2                   NUMBER OF WORDS
         LA    R14,S21NAME+40          POINTER
         L     RB,=X'00010000'
         LOOP  BEGIN
         L     RS,=X'0F1E2D3C'         GET XOR KEY
         X     RS,@R14
         MR    RA,RS                   FACTOR IN RA
         SRDL  RA,16                   SAVE MIDDLE BYTES
         LA    R14,@R14+4              TO NEXT PORTION OF BUFFER
         DECR  R15
         UNTIL (R15,Z),END
         IF    (RB,Z),'L  RB,=X"0F1E2D3C"'
         ST    RB,S21NAME+40           ADD HASH VALUE TO STRING
         END   ,
*
*  GET SET 21 LOCK
*
         L     RA,MATPTR                MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA),'LKOB  CTST21LK'   GET LOCK
*
*  Remove outstanding set 21 wait request
*
         IF    ('LT  RS,SCBENQ',NEG),BEGIN
         LCALL S21CAN
         IF    (RVR,NZ),SET21X         DELETE UNSUCCESSFUL
         END   ,
*
*  Enqueue on name
*
         PSET  @ENQUEUE
         MVC   @ENQRNM,S21NAME         RESOURCE NAME
         MVC   @ENQQNM,=CL8'SET21'     QUEUE NAME
         VCALL ENQUEUE
         IF    (RVR,NZ),BEGIN
         ST    RVR,SCBENQ              THIS USER HAS ENQUEUE NOW
         MVC   SCPGPRS+15*4,=A(0)      GOOD RETURN
         END   ,
*
*  Resource not immediately available - done if mode test
*
         ELSE  BEGIN
         IF    S21OTEST,'MVC  SCPGPRS+15*4,=A(4)'    MODE TEST
*
*  Caller will wait - back up PSW and mark for suspend
*
         ELSE  BEGIN
         LH    R14,SCPIPSW+2           GET CURRENT ILC
         SRL   R14,8+6-1               ISOLATE
         N     R14,=X'00000006'         INSTRUCTION LENGTH
         L     R15,SCPPSW+4            GET CURRENT PSW ADDRESS
         SLR   R15,R14                 BACK UP TO SVC INSTRUCTION
         ST    R15,SCPPSW+4            RESET PSW
         CLEAR SCPIPSW+2.X'C0'
         SET   SCBFWAIT                MARK USER AS WAITING
         SET   SCBFNPUP                DON'T CHANGE PSW CC
*
*  Obtain memory for wait element
*
         VMGET L'S21WAIT,LOC=GLOBHI,FIX=YES  GET WAIT ELEMENT
         IF    ('LTR  RB,RVR',Z),'ABORT S21WAIT'
         WITH  (S21WAIT,RB)
         CLEAR S21WAIT
         ST    RB,SCBENQ
         SET   SCBENQ.X'80'            MARK AS WAIT ELEMENT
*
*  Build wait element
*
         MVC   S21WID,=CL4'S21W'       ID
         MVC   S21ADDR,SCPPSW+4        Location
         PSET  @SYSRNEW
         VCALL SYSRNEW                 CREATE SYSR ID
         ST    RVR,S21SYSR
         ST    RY,S21SCP               SCP POINTER IS PARM
         MVC   S21ASB,PZCURASB         INCLUDE ASB
*
*  Add wait element to SET 21 queue
*
         L     RA,MATPTR               MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA),BEGIN
         LA    R15,CTST21QH            Head of queue
         ST    R15,S21WFP               is forward pointer
         L     R15,CTST21QT            Previous end element
         WITH  (S21WAIT,R15),'ST  RB,S21WFP'   Now points here
         ST    R15,S21WBP               and this points there
         ST    RB,CTST21QT              New queue tail
         END   ,
         END   ,
         END   ,
*
*  RELEASE THE SET 21 LOCK
*
SET21X   LABEL ,
         L     RA,MATPTR                MAT POINTER
         WITH  (MAT,RA),'L  RA,MATM1CT'   CT POINTER
         WITH  (M1CT,RA),'LKREL  CTST21LK'   RELEASE THE LOCK
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 22 - Dequeue resource                                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET22    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  User neither owns nor is waiting
*
         L     RB,SCBENQ               GET ENQUEUE VALUE
         IF    (RB,Z),EXIT
*
*  GET CT POINTER
*
         L     RK,MATPTR                MAT POINTER
         WITH  (MAT,RK),'L  RK,MATM1CT'   CT POINTER
         WITH  (M1CT,RK)
*
*  GET SET 21 LOCK
*
         LKOB  CTST21LK                GET LOCK
*
*  USER OWNS THE RESOURCE - RELEASE IT
*
         IF    (RB,P),BEGIN
         CLEAR SCBENQ                  RESET THE ENQ FIELD
         PSET  @DEQUEUE
         ST    RB,@DEQID               GIVE ENQUEUE ID
         VCALL DEQUEUE
*
*  THEN POST THOSE ON SET 21 WAIT QUEUE
*
         LA    RA,CTST21QH             SET 21 WAIT QUEUE HEAD
         WHILE (RA,NE,CTST21QH),BEGIN
         L     RB,CTST21QH
         WITH  (S21WAIT,RB)
         LM    R14,R15,S21WFP          Get previous and next
         WITH  (S21WAIT,R14),'ST  R15,S21WBP'
         WITH  (S21WAIT,R15),'ST  R14,S21WFP'
         SET   S21FPOST                MARK ELEMENT POSTED
         PSET  @SYSRDO
         MVC   @SYSRID,S21SYSR         SET SYSR ID
         MVC   @SYSRASB,S21ASB          ASB
         MVC   @SYSRLOC,=A(S21POST)     ROUTINE ADDRESS
         ST    RB,@SYSRPRM              S21WAIT IS PARM
         VCALL SYSRDO                  START IT UP
         END   ,
         END   ,
*
*  REMOVE WAITING USER FROM WAIT QUEUE
*
         ELSE  'LCALL S21CAN'          TRY TO GET RID OF IT
*
*  RELEASE THE SET 21 LOCK
*
         LKREL CTST21LK                RELEASE THE LOCK
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    S21POST - SET 21 Post SYSR routine                           *
*                                                                 *
*                                                                 *
*     Input - @SYSRTN                                             *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
S21POST  PROC  @SYSRTN,SCOPE=LOCAL
         L     RB,@SYSPARS             S21 WAIT ELEMENT POINTER
         WITH  (S21WAIT,RB)
         L     RY,S21SCP               SCP POINTER
         WITH  (SCP,RY)
*
*  TASK IS STILL SUSPENDED - WAKE IT UP
*
         IF    SCBFWAIT,BEGIN
         IF    (S21ADDR,NE,SCPPSW+4),EXIT   Not waiting for SET 21
         PSET  @RESUME
         MVC   @RESCTL,SCPSID          SET SUSPEND ID
         VCALL RESUMTS                 START THE TASK GOING
         CLEAR SCBFWAIT
         END   ,
*
*  DELETE SYSR
*
         PSET  @SYSRDEL
         MVC   @SYSRDID,S21SYSR
         VCALL SYSRDEL
         SET   S21FSYSD                Mark it deleted
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    S21CAN - SET 21 Cancel wait request routine                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*             SET 21 lock must be held                            *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
S21CAN   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RA,SCBENQ               Element pointer
         N     RA,=X'7FFFFFFF'
         WITH  (S21WAIT,RA)
*
*  IF NOT YET POSTED REMOVE THIS USER FROM THE SET 21 WAIT QUEUE
*
         IF    ^S21FPOST,BEGIN
         LM    R14,R15,S21WFP          Get previous and next
         WITH  (S21WAIT,R14),'ST  R15,S21WBP'
         WITH  (S21WAIT,R15),'ST  R14,S21WFP'
         SET   S21FPOST                Note that it is removed
         END
*
*  IF SYSR STILL ACTIVE TRY TO DELETE IT
*
         IF    ^S21FSYSD,BEGIN
         PSET  @SYSRDEL
         MVC   @SYSRDID,S21SYSR
         VCALL SYSRDEL
*
*  IF THE SYSR COULDN'T BE DELETED CAUSE THIS USER TO RE-RUN
*
         IF    (RVR,NZ),BEGIN
         LH    R14,SCPIPSW+2           GET CURRENT ILC
         SRL   R14,8+6-1               ISOLATE
         N     R14,=X'00000006'         INSTRUCTION LENGTH
         L     R15,SCPPSW+4            GET CURRENT PSW ADDRESS
         SLR   R15,R14                 BACK UP TO SVC INSTRUCTION
         ST    R15,SCPPSW+4            RESET PSW
         CLEAR SCPIPSW+2.X'C0'
         SET   SCBFNPUP                DON'T CHANGE PSW CC
         EXIT  S21CAN
         END   ,
         END   ,
*
*  Release the wait element
*
         VMFREE L'S21WAIT,A=(RA),LOC=GLOBHI,FIX=YES
         IF    (RVR,NZ),'ABORT S21FREE'
         CLEAR SCBENQ                  RESET THE ENQ FIELD
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 23 - Set trash (memory clearing) byte                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET23    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RS,SCPGPRS+1*4
         STC   RS,SCPTRASH
         MVC   SCPGPRS+15*4(4),=A(0)   SIMPLY DONE
*
*  Set user's hash value
*
         PSET  @PAGE
         PMOV  @PAGLOC,SCPRRSEG        For the whole user area
         PMOV  @PAGLEN,SCPUMSIZ
         PMOV  @PAGHASH,(RS)
         VCALL PAGHASH
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 24 Program name translation table                        *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
PNAMTAB  DC    256X'01'                DEFAULT IS ALL INVALID
         ORG   PNAMTAB+C'A'
         DC    X'000000000000000000'   A-I
         ORG   PNAMTAB+C'J'
         DC    X'000000000000000000'   J-R
         ORG   PNAMTAB+C'S'
         DC    X'0000000000000000'     S-Z
         ORG   PNAMTAB+C'0'
         DC    X'00000000000000000000' 0-9
         ORG   PNAMTAB+C' '
         DC    X'00'                   BLANK
         ORG   PNAMTAB+C'a'
         DC    X'000000000000000000'   a-i
         ORG   PNAMTAB+C'j'
         DC    X'000000000000000000'   j-r
         ORG   PNAMTAB+C's'
         DC    X'0000000000000000'     s-z
         ORG
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    S24WORK - SET 24 work area                                   *
*                                                                 *
*******************************************************************
         SPACE
S24WORK  RECORD BEGIN
S24NAME  DS    CL8                     PROGRAM NAME
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SET 24 - Set Program Name                                    *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET24    PROC  ,S24WORK,SCOPE=LOCAL
         WITH  (SCP,RY)
         L     RB,SCPGPRS+15*4         LENGTH
         IF    (RB,NP),BEGIN
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET24
         END   ,
         PSET  @PAGE
         L     RA,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         ST    RA,@PAGLOC              SET LOCATION
         ST    RB,@PAGLEN               and LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN        NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET24
         END   ,
         CEIL  RB,L'SCBPNAM            CAN'T MOVE MORE THAN THIS
         DEX   RB,'MVC  S24NAME(0),@RA'    GET THE DATA
         EX    RB,'TRT S24NAME(0),PNAMTAB'     CHARS OK
         IF    NZ,BEGIN
         MVC   SCPGPRS+15*4(4),=A(4)   INVALID CHARS
         EXIT  SET24
         END   ,
         MVC   SCBPNAM,=CL(L'SCBPNAM)' '      FOR ALL CAPS
         EX    RB,'OC SCBPNAM(0),S24NAME'     MOVE IN THE NAME
         INCR  RB
         STH   RB,SCBPNAML             SAVE NAME LENGTH
         PSET  @ACPINFO                Set name globally
         PMOV  @ACPASB,PZCURASB        |
         PMOV  @ACPPGNM,SCBPNAM        |
         VCALL ACPINFO                 |
         MVC   SCPGPRS+15*4(4),=A(0)   ALL IS WELL
         PEND
         EJECT
*box
*
*    SET 29 - Suspend task for specified time interval
*
*     Macro format:
*         SET  29,time-interval (count of 0.1 second increments)
*              (0) (1)
*
*         Returns in R15:
*             0 = successful completion
*
*     Input - RY Points to SCP
*
SET29    PROC  ,
         WITH  (SCP,RY)
         LT    R0,SCPGPRS+1*4
         IF    (NP,OR,(R0,GT,100)),BEGIN Not more than 10 seconds
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET29
         END   ,
         ACALL M1GOWAIT                GO WAIT
         MVC   SCPGPRS+15*4(4),=A(0)   ALL IS WELL
         PEND
         EJECT
*box
*
*    SET 30 - Add new shared symbol entry.
*
*     Macro format:
*         SET  30,symbol-location,symbol-length,address
*              (0) (1)            (15)          (14)
*
*         Returns in R15:
*            -4 = not allowed (program not authorized)
*             0 = successful completion
*             4 = symbol already defined
*
*     Input - RY Points to SCP
*
S30WORK  RECORD BEGIN
S30NAME  DS    CL(L'SSBNAME)       Working symbol name
         END
*-
SET30    PROC  ,S30WORK,SCOPE=LOCAL
         WITH  (SCP,RY)
*
         L     RK,MATPTR               MAT POINTER
         WITH  (MAT,RK),'L  RK,MATM1CT'   CT POINTER
         WITH  (M1CT,RK)
*-
*-       Check symbol location and length for validity.
*-
         LT    RB,SCPGPRS+15*4     Symbol length
         IF    NP,BEGIN            Incorrectly specified...
         MVI   SCPPANSY,PANSPEC    Set code for spec
         SET   SCBXP               Mark user for panic
         EXIT  SET30               Scram
         END
*
         PSET  @PAGE
         L     RA,SCPGPRS+1*4      Location
         ST    RA,@PAGLOC              SET LOCATION
         ST    RB,@PAGLEN               and LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN        NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET30
         END
*-
*-       Create symbol name in fixed blank padded work area.
*-
         MVI   S30NAME,C' '
         MVC   S30NAME+1(L'S30NAME-1),S30NAME  Pre-blank
         CEIL  RB,L'S30NAME        Can't move more than this
         DEX   RB,'MVC S30NAME(0),@RA'  Get the symbol name
*-
*-       Only allow authorized programs to do this.
*-
         LT    RJ,SCBSPB               Get Current SPB
         WITH  (SPB,RJ)
         IF    (Z,OR,^SPBFAUTH),BEGIN
         MVC   SCPGPRS+15*4(4),=F'-4'  Not allowed
         EXIT  SET30                   Scram
         END
*-
*-       Make sure the symbol doesn't already exist.
*-
         LKOB  CTSPBCLK                Lock up the SPB queue
*
         L     RA,CTSPBS               Get first of the SPBs
         WHILE (RA,NZ),BEGIN           Search SPB list
         WITH  (SPB,RA)
         IF    ^SPBFCORPSE,BEGIN       Only look at real ones
         L     RB,SPBSSB
         WHILE (RB,NZ),BEGIN           Search SSB's
         WITH  (SSB,RB)
         FAIL  (SSB,NE,'SSB'),BADSSBQ  For safety sake
         IF    (SSBNAME,EQ,S30NAME),BEGIN
         MVC   SCPGPRS+15*4(4),=A(4)   RC=4, Already defined
         B     S30UEXIT                Unlock and return
         END
         L     RB,SSBNEXT              Point at the next one
         END
         END
         L     RA,SPBNEXT              Point at the next SPB
         END
*-
*-       We have looked everywhere for it and it has not been
*-       found.  We are therefore justified in defineing the
*-       damn thing.
*-
*         VMGET L'SSB,LOC=GLOBLO,TYPE=DATA
         VMGET L'SSB,LOC=GLOBHI,TYPE=PROG
         LTR   RB,RVR                  Copy new data ptr
         FAIL  Z,SSBMEM                Trouble
         WITH  (SSB,RB)
         CLEAR SSB
         MVC   SSBID,=CL4'SSB'
         MVC   SSBNAME,S30NAME         Save symbol name
         MVC   SSBWORD,SCPGPRS+14*4    Save value
*-
*-       Add new symbol entry to the linked list.
*-
         MVC   SSBNEXT,SPBSSB          Point it to the list
         ST    RB,SPBSSB               Then point at this one
*-
*-       Finish up.
*-
         MVC   SCPGPRS+15*4(4),=F'0'   RC=0  Successful completion
*
S30UEXIT LKREL CTSPBCLK                Release queue search lock
         PEND
         EJECT
*box
*
*    SET 31 - Delete existing shared symbol entry.
*
*     Macro format:
*         SET  29,symbol-location,symbol-length
*              (0) (1)            (15)
*
*         Returns in R15:
*            -4 = not allowed (program not authorized)
*             0 = successful completion
*             4 = symbol already defined
*
*     Input - RY Points to SCP
*
S31WORK  RECORD BEGIN
S31PREVP DS    A                   Previous SSB ptr
S31NAME  DS    CL(L'SSBNAME)       Working symbol name
         END
*-
SET31    PROC  ,S31WORK,SCOPE=LOCAL
         WITH  (SCP,RY)
*
         L     RK,MATPTR               MAT POINTER
         WITH  (MAT,RK),'L  RK,MATM1CT'   CT POINTER
         WITH  (M1CT,RK)
*-
*-       Check symbol location and length for validity.
*-
         LT    RB,SCPGPRS+15*4     Symbol length
         IF    NP,BEGIN            Incorrectly specified...
         MVI   SCPPANSY,PANSPEC    Set code for spec
         SET   SCBXP               Mark user for panic
         EXIT  SET31               Scram
         END
*
         PSET  @PAGE
         L     RA,SCPGPRS+1*4      Location
         ST    RA,@PAGLOC              SET LOCATION
         ST    RB,@PAGLEN               and LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN        NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET31
         END
*-
*-       Create symbol name in fixed blank padded work area.
*-
         MVI   S31NAME,C' '
         MVC   S31NAME+1(L'S31NAME-1),S31NAME  Pre-blank
         CEIL  RB,L'S31NAME        Can't move more than this
         DEX   RB,'MVC S31NAME(0),@RA'  Get the symbol name
*-
*-       Only allow authorized programs to do this.
*-
         CLEAR RA                  Assume not authorized
         IF    ('LT RB,SCBSPB',NZ),BEGIN
         WITH  (SPB,RB)
         IF    SPBFAUTH,'LA RA,4'  Program is authorized
         END
*
         IF    (RA,Z),BEGIN       Not authorized...
         MVC   SCPGPRS+15*4(4),=F'-4'  Not allowed
         EXIT  SET31               Scram
         END
*-
*-             I M P O R T A N T   N O T E
*-
*-       The remainder is not implemented as defined. This entire
*-       service should be removed.
*-
         MVC   SCPGPRS+15*4(4),=F'0'  RC=0  Successful completion
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 150 - Clear pseudo user                                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET150   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*         CLEAR SCPFPSEU                CLEAR THE FLAG
*         CLEAR SCPPACCT                CLEAR THE ACCOUNT,
*         CLEAR SCPPRIVS                PRIVS. JUST FOR NEATNESS
         VCALL FMCLSUDO                CLEAR PSEUDO USER
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 151 - Ignore multiple attentions                         *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET151   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         CLEAR SCBCFNMA                DEFAULT IS ZERO
         IF    (SCPGPRS+1*4,EQ,1873),'SET SCBCFNMA'  IF OK, SET IT
         MVC   SCPGPRS+15*4,=A(0)      GOOD COMPLETION
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 152 - Set CLP real time (interval) timer                 *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET152   PROC  ,SETCLK,SCOPE=LOCAL
         WITH  (SCP,RY)
         IF    ^SCBFCLP,BEGIN          MUST BE (REAL) CLP
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET152
         END   ,
         L     RB,SCPGPRS+1*4          SUPPLIED TIME VALUE
         CLEAR RJ                      OLD INTERVAL
         CLEAR SCBXCPT                 CLP TIMER EXIT CANCEL
         IF    SCBTCPTR+SCBTCPCT,BEGIN A TIMER NOW RUNNING
*
*  CPU TIMER IS NOW RUNNING
*
         IF    SCBTCPCT,BEGIN          CURRENT TIMER IS CPU TIME
         PSET  @CPCNCK
         MVC   @CPCID,SCPCCLK          CLOCK ID
         VCALL CPCAN                   CAN IT
         LD    R0,@CPCCLK              PREVIOUS INTERVAL
         END   ,
*
*  REAL TIMER IS NOW RUNNING
*
         ELSE  BEGIN                   CURRENT TIMER IS REAL TIME
         PSET  @RTCNCK
         MVC   @RTCID,SCPCCLK          CLOCK ID
         VCALL RTCAN                   CAN IT
         LD    R0,@RTCCLK              PREVIOUS INTERVAL
         END   ,
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SWCLOCK
         L     RJ,SWCLOCK+4            PREVIOUS TIMER
         CLEAR SCBTCPTR+SCBTCPCT       NOTE
         CLEAR SCPCCLK                  CANCELLED
         END   ,
*
*  NOW SET NEW TIMER IF SO REQUESTED
*
         IF    (RB,NZ),BEGIN
         PSET  @RTSET
         MVC   @RTSCLK(4),=XL8'4E00000000000000'
         ST    RB,@RTSCLK+4            NORMALIZED TIME VALUE
         LD    R0,@RTSCLK
         MD    R0,=D'106667'            TO USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,@RTSCLK
         MVI   @RTSCLK,0               REMOVE EXPONENT
         SET   @RTSFINT                VALUE IS AN INTERVAL
         MVC   @RTSXIT,SCPCCXIT        SET EXIT ID
         VCALL RTSET                   START THE CLOCK
         ST    RVR,SCPCCLK             SAVE ID
         SET   SCBTCPTR
         END
         ST    RJ,SCPGPRS+15*4         RETURN VALUE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 153 - Set CLP compute time timer                         *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET153   PROC  ,SETCLK,SCOPE=LOCAL
         WITH  (SCP,RY)
         IF    ^SCBFCLP,BEGIN          MUST BE (REAL) CLP
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET153
         END   ,
         CLEAR RJ                      OLD INTERVAL
         CLEAR SCBXCPT                 CLP TIMER EXIT CANCEL
         IF    SCBTCPTR+SCBTCPCT+SCBTCPQU,BEGIN  A TIMER NOW RUNNING
*
*  CPU TIMER IS RUNNING
*
         IF    SCBTCPCT,BEGIN           CURRENT TIMER IS CPU TIME
         PSET  @CPCNCK
         MVC   @CPCID,SCPCCLK          CLOCK ID
         VCALL CPCAN                   CAN IT
         LD    R0,@CPCCLK              PREVIOUS INTERVAL
         END   ,
*
*  REAL TIMER IS RUNNING
*
         ELSE  BEGIN                   CURRENT TIMER IS REAL TIME
         PSET  @RTCNCK
         MVC   @RTCID,SCPCCLK          CLOCK ID
         VCALL RTCAN                   CAN IT
         LD    R0,@RTCCLK              PREVIOUS INTERVAL
         END   ,
         IF    ^SCBTCPQU,BEGIN          RETURN PREVIOUS TIMER
         DD    R0,=FL8'106667'          TO 26 USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,SWCLOCK
         L     RJ,SWCLOCK+4            PREVIOUS TIMER
         END
         CLEAR SCBTCPTR+SCBTCPCT+SCBTCPQU
         CLEAR SCPCCLK                  CANCELLED
         END   ,
*
*  NOW SET NEW TIMER IF SO REQUESTED
*
         L     RB,SCPGPRS+1*4          SUPPLIED TIME VALUE
         IF    (RB,NZ),BEGIN
         PSET  @CPSET
         MVC   @CPSCLK(4),=XL8'4E00000000000000'
         ST    RB,@CPSCLK+4            NORMALIZED TIME VALUE
         LD    R0,@CPSCLK
         MD    R0,=D'106667'            TO USEC UNITS
         AW    R0,=XL8'4E00000000000000'
         STD   R0,@CPSCLK
         MVI   @CPSCLK,0               REMOVE EXPONENT
         MVC   @CPSXIT,SCPCCXIT        SET EXIT ID
         VCALL CPSET                   START THE CLOCK
         ST    RVR,SCPCCLK             SAVE ID
         SET   SCBTCPTR+SCBTCPCT
         END
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 154 - Write an SMF record                                *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET154   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Validate length
*
         L     RB,SCPGPRS+15*4        LENGTH
         IF    (RB,NP),BEGIN          CHECK VALID
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET154
         END   ,
*
*  Validate caller's area
*
         L     RA,SCPGPRS+1*4          LOCATION
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         PSET  @PAGE
         ST    RA,@PAGLOC              SET LOCATION
         ST    RB,@PAGLEN              LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT               CHECK IT OUT
         IF    (RVR,GE,2),BEGIN          NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET154
         END   ,
*
*  Validate SMF number
*
         L     R14,SCPGPRS+14*4        SMF NUMBER
         IF    (R14,NP),BEGIN          NOT VALID
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET154
         END   ,
*         LA    TR,L'CTUSRSMF           CHECK
*         LA    SR,CTUSRSMF              USER
*SMFLOOP  EX    R14,'CLI  @SR,0'          SUPPLIED
*         BE    SMFOK                      NUMBER
*         INCR  SR                      NEXT
*         BCT   TR,SMFLOOP
*         B     SETSPEC                 NOT VALID
         SLL   R14,24
         OR    RB,R14
         SYSCTL RA,RB,TYPE=SMF         GO WRITE SMF RECORD
         ST    RA,SCPGPRS+15*4         RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    SET 155 - Set Program Key Mask                               *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SET155   PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         BEGIN
         IF    (SCPACCT,EQ,'GG.'),EXIT  Liberalized, 6/90, Niz
         IF    (SCPACCT,EQ,'GQ.'),EXIT  Liberalized, 6/90, Niz
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SET155
         END   ,
         L     RX,PZCURASB             CURRENT ASB
         WITH  (ASB,RX)
         LH    RS,ASBPKM               GET CURRENT MASK
         MVC   ASBPKM,SCPGPRS+1*4+2    SET NEW MASK
         DROP  ASB
         ST    RS,SCPGPRS+1*4          RETURN PREVIOUS MASK
         MVC   SCPGPRS+15*4(4),=A(0)   ALL DONE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    @SETEXIT - Set parameters for user exit                      *
*                                                                 *
*******************************************************************
         SPACE
@SETEXIT RECORD BEGIN
@SETEXL  DS    A                       Exit block address
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SETEXIT - Common processing for setting an exit              *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SETEXIT  PROC  @SETEXIT,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  Validate routine address
*
         L     RA,SCPGPRS+1*4          SUPPLIED ROUTINE ADDRESS
         TM    SCPPSW+4,X'80'          31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         IF    (RA,NZ),BEGIN
         PSET  @PAGE
         ST    RA,@PAGLOC              LOCATION
         MVC   @PAGLEN,=A(2)           MINIMUM ROUTINE LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN         NO GOOD
         MVI   SCPPANSY,PANSPEC        SET CODE FOR SPEC
         SET   SCBXP                   MARK USER FOR PANIC
         EXIT  SETEXIT
         END   ,
         LR    R0,RA                   SUPPLIED ROUTINE ADDRESS
         TM    SCPPSW+4,X'80'          31 bit mode?
         IF    O,'O R0,=X"80000000"'   Set to 31 bit mode
         L     R1,SCPGPRS+14*4          AND PARM
         END
         ELSE  'CLEAR R0,R1'           CALLER IS DELETING EXIT
*
*  Return previous exit info - then set new exit info
*
         L     RB,@SETEXL
         L     R15,@RB                 PREVIOUS EXIT ADDRESS
         L     R14,@RB+4                AND PARM
         STM   R14,R15,SCPGPRS+14*4    RETURN PREVIOUS
         STM   R0,R1,@RB               SET NEW EXIT AND USER INFO
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    VMUPDAT - Update memory reserve and unreserve counts         *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
VMUPDAT  PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
*
*  UPDATE RESERVE/UNRESERVE COUNTS
*
         L     RA,SCPGPRS+1*4          LOCATION IN R1
         L     RB,SCPGPRS+0*4          LENGTH IN R0
         SRL   RB,12                   BACK TO 4K INCREMENTS
         LH    RS,SCPUNRSV             ADJUST UNRESERVED COUNT
         SR    RS,RB
         STH   RS,SCPUNRSV
         LH    RS,SCPRESRV             ADJUST RESERVED COUNT
         AR    RS,RB
         STH   RS,SCPRESRV
         AGO   .NOTRASH
*
*  TRASH MEMORY IF USER TRASH BYTE IS DIFFERENT FROM SYSTEM
*
         L     RS,MATPTR               MAT POINTER
         WITH  (MAT,RS),'L  RS,MATM1CT'  CT POINTER
         WITH  (M1CT,RS),'CLC  SCPTRASH,CTTRASH'
         IF    NE,BEGIN
         LR    R14,RA                  LOCATION
         SLL   RB,12                   LENGTH
         LCM   R15,B'1000',SCPTRASH    DESIRED TRASH CHARACTER
         MVCL  RA,R14                  DO IT
         END
.NOTRASH ANOP  ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    PERCHECK - Set PSW PER flag                                  *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PERCHECK PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         NI    SCPPSW,B'10111111'      ASSUME NO PER
         IF    (SCPCTL9.B'11110000',NZ),BEGIN   SOME EVENTS
         IF    SCPFPER,'SET  SCPPSW.B"01000000"'   SET PER GOING
         ELSE  BEGIN
         IF    ^SCBMB.SCBXP,EXIT       USER PANIC DISABLED
         IF    ('LT  RS,SCPPXEP',Z),EXIT   NO PANIC ROUTINE
         SET   SCPPSW.B'01000000'      SET PER GOING
         END
         END   ,
         PEND
         SPACE 3
         EJECT
         LTORG
         TITLE 'ORVYL''S Mode 1 Enqueue/Dequeue SVC'
*******************************************************************
*                                                                 *
*   M1ENQPRM - Mode 1 Enqueue/Dequeue parameters                  *
*                                                                 *
*******************************************************************
         SPACE
M1ENQPRM RECORD BEGIN
M1EQID   DS    A                       ENQUEUE ID
M1EQSLOT DS    A                       SLOT ADDRESS
M1EQRQID DS    A                       REQUEST ID
M1EQEXID DS    A                       EXIT ID
M1EQTASK DS    A                       TASK ID
M1EQNAME DS    CL44                    NAME
M1EQFL   FLAG  ,
         FLAG  M1EQWAIT                WAIT MODE
         FLAG  M1EQSHR                 SHARE MODE
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*   @M1EQHLT - Mode 1 Enqueue/Dequeue halt parameters             *
*                                                                 *
*******************************************************************
         SPACE
@M1EQHLT RECORD BEGIN
@M1EHDEV DS    A                       ENQUEUE ID
         END   ,
         SPACE 3
*
*  @M1EIOCP -- This area maps the parm area of the Enqueue
*              I/O complete exit.
*
         SPACE
@M1EIOCP RECORD BEGIN
@M1EICRQ DS    A             Request ID
@M1EIR01 DS    A             Value of R1 to be returned to user
@M1EIR14 DS    A             Value of R14 to be returned to user
@M1EIR15 DS    A             Value of R15 to be returned to user
*
@M1EINRV EQU   X'80'         Value should not be returned
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   M1ENQTAB - Mode 1 Enqueue/Dequeue Translate table             *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
M1ENQTAB DC    256X'04'
         ORG   M1ENQTAB+C'.'
         DC    X'00'
         ORG   M1ENQTAB+C'A'
         DC    9X'00'
         ORG   M1ENQTAB+C'J'
         DC    9X'00'
         ORG   M1ENQTAB+C'S'
         DC    8X'00'
         ORG   M1ENQTAB+C'0'
         DC    10X'00'
         ORG   ,
         SPACE 3
*
*  REQUEUE RETURN CODE TRANSLATION
*
REQTAB   DC    A(-4)                   REQUEUE CODE 4
         DC    A(4)                    REQUEUE CODE 8
         DC    A(8)                    REQUEUE CODE 12
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    M1ENQ  - Mode 1 ENQUEUE/DEQUEUE SVC                          *
*                                                                 *
*                                                                 *
*     Input - RY Points to SCP                                    *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1ENQ    PROC  ,SCOPE=LOCAL
         WITH  (SCP,RY)
         LH    RX,SCPQIDT              IDT NUMBER
         DECR  RX
         MH    RX,=Y(L'IDT)
         AL    RX,SCPIDT               IDT VIRTUAL ADDDRESS
         WITH  (IDT,RX)
*
*  IDT IN USE - RETURN ERROR
*
         IF    (IDTFA+IDTFACL,NZ),BEGIN
         MVI   SCPPANSY,PANWAIT        RE-USING IDT
         SET   SCBXP                   ENTER PANIC EXIT
         EXIT  M1ENQ
         END   ,
*
*  VALIDATE NAME LENGTH
*
         L     RB,SCPGPRS+15*4         USER SUPPLIED NAME LENGTH
         IF    ('LPR  RB,RB',NZ),BEGIN
         IF    (RB,GT,L'M1EQNAME-4),BEGIN   NAME TOO LONG
         LH    R15,=Y(-8)
         ST    R15,SCPGPRS+15*4        NAME ERROR CODE
         EXIT  M1ENQ
         END   ,
         EJECT
*
*  Check user name area
*
         PSET  @PAGE
         L     RA,SCPGPRS+1*4          LOCATION
         LPR   RA,RA
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N RA,=X"00FFFFFF"'
         ST    RA,@PAGLOC               SET
         ST    RB,@PAGLEN              LENGTH
         MVC   @PAGKEY,SCPPSW+1        PSW KEY
         NI    @PAGKEY,X'F0'            KEY ONLY
         VCALL PAGTPROT                CHECK IT OUT
         IF    (RVR,GE,2),BEGIN        NO GOOD
         MVI   SCPPANSY,PANSPEC
         SET   SCBXP
         EXIT  M1ENQ
         END   ,
*
*  CHECK NAME
*
         LR    RS,RB
         DEX   RS,'TRT  @RA(0),M1ENQTAB'
         IF    NZ,BEGIN                NO GOOD
         LH    R15,=Y(-8)
         ST    R15,SCPGPRS+15*4        NAME ERROR CODE
         EXIT  M1ENQ
         END   ,
         END   ,
*
*  NAME NOT SUPPLIED - ONLY VALID FOR CLP DEQUEUES
*
         ELSE  BEGIN
         IF    (SCBFCLP,AND,('LT  R14,SCPGPRS+14*4',NZ)),EXIT
         MVI   SCPPANSY,PANSPEC
         SET   SCBXP
         EXIT  M1ENQ
         END   ,
*
*  PARAMETERS ARE OTAY SPANKY - INITIALIZE IDT
*
         IF    SCBFCLP,'SET  IDTFACL'  MARK IN USE
         ELSE  'SET  IDTFA'
         SET   IDTCENQ                 SET CLASS
         SET   IDTFFIDT                FREE IDT AT POST
         EJECT
*
*  DETERMINE STATUS WITH TEST MODE ENQUEUE
*
         IF    (RB,NZ),BEGIN
         PSET  @ENQUEUE
         MVC   @ENQQNM,=CL8'ENQ/DEQ'   QUEUE NAME
         MVC   @ENQRNM,=CL44'ENQ.'     RESET NAME FIELD
         DEX   RB,'MVC  @ENQRNM+4(0),@RA'    RESOURCE NAME
         SET   @ENQTEST
         VCALL ENQUEUE
         END   ,
         ELSE  'L  RVR,SCPGPRS+1*4'    ENQUEUE ID
*
*  DEQUEUE REQUEST - REMOVE ENTRY FROM SLOT TABLE
*
         IF    ('LT  R14,SCPGPRS+14*4',P),BEGIN
         IF    (RVR,NZ),BEGIN
         LH    RS,SCPNENQ              NUMBER OF ENQUEUE SLOTS
         L     RA,SCPENQL              SLOT AREA
         LOOP  BEGIN
         IF    (RVR,EQ,@RA),EXIT       FOUND THE SLOT
         DECR  RS
         IF    (RS,Z),'ABORT ENQSLOT'
         LA    RA,@RA+4                TO NEXT SLOT
         END   ,                       DO THEM ALL
         CLEAR (@RA,4)                 CLEAR THE SLOT
*
*  WE HAVE ENQUEUE ID - CALL RESMAN DIRECTLY
*
         PSET  @DEQUEUE
         ST    RVR,@DEQID              TO ID FIELD
         VCALL DEQUEUE
         END   ,
         ELSE  'LA  RVR,4'             NOT OWNED TO DEQUEUE
*
*  SET DEQUEUE WAIT RETURNS
*
         ST    RVR,IDTR15              RETURN CODE
         SET   IDTFR15                 R15 HAS VALUE
         SET   IDTFPOST                REQUEST COMPLETE
         END   ,
         EJECT
*
*  PROCESS MODE TEST WAIT RETURNS
*
         ELSEIF  ('LT  R15,SCPGPRS+15*4',M),BEGIN
         PSET  @ENQUEUE,CLEAR=NO       FOR ADDRESSIBILITY ONLY
         IF    (RVR,Z),'LA  R15,8'     NOT OWNED
         ELSE  BEGIN
         CLEAR R15                     ASSUME OWNED EXCLUSIVELY
         IF    @ENQSHR,'LA  R15,4'     OWNED SHARED
         END   ,
         ST    R15,IDTR15              RETURN CODE
         SET   IDTFR15                 R15 HAS VALUE
         SET   IDTFPOST                REQUEST COMPLETE
         END   ,
*
*  ENQUEUE OR REQUEUE REQUEST
*
M1ELOOP  ELSE  BEGIN
*
*  RESOURCE NAME ALREADY ENQUEUED
*
         IF    ('LTR  RK,RVR',NZ),BEGIN
         L     R15,SCPGPRS+1*4         REG 1 COMPLEMENTED IF SHARE
         IF    ((@ENQSHR,AND,(R15,M)),OR,(^@ENQSHR,AND,(R15,NM))),BEGIN
         LA    R15,4                   OWNED AS REQUESTED
         ST    R15,IDTR15               FOR WAIT
         SET   IDTFR15
         SET   IDTFPOST                REQUEST COMPLETE
         EXIT  M1ELOOP
         END   ,
         EJECT
*
*  FIND SLOT TABLE ENTRY
*
         LH    RS,SCPNENQ              NUMBER OF ENQUEUE SLOTS
         L     RA,SCPENQL              SLOT AREA
         LOOP  BEGIN
         IF    (RK,EQ,@RA),EXIT        FOUND THE SLOT
         DECR  RS
         IF    (RS,Z),'ABORT EQSLTERR'
         LA    RA,@RA+4                TO NEXT SLOT
         END   ,                       DO THEM ALL
         END   ,
*
*  NAME NOT YET IN TABLE - FIND AN AVAILABLE SLOT
*
         ELSE  BEGIN
         LH    RS,SCPNENQ              NUMBER OF ENQUEUE SLOTS
         L     RA,SCPENQL              SLOT AREA
         LOOP  BEGIN
         IF    ('LT  R15,@RA',Z),EXIT    FOUND A SLOT
         DECR  RS
         LA    RA,@RA+4                TO NEXT SLOT
         IF    (RS,P),NEXT             DO THEM ALL
*
*  NO SLOT AVAILABLE - SET UP ERROR RETURN
*
         LA    RS,12                   RETURN CODE
         ST    RS,IDTR15               TO IDT
         SET   IDTFR15
         SET   IDTFPOST                MARK POSTED
         EXIT  M1ELOOP                  AND EXIT
         END   ,
         END   ,
         EJECT
*
*  SET UP ENQUEUE TASK PARAMETERS
*
         VMGET L'M1ENQPRM,LOC=LOCSYS
         IF    ('LTR  RJ,RVR',Z),'ABORT ENQMEM'
         WITH  (M1ENQPRM,RJ)
         ST    RJ,IDTDEVID             PARM AREA IS DEVICE ID
         CLEAR M1ENQPRM
         ST    RX,M1EQRQID             IDT IS REQUEST ID
         ST    RA,M1EQSLOT             SET SLOT LOCATION
         MVC   M1EQEXID,SCPEPXIT       SET EXIT ID
*
*  R0 COMPLEMENTED IF MODE WAIT
*
         L     R15,SCPGPRS+0*4         USER "DEVICE TYPE"
         IF    (R15,M),'SET  M1EQWAIT'   SET WAIT MODE
*
*  R1 COMPLEMENTED IF MODE SHARE
*
         IF    ('LT  R14,SCPGPRS+1*4',M),BEGIN   USER NAME LOCATION
         LPR   R14,R14                 SET LOCATION VALUE POSITIVE
         SET   M1EQSHR                 NOTE SHARE MODE
         END   ,
         TM    SCPPSW+4,X'80'      31 bit mode?
         IF    Z,'N R14,=X"00FFFFFF"'
         EJECT
*
*  MOVE NAME TO WORK AREA
*
         IF    (RK,Z),BEGIN
         L     R15,SCPGPRS+15*4        USER SUPPLIED NAME LENGTH
         LPR   R15,R15                 MAKE POSITIVE
         MVC   M1EQNAME,=CL44'ENQ.'    RESET NAME FIELD
         DEX   R15,'MVC  M1EQNAME+4(0),@R14'    RESOURCE NAME
         END   ,
*
*  PROVIDE ENQUEUE ID FOR REQUEUE
*
         ELSE  'ST  RK,M1EQID'
*
*  REQUEUE OR ENQUEUE RESOURCE AS REQUESTED
*
         WITH  (M1ENQPRM,RJ)
         MVC   M1EQTASK,PZCURTSK       COPY TASK ID
         PSET  @TCREATE
         ST    RJ,@TCRPARM             M1ENQPRM IS PARAMETER
         LA    RS,1                    TASK PRIORITY
         ST    RS,@TCRPRIO              IS JUST ABOVE CALLER
         MVC   @TCRPSW(4),=X'070C0000'  SET PSW
         MVC   @TCRPSW+4(4),=A(M1ENQTSK+X'80000000')
         SET   @TCRFSTK                GIVE HIM A STACK
         VCALL TCREATE                 CREATE THE TASK
         END   ,
*
*  SET SVC RETURNS
*
         LC    R15,IDTID               GET ID NUMBER
         ST    R15,SCPGPRS+0*4         SAVE ID NUMBER FOR USER
         CLEAR R15                     SET SVC RETURN
         ST    R15,SCPGPRS+15*4         CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1ENQHLT - Mode 1 Enqueue/Dequeue halt processing            *
*                                                                 *
*                                                                 *
*     Input -  @M1EQHLT                                           *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1ENQHLT PROC  @M1EQHLT,SCOPE=LOCAL
         L     RJ,@M1EHDEV             M1ENQPRM IS DEVICE ID
         WITH  (M1ENQPRM,RJ)
         PSET  @ENQHALT
         MVC   @EQHQNM,=CL8'ENQ/DEQ'   QUEUE NAME
         MVC   @EQHRNM,M1EQNAME        RESOURCE NAME
         VCALL ENQHALT                 STOP THE MUSIC
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1ENQTSK - Mode 1 Enqueue/Dequeue wait task                  *
*                                                                 *
*                                                                 *
*     Input -  @TENTRY                                            *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
M1ENQTSK PROC  @TENTRY,SCOPE=LOCAL
         L     RK,@TEPARM              PARM IS IDT POINTER
         WITH  (M1ENQPRM,RK)
*
*  IF ENQUEUE ID SUPPLIED ASSUME WE HAVE A REQUEUE
*
         IF    ('LT  RS,M1EQID',NZ),BEGIN
         PSET  @REQUEUE
         ST    RS,@REQID               ENQID
         IF    M1EQSHR,'SET  @REQSHR'   MARK SHARED
         IF    M1EQWAIT,'SET  @REQSUSP'   MARK WAIT
         VCALL REQUEUE
*
*  SET RETURNS
*
         IF    ('LTR  RA,RVR',NZ),BEGIN    ERROR RETURN
         L     RA,REQTAB-4(RA)         GET USER RETURN CODE
         END   ,
         END   ,
         EJECT
*
*  WE HAVE AN ENQUEUE
*
         ELSE  BEGIN
         PSET  @ENQUEUE
         MVC   @ENQQNM,=CL8'ENQ/DEQ'   QUEUE NAME
         MVC   @ENQRNM,M1EQNAME        RESOURCE NAME
         IF    M1EQSHR,'SET  @ENQSHR'   MARK SHARED
         IF    M1EQWAIT,'SET  @ENQSUSP'   MARK WAIT
         VCALL ENQUEUE
*
*  SET RETURNS
*
         IF    (RVR,NZ),BEGIN          GOOD RETURN
         L     RS,M1EQSLOT             GET SLOT POINTER
         ST    RVR,@RS                 SAVE ENQ ID
         CLEAR RA
         END   ,
         ELSE  'LA  RA,8'              ERROR RETURN
         END   ,
         EJECT
*
*  ENTER I/O POST
*
         PSET  @XITDO
         MVC   @XITRQID,M1EQEXID       SET EXIT ID
         MVC   @XITTSK,M1EQTASK        COPY TASK ID
         MVI   @XITTYPE,XITTIOCN       EXIT TYPE IS I/O
         WITH  (@M1EIOCP,@XITPARM)
         MVC   @M1EICRQ,M1EQRQID       REQUEST ID
         ST    RA,@M1EIR15             RETURN CODE
         MVC   @M1EIR01,=X'80000000'   NO RETURN IN R1
         MVC   @M1EIR14,=X'80000000'   NO RETURN IN R14
         VCALL XITDO
         VMFREE L'M1ENQPRM,A=(RK),LOC=LOCSYS
         IF    (RVR,NZ),'ABORT FREEMEQP'
         EJECT
*
*  RETURN TO DISPATCHER
*
         PSET  @TEXIT
         VCALL TEXIT                   RETURN TO DISPATCHER
         PEND
         TITLE 'ORVYL''S Mode 1 Compatibility Routines'
*******************************************************************
*                                                                 *
*    @TOD -  Mode 1 Time conversion                               *
*                                                                 *
*******************************************************************
         SPACE
@TOD     RECORD BEGIN
@TODCLK  DS    D                       STORE CLOCK VALUE
@TODTIM  DS    D                       TIME IN CLOCK UNITS
@TODDAT  DS    A                       DATE IN YYYYDDMM FORM
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    TODWRK - Time conversion work area                           *
*                                                                 *
*******************************************************************
         SPACE
TODWRK   RECORD BEGIN
TWCVD    DS    D                       CONVERT TO BINARY AREA
TWCLK    DS    D                       STORE CLOCK AREA
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*      Time conversion constants                                  *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
DAYTAB   DC    H'31,29,31,30,31,30,31,31,30,31,30,31'
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SENSETD - Calculate time and date                            *
*                                                                 *
*                                                                 *
*     Input - @TODCLK                                             *
*                                                                 *
*                                                                 *
*    Output - @TODTIM  Time in clock units since midnight         *
*             @TODDAT  Date in "yyyymmdd" format                  *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SENSETD  PROC  @TOD,TODWRK,SCOPE=LOCAL
         LM    RA,RB,@TODCLK           GET SUPPLIED CLOCK
         IF    ((RA,Z),AND,(RB,Z)),BEGIN
         STCK  TWCLK                 GET CURRENT TIME
         LM    RA,RB,TWCLK
         ADL   RA,PZTZOFF            ADD TIME ZONE OFFSET
         END   ,
*
*  FIRST COMPUTE TIME
*
         SRDL  RA,12+6                 .000001*64 OF A SEC
         D     RA,=A(1000000/64*60*60*24)  ONE DAY
         LA    RS,@RB+1                NO. OF DAYS SINCE 1900
         LR    RB,RA                   .000001*64 SEC SINCE MIDNIGHT
         CLEAR RA
         SLDL  RA,12+6                 BACK TO CLOCK FORMAT
         STM   RA,RB,@TODTIM
         EJECT
*
*  THEN COMPUTE YEAR
*
         CLEAR RA
         LR    RB,RS
         M     RA,=A(100)
         D     RA,=A(36525)            DAYS/365.25 = YEARS
         A     RB,=A(1900)             YEAR 19YY
         CVD   RB,TWCVD                 TO DECIMAL
         L     RS,TWCVD+4              GET RESULT
         SRL   RS,4                    REMOVE SIGN NIBBLE
         STH   RS,@TODDAT              AND SET
*
*  NOW COMPUTE JULIAN DATE WITH LEAP YEAR FACTOR
*
         LR    RB,RA
         CLEAR RA
         D     RA,=A(100)              DAYS IN THIS YEAR (REL ZERO)
         INCR  RB                      FORM "DDD"
         IF    (RB,GT,59),BEGIN
         IF    ((@TODDAT+1.X'01',Z),AND,(@TODDAT+1.X'12',NM)),EXIT
         INCR  RB
         END
*
*  NOW COMPUTE MONTH AND DATE
*
         LA    RS,DAYTAB               DAYS PER MONTH TABLE
         LA    R15,12
         CLEAR RA                      MONTH COUNTER
         LOOP  BEGIN
         INCR  RA                      BUMP MONTH
         IF    ('CH  RB,@RS',LE),EXIT  FOUND THE MONTH
         SH    RB,@RS                  TRY NEXT
         LA    RS,@RS+2
         DECR  R15
         UNTIL (R15,Z),END
         CVD   RA,TWCVD                CONVERT MONTH
         L     RS,TWCVD+4              GET RESULT
         SRL   RS,4                    REMOVE SIGN NIBBLE
         STC   RS,@TODDAT+2             AND SET
         CVD   RB,TWCVD                CONVERT DAY
         L     RS,TWCVD+4              GET RESULT
         SRL   RS,4                    REMOVE SIGN NIBBLE
         STC   RS,@TODDAT+3             AND SET
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SENSETD2 - Calculate time and date                            *
*                                                                 *
*                                                                 *
*     Input - @TODCLK                                             *
*                                                                 *
*                                                                 *
*    Output - @TODTIM  Time in .01 sec units since midnight       *
*             @TODDAT  Date in "00yydddf" packed decimal format   *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SENSETD2 PROC  @TOD,TODWRK,SCOPE=LOCAL
         LM    RA,RB,@TODCLK           GET SUPPLIED CLOCK
         IF    ((RA,Z),AND,(RB,Z)),BEGIN
         STCK  TWCLK                 GET CURRENT TIME
         LM    RA,RB,TWCLK
         ADL   RA,PZTZOFF            ADD TIME ZONE OFFSET
         END   ,
*
*  FIRST COMPUTE TIME
*
         SRDL  RA,12+6                 .000001*64 OF A SEC
         D     RA,=A(1000000/64*60*60*24)  ONE DAY
         LA    RS,@RB+1                NO. OF DAYS SINCE 1900
         LR    RB,RA                   .000001*64 SEC SINCE MIDNIGHT
         CLEAR RA
         SLDL  RA,6                    .000001 secs since midnight
         D     RA,=A(10000)            Convert to .01 secs
         ST    RB,@TODTIM
         EJECT
*
*  THEN COMPUTE YEAR
*
         CLEAR RA
         LR    RB,RS
         M     RA,=A(100)
         D     RA,=A(36525)            DAYS/365.25 = YEARS
         LR    RS,RB                   YEAR
         MH    RS,=H'1000'             Times 1000
*
*  NOW COMPUTE JULIAN DATE
*
         LR    RB,RA
         CLEAR RA
         D     RA,=A(100)              DAYS IN THIS YEAR (REL ZERO)
         LA    RS,@RB+1(RS)            FORM "YYDDD"
         CVD   RS,TWCVD                CONVERT DAY TO DECIMAL
         MVC   @TODDAT,TWCVD+4          AND SET
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1TIME  - Mode 1 time/date routine for I/O SVCs              *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
M1TIME   PROC  SCOPE=GLOBAL
         PSET  @TOD
         ACALL SENSETD
         LM    RA,RB,@TODTIM           TIME OF DAY
         D     RA,=A(10000*4096)       TO .01 SEC UNITS
         IF    (RA,GE,20480000),'INCR  RB'  ROUND
         LR    R0,RB                   RETURN TIME OF DAY
         L     RS,@TODDAT              GET DATE
         ST    RS,@R12+8                AND RETURN
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    M1GOWAIT - Suspend this task for the specified number of     *
*               seconds                                           *
*                                                                 *
*     Input - R0 = number of 0.1 second intervals                 *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
M1GOWAIT PROC  SCOPE=GLOBAL
         WITH  (SBWAIT,RY)
         WITH  (SLDUM,RM)
         L     RJ,PZCURASB         CURRENT ASB
         WITH  (ASB,RJ),'L RJ,ASBM1SCP' SCP POINTER
         WITH  (SCP,RJ)

         IF    (R0,NP),'EXIT M1GOWAIT' Hope we're not late!
         LR    RN,R0               Save number of seconds
         LA    R0,4                Can't do multiple times
         IF    ((RJ,NZ),AND,(SCBWAITB,NZ)),'EXIT M1GOWAIT'

         L     RS,MATPTR           Get a wait block
         WITH  (MAT,RS),'L RM,MATSBWB'
         SAVAIL HEAD=SLDUM,LEN=L'SBWAIT Get a wait block
         LR    RY,RVR              Set pointer
         CLEAR SBWAIT
         MVC   SBWBID,=CL4'FIRE'
         MVC   SBWASB,PZCURASB

         PSET  @XITNEW             Get exit request ID
         VCALL XITNEW
         LR    RX,RVR

         PSET  @EXRADD             Define routine for timer fire
         WITH  (XITMSKD,@EXRTYPE)
         SET   XITMRTC             Set type of real-time-timer
         MVC   @EXRPSW(4),=X'070C0000' PSW
         MVC   @EXRPSW+4(4),=A(M1GOFIRE+X'80000000')
         ST    RY,@EXRPARM         Wait buffer is the parameter
         SET   @EXRAFS
         VCALL EXRADD
         LR    RA,RVR              Save exit routine ID

         PSET  @XITMASK            Enable exit type
         WITH  (XITMSKD,@XITMSK)
         SET   XITMRTC
         VCALL XITMASK
         LR    RB,RVR              Save prev exit mask

         LM    R0,R1,=FL8S12E5'1'  Get 0.1 second
         MR    R0,RN               Calc number of seconds TOD format

         PSET  @RTSET              Set real time timer
         STM   R0,R1,@RTSCLK       Set time to wait
         SET   @RTSFINT            Indicate interval timer
         PMOV  @RTSXIT,(RX)        Exit ID
         PMOV  @RTSPARM,LA:SBWAIT,LEFTADJ=YES Wake this one
         VCALL RTSET
         LR    RK,RVR              Save ID
         IF    (RJ,NZ),'ST RY,SCBWAITB' Save wait block

         AWAIT SBWECB,LEN=LONG     Wait as long as necessary
         IF    (RJ,NZ),'CLEAR SCBWAITB'
         PSET  @SYSRDEL            Release system routine ID
         PMOV  @SYSRDID,(RVR)
         VCALL SYSRDEL

         IF    (SBWORD1,NZ),BEGIN  Posted early by logoff
         PSET  @RTCNCK
         PMOV  @RTCID,(RK)             CLOCK ID
         VCALL RTCAN               Cancel timer
         END   ,

         CLEAR SBWAIT
         MVC   SBWBID,=C'sBWB'
         SPUSH HEAD=SLDUM,ITEM=SBWAIT Put away the wait block

         PSET  @XITDEL             Delete exit request ID
         PMOV  @XITDID,(RX)
         VCALL XITDEL
         PSET  @XITMASK            Reinstate previous exit levels
         PMOV  @XITMSK,(RB)
         SET   @XITMSS             Set this mode
         VCALL XITMASK
         PSET  @EXRDEL             Free exit routine definition
         PMOV  @EXRDID,(RA)
         VCALL EXRDEL

         CLEAR RVR
         PEND  ,
         EJECT ,
********************************************************************
*  Exit routine for timer                                          *
*                                                                  *
*   Input - 1st parm from when the timer was set = wait block      *
*                                                                  *
*  Output - none                                                   *
*                                                                  *
********************************************************************
M1GOFIRE PROC  @XITDATA
         L     RM,@XITDSA
         WITH  (XITSAREA,RM)
         WITH  (RTEXIT,XITSXPRM)
         WITH  (SBWAIT,RN)
         L     RN,RTXPARM

         CLC   SBWBID,=CL4'FIRE'
         IF    NE,'ABORT NOSMOKE'
         PSET  @SYSRNEW            Get system routine ID
         VCALL SYSRNEW
         LR    R15,RVR
         SIGNL SBWECB,(R15),SBWASB,(R15) Been waiting long?

         PSET  @EXRDONE            Set this exit as done
         SET   @EXRDFIN
         VCALL EXRDONE

         PEND  CODE=NO

M1CANWAI PROC  SCOPE=GLOBAL            Cancel waiting
         L     RY,PZCURASB             CURRENT ASB
         WITH  (ASB,RY),'L RY,ASBM1SCP' SCP POINTER
         WITH  (SCP,RY)
         IF    ('LT RN,SCBWAITB',NZ),BEGIN
         WITH  (SBWAIT,RN)
         MVI   SBWORD1,255             Indicate early
         PSET  @SYSRNEW                Get system routine ID
         VCALL SYSRNEW
         LR    R15,RVR
         SIGNL SBWECB,(R15),SBWASB,(R15) Been waiting long?
         END   ,
         PEND  ,
         EJECT
*******************************************************************
*                                                                 *
*    M1GOSTAT - Mode 1 service to set ORVYL ready in SCIPCVT      *
*                                                                 *
*                                                                 *
*     Input - R0 = 0  Mark ORVYL ready                            *
*             R0 = 4  Mark ORVYL unavailable                      *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
M1GOSTAT PROC  SCOPE=GLOBAL
*
*  GET POINTER TO CT
*
         L     RA,MATPTR                MAT POINTER
         WITH  (MAT,RA)
         IF    (MATSNAME,EQ,'ORVYL'),BEGIN  Only production...
         L     R14,MATM1CT              CT POINTER
         WITH  (M1CT,R14),'L  R14,CTSCVT'   "SCIP" CVT POINTER
         IF    (R14,Z),EXIT             NONE THERE
         WITH  (SCVT,R14),'LA  R14,SCVHSPFL'   FLAG BYTE ADDRESS
         LA    RB,1                    NUMBER OF BYTES TO MODIFY
         IF    (RVR,Z),BEGIN           ORVYL UP AND READY
         LA    RA,=AL1(HSPFORV)        ORVYL (FILES) AVAILABLE
         IF    ((MATSNAME,EQ,'ORVYLRLG'),OR,(MATSNAME,EQ,'ORVYLB')),   *
               'LA  RA,=AL1(HSPFORV+HSPFORVR)'
         LA    R15,1*256               "OR" OPERATION
         END   ,
         ELSE  BEGIN
         LA    RA,=AL1(255-HSPFORV)    ORVYL (FILES) UNAVAILABLE
         IF    ((MATSNAME,EQ,'ORVYLRLG'),OR,(MATSNAME,EQ,'ORVYLB')),   *
               'LA  RA,=AL1(255-(HSPFORV+HSPFORVR))'
         LA    R15,2*256               "AND" OPERATION
         END   ,
         SYSCTL RA,R14,TYPE=MVSMWR     SET THE FLAGS
         END   ,
         CLEAR RVR                     RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    VWTO  - Mode 1 WTO routine for I/O SVCs                      *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
         ENTRY VWTO
VWTO     LR    RAR,R9
         BASE  EPAR
         LA    EPAR,M1GOVWTO           SET ENTRY REGISTER
         BR    EPAR                    AND GO
M1GOVWTO PROC  SCOPE=LOCAL,BCH=NO
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    VENQ - Mode 1 MVS ENQUEUE/DEQUEUE routine                    *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
         ENTRY VENQ
VENQ     LR    RAR,R9
         BASE  EPAR
         LA    EPAR,M1GOVENQ           SET ENTRY REGISTER
         BR    EPAR                    AND GO
M1GOVENQ PROC  SCOPE=LOCAL,BCH=NO
         PEND
         EJECT
         XTRCDATA
         LTORG
         END   .
