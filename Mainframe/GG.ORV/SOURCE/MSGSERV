MSGSERV  TITLE 'ORVYL''S Message Services'
         COPY  HEADER
MSGSERV  MODULE
         EJECT
         COPY  RTCB
         USING RTCB,RTCBR
         EJECT
         COPY  CBAT
         EJECT
         COPY  LOCKPARM      GET LOCK PARMS
         COPY  MSGPARM       GET MSG PARMS
         COPY  POOLPARM      GET OS MEMORY PARMS
         SPACE 2
         COPY  MEMPARM       GET ORVYL MEMORY PARMS
         EJECT ,
         COPY  POSTPARM
         COPY  WAITPARM
         EJECT
LOCKCT   RECORD BEGIN
*
* Lock manager CT -- Pointed to by everyone's RTCB
*
         DS    CL4'LKCT'
LOCKHEAD DS    A             Pointer to the chain of locks
LOCKECNT DS    A             Number of lock elements/lock
         END   ,
         SPACE 2
LOCKCB   RECORD BEGIN
*
* Lock Control Block
*
         DC    CL4'LOCK'     Control block id
LOCKNAME DS    CL16          Name of this lock
LOCKCHN  DS    A             Pointer to LOCKCB chain
         DS    0D
LOCKFREE DS    A             Queue of free LQE's
         DS    A             Control word for free queue
LOCKPLUM DS    A             Pointer to the 'plum' LQE
LOCKOWNR DS    A             Lock owner's LQE address
LOCKECHN DS    A             Chain of all LQE's for this lock
LOCKWCNT DS    A             Count of waits
LOCKRCNT DS    A             Count of requests
         END   ,
         SPACE 2
LQE      RECORD BEGIN
*
* Lock Queue Element
*
         DC    CL4'LQE'      Control block id
LQENEXT  DS    A             Next on free queue/Element to post
LQECHAIN DS    A             Chain of all LQES for a lock
LQELOCK  DS    A             Pointer to the LOCKCB for the lock
LQERTCB  DS    A             Owner RTCB/Zero if free
LQEECB   DS    A             Syncronization word
         END   ,
         EJECT ,
MCCT     RECORD BEGIN
*
* Message manager CT
*
         DC    CL4'MCCT'
MCCTMCCB DS    A             Chain of all MCCB's in the system
MCCTLOCK DS    A             Lock of MCCT (including MCCB chain)
         END   ,
         SPACE ,
MCCB     RECORD BEGIN
*
* Message Channel Control Block.  Contains info on one message
* channel.
*
         DC    CL4'MCCB'     Control block id
MCCBNEXT DS    A             Chain of MCCBs in the system
MCCBNAME DS    CL8           Channel name
MCCBMBCT DS    A             Max number of buffers per requestor
MCCBSERV DS    A             Chain of servers attached (SCCBs)
MCCBRQST DS    A             Chain of requestors attached (RCCB's)
MCCBQLCK DS    A             Lock for this channel's message queue
MCCBMLCK DS    A             Lock for the MCCB other than message Q
MCCBMBH  DS    A             Head of list of msgs for servers
MCCBSEQ  DS    A             Message sequence numbers
         END   ,
         SPACE ,
SCCB     RECORD BEGIN
*
* Server Channel Control Block.  Contains info about each server
* attached to a message channel.
*
         DC    CL4'SCCB'     Control block id
SCCBNEXT DS    A             Chain of the SCCB's off the MCCB
SCCBLOCK DS    A             Lock for this end of the channel
SCCBMCCB DS    A             Address of the MCCB
SCCBRTCB DS    A             Address of the RTCB
SCCBECB  DS    A             ECB for this end of the channel
SCCBCANH DS    A             Head of chain of cancel requests
SCCBCANT DS    A             Tail of chain of cancel requests
SCCBNRCV DS    A             Count of buffers received here
         END   ,
         SPACE ,
RCCB     RECORD BEGIN
*
* Requestor Channel Control Block. Contains info about each
* requestor attached to a message channel.
*
         DC    CL4'RCCB'     Control block id
RCCBNEXT DS    A             Chain of the RCCB's off the MCCB
RCCBMCCB DS    A             Address of the MCCB
RCCBRTCB DS    A             Address of the RTCB
RCCBLOCK DS    A             Address of lock
RCCBMBH  DS    A             Pointer to first in list of messages
RCCBMBT  DS    A             Pointer to the last in msg list
RCCBMBCH DS    A             Chain of all messages originating here
RCCBMBCT DS    A             Count of additional messages allowed
RCCBECB  DS    A             ECB for this end of the channel
RCCBNREQ DS    A             Count of messages sent
         END   ,
         EJECT ,
MSGBUF   RECORD BEGIN
*
* This dsect describes the header on a message buffer.  This header
* contains information to enable the message manager to transmit
* information reliably between tasks.
*
         DC    CL4'MSGB'     Control block id
MSGBNEXT DS    A             Next MSGB in Receive/reply chain
MSGBCHN  DS    A             Next MSGB for this requestor
MSGBPEND DS    A             Pointer to last MSGB at this priority
MSGBRCCB DS    A             Pointer to the owning RCCB
MSGBSCCB DS    A             Pointer to the SCCB of processing server
MSGBFLGS FLAG  ,                    Flags
         FLAG  MSGBCAN                 Message has been cancelled
*
MSGBSTAT FLAG  ,                    Status
         FLAG  (MSGBALOC,0,EQ)         Allocated
         FLAG  (MSGBSENT,1,EQ)         Waiting for a server
         FLAG  (MSGBRCVD,2,EQ)         Being processed by server
         FLAG  (MSGBREPL,3,EQ)         Reply for requestor
         FLAG  (MSGBDONE,4,EQ)         Being processed by requestor
MSGBLEN  DS    H
MSGBPRIO DS    A             Priority of this message
MSGBRVAL DS    A             Value set by reqestor
MSGBSEQ  DS    A             Sequence number of this message
MSGBDATA DS    0D            Start of the user data
         END   ,
         SPACE ,
CANREQ   RECORD BEGIN
*
* Message cancel request.  These are queued up for the server to
* indicate to him that he should cancel a previously received
* request.
*
         DS    CL4'CANR'
CANRNEXT DS    A             Next cancel request in the chain
CANRSEQ  DS    A             Sequence number of the msg to cancel
CANRBUF  DS    A             Address of the buffer
         END   ,
         EJECT ,
*******************************************************************
*                                                                 *
*   LOCKCRE - Create a lock.                                      *
*                                                                 *
*     Input - @LOCKCRE                                            *
*                                                                 *
*    Output - Returns a 32 bit lock id.                           *
*                                                                 *
*******************************************************************
         SPACE 3
LOCKCRE  PROC  @LOCKCRE,SCOPE=GLOBAL
         L     RY,RTCBCBAT             Get the CBAT address
         WITH  (CBAT,RY),'L RY,CBATLOCK'    Get the LOCKCT
         USING LOCKCT,RY               address it
         POOLGET L'LOCKCB,TYPE=GLOBAL  Get space for the lock
         LR    RK,RVR
         USING LOCKCB,RK               and address it
         MVC   LOCKCB(4),=C'LOCK'      Move in the cb id
         MVC   LOCKNAME,@LOCKNAM       save the name
*
* Now allocate all the elements for the lock
*
         L     RB,LOCKECNT             Number of LQE's to get
         LA    RA,LOCKECHN-LQECHAIN+LQE
         USING LQE,RA
LQEGET   POOLGET L'LQE,TYPE=GLOBAL     Get memory for it
         ST    RVR,LQECHAIN            Link up all LQE's
         LR    RA,RVR                  Address the new one
         MVC   LQE(4),=CL4'LQE'        Move in the ID
         ST    RK,LQELOCK              Save ptr to LOCKCB
         BCT   RB,LQEGET               Continue till we get em all
*
* Have them all allocated.  Put one as the current and free the rest
*
         L     RA,LOCKECHN             Get first on the list
         FPOST LQEECB                  Signal the ECB
         ST    RA,LOCKPLUM             Save as the current
         MVC   LOCKFREE,LQECHAIN       Rest of chain is free
         WHILE ('LT RA,LQECHAIN',NZ),'MVC LQENEXT,LQECHAIN'
*
* Now all the elements are in place, put it on the chain
*
QLOCK    L     RJ,LOCKHEAD             Get head of the queue
         ST    RJ,LOCKCHN              Make this point to queue
         CS    RJ,RK,LOCKHEAD          Make header point to this
         IF    NZ,QLOCK
*
* Time to return to the user
*
         LR    RVR,RK                  Get the lock id (address)
         PEND
         DROP  RA,RK,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   LOCKOB  - Obtain a lock.                                      *
*                                                                 *
*     Input - @LOCKS                                              *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*******************************************************************
         SPACE 3
LOCKOB   PROC  @LOCKS,SCOPE=GLOBAL
         L     RY,@LOCKID              Get the lock id
         USING LOCKCB,RY
         IF    (LOCKCB,NE,'LOCK'),'KAPUT LOCKCB'
*
* First get an element off the free queue
*
         LM    RA,RB,LOCKFREE          Get first free and control
GETFE    WITH  (LQE,RA),'L RJ,LQENEXT' Next in the queue
         LA    RK,1
         AR    RK,RB                   Update the control word
         CDS   RA,RJ,LOCKFREE          Do the actual removal
         IF    NZ,GETFE
*
* Exchange the free one we just got with the 'plum'
*
         L     RB,LOCKPLUM             Get the current plum
NEWPLUM  CS    RB,RA,LOCKPLUM          And replace with our free
         IF    NZ,NEWPLUM
*
* Now we update our element
*
         USING LQE,RB                  Address it
         ST    RA,LQENEXT              Address of who we must signal
         ST    RTCBR,LQERTCB           Mark it as belonging to us
*
* Wait for the lock
*
         ST    RY,RTCBLKWT             Save info in the RTCB
         FWAIT LA:LQEECB               Wait for it
         CLEAR RTCBLKWT                Maintain info in in the RTCB
         INCR  RS,LOCKRCNT             Count the request
*
* When we we get the lock, mark the LOCKCB then return to the user
*
         ST    RB,LOCKOWNR             Mark us as the owner
         PEND                          Return to caller, lock held
         DROP  RB,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   LOCKREL - Release a lock.                                     *
*                                                                 *
*     Input - @LOCKS                                              *
*                                                                 *
*    Output - none                                                *
*                                                                 *
*******************************************************************
         SPACE 3
LOCKREL  PROC  @LOCKS,SCOPE=GLOBAL
*
* Get and validity check the parm and calling circumstances
*
         L     RY,@LOCKID              GET THE LOCK IDENTITY
         USING LOCKCB,RY
         LT    RA,LOCKOWNR             GET LQE ID OF OWNER
         IF    Z,'KAPUT BADTID'
         IF    (@RA,NE,'LQE '),'KAPUT BADTID'
         USING LQE,RA
         IF    (RTCBR,NE,LQERTCB),'KAPUT BADOWNR'
*
* Clean up info
*
         CLEAR LOCKOWNR                We no longer own this
         L     RX,LQENEXT              Get the fellow we must signal
         CLEAR LQERTCB                 We don't own this either
*
* Free our element
*
FRLQE    LM    RJ,RK,LOCKFREE          First on the free chain
         ST    RJ,LQENEXT              Update pointer
         LA    RB,1
         AR    RB,RK                   Update the control field
         CDS   RJ,RA,LOCKFREE          Free the LQE
         IF    NZ,FRLQE                Keep on trying
         DROP  RA
*
* Signal the next fellow
*
         USING LQE,RX                  Point at the next entry
         FPOST LQEECB                  Wake up the next chap.
         PEND  ,                       Return to caller
         DROP  RX,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   LOCKINIT - Initialize the Lock Manager                        *
*                                                                 *
*     Input - Init parm pointer                                   *
*                                                                 *
*    Output - none                                                *
*                                                                 *
*******************************************************************
         SPACE 3
LOCKINIT PROC  SCOPE=GLOBAL
*
* First thing we do is allocate the lockct
*
         POOLGET L'LOCKCT,TYPE=GLOBAL  Get the storage
         LR    RY,RVR                  Get its address
         USING LOCKCT,RY
         MVC   LOCKCT(4),=CL4'LKCT'    Control block id
         MVC   LOCKECNT,=A(40)         Default number of Elements
*
* GET PARMS
*
         L     RS,RTCBCBAT             Get the CBAT address
         WITH  (CBAT,RS),BEGIN
         ST    RY,CBATLOCK             Save our roots
         END   ,
         PEND  ,
         DROP  RY
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGINIT - Initializes the Message manager                     *
*                                                                 *
*     Input - Init parm pointer                                   *
*                                                                 *
*    Output - none                                                *
*                                                                 *
*******************************************************************
         SPACE 3
MSGINIT  PROC  SCOPE=GLOBAL
*
* First thing, allocate the message channel CT
*
         POOLGET L'MCCT,TYPE=GLOBAL    Get the memory
         LR    RY,RVR
         USING MCCT,RY                 Address it
         MVC   MCCT(4),=CL4'MCCT'      Move in the block id
*
* We have to have a lock for the queue of MCCB's
*
         PSET  @LOCKCRE                Address the parm area
         MVC   @LOCKNAM,=CL16'MCCT Mods'
         VCALL LOCKCRE
         ST    RVR,MCCTLOCK            Save the lock id
*
* Save the address of the MCCT
*
         L     RS,RTCBCBAT             Get the address of the CBAT
         WITH  (CBAT,RS),BEGIN
         ST    RY,CBATMSGS             Save the MCCT address
         END   ,
         PEND  ,
         DROP  RY
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGATTS - Attach a message channel as a server.               *
*                                                                 *
*     input - @MSGATTS                                            *
*                                                                 *
*    Output - Returns message channel id pointer (addr of SSCB)   *
*                                                                 *
*******************************************************************
         SPACE 3
MSGATTS  PROC  @MSGATT,SCOPE=GLOBAL
*
* Find the Corresponding MCCB
*
         PSET  @FMCCB
         MVC   FMCCBNAM,@MSGCNAM       move in the name
         LCALL FMCCB                   Find/create an MCCB
         LR    RY,RVR                  Get its address
         USING MCCB,RY                 And address it
*
* Allocate an SCCB and initialize it
*
         POOLGET L'SCCB,TYPE=GLOBAL    Get the memory
         LR    RX,RVR
         USING SCCB,RX
         MVC   SCCB(4),=CL4'SCCB'
         ST    RY,SCCBMCCB             Save the pointer to channel
         ST    RTCBR,SCCBRTCB          And to the owner
*
* Get the SCCB lock
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM(8),MCCBNAME    Use channel name
         MVC   @LOCKNAM+8(8),RTCBNAME  and the task name
         VCALL LOCKCRE
         ST    RVR,SCCBLOCK            Save the lock id
         LA    RVR,SCCBCANH-CANRNEXT+CANREQ      Empty queue value
         ST    RVR,SCCBCANT            Saved in the tail pointer
*
* Update the info in the MCCB
*
         LOCKOB MCCBMLCK               Get a lock on the mccb
*
         MVC   SCCBNEXT,MCCBSERV       Make this point at the chain
         ST    RX,MCCBSERV             And the head point at this
*
* If there are any buffers queued, this guy missed out on his
* post, so set him up with his ECB posted to start.
*
         IF    (MCCBMBH,NZ),BEGIN
         FPOST SCCBECB
         END   ,
*
         LOCKRL MCCBMLCK               Release the lock
*
* Return to the caller
*
         LA    RVR,SCCBECB             Get the ecb for this side
         ST    RVR,@MSGCECB            Tell the caller where it is
         LR    RVR,RX                  Give him the SCCB address
         PEND  ,
         DROP  RX,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGATTR - Attach a message channel as a requestor.            *
*                                                                 *
*     input - @MSGATTR                                            *
*                                                                 *
*    Output - Returns message channel id pointer (addr of RCCB)   *
*                                                                 *
*******************************************************************
         SPACE 3
MSGATTR  PROC  @MSGATT,SCOPE=GLOBAL
*
* Find the Corresponding MCCB
*
         PSET  @FMCCB
         MVC   FMCCBNAM,@MSGCNAM       move in the name
         LCALL FMCCB                   Find/create an MCCB
         LR    RY,RVR                  Get its address
         USING MCCB,RY                 And address it
*
* Allocate an RCCB and initialize it
*
         POOLGET L'RCCB,TYPE=GLOBAL    Get the memory
         LR    RX,RVR
         USING RCCB,RX
         MVC   RCCB(4),=CL4'RCCB'
         ST    RY,RCCBMCCB             Save the pointer to channel
         ST    RTCBR,RCCBRTCB          And to the owner
         MVC   RCCBMBCT,MCCBMBCT       Initial number of buffers
*
* We need a lock for this control block.
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM(8),MCCBNAME    Use the channel name
         MVC   @LOCKNAM+8(8),RTCBNAME  And the task name
         VCALL LOCKCRE                 Create the lock
         ST    RVR,RCCBLOCK            Save the lock id
         LA    RVR,RCCBMBH-MSGBNEXT+MSGBUF       Empty queue value
         ST    RVR,RCCBMBT             Saved in the tail pointer
*
* Update the info in the MCCB
*
         LOCKOB MCCBMLCK               Get a lock on the mccb
*
         MVC   RCCBNEXT,MCCBRQST       Make this point at the chain
         ST    RX,MCCBRQST             And the head point at this
*
         LOCKRL MCCBMLCK               Release the lock
*
* Return to the caller
*
         LA    RVR,RCCBECB             Get the ecb address
         ST    RVR,@MSGCECB            Return it to the caller
         LR    RVR,RX                  Give him the RCCB address
         PEND  ,
         DROP  RX,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   FMCCB   - Finds an MCCB and creates one if no match is found  *
*                                                                 *
*     Input - @FMCCB                                              *
*                                                                 *
*    Output - Returns pointer the MCCB.                           *
*                                                                 *
*******************************************************************
         SPACE 3
@FMCCB   RECORD BEGIN
FMCCBNAM DS    CL8           Name of the message channel
         END   ,
         SPACE 2
FMCCB    PROC  @FMCCB
*
* First get the address of the MCCT, then lock it.
*
         L     RY,RTCBCBAT             Get the CBAT address
         WITH  (CBAT,RY),'L RY,CBATMSGS'    Get MCCT Address
         USING MCCT,RY                 Address it
         LOCKOB MCCTLOCK               Lock that baby up
*
* Search for a match
*
         USING MCCB,RA
         L     RA,MCCTMCCB             Point at the chain
         WHILE (RA,NZ),BEGIN
         CLC   MCCBNAME,FMCCBNAM       This the one we want?
         IF    EQ,FNDMCCB              Yep.
         L     RA,MCCBNEXT             Point at the next in chain
         END   ,
*
* If we get here it means that the MCCB was not found...time to
* allocate one.
*
         POOLGET L'MCCB,TYPE=GLOBAL    Get the memory
         LR    RA,RVR                  Get the address
         MVC   MCCB(4),=CL4'MCCB'      Identify the control block
         MVC   MCCBNAME,FMCCBNAM       Save the
         MVC   MCCBMBCT,=A(1000)       **temp** Default # buffers
*
* Get a lock for this MCCB
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM(8),FMCCBNAM    Channel name
         MVC   @LOCKNAM+8(8),=CL8'--MCCB--'
         VCALL LOCKCRE
         ST    RVR,MCCBMLCK            Save the lock id
*
* And one for the message queue
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM(8),FMCCBNAM    Channel name
         MVC   @LOCKNAM+8(8),=CL8'--MSGQ--'
         VCALL LOCKCRE
         ST    RVR,MCCBQLCK            Save the lock id
*
         MVC   MCCBNEXT,MCCTMCCB       move in the head of the chain
         ST    RA,MCCTMCCB             Make this one the head
*
* MCCB is all set
*
FNDMCCB  LABEL ,
         LOCKRL MCCTLOCK               Free the MCCT lock
*
* Return to the caller
*
         LR    RVR,RA                  Address of the MCCB
         PEND  ,
         DROP  RA,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGGBUF - Get a message buffer.                               *
*                                                                 *
*     Input - @MSGGBUF                                            *
*                                                                 *
*    Output - Returns a pointer to the buffer.                    *
*                                                                 *
*******************************************************************
         SPACE 3
MSGGBUF  PROC  @MSGGBUF,SCOPE=GLOBAL
         L     RY,@MSGGCHN             Get the channel id (CCB addr)
         USING RCCB,RY                 Should be a requestor
         IF    (RCCB,NE,'RCCB'),'KAPUT BADCHID'  Must be good CB
         IF    (RTCBR,NE,RCCBRTCB),'KAPUT BADCH' Must belong to him
*
* Allocate a buffer from dynamic memory
*
         L     RA,@MSGGLEN             Get length of the buffer
         LA    RVR,L'MSGBUF            Length of the header
         AR    RVR,RA                  Add to get total length
*        MEMGET (RS),TYPE=GLOBAL       Get a dynamic buffer
MSBUFOB  STORAGE OBTAIN,LENGTH=(RVR),SP=8,RELATED=MSBUFREL
         LR    RX,RS                   Get its address
         USING MSGBUF,RX               Address it
         CLEAR MSGBUF
*
* Initialize the header
*
         MVC   MSGBUF(4),=CL4'MSGB'    Save a block id
         STH   RA,MSGBLEN              Save the length (user area)
         ST    RY,MSGBRCCB             Pointer to the owner
*
* Put the message on the RCCB queue
*
         LOCKOB RCCBLOCK               Get the lock
         MVC   MSGBCHN,RCCBMBCH        Point this one at the chain
         ST    RX,RCCBMBCH             And the head at this one
         LOCKRL RCCBLOCK               Release the lock now
*
* Return the start of the data area to the user
*
         LA    RVR,MSGBDATA            Get offset of the user data
         PEND  ,
         DROP  RX,RY
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGSEND - Send a message/reply.                               *
*                                                                 *
*     Input - @MSGSEND                                            *
*                                                                 *
*    Output - none                                                *
*                                                                 *
*******************************************************************
         SPACE 3
MSGSEND  PROC  @MSGSEND,SCOPE=GLOBAL
*
* Get and validate the message buffer
*
         L     RX,@MSGSBUF             Get the buffer location
         S     RX,=A(L'MSGBUF)         Get the true offset
         USING MSGBUF,RX               Address it
         IF    (MSGBUF,NE,'MSGB'),'KAPUT BADMBUF'
*
* Get the channel designator and determine whether this is a send
* message or send reply.  Then do the work.
*
         L     RY,@MSGSCHN             Get (RCCB/SCCB) address
         IF    (@RY,EQ,'RCCB'),BEGIN   This is a Send Message
         WITH  (RCCB,RY)
*
* validate the state of the message and that it belongs on this
* channel.
*
         IF    (RY,NE,MSGBRCCB),'KAPUT BADMCH'
         IF    (^MSGBALOC,AND,^MSGBDONE),'KAPUT MSGSTATE'
*
* Looks like everything is ok for the send...
*
         INCR  RB,RCCBNREQ             Count the request
         SET   MSGBSENT                Set the new state
         MVC   MSGBRVAL,@MSGSVAL       Move in the Requestor value
         MVC   MSGBPRIO,@MSGSPRI       And also the priority
         L     RY,RCCBMCCB             Get the MCCB Address
         WITH  (MCCB,RY)
         LOCKOB MCCBQLCK               Obtain the lock
*
* Get the serial number
*
         INCR  RJ,MCCBSEQ              Update the number
         ST    RJ,MSGBSEQ              Save it in the buffer
         ST    RJ,@MSGSSEQ             And in the return parms
         EJECT ,
*
* Queue it to the MCCB
*
* Add the buffer to the chain in priority order.  Each buffer
* has a pointer to the next one in the queue (MSGBNEXT).  The
* first buffer with a given priority level has a pointer to
* the last buffer in the queue with the same priority level
* (MSGBPEND).  If there is only one buffer in the queue with a
* given priority, this pointer will point to its own buffer.
* These pointers are used to get to the correct point in the
* queue as quickly as possible.  The following code is a bit
* tricky.  RX always points to the buffer we wish to add to
* the queue.  RA points at the buffer we will insert after,
* assuming all the tests go correctly.  RB points to the
* buffer after RA's.  This buffer is the one we test to see
* whether to insert our buffer after RA's.
*
*
* Assume that this buffer is the only one at its priority
*
         ST    RX,MSGBPEND
         L     RS,MSGBPRIO             Get the priority of ours
*
* Start at the queue head pointer.  Imitate a buffer address
*
         LA    RA,MCCBMBH-MSGBNEXT+MSGBUF  Fake message address
*
* Loop until we find the end of the chain or the right spot
*
*   We have a trial insertion spot...(RA).  Check it out.
*
PQLOOP   WITH  (MSGBUF,RA),'LT RB,MSGBNEXT'      Following buffer
         IF    Z,PUTONQ                At the end of our rope
         WITH  (MSGBUF,RB),BEGIN
*
*   Compare the test buffer (RB) priority with ours (in RS)
*
         C     RS,MSGBPRIO
         IF    EQ,RITPRIO              Have the general vicinity
*
*   If our buffer has a higher priority, we found the spot
*
         IF    GT,PUTONQ               Found its spot
*
*   If our buffer is of lower priority, we skip to the end of all
*   those buffers with the same priority as RB's
*
         L     RA,MSGBPEND             Try a new insert point
         B     PQLOOP
*
*   If our buffer is of the same priority, we skip to the end of
*   those buffers with the same priority and insert it.  We must
*   also update the pointer to the last buffer of the priority
*   level.
*
RITPRIO  L     RA,MSGBPEND             Get last at this prio
         ST    RX,MSGBPEND             This is the new last one
         END   ,
*
* We now insert the buffer after the one pointed to by RA
*
PUTONQ   MVC   MSGBNEXT,MSGBNEXT-MSGBUF(RA) Point ours at the queue
         ST    RX,MSGBNEXT-MSGBUF(RA)       And the queue at ours
         LOCKRL MCCBQLCK
         EJECT ,
*
* Now all the servers must be posted
*
         LOCKOB MCCBMLCK
         L     RB,MCCBSERV             Get first in list
         WHILE (RB,NZ),BEGIN
         WITH  (SCCB,RB)
         FPOST SCCBECB                 Wake this fellow up
         IF    (RVR,NZ),EXIT           POST issued, no need to go on
         L     RB,SCCBNEXT             Point to the next server
         END   ,
         LOCKRL MCCBMLCK               Release the lock now
         LR    RVR,RJ                  Return the Sequence number
         END   ,
         ELSEIF (@RY,EQ,'SCCB'),BEGIN  This is a send reply
         WITH  (SCCB,RY)
*
* Check to see whether the msg is on the right channel
*
         IF    (RY,NE,MSGBSCCB),'KAPUT BADCHAN' Not his
         IF    (RTCBR,NE,SCCBRTCB),'KAPUT BADCHAN' ditto
         L     RA,MSGBRCCB             Get the owner's RCCB
         WITH  (RCCB,RA)
*
* Check the state of the message buffer
*
         IF    ^MSGBRCVD,'KAPUT MSGSTATE'        No good.
*
* Queue it to the one who sent it
*
         LOCKOB RCCBLOCK               Lock up the RCCB
         SET   MSGBREPL                Set the new state
         CLEAR MSGBNEXT
         L     RS,RCCBMBT              Address of last reply
         WITH  (MSGBUF,RS),'ST RX,MSGBNEXT'  Add it to the queue
         ST    RX,RCCBMBT              Last one is now this one
         LOCKRL RCCBLOCK               Unlock the RCCB
         FPOST RCCBECB                 Wake him up
         END   ELSE,'KAPUT BADCHAN'    Bad channel passed
*
* OK. Return to the caller. The check is in the mail.
*
         PEND
         DROP RX
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGRECV - Receive a message/reply.                            *
*                                                                 *
*     Input - @MSGRECV                                            *
*                                                                 *
*    Output - none                                                *
*                                                                 *
*******************************************************************
         SPACE 3
MSGRECV  PROC  @MSGRECV,SCOPE=GLOBAL
*
* Verify the information passed to us
*
         L     RY,@MSGRCHN             Get the channel pointer
         IF    (@RY,EQ,'SCCB'),BEGIN   It is a server channel
         WITH  (SCCB,RY)
*
* Make sure this belongs to him
*
         IF    (RTCBR,NE,SCCBRTCB),'KAPUT BADCHAN'
*
* Check to see if there is a cancel request waiting for him.
*
         IF    (SCCBCANH,NZ),BEGIN     Cancel request waiting
         LOCKOB SCCBLOCK               Lock up the cancel chain
         L     RS,SCCBCANH             Get the address of the first
         WITH  (CANREQ,RS)
         MVC   SCCBCANH,CANRNEXT       Remove this entry
         IF    (RS,EQ,SCCBCANT),BEGIN  Last one in queue
         LA    RVR,SCCBCANH-CANRNEXT+CANREQ      Empty queue value
         ST    RVR,SCCBCANT            Save it in the tail
         END   ,
         LOCKRL SCCBLOCK
*
* Move info into the return area
*
         MVC   @MSGRSEQ,CANRSEQ        Move the sequence number in
         MEMFREE L'CANREQ,A=(RS),TYPE=GLOBAL    Free the request
         L     RVR,=A(-1)              Indicate cancel request
         END   ELSE,BEGIN
*
* No cancel requests... see if there are any messages waiting
*
         L     RK,SCCBMCCB             Get a pointer to the main
         WITH  (MCCB,RK)
         LOCKOB MCCBQLCK               Lock up the msg queue
         LT    RJ,MCCBMBH              Get addr of message
         IF    Z,BEGIN                 No buffers queued
         LOCKRL MCCBQLCK               Release the lock
         CLEAR RVR                     Make the address zero
         END   ELSE,BEGIN
         WITH  (MSGBUF,RJ)
*
* Remove the buffer from the queue
*
         L     RS,MSGBNEXT             Address of the next one
         IF    (RJ,NE,MSGBPEND),BEGIN  More at this priority level
         MVC   MSGBPEND-MSGBUF(,RS),MSGBPEND     Move pointer to next
         END   ,
         ST    RS,MCCBMBH              Update the queue header
*
* We have the new buffer...update the info and return it to the
* caller.
*
         ST    RY,MSGBSCCB             Save the address of the server
         SET   MSGBRCVD                Set the status of the buffer
         LOCKRL MCCBQLCK               Free up the message queue
         MVC   @MSGRSEQ,MSGBSEQ        Tell the caller the seqence #
         MVC   @MSGRPRI,MSGBPRIO       Tell him about the priority
         LH    RS,MSGBLEN              Get the user data length
         ST    RS,@MSGRLEN             And tell the caller what it is
         LA    RVR,MSGBDATA            Address of the user data
         INCR  RS,SCCBNRCV             Count received buffers
         END   ,
         END   ,
         END   ,
         ELSEIF (@RY,EQ,'RCCB'),BEGIN  Requestor...so its a reply
         WITH  (RCCB,RY)
*
* Check to see if any replies are queued.
*
         LT    RA,RCCBMBH              Get address of first buffer
         IF    Z,'CLEAR RVR'           No replies queued
         ELSE  BEGIN                   Some replies queued
         LOCKOB RCCBLOCK               Get exclusive access
         WITH  (MSGBUF,RA),BEGIN
         MVC   RCCBMBH,MSGBNEXT        Update the chain
         IF    (RA,EQ,RCCBMBT),BEGIN   That was the last one
         LA    RVR,RCCBMBH-MSGBNEXT+MSGBUF       Empty q value
         ST    RVR,RCCBMBT             Saved in the tail pointer
         END   ,
         LOCKRL RCCBLOCK               Free the lock
         SET   MSGBDONE                Set the buffer state
         MVC   @MSGRSEQ,MSGBSEQ        Tell caller about the seq #
         MVC   @MSGRVAL,MSGBRVAL       And value set on send
         LH    RS,MSGBLEN              Get the user data length
         ST    RS,@MSGRLEN             Save the length
         LA    RVR,MSGBDATA            And the buffer address
         END   ,
         END   ,
         END   ELSE,'KAPUT BADCHAN'
         PEND  ,
         EJECT ,
*******************************************************************
*                                                                 *
*    MSGCAN - Cancel a message previously sent.                   *
*                                                                 *
*     Input - @MSGCAN                                             *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*******************************************************************
         SPACE 3
MSGCAN   PROC  @MSGCAN,SCOPE=GLOBAL
*
* Check out the parms
*
         L     RY,@MSGCCHN             Get the channel block ptr
         IF    (@RY,NE,'RCCB'),'KAPUT BADCHAN'
         USING RCCB,RY
         IF    (RTCBR,NE,RCCBRTCB),'KAPUT BADCHAN'
*
* See if we can find the buffer on the chain
*
         L     RJ,@MSGCSEQ             Sequence number to cancel
         LOCKOB RCCBLOCK               Lock up the chain
*
* Loop through all buffers allocated by this task
*
         LT    RB,RCCBMBCH             Get first buffer ptr
         WHILE NZ,BEGIN                'till the end of the chain
         WITH  (MSGBUF,RB)
         IF    (RJ,EQ,MSGBSEQ),CANFND  Found the one we seek
         LT    RB,MSGBCHN              Address of the next buf
         END   ,
*
* No matching buffer was found... skip the processing step
*
         LOCKRL RCCBLOCK               Release the lock
         B     CANDONE                 And skip the rest
*
* The message was found.  Check on its status and do the right
* thing based on what it is.
*
CANFND   WITH  (MSGBUF,RB),BEGIN       Set up the addressing
         IF    MSGBSENT,BEGIN          Queued for receiver
*
* It appears the the message has not yet been received.  Get the
* lock on the MCCB and check it again.
*
         L     RJ,RCCBMCCB             Get location of the MCCB
         WITH  (MCCB,RJ)
         LOCKOB MCCBQLCK               Lock it up
         IF    ^MSGBSENT,BEGIN         Things have changed
         LOCKRL MCCBQLCK               release the lock
         B     CANST1                  Try for another case
         END   ,
*
* It has truly not yet been received.  Move the message to the
* reply queue of the requestor.  First find the spot.
*
         LA    RA,MCCBMBH-MSGBNEXT+MSGBUF        Dummy first one
         WITH  (MSGBUF,RA),BEGIN
         LR    RK,RB                   Dummy first in prio chain
         WHILE (RB,NE,MSGBNEXT),BEGIN
         L     RA,MSGBNEXT                       Get the next one
         IF    (RB,EQ,MSGBPEND),'LR RK,RA' First of prio chain
         END   ,
         END   ,
*
* Found the buffer in front of the one to be removed...it is pointed
* to by RA.
*
         L     RS,MSGBNEXT             Address of the buffer after
         IF    (RB,NE,MSGBPEND),BEGIN  Must fix up the prio chain
         MVC   MSGBPEND-MSGBUF(,RS),MSGBPEND     Do the fixup
         END   ,
         ST    RA,MSGBPEND-MSGBUF(,RK) Make first prio point to prev
         ST    RS,MSGBNEXT-MSGBUF(,RA) Remove the element
         LOCKRL MCCBQLCK
*
* Then queue it on the requestor's reply queue
*
         CLEAR MSGBNEXT                This one is the last
         SET   MSGBREPL                It is now a reply
         L     RA,RCCBMBT              Address of last buffer
         WITH  (MSGBUF,RA),'ST RB,MSGBNEXT'
         ST    RB,RCCBMBT              This buffer is now the last
         FPOST RCCBECB                 Post the ecb
         END   ,
CANST1   ELSEIF MSGBRCVD,BEGIN         It has been received.
*
* Since the message has been received by a server, a cancel
* request must be formatted and queued to the proper server. Since
* we currently hold the lock on the RCCB, the server won't be able
* to free or reply to the message until we are done.
*
         MEMGET L'CANREQ,TYPE=GLOBAL
         LR    RK,RVR
         WITH  (CANREQ,RK)
         MVC   CANREQ(4),=C'CANR'
         ST    RB,CANRBUF              Save the buffer address
         ST    RJ,CANRSEQ              And the sequence number
         L     RX,MSGBSCCB             Get the SCCB of the processor
         WITH  (SCCB,RX)
         LOCKOB SCCBLOCK               Lock up the Cancel queue
         L     RS,SCCBCANT             Get end ptr
         WITH  (CANREQ,RS),'ST RK,CANRNEXT'
         ST    RK,SCCBCANT             It is the last one now
         LOCKRL SCCBLOCK
         END   ,
*
* Any other cases, we don't do anything cause it is either not yet
* sent or has already been processed and the reply is waiting.
*
         LOCKRL RCCBLOCK               Free lock on this side
         END   ,
CANDONE  PEND  ,
         DROP  RY
         EJECT ,
*******************************************************************
*                                                                 *
*   MSGFREE - Free a previously allocated message buffer.         *
*                                                                 *
*     Input - @MSGFREE                                            *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*******************************************************************
         SPACE 3
MSGFREE  PROC  @MSGFREE,SCOPE=GLOBAL
         L     RX,@MSGFBUF             Address of buffer to free
         S     RX,=A(L'MSGBUF)         Get address of the header
         USING MSGBUF,RX
         IF    (MSGBUF,NE,'MSGB'),'KAPUT BADBUF'
         L     RY,@MSGFCHN             And of the channel
*
* Validate the information passed to us
*
         IF    (@RY,EQ,'RCCB'),BEGIN   Requestor
         WITH  (RCCB,RY)
         IF    (RTCBR,NE,RCCBRTCB),'KAPUT BADCHAN'
         IF    (RY,NE,MSGBRCCB),'KAPUT BADCHAN'
         IF    (^MSGBALOC,AND,^MSGBDONE),'KAPUT MSGSTATE'
         END   ,
         ELSEIF (@RY,EQ,'SCCB'),BEGIN  Server doing it
         WITH  (SCCB,RY)
         IF    (RTCBR,NE,SCCBRTCB),'KAPUT BADCHAN'
         IF    (RY,NE,MSGBSCCB),'KAPUT BADCHAN'
         IF    ^MSGBRCVD,'KAPUT MSGSTATE'
         L     RY,MSGBRCCB                       Point at the owner
         END   ,
*
* At this point RY points to the RCCB, RX to the message and the
* state and validity has been verified.
*   Now it is time to remove the message.
*
         USING RCCB,RY
         LOCKOB RCCBLOCK               Lock up the chain
         LA    RA,RCCBMBCH             Addr of pointer
         L     RB,@RA                  Addr of first buffer
         WHILE (RX,NE,RB),BEGIN
         WITH  (MSGBUF,RB)
         LA    RA,MSGBCHN              Addr of the next pointer
         L     RB,MSGBCHN              And the addr of the buffer
         END   ,
*
* Found it...remove it.
*
         MVC   @RA(4),MSGBCHN          Remove it from the queue
         LOCKRL RCCBLOCK
         LA    RA,L'MSGBUF             Get the length of the header
         AH    RA,MSGBLEN              Add user length = total len
*        MEMFREE (RA),A=(RB),TYPE=GLOBAL        Free the memory
MSBUFREL STORAGE RELEASE,ADDR=(RB),LENGTH=(RA),                        *
               SP=8,RELATED=MSBUFOB
*
* All done... Return to the user.
*
         PEND
         DROP  RX,RY
         END   .
