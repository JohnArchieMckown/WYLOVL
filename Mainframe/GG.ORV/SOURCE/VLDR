VLDR     TITLE 'ORVYL''S LOADER'
********************************************************************
*                                                                  *
*       ORVYL/370  RELEASE III - CLASS I - STANFORD PROPRIETARY    *
*                                                                  *
********************************************************************
* All external calls to this module can be done in 24 or 31 bit mode
* (I think). This module must reside below the 16 meg line however.
         SPACE 2
         HIBAL ,
         SPACE 2
* MODIFICATIONS
*
         EJECT ,
VLDR     CSECT ,
         IDENT 00
         SPACE 2
         COPY  ORVDEFN
         SPACE 2
         REGS  ,,SR,TR,QR,XRNT,BRR,BR,WAR,RAR,,LCBR
         REGS  ,,,,,RR
         EJECT ,
         MACRO
&L       DIAG  &LOC,&LEN,&B,&EC=4,&REG=
         LCLC  &DESCR
         LCLA  &LOCLNG
&DESCR   SETC  '&LOC'
         AIF   ('&REG' EQ '').CALMSG
         AIF   ('&DESCR'(1,1) NE '''').CALMSG
&LOCLNG  SETA  K'&LOC-1
&DESCR   SETC  '&LOC'(1,&LOCLNG)' @             ''' WORK SPACE
.CALMSG  ANOP
&L       SETMSG &DESCR,&LEN
         AIF   ('&REG' EQ '').CHKEXIT
         AIF   ('&REG' EQ 'R15').SKPLR15
         LR    R15,&REG
.SKPLR15 ANOP
         LCALL EMSGLOC
.CHKEXIT ANOP  ,
         AIF   ('&B' EQ 'EXIT').EXIT
         AIF   ('&EC' EQ '').NOEC
         LA    R15,&EC
.NOEC    ST    R10,LDWTEMP
         L     R10,WAR10
         VCALL LDMSG
         BNZ   EXIT
         L     R10,LDWTEMP
         AIF   ('&B' NE '').A
         MEXIT
.A       B     &B
         MEXIT
.EXIT    LCALL MSGEX&EC
         MEND
         EJECT
*GEN
*
* ESD FORMAT
*
ESD      RECORD BEGIN
ESDSTART DS    0A
ESDNAME  DS    CL8                     NAME
ESDTYP   DS    XL1                     TYPE
         ORG   ESDTYP
ESDADDR  DS    A                       ADDRESS
ESDLNG   DS    A                       LENGTH (SD,PC,CM)
         ORG   ESDLNG+2
ESDSDID  DS    H                       SD ID (LD)
*
ESDTSD   EQU   0                       SD
ESDTLD   EQU   1                       LD
ESDTER   EQU   2                       ER
ESDTLR   EQU   3                       LR
ESDTPC   EQU   4                       PC
ESDTCM   EQU   5                       CM
ESDTPR   EQU   6                       PR
ESDTNL   EQU   7                       NULL
ESDTWX   EQU   10                      WX
ESDTDEL  EQU   X'10'                   DELETE
*
         ORG
ESDNXT   DS    0A
         END   ,
         EJECT
         COPY  CSD
         EJECT
         COPY  RLD
         EJECT
*
* RNT ENTRY FORMAT
*
RNT      RECORD BEGIN
RNTSTART DS    0C
RNTCSD   DS    H                       CSDID
RNTFL    FLAG ,                        FLAGS
         FLAG  (RNTFUSE,X'80')         ENTRY IS IN USE
         FLAG  (RNTFDEL,X'40')         DELINK DATA SAVED
         FLAG  (RNTFSDX,X'08')         ENTRY IS FOR LD FORWARD SD REF
         FLAG  (RNTFSD,X'04')          SD
         FLAG  (RNTFER,X'02')          ER
         FLAG  (RNTFCM,X'01')          CM
RNTDLNK  DS    AL3                     DELINK DATA
RNTNXT   DS    0X
         END   ,
         EJECT
*GEN
LNKPAGE  RECORD BEGIN
         COPY  LCB  FULLST=YES
*
*  CARD IMAGE
*
         ORG   LCBCI
CICODE   DS    XL1                     CC 1
CITYPE   DS    CL3                     CC 2-4
CITADDR  DS    A                       CC 5-8  TEXT LOAD ADDRESS
         DS    CL2                     CC 9-10
CICNT    DS    H                       CC 11-12  BYTE COUNT
         DS    H
CIESID   LABEL ,                       CC 15-16 FIRST ESID (ESD CARD)
CITESID  DS    H                       CC 15-16  SD FOR TEXT
CITEXT   DS    0C                      CC 17-72  TEXT
         ORG   CITEXT
CIRLD    DS    0C                      RLD DATA
         ORG   CITEXT
CIESD    DS    0C                      ESD DATA
         ORG   CITEXT
CIEND    DS    0C                      END DATA
CINSEP   DS    CL8                     SYMBOLIC ENTRY POINT
         DS    CL4
CINLEN   DS    CL4                     LENGTH OF SECTION
         ORG   LCBCI+72
CISEQ    DS    CL8                     SEQUENCE
         ORG
         END   ,
*
*NOGEN
         EJECT
* LOAD MODULE RECORD
*
MRC      DSECT
MRID     DS    AL1                     RECORD TYPE
*
MRIDRID  EQU   B'10000000'             IDENTIFICATION RECORD
MRSYMID  EQU   B'01000000'             SYM RECORD
MRESDID  EQU   B'00100000'             ESD RECORD
MRSCTID  EQU   B'00010000'             SCATTER/TRANSLATION
MREOMID  EQU   B'00001000'             END OF MODULE RECORD
MREOSID  EQU   B'00000100'             END OF SEGMENT RECORD
MRRLDID  EQU   B'00000010'             RLD RECORD
MRCTLID  EQU   B'00000001'             CONTROL RECORD
*
MR1      DS    0X                      TYPE DEPENDENT FIELDS
*
* SYM FIELDS
MRSYMTYP DS    AL1
MRSYMCNT DS    AL2
MRSYM    DS    XL240                   SYM DATA
*
         ORG   MR1
*
* ESD FIELDS
MRESFLAG DS    AL1                     ESD FLAG 1XXX XXXX- A/RMODE info LOADCOPY
MRESAMOD EQU   B'10000000'             AMODE/RMODE data in CESD data    LOADCOPY
MRESSPAR DS    AL2                     SPARE                            LOADCOPY
MRESID   DS    AL2                     ID OF FIRST ESD ITEM
MRESDCNT DS    AL2                     COUNT OF ESD DATA
MRESD    DS    XL240                   ESD DATA (240 BYTES MAX)
*
         ORG   MR1
*
* SCATTER/TRANSLATION FIELDS
         DS    X                       SPARE
MRSCTCNT DS    AL2                     COUNT
MRSCT    DS    1020X                   SCATTER DATA
*
         ORG   MR1
*
* IDR FIELDS
MRIDR    DS    CL255                   IDR DATA
         ORG   MRIDR                   DATA INCLUDES COUNT
MRIDRCNT DS    AL1                     COUNT (INCLUDING THIS FIELD)
MRIDRTYP DS    AL1                     SUBTYPE
MRIDRORV EQU   B'00010000'             ORVYL IDR SUBTYPE
MRIDRLST EQU   B'10000000'             LAST IDR RECORD FLAG
         SPACE
* ORVYL IDR RECORD FIELDS
*
MRIDRFL  DS    CL5                     FLAGS
MRIDRMSZ DS    A                       MAIN STORAGE REQUIREMENT
MRIDREP  DS    A                       ENTRY POINT
         ORG   MRIDR+L'MRIDR           RESERVE MAXIMUM RECORD
MRIDREND DS    0F
MRIDRSIZ EQU   MRIDREND-MRIDR          COUNT FIELD FOR ORVYL IDR
*
         ORG   MR1
*
* RLD/CONTROL FIELDS
         DS    AL3                     SPARE (ZEROES)
MRCTLCNT DS    AL2                     CONTROL DATA COUNT
MRRLDCNT DS    AL2                     RLD DATA COUNT
MRCCW    CCW   6,0,X'40',0             READ CCW FOR TEXT
MRRLD    DS    XL240                   RLD AND CONTROL DATA
         SPACE
CTL      DSECT
CTLID    DS    H                       ID OF CSECT
CTLLNG   DS    H                       LENGTH OF CSECT BLOCK
CTLNXT   DS    0F
CTLSIZE  EQU   CTLNXT-CTL
         EJECT
*
* WORK AREA
*
LDWA     RECORD BEGIN
WAR0     DS    A
WAR1     DS    A
         VSA   2,8
WARAR    DS    A
WAR10    DS    A
         VSA   LCBR,14
LDWESDTP DS    X                       WORK AREA FOR ESD TYPE
LDWCSDTP DS    X                       WORK AREA FOR CSD TYPE
LDWTXEND DS    A                       END OF TEXT ON CARD
LDWRANDP DS    2H                      RLD - SAVED R & P
LDWR     EQU   LDWRANDP,2,C'H'
LDWP     EQU   LDWRANDP+2,2,C'H'
         ORG   LDWRANDP
LDWLDC   DS    H                       ESD - POSSIBLE LD CHAIN
LDWTEMP  DS    2F
         ORG   LDWTXEND
LDWPRCL  DS    A                       PR CUM LENGTH FOR LDFIX
         ORG   LDWESDTP
LDWDLEN  DS    A                       LAST DLNK VALUE
         ORG
LDWFLAG  FLAG  ,                       FLAGS                            LOADCOPY
         FLAG  (LDWESDMD,X'80')        CESD data - AMODE/RMODE data     LOADCOPY
LDWASZ   EQU   *-LDWA
         END   ,
*
*
VLDR     CSECT
*        CALLING CONVENTIONS:
*              1. STANDARD ORVYL LINKA E WITH SAVE AREA STACK IN R13
*                 AND RETURN ADDR IN R9
*              2. LCBR CONTAINS POINTER TO LOADER CONTROL BLOCK.
*              3. USER MUST PROVIDE LDMSG & VSEG ROUTINES FOR
*                 MESSAGES.
*              4. NO OTHER ASSUMPTIONS ABOUT ORVYL ORGANIZATION
*                 IS ASSUMED.
         SPACE 3
NSDID    EQU   128                     NUMBER OF SD'S (CSECTS)
         EJECT
*  INITIALIZATION
*
*        ENTER WITH ALL REQUIRED FIELDS OF LCB SET.
*
LDINIT   VENTER R0,R14,LDWASZ
BASE     EQU   *
         L     BRR,=A(BASE+4096)
         USING BASE+4096,BRR           ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         LA    SR,3                    IS MAP ON A WORD BOUNDARY?
         N     SR,LCBMAP
         BNZ   BADINIT
         CLEAR (LCBEP,LCBEND-LCBEP)    CLEAR THE WORK AREA
         OI    LCBEP,X'80'             MARK EP NOT DEFINED.
         ZAP   LCBSEQ,=P'0'            SET SEQUENCE
         LM    SR,TR,LCBMAP            MAP START, LENGTH
         CH    TR,=Y(256)              MINIMUM ACCEPTABLE SIZE
         BL    BADINIT                 MAP AREA TOO SMALL
         SPACE
* PLACE RENUMBER TABLE AND CSECT TABLE AT END OF MAP AREA
         SRL   TR,5                    NUMBER OF RNT ENTRIES
         BCTR  TR,0                    RESERVE ZEROTH ENTRY
         CH    TR,=Y(32767)            TOO MANY?
         BNH   *+8                     NO, SKIP
         LH    TR,=Y(32767)            USE MAXIMUM
         STH   TR,LCBNRNTE             SAVE NUMBER OF ENTRIES
         LA    TR,@TR+1                COUNT INCLUDING ZEROTH
         MH    TR,=Y(-L'RNT)           SUBTRACT SPACE REQUIREMENTS
         A     TR,LCBMPLEN              FROM LENGTH
         ALR   TR,SR                   START OF RNT
         ST    TR,LCBRNT               ADDR OF RENUMBER TABLE
         USING RNT,TR                  ##
         CLEAR RNT                     PRCL IS ZERO ENTRY IN RNT
         SET   RNTFUSE
         DROP  TR                      ##
         ST    TR,LCBSDEND
         L     TR,LCBMPLEN             SIZE OF AREA
         SRL   TR,7                    NUMBER OF SDID'S
         AR    TR,TR                   SIZE OF SDID TABLE
         LCR   TR,TR                   ALLOCATE SPACE
         A     TR,LCBSDEND             START OF SDID TABLE
         ST    TR,LCBSD
         ST    TR,LCBSDLC
         ST    TR,LCBRLDLC             RLD AREA.
         MVC   @SR(L'CSD),PRCLCSD      LAST ITEM NAME=X'FFFFFFFFFFFFF'
         ST    SR,LCBCSDH               CHAIN HEAD
         LA    SR,L'CSD(,SR)           ALLOCATE A CSD
         ST    SR,LCBCSDLC
         LCALL CLRNT                   CLEAR THE RNT
         B     EXIT
*
BADINIT  DIAG  'ERROR IN LOADER INITIALIZATION',,EXIT,EC=8
         DROP  ,                       ##
         SPACE 3
PRCLCSD  DC    (L'CSD)X'00'            END OF CSD CHAIN SERVES AS
         ORG   PRCLCSD+(CSDNAME-CSD)   PR CUMULATIVE LENGTH CSD ITEM
         DC    8X'FF'
         ORG   PRCLCSD+(CSDTYP-CSD)
         DC    AL1(ESDTPR)             TYPE=PSEUDO REGISTER
         ORG   PRCLCSD+(CSDFL-CSD)
         DC    AL1(L'CSDFPRCL)         SUBTYPE=CUMULATIVE LENGTH
         ORG
         EJECT
* LOAD MODULE INPUT INITIALIZATION
*
*        LCB MUST BE INITIALIZED BY CALL TO LDINIT
*
LDMIINIT VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         IF    (LCBFMI+LCBFMO,Z),MARKLMI   ALREADY PROCESSING LMD
         BAS   R15,PROCERR
MARKLMI  LABEL ,
         SET   LCBFMI                  MARK LOAD MODULE INPUT
         CLEAR LCBMLEN                 MODULE LENGTH
         B     EXIT                    ALL SET
         DROP  ,                       ##
         EJECT
*** DRIVER ***
*
*
LDGO     VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         IF    (LCBFMI+LCBFMO,Z),LMINPRCS  PROCESSING LMD'S?
         BAS   R15,PROCERR
LMINPRCS LABEL ,
         LM    SR,QR,CCSRCH            SEARCH FOR
NXTCC    CLC   LCBCI(4),@QR            IT
         BE    GOTCC                   IN
         BXLE  QR,SR,NXTCC             TABLE
BADCARD  DIAG  'INVALID OBJECT CARD',,EXIT,EC=8
*
GOTCC    L     SR,@QR+4                GO PROCESS
         CLEAR (LCBCI,1)               NOW USED AS LOADMODULE CONTROL
         BR    SR                      CARD.
*
PUSHMSG  MVC   4(*-*,R5),0(R1)
*
PROCERR  DIAG 'ERROR IN LOADER CALL SEQUENCE',,EXIT,EC=16,REG=R15
*
LDRERR   DIAG  'SEVERE ERROR IN LOADER',,EXIT,EC=16,REG=R15
MSGEX16  LA    R15,16
         B     MSGEX
*
MSGEX12  LA    R15,12
         B     MSGEX
*
MSGEX8   LA    R15,8
         B     MSGEX
*
MSGEX4   LA    R15,4
MSGEX    DIAG  (1),(0),,,EC=
         VPOP  R5,R5,PTR=R5
EXIT     LABEL ,
EXIT2    LABEL ,
         L     R15,LCBMXC
EXITR15  VEXIT R0,R14,LTR               PRESERVE R15
*
CCSRCH   DC    F'8'
         DC    A(CCTBLND-8)
         DC    A(CCTBL)
*
CCTBL    DS    0F
         DC    X'02',C'ESD',A(ESDCARD)
         DC    X'02',C'TXT',A(TXTCARD)
         DC    X'02',C'RLD',A(RLDCARD)
         DC    X'02',C'SYM',A(SYMCARD)
         DC    X'02',C'END',A(ENDCARD)
CCTBLND  EQU   *
         DROP  ,                       ##
         SPACE 4
         EJECT
*** LOAD MODULE INPUT DRIVER ***
*
*
LDMIGO   VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         LTR   R0,R0                   END OF FILE?
         IF    NP,BEGIN
         IF    LCBFMI,EOMUNEX          EOM BEEN PROCESSED?
         L     RAR,WARAR
         LA    RAR,@RAR+8
         ST    RAR,WARAR
         B     EXIT
         END   ,
         SPACE
         IF    LCBFMI,INPLULE          ALREADY INPUTTING LOAD MODULE?
         BAS   R15,PROCERR
INPLULE  LABEL ,
         ST    R1,LCBCI                SAVE RECORD POINTER
         MVC   LCBCI(1),@R1            MOVE CODE FORM RECORD
         LM    SR,QR,MRSRCH            SEARCH FOR
NXTMR    CLC   LCBCI(1),@QR
         BE    GOTMR
         BXLE  QR,SR,NXTMR
BADREC   DIAG  'INVALID LOAD MODULE RECORD',,EXIT,EC=8 ,REG=R15
EOMUNEX  DIAG  'INCOMPLETE LOAD MODULE',,EXIT,EC=8
*
GOTMR    L     SR,@QR+4                GO PROCESS RECORD.
         BR    SR                      (1) AND (0) ARE RECORD POINTERS
*
MRSRCH   DC    F'8'
         DC    A(MRTBLND-8)
         DC    A(MRTBL)
*
MRTBL    DS    0F
         DC    AL1(MRIDRID),A(IDRREC)
         DC    AL1(MRSYMID),A(SYMREC)
         DC    AL1(MRESDID),A(ESDREC)
         DC    AL1(MRSCTID),A(SCATREC)
         DC    AL1(MREOMID+MREOSID+MRRLDID),A(RLDREC)
         DC    AL1(MREOMID+MREOSID+MRCTLID),A(RLDREC)
         DC    AL1(MREOMID+MREOSID+MRRLDID+MRCTLID),A(RLDREC)
         DC    AL1(MRRLDID),A(RLDREC)
         DC    AL1(MRCTLID),A(RLDREC)
         DC    AL1(MRRLDID+MRCTLID),A(RLDREC)
MRTBLND  DS    0C
*
         EJECT
*** END CARD PROCESSOR ***
*
*
ENDCARD  LABEL ,
         L     RAR,WARAR               SET SPECIAL RETURN ADDRESS
         LA    RAR,@RAR+4
         ST    RAR,WARAR
         ZAP   LCBSEQ,=P'0'            RESET SEQUENCE
         LT    R12,LCBLSD              NEED CSECT LENGTH?
         IF    NZ,BEGIN
         CLEAR LCBLSD
         USING CSD,R12                 ##
         CLI   CINLEN,0                If Zero, we have a length
         IF    EQ,BEGIN
         MVC   CSDLNG+1(3),CINLEN+1    PLANT LENGTH
         END   ,
         ELSE  BEGIN
         MVC   CSDLNG+1(3),=A(0)
         END   ,
         LR    R1,R12                  CSD POINTER
         LCALL GETSD                   GET SPACE
         DROP  R12                     ##
         END   ,
         LT    R0,LCBEP                ENTRY ALREADY PRESENT?
         BNM   ENDCOM                  BR IF SO
         CLI   CINSEP,C' '             SYMBOLIC ENTRY?
         IF    NE,BEGIN
         LA    LCBR,CINSEP
         LCALL LDFIND                  LOOK IT UP
         LTR   R15,R15
         BZ    ENDERA                  BR IF UNDEFINED
         LTR   R1,R1
         BM    ENDERA
         SL    R1,LCBCORE
         ST    R1,LCBEP
         END   ,
         LH    R1,CIESID               OR IF NONE
         CH    R1,ENDBL                GIVEN OR
         BE    ENDCOM                  CARD.
         LCALL RNTFU                   RENUMBER ID
         USING RNT,XRNT                ##
         IF    ^RNTFSD,ENDERA          ERROR IF ESID IS
         LH    R1,RNTCSD               LOCATE CSD.
         MH    R1,=Y(L'CSD)
         AL    R1,LCBCSD
         DROP  XRNT                    ##
         USING CSD,R1                  ##
         L3    R15,CSDREL+1            RELOCATE ENTRY POINT.
         DROP  R1                      ##
         LR    R1,R15
         AL    R1,CITADDR
         ST    R1,LCBEP                STORE.
ENDCOM   LCALL CLRNT                   CLEAR RNT.
         LT    R12,LCBCHRPH            RELEASE ANY CHANGE/REPLACE ITEMS
         BZ    EXIT
         USING CSD,R12                 ##
ENDCHRP  LR    R1,R12
         LCALL RELCSD                  PUT ON FREE CHAIN
         LT    R12,CSDLINK             GET NEXT
         BNZ   ENDCHRP
         ST    R12,LCBCHRPH            ZERO LIST POINTER
         DROP  R12                     ##
         B     EXIT
*
ENDBL    LABEL ,
         DC    C'  '
ENDERA   DIAG  'ENTRY INVALID'
         B     ENDCOM
         EJECT
*** SYM RECORD PROCESSING ***
*
*
SYMREC   LABEL ,
         USING MRC,R1                  ##
         LH    SR,MRSYMCNT             COUNT OF SYM DATA
         DROP  R1                      ##
         CH    SR,=Y(L'MRSYM)
         IF     HIGH,'BAS R15,BADREC'
         LA    SR,@SR+MRSYM-MRC        RECORD LENGTH
         SR    R0,SR
         IF    NEG,'BAS R15,BADREC'
         AR    R1,SR
         STM   R0,R1,WAR0              UPDATED RECORD POINTERS
         B     EXIT                    THROW AWAY INFO
         SPACE
*** SYM CARD PROCESSING ***
*
*
SYMCARD  B     EXIT                    SOME DAY
         EJECT
*** SCATTER RECORD PROCESSING ***
*
*
SCATREC  LABEL ,
         USING MRC,R1                  ##
         LH    SR,MRSCTCNT             COUNT OF SCATTER DATA
         DROP  R1                      ##
         CH    SR,=Y(L'MRSCT)
         IF    HIGH,'BAS R15,BADREC'
         LA    SR,@SR+MRSCT-MRC        RECORD LENGTH
         SR    R0,SR
         IF    NEG,'BAS R15,BADREC'
         AR    R1,SR
         STM   R0,R1,WAR0              UPDATED RECORD POINTERS
         B     EXIT                    THROW AWAY INFO
         EJECT
*** IDR RECORD PROCESSING ***
*
*
IDRREC   LABEL ,
         USING MRC,R1                  ##
         LC    SR,MRIDRCNT
         CH    SR,=Y(L'MRIDR)
         IF    HIGH,'BAS R15,BADREC'
         LA    SR,@SR+MRIDR-MRC        RECORD LENGTH
         SR    R0,SR
         IF    NEG,'BAS  R15,BADREC'
         ST    R0,WAR0
         LR    R0,R1
         AR    R0,SR
         ST    R0,WAR1
         NI    MRIDRTYP,255-MRIDRLST   CLEAR LAST BIT
         CLI   MRIDRTYP,MRIDRORV       AN ORVYL IDR RECORD?
         BNE   EXIT
         MVC   LCBIDRFL,MRIDRFL        SET FLAGS
         L     R0,MRIDRMSZ             STORAGE REQUIREMENTS
         AL    R0,LCBLC                CURRENT LOAD LENGTH.
         CL    R0,LCBCLEN              WILL IT FIT?
         BH    NOSDCORE                NO
         LT    R0,LCBEP                ENTRY POINT DEFINED YET?
         IF    MIN,'MVC LCBEP,MRIDREP'
         B     EXIT
         DROP  R1                      ##
         EJECT
*** PROCESS LOAD MODULE ESD RECORD
*
*
ESDREC   LABEL ,
         USING MRC,R1                  ##
         CLEAR LDWFLAG                 Reset flag for ESD segment       LOADCOPY
*                                                                       LOADCOPY
*  Check ESD header flag (byte 1)                                       LOADCOPY
*    0XXX XXXX - byte 12 of CESD data item contain segment numbers      LOADCOPY
*    1XXX XXXX - byte 12 of CESD data items contains AMODE/RMODE data   LOADCOPY
*                                                                       LOADCOPY
         IF    ('TM MRESFLAG,MRESAMOD',NZ),'SET LDWESDMD'               LOADCOPY
*                                                                       LOADCOPY
         MVC   CIESID,MRESID           COPY FIRST ESD ID
         LA    SR,MRESD                FIRST ESD ITEM
         LH    TR,MRESDCNT             COMPUTE END
         DROP  R1                      ##
         CH    TR,=Y(L'MRESD)
         IF    HIGH,'BAS R15,BADREC'
         LA    QR,@TR+MRESD-MRC        RECORD LENGTH
         SR    R0,QR
         IF    NEG,'BAS R15,BADREC'
         AR    R1,QR
         STM   R0,R1,WAR0              SAVE NEXT RECORD POINTERS
         B     ESDCOM                  JOIN OBJECT CARD CODE
         EJECT
*** PROCESS ESD CARD ***
*
*
*
ESDCARD  LABEL ,
         LA    SR,CIESD               LOCATE FIRST ESD.
         USING ESD,SR                 ##
         LH    TR,CICNT               COMPUTE END
         CH    TR,=Y(CISEQ-CITEXT)
         BH    BADCARD                BRANCH IF HASH IN COUNT FIELD
ESDCOM   AR    TR,SR                  END MARKER
         ST    TR,LDWTXEND            SAVE END
*
* PROCESS NEXT ESD
*
ESDNXA   NI    ESDTYP,X'1F'            CLR SUBCLASS (EX. DELETE)
         MVC   LDWESDTP,ESDTYP         SAVE TYPE
         CLI   ESDTYP,HIESDTYP         ERROR IF
         BH    ESDTPERR                ILLEGAL TYPE.
         LC    R1,ESDTYP               AN X'FF' IN THE
         LA    R1,ESDTPTB(R1)          TABLE
         TM    @R1,X'FF'               IS ALSO
         BO    ESDTPERR                AN ERROR.
         CLI   ESDTYP,ESDTLD
         IF    NE,BEGIN
         LH    R1,CIESID
         LA    R0,@R1+1
         STH   R0,CIESID
         CLI   ESDTYP,ESDTNL           NULL?
         BE    NXTESD                  SKIP IT
         LCALL RNTF                    RENUMBER ID
         USING RNT,XRNT                ##
         END   ,
         LT    R15,LCBCHRPH            ANY CHA/REP LIST?
         BZ    ESDSRCH                 NO
         EJECT
* CHANGE/REPLACE/DELETE LIST EXISTS. SEARCH FOR CURRENT ESDNAME.
*
         USING CSD,R15                 ##
ESDCHRP  CLC   CSDNAME,ESDNAME
         BE    ESDCR1                  MATCH FOUND
RECHRP   LT    R15,CSDLINK
         BNZ   ESDCHRP
         B     ESDSRCH                 NO MATCH FOUND
         SPACE
ESDCR1   CLI   CSDTYP,CSDTCHA          CHANGE?
         BE    ESDCHA                  YES
* DELETE/REPLACE
         CLI   ESDTYP,ESDTPR           PSEUDO-REGISTER?
         BNE   ESDDLNPR                NO
         CLEAR ESDLNG                  CLEAR LENGTH/ALIGNMENT
ESDDLNPR LABEL ,
         CLI   CSDTYP,CSDTREP          REPLACE?
         BE    ESDREP                  YES
* DELETE
         CLI   ESDTYP,ESDTPR           ESD=PR?
         BE    RECHRP                  CONTINUE SEARCH
ESDDEL   LABEL ,                       JOIN HERE TO DELETE DUP SYM
         OI    ESDTYP,ESDTDEL          DELETE ESD
         CLI   ESDTYP,ESDTLD+ESDTDEL   ESD=LD?
         BE    NXTESD                  DISCARD
         CLI   ESDTYP,ESDTSD+ESDTDEL   ESD=SD?
         BE    ESDDLCOM
         MVI   ESDTYP,ESDTER+ESDTDEL
         B     ESDDLCOM                DO COMMON PROCESSING
*
* REPLACE
ESDREP   CLI   ESDTYP,ESDTSD           ESD=SD?
         BNE   ESDCHA                  NO
         OI    ESDTYP,ESDTDEL          SET ESD DELETE
*
ESDCHA   MVC   ESDNAME,CSDNAM2         CHANGE NAME TO PROTECT INNOCENT
ESDDLCOM MVC   LDWESDTP,ESDTYP         GET NEW TYPE
         NI    LDWESDTP,X'0F'          CLEAR DELETE FLAG
         CLI   LDWESDTP,ESDTWX         WX?
         BNE   ESDSRCH                 NO.
         MVI   LDWESDTP,ESDTER         MATCH LIKE ER.
         DROP  R15                     ##
         USING CSD,R12                 ##
         EJECT
* SEARCH THROUGH CHAINED CSD FOR ESD MATCH
*
ESDSRCH  LA    R12,LCBCSDH              MERGE ESD INTO CSD
         CLEAR LDWLDC                  ZERO LD CHAIN INDICATOR
ESDSLOOP LR    R10,R12                 SAVE PREV R12
         L     R12,CSDLINK             GET NEXT
         CLC   CSDNAME,ESDNAME
         BL    ESDSLOOP                KEEP UP THE SEARCH
         BE    ESDRSLV                 FOUND THE NAME
*
* NON-RESOLUTION PROCESSING
*
ESDNR    LCALL GETCSD                  RETURNS (1) =A(CSD)
         ST    R1,@R10                 LINK IN NEW ITEM
         ST    R12,@R1
         LR    R12,R1
ESDNR1   MVC   CSDNAME(12),ESDNAME     MOVE IN NAME, TYPE, ADDR.
         NI    CSDTYP,255-ESDTDEL      TABLES NOT FILLED FRO DEL
         CLI   LDWESDTP,ESDTLD         BRANCH IF ESD IS LD.
         BE    ESDNRJMP                (NO RENUMBERING)
*
* RE-NUMBER NON-LD ESD
*
         IF    (RNTFUSE*RNTFSDX),'MVC LDWLDC,RNTCSD'
         LCALL RENUM                   FIX RNT
         TM    ESDTYP,ESDTDEL          PUT DELETE FLAG ON IF
         IF    ONE,'SET RNTFDEL'       NECESSARY
*
* PROCESS BY TYPE
*
ESDNRJMP LC    R1,LDWESDTP             JUMP ON CODE.
         SLL   R1,2                    BRANCH
         B     *+4(R1)                 ON TYPE
         B     ESDNSD                  SD
         B     ESDNLD                  LD
         B     NXTESD                  ER
         B     ESDNLR                  LR
         B     ESDNPC                  PC
         B     ESDNCM                  CM
         B     ESDNPR                  PR
         BAS   R15,LDRERR              NL - SHOULDN'T HAPPEN
         BAS   R15,LDRERR              INVALID - SHOULDN'T HAPPEN
         BAS   R15,LDRERR              INVALID - SHOULDN'T HAPPEN
         B     NXTESD                  WX
         SPACE
* MOVE TO NEXT ESD
*
NXTESD   LA    SR,ESDNXT
         C     SR,LDWTXEND            END OF TEXT?
         BL    ESDNXA
         B     EXIT
         EJECT
* SD OR PC   (DELETE ZERO LENGTH PCS)
*
ESDNPC   LABEL ,
         L3    R1,ESDLNG+1             CHECK PC LENGTH
         IF    (R1,ZERO),NXTESD
ESDNSD   LABEL ,
         IF    LCBFMI,BEGIN            FIX UP LNG IF LOAD MOD
         L3    R15,ESDADDR+1           STARTING ADDRESS
         L3    R14,ESDLNG+1            LENGTH
         ALR   R15,R14                 PLUS LENGTH
         IF    (R15,GT,LCBCLEN),NOSDCORE
         IF    (R15,GT,LCBMLEN),'ST 15,LCBMLEN' NEW MAX
         END  ,
         TM    ESDTYP,ESDTDEL          MARKED FOR REP/DEL?
         BZ    SDKEEP                  NO
         SPACE
* SD/PC MARKED FOR DELETION. RELEASE ANY SDX CHAIN.
*
         SET   RNTFDEL                 DELETE ALL TEXT/RLDS
         MVI   CSDTYP,ESDTER           UNRESOLVE CSD
         CLEAR CSDFDEF
LDCDEL   LH    R1,LDWLDC               TEST FOR LD CHAIN
         LTR   R1,R1
         BZ    NXTESD                  NONE
         DROP  R12                     ##
         MH    R1,=Y(L'CSD)
         AL    R1,LCBCSD
         USING CSD,R1                  ## DISPLACE R12 FOR A SECOND
LDCLOOP  MVI   CSDTYP,ESDTER           MAKE LD INTO ER
         CLEAR CSDFDEF
         LT    R1,CSDSDC               MORE ON CHAIN?
         BNZ   LDCLOOP                 Y
         DROP  R1                      ##
         B     NXTESD
         EJECT
* ALLOCATE SD/PC. PROCESS ANY SDX CHAIN.
*
*        FILL IN THE CSDADDR AND CSDREL FIELDS
*
         USING CSD,R12                 ##
SDKEEP   MVC   CSDLNG+1(3),ESDLNG+1    SD LENGTH
         IF    LCBFMI,SDLM             LOAD MODULE
         LR    R1,R12                  GET CORE
         LCALL GETSD                   FOR SECTION.
         LR    R0,R1                   COMPUTE
         L3    R1,CSDADDR+1            CSECT START ADDRESS
         ST3   R0,CSDADDR+1            ADDRESS
         SR    R0,R1                   AND MODULE
         ST3   R0,CSDREL+1             START ADDRESS.
         LR    R1,R12                  CSD ADDR
         LCALL SAVESD
         CLEAR LCBLSD
         LT    R0,CSDLNG               LENGTH SPECIFIED?
         BNZ   ESDNXB
         ST    R12,LCBLSD              SAVE POINTER TO CSD ENTRY
         B     ESDNXB
         EJECT
* LOAD MODULE SD
SDLM     LR    R1,R12
         LCALL SAVESD                  PUT SDID IN TABLE
         MVC   CSDREL+1(3),LCBLC+1     MODULE START ADDRESS
         L     R1,ESDADDR              CSECT ADDR IN MODULE
         L     R15,LCBLC               MODULE START
         LA    R0,@R1(R15)
         ST3   R0,CSDADDR+1
ESDNXB   MVC   CSDTYP,ESDTYP           REFRESH TYPE AND
         SET   CSDFDEF                 FLAG AS DEFINED.
         LH    TR,LDWLDC               ANY LD CHAIN?
         LTR   TR,TR
         BZ    NXTESD                  SD NOT LATE
         L3    R15,CSDREL+1            PICK UP RELOC DELTA
         LH    R0,RNTCSD               SDID
         MH    TR,=Y(L'CSD)
         AL    TR,LCBCSD
         DROP  R12                     ##
         USING CSD,TR                  ##
ESDSDLA  L3    R1,CSDADDR+1            RELOCATE LD,
         LA    R1,@R1(R15)
         ST3   R1,CSDADDR+1
         MVI   CSDTYP,ESDTLR           SET TYPE
         SET   CSDFDEF                 FLAG AS DEFINED.
         STH   R0,CSDSDID              SD CONTAINING LR
         LT    TR,CSDSDC               CHAIN ON.
         BNZ   ESDSDLA                 BACK FOR MORE ESD'S
         B     NXTESD
         DROP  TR                      ##
         USING CSD,R12                 ##
         EJECT
* CM
*
ESDNCM   LABEL ,
         L3    R1,ESDLNG+1             PLANT LENGTH
         ST    R1,CSDLNG               GO
ESDCMDEL SET   RNTFDEL                 FLAG AS DELETED
         IF    ^LCBFMI,NXTESD          NOT LOAD MODULE
*         L     R1,ESDADDR              GE REL ADDR
         L3    R1,ESDADDR+1            GE REL ADDR
         AL    R1,LCBLC                ABSOUTE ADDR
         L3    R15,ESDLNG+1
         ALR   R1,R15
         IF    (R1,GT,LCBMLEN),'ST R1,LCBMLEN' MAX MODULE LEN
         B     NXTESD                  ON.
         EJECT
*
* LR (OR LD CONVERTED TO LR)
*
ESDNLD   OI    ESDTYP,ESDTLR           X'03' ORS OVER X'01'
ESDNLR   SET   CSDFDEF                 SYMBOL DEFINED
         LH    R1,ESDSDID              RENUMBER CONTAINING
         LCALL RNTF                    SDID.
         IF    ^RNTFUSE,ESDNL2         IF SD NOT
         IF     RNTFDEL,BEGIN          DELETED
         MVI   CSDTYP,ESDTER           CHANGE TO LR
         B     NXTESD
         END    ,
         IF    ^RNTFSD,ESDNL1          IF NOT SD, CHECK FOR SDX CHAIN.
         LH    R1,RNTCSD               LOOK UP SD CSD.
         STH   R1,CSDSDID              SD CONTAINING LR.
         MH    R1,=Y(L'CSD)
         AL    R1,LCBCSD
         DROP  R12                     ##
         USING CSD,R1                  ##
         IF    ^CSDFDEF,NXTESD         IS CONTAINING SD DEFINED?
         L     R0,ESDADDR              GET DIRTY LD ADDRESS.
         AL    R0,CSDREL               RELOCATE LD ADDRESS.
         DROP  R1                      ##
         USING CSD,R12                 ##
         ST    R0,CSDADDR              LD ABSOLUTE ADDRESS.
         B     ESDNXB                  SETS CSDTYP.
*
ESDNL1   LABEL ,                       SDID IN USE BUT NOT SD.
         IF    ^RNTFSDX,'BAS R15,LDRERR' ERROR IF NOT SDX
         LH    R1,RNTCSD               ADD TO SDX CHAIN.
         MH    R1,=Y(L'CSD)
         AL    R1,LCBCSD
         ST    R1,CSDSDC
ESDNL2   LCALL RENUM                   SET CSDID IN RNT
         SET   RNTFUSE+RNTFSDX
         B     ESDNXB
         SPACE
         EJECT
*
* RESOLUTION PROCESSING
*
ESDRSLV  LABEL ,
         CLI   CSDTYP,ESDTNL           MATCH WITH NULL?
         BE    ESDSLOOP                IGNORE
         IF    ('TM   ESDTYP,ESDTDEL',O),ESDR1
         CLI   LDWESDTP,ESDTLD
         IF    NE,BEGIN                TYPE IS NOT LO.
         IF    (RNTFUSE+RNTFSDX,NO),'LCALL RENUM'
         END   ,
         LC    R1,LDWESDTP
         AR    R1,R1
         LH    R0,ESDESDTB(R1)         IN LOCATOR TABLE.
         IF    (R0,ZERO),'BAS R15,LDRERR'
         IC    R1,CSDTYP               PICK UP CSD
         CLI   CSDTYP,ESDTWX           WX?
         IF    EQ,'LA R1,ESDTER'       PROCESS AS AN ER.
         AR    R1,R1                   TYPE.
         AR    R1,R0                   FORM DISPLACEMENT AND
         LH    R1,BASE(R1)             GET BRANCH ADDRESS.
         IF    (R1,ZERO),'BAS R15,LDRERR'
         B     BASE(R1)                GO TO PROCESS
*
* ACTION 1 --  DELETE INCOMING SD
*
ESDR1    IF     RNTFSDX,BEGIN
         MVC   LDWLDC,RNTCSD           SAVE POSSIBLE LD CHAIN
         LCALL RENUM                   SET RNT.
         END   ,
         SET   RNTFDEL                 DELETE REFERENCES.
         B     LDCDEL                  DELETE ANY SDX CHAIN.
*
* ACTION 2 -- A) INCOMING ER/WX MATCHES SD,LD,CM
*             B) ER/WX MATCHES ER/WX
*
ESDR2A   EQU   NXTESD
*
ESDR2B   CLI   LDWESDTP,ESDTER         IF INCOMING IS ER
         BNE   NXTESD                  THEN CHANGE CSD
         NI    CSDTYP,255-(ESDTWX-ESDTER)  TO ER FROM ER/WX.
         B     NXTESD
*
* ACTION 3 -- INCOMING ESD MATCHES ER
*
ESDR3SD  IF    RNTFSDX,ESDNR1          DON'T TOUCH RNT IF
ESDR3CM  CLEAR RNTFL                   RESET RNT AND GO PERFORM
ESDR3LD  B     ESDNR1                  NON-RESOLUTION
*
* ACTION 4 --  PC, CM MATCHES PC
*
ESDR4    EQU   ESDSLOOP                CONTINUE SEARCH.
*
* ACTION 6 -- ACCUMULATE CM LENGTHS
*
ESDR6    LABEL ,
         L3    R1,ESDLNG+1             TAKE MAX OF OLD AND NEW
         IF    (R1,GT,CSDLNG),'ST R1,CSDLNG'
         B     ESDCMDEL                DELETE TEXT
*
* ACTION 7 -- ACCUMULATE PR LENGTHS
*
ESDR7X   EQU   ESDSLOOP                PR & NONPR DO NOT MATCH
*
ESDNPR   LABEL ,
ESDR7    LABEL ,
         CLC   ESDLNG(1),CSDLNG        TAKE MOST RESTRICTIVE ALIGNMENT.
         IF    NLOW,'MVC CSDLNG(1),ESDLNG'
         CLC   ESDLNG+1(3),CSDLNG+1    AND LONGEST LENGTH.
         BNH   NXTESD                  CSD LONGEST
         MVC   CSDLNG+1(3),ESDLNG+1    SAME NOW.
         B     NXTESD
*
* COMMON PROCESSING
ESDRSDCM CLC   ESDLNG+1(3),CSDLNG+1    IS COMMON LONGER THAN SD?
         BH    CMLENERR                YES, TOO BAD
         B     ESDR1                   NO, GO TREAT LIKE SD
*
ESDRCMSD CLC   ESDLNG+1(3),CSDLNG+1    IS SD SHORTER THAN COMMON?
         BL    CMLENERR                YES, TOO BAD
         B     ESDR3SD                 NO, GO GET SD
*
*
* FLAG TABLE TO CONVERT ESD TYPE TO RNTFLAGS
*
ESDTPTB  DS    0C
         DC    AL1(L'RNTFUSE+L'RNTFSD)       SD
         DC    AL1(0)                        (LD)
         DC    AL1(L'RNTFUSE+L'RNTFER)       ER
         DC    AL1(L'RNTFUSE)                LR
         DC    AL1(L'RNTFUSE+L'RNTFSD)       PC
         DC    AL1(L'RNTFUSE+L'RNTFCM)       CM
         DC    AL1(L'RNTFUSE)                PR
         DC    AL1(0)                        (NL)
         DC    X'FF'                         INVALID
         DC    X'FF'                         INVALID
         DC    AL1(L'RNTFUSE+L'RNTFER)       WX
HIESDTYP EQU   *-ESDTPTB-1
*
*
* BRANCH TABLES FOR RESOLUTION PROCESSING
*
ESDESDTB LABEL ,
         DC    AL2(ESDTBSD-BASE)       ESD=SD
         DC    AL2(ESDTBLD-BASE)       ESD=LD
         DC    AL2(ESDTBER-BASE)       ESD=ER
         DC    AL2(ESDTBLR-BASE)       ESD=LR
         DC    AL2(ESDTBPC-BASE)       ESD=PC
         DC    AL2(ESDTBCM-BASE)       ESD=CM
         DC    AL2(ESDTBPR-BASE)       ESD=PR
         DC    AL2(0)                  INVALID
         DC    AL2(0)                  INVALID
         DC    AL2(0)                  INVALID
         DC    AL2(ESDTBER-BASE)       ESD=WX (TREAT LIKE ER)
*
* ESD=SD
*
ESDTBSD  LABEL ,
         DC    AL2(ESDR1-BASE)         CSD=SD
         DC    AL2(ESDR5-BASE)         CSD=LD
         DC    AL2(ESDR3SD-BASE)       CSD=ER
         DC    AL2(ESDR5-BASE)         CSD=LR
         DC    AL2(0)                  CSD=PC
         DC    AL2(ESDRCMSD-BASE)      CSD=CM
         DC    AL2(ESDR7X-BASE)        CSD=PR (TREAT AS NON-RESOLUTION)
*
* ESD=LD OR LR
*
ESDTBLD  LABEL ,
ESDTBLR  LABEL ,
         DC    AL2(ESDR5-BASE)         CSD=SD
         DC    AL2(ESDR5-BASE)         CSD=LD
         DC    AL2(ESDR3LD-BASE)       CSD=ER
         DC    AL2(ESDR5-BASE)         CSD=LR
         DC    AL2(0)                  CSD=PC
         DC    AL2(ESDR5-BASE)         CSD=CM
         DC    AL2(ESDR7X-BASE)        CSD=PR (TREAT AS NON-RESOLUTION)
*
* ESD=ER
*
ESDTBER  LABEL ,
         DC    AL2(ESDR2A-BASE)        CSD=SD
         DC    AL2(ESDR2A-BASE)        CSD=LD
         DC    AL2(ESDR2B-BASE)        CSD=ER
         DC    AL2(ESDR2A-BASE)        CSD=LR
         DC    AL2(0)                  CSD=PC
         DC    AL2(ESDR2A-BASE)        CSD=CM
         DC    AL2(ESDR7X-BASE)        CSD=PR (TREAT AS NON-RESOLUTION)
*
* ESD=PC
*
ESDTBPC  LABEL ,
         DC    AL2(0)                  CSD=SD
         DC    AL2(0)                  CSD=LD
         DC    AL2(0)                  CSD=ER
         DC    AL2(0)                  CSD=LR
         DC    AL2(ESDR4-BASE)         CSD=PC
         DC    AL2(ESDR4-BASE)         CSD=CM
         DC    AL2(ESDR7X-BASE)        CSD=PR (TREAT AS NON-RESOLUTION)
*
* ESD=CM
*
ESDTBCM  LABEL ,
         DC    AL2(ESDRSDCM-BASE)      CSD=SD
         DC    AL2(ESDR5-BASE)         CSD=LD
         DC    AL2(ESDR3CM-BASE)
         DC    AL2(ESDR5-BASE)         CSD=LR
         DC    AL2(ESDR4-BASE)         CSD=PC
         DC    AL2(ESDR6-BASE)         CSD=CM
         DC    AL2(ESDR7X-BASE)        CSD=PR (TREAT AS NON-RESOLUTION)
*
*
* ESD=PR                               NON-PR CSD'S ARE NON-RESOLUTION
*
ESDTBPR  LABEL ,
         DC    AL2(ESDR7X-BASE)        CSD=SD
         DC    AL2(ESDR7X-BASE)        CSD=LD
         DC    AL2(ESDR7X-BASE)        CSD=ER
         DC    AL2(ESDR7X-BASE)        CSD=LR
         DC    AL2(ESDR7X-BASE)        CSD=PC
         DC    AL2(ESDR7X-BASE)        CSD=CM
         DC    AL2(ESDR7-BASE)         CSD=PR
*
*
ESDTPERR LABEL ,
         SETMSG ': INVALID SYMBOL TYPE'
         LA    R15,8                   ERROR CODE
*
NAMEMSG  LABEL ,
         VPUSH R0,R15,*            SAVE EVERYTHING
         VPUSH ,,132,PTR=R5
         MVC   0(L'ESDNAME,R5),ESDNAME   FORMAT THE MESSAGE
         LA    R4,L'ESDNAME(,R5)   STRIP BLANKS
         LA    R3,7                SET COUNT TO ASSUME 1 NON-BLNK
         BCTR  R4,0
NAMSTRP  IF    (@R4,EQ,C' '),'BCTR R4,0 ; BCT R3,NAMSTRP'
         LR    R2,R0               GET BASIC MESSAGE LENGTH
         BCTR  R2,0                STRIP 1 OFF FOR EXECUTE
         LA    R4,1(,R4)           FREE  SPACE AFTER ESDNAME
         EX    R2,MVCERRMS         ADD MESSAGE AFTER NAME
         SR    R4,R5               LENGTH OF ESDNAME
         AR    R0,R4               ADDS TO LENGTH OF MESSAGE
         LR    R1,R5
         VCALL LDMSG               NOW SEND THE MESSAGE
         IF    NZER,'VPOP ,,132 ; VPOP R0,R15,* ; B EXIT'
         VPOP  PTR=R5
         VPOP  R0,R15,*
         B     ESDDEL              DELETE ESD IN ERROR & CONTINUE
*
MVCERRMS MVC   0(*-*,R4),0(R1)     * EXECUTED *
*
DICTFULL DIAG  'MAP OVERFLOW. SPECIFY LARGER MAP SIZE',,EXIT,EC=8
ESDR5    LABEL ,
         SETMSG ': PREVIOUSLY DEFINED'
         LA    R15,4
         B     NAMEMSG
*
CMLENERR SETMSG ': COMMON SIZE GREATER THAN CSECT WITH SAME NAME'
         LA    R15,4
         B     NAMEMSG
*
*  SET UP FOR OUTPUT OF DIAGNOSTIC ADDRESS
EMSGLOC  LABEL ,
         ST    R5,0(,R13)
         LR    R5,R13              VPUSH FOR WRK AREA OF LNG
         AR    R13,R0
         LR    R2,R0               LENGTH OF MSG
         BCTR  R2,0
         EX    R2,PUSHMSG
         LA    R2,4(,R5)           LOCATION
         LR    R1,R2               SAVE LOCATION
         AR    R2,R0 .             POINT PAST END
         SH    R2,=H'13' .         SPACE TO UNPACK REGISTER
         STCM  R15,B'1000',9(R2) . RESERVED SPACE  FOR CC
         ICM   R15,B'1000',=X'00' GET OFFSET INTO MODULE
         S     R15,=A(VLDR) .     FOR DEBUGGING
         STCM  R15,B'0111',10(R2) .
         UNPK  0(9,R2),9(5,R2) .   NOW FXFXFXFXFXFXFXFX
         LA    R15,=C'0123456789ABCDEF' . DIFFERENT ORDERING
         SH    R15,=XL2'F0' .
         TR    0(9,R2),0(R15) .    NOW ADJUST LENGTH OF MSG
         SH    R0,=H'5' .          AND WE'RE PRESENTABLE
         BR    RAR
         EJECT
* PLACE RENUMBERED CSDID IN RENUMBER TABLE
*
RENUM    LC    R1,LDWESDTP             GET ESD TYPE.
         LA    R1,ESDTPTB(R1)          LOC
         MVC   RNTFL,@R1               AND
         CLEAR R0
         LR    R1,R12
         SL    R1,LCBCSD
         D     R0,=A(L'CSD)
         STH   R1,RNTCSD
         MVC   RNTDLNK,ESDADDR+1       SAVE DELINK VALUE.
         BR    RAR
         DROP  SR,XRNT,R12             ##
         EJECT
*** PROCESS TEXT CARD ***
*
* REGISTER DEFINITIONS
*
*
*
TXTCARD  LABEL ,
         LH    R1,CITESID              RENUMBER SD
         LCALL RNTFU
         USING RNT,XRNT                ##
         IF    RNTFDEL,EXIT2           SKIP TEXT IF SD
         IF    ^RNTFSD,TXTERA          ERROR IF NOT
         IF    RNTFSDX,TXTERA          SD NOT YET
         LH    SR,RNTCSD
         DROP  XRNT                    ##
         MH    SR,=Y(L'CSD)
         AL    SR,LCBCSD
         USING CSD,SR                  ##
         L3    TR,CITADDR+1
         L3    QR,CSDREL+1
         AR    TR,QR                   RELATIVE TEXT ADDRESS.
         BM    EXIT                    BRANCH IF NEGATIVE
*
         LH    QR,CICNT                MOVE TEXT
         LPR   QR,QR
         L3    R0,CSDADDR+1            COMPUTE END
         A     R0,CSDLNG               SECTION.
         LA    R1,@QR(TR)              COMPARE TEXT END
         CR    R1,R0                   AND END OF CSECT
         IF    GT,BEGIN
         C     SR,LCBLSD               CSECT LENGTH IS
         BNE   TXTERA                  DEFINED,
         END   ,
         CL    R1,LCBCLEN              AND ALSO END OF
         BH    EXIT                    PROGRAM CORE.
*
         LTR   QR,QR                   IGNORE CARDS WITH
         BZ    EXIT                    LENGTH OF ZERO...
         BCTR  QR,0                    ***ADJUST COUNT***
         AL    TR,LCBCORE              GET REAL ADDRESS OF TEXT
         EX    QR,TXTMA                TO CORE
         B     EXIT                    AND CONTINUE.
*
TXTMA    MVC   @TR(*-*),CITEXT
*
         DROP  SR                      ##
*
TXTERA   DIAG  'INVALID TEXT CARD',,EXIT,EC=8
         EJECT
*** PROCESS LOAD MODULE RLD/CTL RECORD
*
*
RLDREC   LABEL ,
         USING MRC,R1                  ##
         LA    SR,MRRLD                FIRST RLD ITEM
         LH    TR,MRRLDCNT             COMPUTE END
         CH    TR,=Y(L'MRRLD)
         IF    HIGH,'BAS R15,BADREC'
         LA    QR,@TR+MRRLD-MRC        RECORD LENGTH
         AH    QR,MRCTLCNT
         DROP  R1                      ##
         SR    R0,QR
         IF    NEG,'BAS R15,BADREC'
         AR    R1,QR
         STM   R0,R1,WAR0
         TM    LCBCI,MRRLDID           ANY RLD DATA?
         BZ    CTLREC                  NO
         B     RLDCOM                  JOIN OBJECT CARD CODE
         EJECT
*** RLD CARD PROCESSOR ***
*
*
*
RLDCARD  LABEL ,
         LA    SR,CIRLD                GET LOC OF RLD TEXT
         LH    TR,CICNT                AND COMPUTE
         CH    TR,=Y(CISEQ-CITEXT)
         BH    BADCARD                 BRANCH IF HASH IN COUNT FIELD
RLDCOM   AR    TR,SR                   END.
         ST    TR,LDWTXEND
         MVC   LDWRANDP(4),@SR         SAVE R AND P
         LA    SR,@SR+4                RLD TEXT POINTER
         LCALL GETRLD                  OBTAIN RLD SPACE
         LR    R10,R1
         USING RLD,R10                 ##
* OLD R & P ARE NOT RE-USED
*
RLDNXB   LH    R1,LDWP                 P PTR
         LCALL RNTFU                   LOCATE RNT ENTRY FOR P
* VALIDITY CHECK ON P
*
         LR    TR,XRNT                 LET TR HOLD P RNT ADDR
         USING RNT,TR                  ##
         IF    RNTFDEL,RLDSDGON
         IF    ^RNTFSD,RLDERA           ERROR IF NOT
         IF    RNTFSDX,RLDERB          OR IF
         LH    R1,LDWR                 PUT R-RNT
         LCALL RNTFU                   IN XRNT.
*
*  R AND P ARE VALID. CHAIN RLD ON CSD
*
RLDNXA   LABEL ,
         IF    RNTFDEL,RLDSDGON
         MVC   RLDP,RNTCSD             RENUMBER P-CSDID.
         DROP  TR                      ##
         MVC   RLDADDR,@SR             HOLD FLAGS AND ADDRESS.
         USING RNT,XRNT                ## XRNT HOLDS R RNT ADDR
         IF    RLDFBRA,SETABS          V-TYPE OR PRCL?
         CLC   LDWR,LDWP               LOCAL A-TYPE?
         BE    NOSTABS                 YES; NO DELINK
         MVC   RLDDLNK+1(3),RNTDLNK
SETABS   SET   RLDFABS
NOSTABS  LABEL ,
         SPACE
         MVC   RLDR,RNTCSD             RENUMBER R-CSDID
         LCALL GETRLD                  GET AN RLD ENTRY
         LR    R10,R1
*
* MOVE TO NEXT RLD TEXT IF ANY
*
RLDSDGON LABEL ,
         IF    @SR.RLDFN,OLDRP         USE OLD R&P?
NEWRP    MVC   LDWRANDP(4),@SR+4       NEW R&P
         LA    SR,@SR+8                NEXT TEXT
         C     SR,LDWTXEND             AT END?
         BL    RLDNXB                  VALIDATE R&P
         B     RLDBYE
*
OLDRP    LA    SR,@SR+4              MOVE TO NEXT.
         C     SR,LDWTXEND             AT END  OF TEXT?
         BL    RLDNXA                  NO  TR POINTS TO P-RNT
         B     RLDBYE
*
RLDBYE   LR    R1,R10                   UNUSED RLD ENTRY
         LCALL RELRLD                  RELEASE IT
         SPACE
         B     CTLREC                  PROCESS ANY CONTROL.
*
RLDERA   LABEL ,
RLDERB   LABEL ,
         DIAG  'INVALID RLD ENTRY',,EXIT,EC=8
         DROP  XRNT,R10                ##
*
         EJECT
*** CONTROL RECORD PROCESSOR ***
*
CTLREC   TM    LCBCI,MRCTLID
         BZ    EOSCHK
         L3    R1,LCBCI+1              SAVE RECORD POINTER
         USING MRC,R1                  ##
         L3    TR,MRCCW+1              GET DATA ADDRESS PART OF CCW
         C     TR,LCBMLEN              INSIDE MODULE?
         IF    HIGH,'BAS R15,BADREC'
         L     SR,MRCCW+4              DATA LENGTH
         DROP  R1                      ##
         N     SR,=X'0000FFFF'         CCW LENGTH IS 16 BITS
         LA    QR,@SR(TR)
         L     R1,LCBMLEN              GET LOAD MODULE LENGTH
         LA    R1,@R1+8                BUMP
         N     R1,=F'-8'               AND ROUND
         CLR   QR,R1                   PAST END OF MODULE?
         IF    HIGH,'BAS R15,BADREC'
         AL    TR,LCBLC                START OF LOADMODULE
         AL    TR,LCBCORE              FULL ADDRESS OF TEXT
*
         STM   SR,TR,WAR0              RETURN POINTERS
         L     RAR,WARAR               SET SPECIAL RETURN ADDRESS
         LA    RAR,@RAR+4
         ST    RAR,WARAR
         EJECT
*** END OF SEGMENT/MODULE PROCESSING.
*
EOSCHK   TM    LCBCI,MREOMID+MREOSID
         BZ    EXIT
         CLEAR LCBFMI
         L     R1,LCBLC                LOCATION COUNTER
         AL    R1,LCBMLEN              MEMORY FOR LOAD MODULE
         ST    R1,LCBLC
         L     R1,WARAR
         LA    R1,@R1+8                EOM EXIT
         ST    R1,WARAR
         B     ENDCOM                  JOIN END CARD PROCESSING.
         EJECT
         LTORG
         EJECT
*** ADCON RELOCATION ROUTINE ***
*
*    ENTRY.. BAS RAR,RELOC
*
*         WITH (1)=L(CSD_ENTRY)
*              (15)=L(RLD_ENTRY)
*
*   REGISTER DEFINITIONS
*
*SR                                    LOCATION OF ADCON
*TR                                    LOCATION OF PCSD
*TR                                    RELOCATION QUANTITY
*QR                                    WORK REG
*
*
RELOC    LABEL ,
         VPUSH RAR,,*
         USING RLD,R15                 ##
         LH    TR,RLDP                 LOCATE P-CSD.
         MH    TR,=Y(L'CSD)
         AL    TR,LCBCSD
         USING CSD,TR                  ##
         L3    SR,CSDREL+1             GET RELOC FACTOR.
         L3    QR,RLDADDR+1            COMPUTE ABSOLUTE LOCATION OF
         LA    SR,@QR(SR)              ADCON.
         LH    QR,RLDP
         LCALL FDECR                   FETCH DECREMENT VALUE
         SR    SR,QR
         L3    QR,CSDADDR+1            VERIFY
         CR    SR,QR                   ADCON
         BL    RELERAX                 FALLS
         IC    R0,RLDFL                     CALCULATE
         SRL   R0,2                         LENGTH
         N     R0,=A(3)
         SR    QR,R0                        ADCON.
         A     QR,CSDLNG               WITHIN
         CR    SR,QR                   THE
         BNL   RELERAX                 SECTION.
         ST3   SR,RLDADDR+1            SAVE ABS LOC OF ADCON.
         AL    SR,LCBCORE              REAL LOCATION OF ADCON
         DROP  TR                      ##
         USING CSD,R1                  ##
         L3    TR,CSDREL+1             PICK UP
         IF    RLDFABS,'L3 TR,CSDADDR+1' ABSOLUTE
         CLI   CSDTYP,ESDTPR           PSEUDO REGISTER?
         IF    NE,'AL TR,LCBRF'        RELOCATE TO VIRTUAL ORIGIN
         LR    QR,R0
         LR    R0,TR                   RELOC FACTOR
         SL    R0,RLDDLNK
         IF    RLDFS,'LCR R0,R0'       COMPLEMENT RELOCATION
         LA    TR,LDWTEMP+3            TEMP ADCON CELL
         SR    TR,QR                   LOC AND MOVE
         IF    ^RLDFBRA,BEGIN          ^BRANCH TYPE
         CLEAR (LDWTEMP,4)             CLEAR A WORD.
         EX    QR,RELMA                ADCON TO WORK CELL.
         AL    R0,LDWTEMP              PICK UP ADCON AND
         IF    ^RLDFABS,BEGIN
         VPUSH QR,,*
         LH    QR,RLDR
         LCALL FDECR                   FETCH DECREMENT VALUE
         SR    R0,QR                   DECREMENT
         VPOP  QR,,*
         END   ,
         END   ,
         ST    R0,LDWTEMP
         EX    QR,RELMB                INTO SLOT
         VPOP  RAR,,*
         BR    RAR                     AND EXIT.
*
RELMA    MVC   @TR(*-*),@SR
RELMB    MVC   @SR(*-*),@TR
*
         DROP  R1                      ##
         DROP  R15                     ##
*
RELERAX  DIAG  'INVALID ADDRESS CONSTANT',,EXIT
         SPACE 2
*  FETCH DECREMENT VALUE GIVEN P-CSD IN QR
*
FDECR    VPUSH R1,R3,*
         LH    R2,LDWP                 LAST P VALUE
         IF    (QR,EQ,R2),BEGIN
         L     QR,LDWDLEN
         END   ,
         ELSE  BEGIN
         LR    R3,RAR
         LR    R1,QR
         STH   R1,LDWP
         LCALL RNTF
         LR    RAR,R3
         USING RNT,XRNT              ##
         L3    QR,RNTDLNK
         ST    QR,LDWDLEN
         END    ,
         VPOP  R1,R3,*
         BR    RAR
         EJECT
*** SPACE PROCESSING ROUTINES ***
*
* GET SPACE FOR SD
* MODULE LENGTH ROUNDED UP TO DOUBLEWORD.
* PAGE ALIGNMENT PERFORMED.
*
*        BAS  RAR,GETSD  WITH (1)=L(CSD)
*
*     RETURNS (1)=L(SPACE)
*
GETSD    LABEL ,
         USING CSD,R1                  ##
         IF    LCBFPAGN,'SET CSDFPAG;CLEAR LCBFPAGN'
         L     R15,CSDLNG              MODULE LENGTH
         LA    R0,@R15+7               ROUND TO DOUBLE WORD.
         N     R0,=X'00FFFFF8'
         ST    R0,CSDLNG
         L     R15,LCBLC               LOCATION COUNTER
         IF    ^CSDFPAG,NOPAGE         PAGE BOUNDARY?
         DROP  R1                      ##
         LA    R15,@R15+X'FFF'
         N     R15,=X'7FFFF000'
         SET   LCBFPAG                 MODULE REQUIRES PAGE ALIGNMENT
NOPAGE   LR    R1,R15                  RETURN START ADDRESS
         AR    R0,R15                  BUMP LOC.
         CL    R0,LCBCLEN              PAST END OF PROGRAM CORE?
         BH    NOSDCORE
         ST    R0,LCBLC
         LR    R1,R15                  PASS BACK SD ADDRESS
         BR    RAR                     RETURN
         SPACE 5
* SAVE SDID IN CSECT TABLE
*
*        LCALL SAVESD  WITH (1)=L(C    SD)
*
SAVESD   CLEAR R0                      NEW ENTRY FOR SD TABLE
         SL    R1,LCBCSD               GET CSDID
         D     R0,=A(L'CSD)
         LR    R0,R1
         L     R1,LCBSDLC
         STH   R0,@R1
         LA    R1,@R1+2
         C     R1,LCBSDEND             TOO MANY CSECTS FOR TABLE?
         BNL   CSECERR
         ST    R1,LCBSDLC
         BR    RAR                     RETURN
*
NOSDCORE LABEL ,
         DIAG  'PROGRAM TOO LARGE',,EXIT,EC=8
CSECERR  DIAG  'TOO MANY CSECTS',,EXIT,EC=8
         EJECT
*
* GET CSD SPACE
*
*        BAS RAR,GETCSD
*
*     RETURNS (1)=L(CSD)
*
GETCSD   LABEL ,
         L     R1,LCBCHF               IF THERE
         LTR   R1,R1                   ARE ANY
         BZ    GCSDA                   CSD ENTRIES ON THE FREELIST?
         L     R0,@R1                  GIVE THE
         ST    R0,LCBCHF               FIRST ONE
         B     CLRCSD                  TO THE CALLER.
*
* TAKE AN ENTRY FROM THE CSD/RLD
GCSDA    L     R1,LCBCSDLC             CSD LOCATION COUNTER
         LA    R0,@R1+L'CSD            TAKE AWAY ONE CSD
         CL    R0,LCBRLDLC             DO CSD AND RLD MEET?
         BNL   DICTFULL
         ST    R0,LCBCSDLC             CSD LOCATION COUNTER
CLRCSD   XC    @R1(L'CSD),@R1
         BR    RAR                     GIVE CSD TO CALLER
*
* RELEASE CSD ENTRIES
*
*        LCALL RELCSD
*
*     ENTERED WITH (1)=L(CSD)
*
RELCSD   LABEL ,
         L     R0,LCBCHF
         ST    R1,LCBCHF
         ST    R0,@R1
         MVI   @R1+CSDTYP-CSDSTART,ESDTNL MARK AS NULL.
         BR    RAR
         EJECT
*
* GET RLD SPACE
*
*        BAS RAR,GETRLD
*
*     RETURNS (1)=L(RLD)
*
GETRLD   LABEL ,
         L     R1,LCBRHF               IF THERE
         LTR   R1,R1                   ARE ANY
         BZ    GRLA                    RLD
         L     R0,@R1                  ENTRIES
         ST    R0,LCBRHF               ON FREE
         B     CLRRLD                  TO THE CALLER.
*
* TAKE AN ENTRY FROM THE CSD/RLS
GRLA     L     R1,LCBRLDLC             RLD LOCATION COUNTER
         SH    R1,=Y(L'RLD)            TAKE AWAY ONE RLD
         CL    R1,LCBCSDLC             DO CSD AND RLD MEET?
         BL    DICTFULL                YES.
         ST    R1,LCBRLDLC             FOR NEXT RLD ALLOCATION.
CLRRLD   XC    @R1(L'RLD),@R1
         BR    RAR                     GIVE RLD TO CALLER
         SPACE 3
*
* RELEASE RLD ENTRIES
*
*        LCALL RELRLD
*
*     ENTERED WITH (1)=L(RLD)
*
RELRLD   LABEL ,
         L     R0,LCBRHF
         ST    R1,LCBRHF
         ST    R0,@R1
         CLEAR (@R1+RLDFL-RLDSTART,1)        MARK AS FREE
         BR    RAR
         EJECT
*** MISCELLANEOUS ROUTINES ***
*
*
*  CLEAR RNT
*            - RNT IS CLEARED AT INITIALIZATION, IN END CARD PROCESSING
*              AND WHEN SEQUENCING ERROR IS DETECTED.
*            - RNT NUMBER 0 IS FOR PR CUMULATIVE LENGTH AND IS NOT
*              CLEARED BY THIS ROUTINE.
*
*        BAS RAR,CLRNT
*
CLRNT    LABEL ,
         L     SR,LCBRNT
         LA    SR,@SR+L'RNT
         LH    TR,LCBNRNTE             NUMBER OF ENTRIES
         MH    TR,=Y(L'RNT)             * SIZE OF EACH ONE
         CLEAR R1
         MVCL  SR,R0
         BR    RAR
*
         EJECT
*
* LOCATE RNT ENTRY
*
*        BAS RAR,RNTF  WITH (1)=ESID
*
*    RETURNS (XRNT)=L(RNT_ENTRY)
*
RNTF     LABEL ,                       ERROR UNLESS
         LTR   R1,R1                   POSITIVE.
         BNP   RNTFERX                 ERROR IF
         CH    R1,LCBNRNTE             TOO
         BH    RNTFERX                 LARGE.
         MH    R1,=Y(L'RNT)            ENTRY ADDRES
         L     XRNT,LCBRNT             IN
         AR    XRNT,R1                 RNT.
         BR    RAR                     RETURN.
*
RNTFERX  LABEL ,
         DIAG  'TOO MANY SYMBOLS IN MODULE',,EXIT,EC=8
         EJECT
*
* LOCATE RNT ENTRY AND CHECK USE FLAG
*
RNTFU    LABEL ,
         LTR   R1,R1
         BM    RNTFERX
         CH    R1,LCBNRNTE
         BH    RNTFERX
         MH    R1,=Y(L'RNT)
         L     XRNT,LCBRNT
         AR    XRNT,R1
         USING RNT,XRNT                ##
         IF    ^RNTFDEL,'IF ^RNTFUSE,RNTFERX'
         BR    RAR
         DROP  XRNT                    ##
*
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
* ACCEPT CHANGE STATEMENTS
*
*        LCBCI = (OLDNAME,NEWNAME)
*
LDCHANGE VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         LCALL GETCSD                  OBTAIN A NEW CSD
         USING CSD,R1                  ##
         MVC   CSDLINK,LCBCHRPH        INSERT NEW ITEM AT HEAD OF
         ST    R1,LCBCHRPH             CHAIN.
         MVC   CSDNAME,LCBCI           MOVE IN OLDNAME
         MVC   CSDNAM2,LCBCI+8         AND NEW NAME
         MVI   CSDTYP,CSDTCHA          MARK AS CHANGE
         B     EXIT                    BYE
         DROP  R1                      ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
* ACCEPT PAGE STATEMENTS
*
*        LCBCI = (NAME)
*
LDPAGE   VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         CLC   LCBCI(8),=CL8' '        BLANK NAME?
         BE    LDPAGNX                 PUT NEXT MODULE ON PAGE
         LA    R12,LCBCSDH-(CSDLINK-CSD) SEARCH CSD.
         USING CSD,R12                 ##
LDPAGLP  LR    R10,R12
         L     R12,CSDLINK
         CLC   CSDNAME,LCBCI
         BL    LDPAGLP
         BE    LDPAGFN                 FOUND MATCH
         SPACE
* NO MATCH. CREATE WEAK EXTERNAL ENTRY
         LCALL GETCSD
         ST    R1,@R10                 INSERT IN
         ST    R12,@R1                 CHAIN.
         LR    R12,R1                  ##
         MVC   CSDNAME,LCBCI
         MVI   CSDTYP,ESDTWX
LDPAGFN  SET   CSDFPAG                 SET PAGE FLAG
         B     EXIT
*
LDPAGNX  SET   LCBFPAGN                PAGE NEXT CSECT
         L     SR,LCBLC                ROUND UP LC TO PAGE BOUNDARY
         LA    SR,@SR+X'FFF'
         N     SR,=X'00FFF000'
         ST    SR,LCBLC
         B     EXIT
         DROP  R12                     ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
* ACCEPT ALIAS STATEMENTS
*
*        LCBCI = (ALIAS)
*
LDALIAS  VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         LCALL GETCSD                  OBTAIN A NEW CSD
         USING CSD,R1                  ##
         MVC   CSDLINK,LCBALIH         INSERT NEW ITEM AT HEAD OF
         ST    R1,LCBALIH              ALIAS CHAIN.
         MVC   CSDNAME,LCBCI           MOVE IN ALIAS
         B     EXIT                    BYE
         DROP  R1                      ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
* ACCEPT REPLACE STATEMENTS
*
*        LCBCI = (OLDNAME,NEWNAME)
*
LDREPDEL VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         LCALL GETCSD                  OBTAIN A NEW CSD
         USING CSD,R1                  ##
         MVC   CSDLINK,LCBCHRPH        INSERT NEW ITEM AT HEAD OF
         ST    R1,LCBCHRPH             CHA/REP CHAIN.
         MVC   CSDNAME,LCBCI           MOVE IN OLDNAME
         MVC   CSDNAM2,LCBCI+8         AND NEW NAME
         MVI   CSDTYP,CSDTREP          MARK AS REPLACE
         CLC   CSDNAM2,=CL8' '         ANY NEWNAME?
         BNE   EXIT                    YES
         MVI   CSDTYP,CSDTDEL          ELSE MARK AS DELETE
         MVC   CSDNAM2,CSDNAME         OLD AND NEW ARE SAME
         B     EXIT                    BYE
         DROP  R1                      ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
*  PREPARE FOR EXECUTION
*
*
LDFIX    VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         IF    (LCBFMI+LCBFMO,Z),FIXCOM
         BAS   R15,PROCERR
FIXCOM   AP    LCBSEQ,=P'0'            WAS LAST CARD END CARD?
         BZ    CLRPRLNG
         BAS   R15,PROCERR
CLRPRLNG LABEL ,
         CLEAR LDWPRCL                 CLEAR PR CUMULATIVE LENGTH
         LA    R12,LCBCSDH             PICK UP CHAIN
         B     LDFLOOP                 JUMP INTO LOOP
         USING CSD,R12                 ##
LFA      CLI   CSDTYP,HIESDTYP         IS TYPE LEGAL?
         BH    LDFLOOP                 NO; SKIP
         LC    R1,CSDTYP
         AR    R1,R1
         AR    R1,R1
         B     *+4(R1)
         B     LDFLOOP                 SD
         BAS   R15,PROCERR             LD
         B     LDFLOOP                 ER
         B     LDFLR                   LR
         B     LDFLOOP                 PC
         B     LDFCM                   CM
         B     LDFPR                   PR
         B     LDFLOOP                 NL
         B     LDFLOOP                 NEVER
         B     LDFLOOP                 NEVER
         B     LDFLOOP                 WX
         EJECT
* FIX UP LR'S IF LOAD MODULE HAS BEEN COMPRESSED
*
LDFLR    IF    ^LCBFMO,LDFLOOP         LOAD MODULE OUTPUT?
         LH    R1,CSDSDID              ID OF CONTAINING CSECT
         LCALL RNTF                    RNT
         USING RNT,XRNT                ##
         IF    (RNTFSD+RNTFUSE,NO),LDFLRER       ACTIVE SD?
         L3    R1,RNTDLNK
         LTR   R1,R1                   ANY FIX UP?
         BZ    LDFLOOP
         L     SR,CSDADDR
         SLR   SR,1
         ST    SR,CSDADDR
         B     LDFLOOP
*
LDFLRER  LABEL ,                       CSECT HAS BEEN DELETED.
         CLEAR CSDFDEF                 UNDEFINED
         MVI   CSDTYP,ESDTER
         B     LDFLOOP
         DROP  XRNT                    ##
         SPACE 3
LDFPR    LABEL ,
         IF    CSDFPRCL,BEGIN          CUMULATIVE LENGTH PR?
         MVC   CSDREL+1(3),LDWPRCL+1   PUT CUMULATIVE LENGTH IN CSD
         B     LDFLOOP                 PROCESS CHAIN
         END   ,
* NOTE: THE PR CUMULATIVE LENGTH IS ASSUMED TO BE THE LAST ON
* THE CSD CHAIN SO THAT THE CUMULATIVE LENGTH HAS BEEN CALCULATED
* IN THIS FIX PASS.
*
         LC    R1,CSDLNG               ALIGN CUMULATIVE LENGTH
         L     R0,LDWPRCL              CURRENT LENGTH
         AR    R0,R1                   R1= (2**N-1) FOR THIS
         OR    R0,R1                   NEAT ALGORITHM
         XR    R1,R0                   TO WORK.
         ST3   R1,CSDADDR+1            ALIGNED LENGTH IS PR VALUE
         A     R1,CSDLNG               DEVELOP NEW CUM LENGTH
         ST    R1,LDWPRCL
         SET   CSDFDEF
         B     LDFLOOP                 PROCESS RLD CHAIN
         SPACE 3
LDFCM    LABEL ,                       COMMON
         LR    R1,R12                  GET CSD POINTER
         LCALL GETSD                   GET SPACE
         ST3   R1,CSDADDR+1            PLANT LOC. OF SECTION
         SET   CSDFDEF                 SET DEFINED
         LR    R1,R12
         LCALL SAVESD                  PUT ID IN CSECT TABLE
*
LDFLOOP  LABEL ,
         L     R12,CSDLINK             LOOP THRU CSD ARRAY
         CLEAR TR                      GET A ZERO
         C     TR,CSDLINK              IS THIS LAST ENTRY?
         BNE   LFA                     NO
         SPACE 3
         MVC   CSDADDR+1(3),LDWPRCL+1
         SET   CSDFDEF
         DROP  R12                     ##
* RELOCATE RLDS
         CLEAR (LDWP,2)                INITIALIZE
         L     R15,LCBRLD              START OF RLDS
         USING RLD,R15                 ##
LDFRLD   SH    R15,=Y(L'RLD)           NEXT RLD
         CL    R15,LCBRLDLC            BELOW LOWEST?
         BL    EXIT
         CLI   RLDFL,0                 FREE?
         BE    LDFRLD                  YES
         LH    R1,RLDR                 R-CSDID(LOCATION OF ADCON)
         MH    R1,=Y(L'CSD)
         AL    R1,LCBCSD
         USING CSD,R1                  ##
         IF    (CSDFDEF,OR,LCBFMO),BEGIN  DEFINED
         LCALL RELOC
         CLEAR RLDFABS                 RLD RELOCATED
         END    ,
         B     LDFRLD
*
         DROP  R1,R15                  ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
* COMPRESS FOR LOAD MODULE OUTPUT
* AND PERFORM FIX PASS FOR MODULE OUTPUT
*
LDMOINIT VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         SPACE
* SORT LIST OF CSECTS
*
         L     R0,LCBCSD               CSD LIST BASE
         L     R1,LCBSD                ADDR OF FIRST SDID
         L     QR,LCBSDLC              SD LIST END
         CR    R1,QR                   ANY CSECTS?
         BE    LMONULL                 NO
MOFLP1   LA    R15,@R1+2               SECOND SDID
         CR    R15,QR                  ONLY ONE?
         BE    MOFSRTD                 SORTED
         LH    SR,@R1                  SDID-A
         LR    TR,SR
         MH    TR,=Y(L'CSD)
         AR    TR,R0                   CSD-A
*
MOFLP2   LH    R14,@R15                SDID-B
         LR    R12,R14
         MH    R12,=Y(L'CSD)
         AR    R12,R0                  CSD-B
*
         CLC   @R12+CSDADDR+1-CSD(3),@TR+CSDADDR+1-CSD
         BH    CSCTALTB                A LESS THAN B
         BNE   CSCDFADR
* CSECTS AT SAME ADDRESS. IS ONE ZERO LENGTH?
*
         OC    @TR+CSDLNG-CSD(4),@TR+CSDLNG-CSD IS A ZERO?
         BZ    CSCTALTB                YES, DON'T SWITCH
         OC    @R12+CSDLNG-CSD(4),@R12+CSDLNG-CSD IS B ZERO?
         BZ    CSCDFADR
         BAS   R15,PROCERR
CSCDFADR LABEL ,                      CSECTS DIFFERENT ADDR
*
         STH   SR,@R15                 SDID-A INTO SLOT B
         STH   R14,@R1                 AND SDID-B INTO SLOT A
         LR    SR,R14                  SAVE SDID-A
         LR    TR,R12                  AND CSD-A
*
CSCTALTB LABEL ,
         LA    R15,@R15+2              NEXT B
         CR    R15,QR                  LAST?
         BNE   MOFLP2
*
         LA    R1,@R1+2                NEXT A
         B     MOFLP1
         EJECT
* COMPRESS ALL CSECTS. PLACE DISPLACEMENTS IN RNT.
*
MOFSRTD  LABEL ,
         CLEAR R14                     MEMORY START ADDRESS
         L     R15,LCBSD               SDID ARRAY
*
MOFCLP   LH    R12,@R15                COMPRESS NEXT SD
         LR    R1,R12                  SAVE SDID
         MH    R12,=Y(L'CSD)
         AL    R12,LCBCSD
         USING CSD,R12                 ##
         IF    CSDFPAG,BEGIN          MODULE ON PAGE BOUNDARY
         LA    R14,@R14+X'FFF'         ROUND UP LC
         N     R14,=X'00FFF000'        TO PAGE BOUNDARY
         END   ,
         L3    SR,CSDADDR+1            CURRENT LOCATION
         LCALL RNTF                    GET RTN ENTRY
         USING RNT,XRNT                ##
         LR    R1,SR                   OLD ADDR
         SR    R1,R14                  SHIFT LENGTH
         BNM   NOVERLAP
         BAS   R15,PROCERR
NOVERLAP LABEL ,
         BZ    MODSHFTD
         ST3   R1,RNTDLNK
         ST3   R14,CSDADDR+1           NEW LOCATION
         L     R1,CSDLNG               MODULE LENGTH
         LR    TR,R1                   FOR MVCL
         L     R0,LCBCORE              RELOCATION VALUE
         ALR   SR,R0                   SOURCE PTR
         ALR   R0,R14                  DESTINATION
         MVCL  R0,SR
MODSHFTD LABEL ,
         SET   RNTFSD+RNTFUSE          MARK AS ACTIVE SD
         DROP  XRNT
         AL    R14,CSDLNG              NEXT MODULE START
         LA    R15,@R15+2              NEXT SDID
         CR    R15,QR                  LAST?
         BNE   MOFCLP
         ST    R14,LCBLC               NEW MODULE COUNTER
         CLEAR R12
         ST    R12,LCBMOCSD
         MVC   LCBMOSD,LCBSD           FIRST SD FOR ESD OUTPUT
         MVC   LCBMOID,=Y(1)           FIRST OUTPUT ESD ID
         SET   LCBFMO                  OUTPUT INITIALIZED
         B     FIXCOM                  JOIN CSD SCAN
         DROP  R12                     ##
         SPACE
*
LMONULL  DIAG 'NO PROGRAM LOADED',,EXIT,EC=4
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
* CONSTRUCT A LOAD MODULE OUTPUT RECORD
*
LDMOGO   VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         IF    LCBFMO,OUTINIT          OUTPUT INITIALIZED?
         BAS   R15,PROCERR
OUTINIT  LABEL ,
         LR    R15,R0                  MAX BLOCK LENGTH
         LA    R15,@R15(R1)            BUFFER END
         LA    R14,@R1                 START OF FIRST RECORD
         USING MRC,R14                 ##
         SPACE
         IF    LCBMFCSD,LMOIDRGO       FINISHED CSD?
* ESD RECORDS
*        - PROCESS IN ORDER OF CSECTS, ATTACHING ALL LR'S
*          TO THEIR CONTAINING CSECTS
*        - THEN OUTPUT ER'S LAST
*
         SPACE
         LH    R10,LCBMOID             NEXT OUTPUT ID
         L     R12,LCBMOCSD            CSD SCAN POINTER
         USING CSD,R12                 ##
         SPACE
         L     XRNT,LCBMORNT           RNT SCAN POINTER
         USING RNT,XRNT                ##
         SPACE
LMOESD   LA    SR,MRESD                START OF ESD DATA
         USING ESD,SR                  ##
         LA    TR,ESDNXT               END OF FIRST ESD ITEM
         CR    TR,15                   WILL ONE FIT?
         BH    LMOEOBES                NO
         SPACE 2
         CLEAR (MRC,MRESD-MRC)
         MVI   MRID,MRESDID            START ESD RECORD
         STH   R10,MRESID              FIRST ID IN RECORD
         LA    TR,MRESD+L'MRESD        MAX RECORD LENGTH
         CR    TR,15                   WILL IT FIT
         IF    GT,'LR TR,R15'          DON'T BE FUSSY
         SH    TR,=Y(L'ESD)            RECORD END WARNING
         SPACE
* CSD TO ESD ITEM LOOP
*
         L     QR,LCBMOSD              CURRENT SD
         C     QR,LCBSDLC              LAST SD?
         BNL   LMOESER                 START ER OUTPUT
LMOCSDGO LTR   R12,R12                 CONTINUE LR SCAN?
         BNZ   CNTLRSCN                YES
         LH    R12,@QR                 NEXT SD ID
         LR    R1,R12                  FOR RNT LOOKUP
         LCALL RNTF                    SETS XRNT
         MH    R12,=Y(L'CSD)
         AL    R12,LCBCSD
         STH   R10,LCBMOSID            ID OF SD FOR LR'S
         LCALL CSDTOESD
         L     R12,LCBCSD              SCAN FOR LR'S
         L     XRNT,LCBRNT             FIRST RNT
         CR    SR,TR                   END OF RECORD?
         BH    LMOEOR
         SPACE
CNTLRSCN LABEL ,
         CLI   CSDTYP,ESDTLR
         IF    EQ,BEGIN
         CLC   @QR(2),CSDSDID          CONTAINED IN CURRENT SD?
         IF    EQ,BEGIN
         MVC   CSDNAME+(ESDSDID-ESD)(2),LCBMOSID POINT LR AT SD
         LCALL CSDTOESD
         END  ,
         END   ,
         LA    R12,CSDNXT
         LA    XRNT,RNTNXT
         C     R12,LCBCSDLC            END OF CSD'S
         BL    LMDCSDND
         CLEAR R12                     NEXT SD, RESTART CSD SCAN
         LA    QR,@QR+2                NEXT SDID
         ST    QR,LCBMOSD
         C     QR,LCBSDLC
         BL    LMDCSDND
         L     R12,LCBCSD
         L     XRNT,LCBRNT
         B     LMOESER
LMDCSDND LABEL ,
         CR    SR,TR                   END OF RECORD?
         BNH   LMOCSDGO                NO, NEXT ESD/CSD
         B     LMOEOR                  END OF RECORD
* ER OUTPUT
*
LMOESER  LTR   R12,R12                 ANY MORE CSD'S
         BZ    LMOESEND                NO
         CR    SR,TR                   FULL RECORD?
         BH    LMOEOR
         CLI   CSDTYP,ESDTER
         BE    LMDESE1                 ER
         CLI   CSDTYP,ESDTWX
         BE    LMDESE1                 WX
         CLI   CSDTYP,ESDTPR           PR?
         BNE   LMDESE2                 NONE OF ABOVE
         IF    CSDFPRCL,LMDESE2        CUMULATIVE LENGTH PR?
LMDESE1  LABEL ,
         LCALL CSDTOESD
LMDESE2  LABEL ,
         LA    R12,CSDNXT
         LA    XRNT,RNTNXT
         C     R12,LCBCSDLC
         BNL   LMOESEND
         CR    SR,TR
         BNH   LMOESER
         SPACE
LMOEOR   LR    RAR,SR
         LA    TR,MRESD                START OF ESD DATA
         SR    RAR,TR                  COUNT
         STH   RAR,MRESDCNT
         IF    NZ,'LR R14,SR'          FOR NEXT RECORD
         IF    ^LCBMFCSD,LMOESD        FINISHED CSDS?
         B     LMOIDRGO                START TEXT OUTPUT
         SPACE
LMOESEND SET   LCBMFCSD                CSD END
         B     LMOEOR                  CLEAN UP RECORD
         SPACE
LMOEOBES ST    R12,LCBMOCSD
         ST    XRNT,LCBMORNT
         STH   R10,LCBMOID
LMOEOB   SL    R14,WAR1                START OF BUFFER
         ST    R14,WAR0
         B     EXIT
         SPACE
CSDTOESD LABEL ,                       CREATE ESD FROM CSD
         MVC   ESD(L'ESDNAME+L'ESDADDR+L'ESDLNG),CSDNAME
         MVI   CSDTYP,ESDTNL           DESTROY CSD ENTRY
         SET   RNTFUSE
         STH   R10,RNTCSD              RLD RENUMBER VALUE
         LA    R10,@R10+1
         LA    SR,ESDNXT
         BR    RAR
         DROP  SR                      ##
         DROP  R12,XRNT                ##
         EJECT
* IDR RECORD
*
LMOIDRGO LABEL ,
         IF    LCBMFIDR,LMOTXTGO       IDRS FINISHED?
         LA    TR,MRIDREND             END OF ORVYL IDR RECORD
         CR    TR,15                   ROOM?
         BH    LMOEOB                  CATCH YOU NEXT TIME
         CLEAR (MRIDR,MRIDRSIZ)        CLEAR RECORD
         MVC   MRID(3),=AL1(MRIDRID,MRIDRSIZ,MRIDRORV+MRIDRLST)
         MVC   MRIDRFL,LCBIDRFL
         MVC   MRIDREP,LCBEP
         MVC   MRIDRMSZ,LCBLC
         SET   LCBMFIDR                IDR FINISHED
         LR    R14,TR                  END OF DATA
         EJECT
* CONTROL RECORD/TEXT OUTPUT
*        - ALL TEXT IS PROCESSED BEFORE ANY RLDS ARE OUTPUT
*
         L     R10,LCBSD               INIT POINT
         ST    R10,LCBMOSD             SD POINTER
         CLEAR R1
         ST    R1,LCBMOLC              OUTPUT LOC COUNTER
         LA    SR,MRRLD                START OF CONTROL INFO
         USING CTL,SR                  ##
         LA    TR,CTLNXT               ROOM FOR AN SD?
         CR    TR,R15
         BH    LMOEOB                  NO ROOM
         DROP  SR                      ##
         B     LMDTXTG1
         SPACE
LMOTXTGO LABEL ,                       CONTINUE POINT
         IF    LCBMFCCW,LMOCCW         READY TO PASS CCW?
         IF    LCBMFTXT,LMORLDGO       FINISHED WITH TEXT?
         L     R1,LCBMOLC              CONTINUE LOC COUNTER
         L     R10,LCBMOSD             CONTINUE SD ITEM
         SPACE
LMDTXTG1 LABEL ,
         L     QR,LCBLC                END OF ALL TEXT
         SR    QR,R1                   HOW FAR TO GO
         CH    QR,LCBMOMTB             MAX TEXT BLOCK
         IF    NL,BEGIN
         LH    QR,LCBMOMTB             USE MAX
         N     QR,=X'00007FF8'
         IF    ZERO,'BAS R15,PROCERR'
         END   ,
         ST    R1,LCBMOCCW             START ADDRESS
         ST    QR,LCBMOCCW+4           COUNT
         LA    R1,@R1(QR)              NEXT TEXT BLOCK START
         ST    R1,LCBMOLC
         LA    SR,MRRLD                START OF CONTROL INFO
         USING CTL,SR                  ##
         LA    TR,CTLNXT
         CR    TR,15                   ROOM FOR ONE?
         BH    LMOEOBTX
         LA    TR,MRRLD+L'MRRLD
         CR    TR,15
         IF    GT,'LR TR,R15'
         SH    TR,=Y(CTLSIZE)          WARNING POINT
         CLEAR (MRC,MRRLD-MRC)
         MVI   MRID,MRCTLID
LMOTXLP  LH    R12,@R10                ID OF CURRENT SD
         LR    R1,R12
         LCALL RNTFU
         USING RNT,XRNT                ##
         MVC   CTLID,RNTCSD            RENUMBERED ID
         DROP  XRNT                    ##
         SPACE
         MH    R12,=Y(L'CSD)
         AL    R12,LCBCSD
         USING CSD,R12                 ##
         IF    CSDFPAG,BEGIN           HANDLE PAGE BOUNDARIES
         L3    R1,CSDADDR+1            RESET OLD LOCATION COUNTER
         ST3   R1,LCBMOLC+1
         CLEAR CSDFPAG                 WON'T HANDLE AS PAGE CASE AGAIN
         IF    (QR,EQ,LCBMOCCW+4),LMOTXTGO IF 1ST SD THIS PASS
         SR    QR,QR                   WRITE TEXT NEXT PASS IF NOT 1ST
         B     LMDTXL5
         END   ,
         SPACE
         LT    R1,CSDLNG
         IF    ZERO,BEGIN
         LA    R10,@R10+2              SKIP NULL SD
         B     LMOTXLP
         END   ,
         SR    QR,R1                   SUBTRACT CSECT FROM BLOCK
         IF    MIN,BEGIN               NO OVERFLOW
         LCR   QR,QR                   OVERFLOW AMOUNT
         ST    QR,CSDLNG               SAVE FOR NEXT TIME
         SR    R1,QR                   AMOUNT INCLUDED IN BLOCK
         SR    QR,QR                   DENOTE FULL BLOCK
         B     LMDTXL5
         END   ,
         DROP  R12                     ##
         SPACE
         LA    R10,@R10+2              SD COMPLETE
LMDTXL5  LABEL ,
         STH   R1,CTLLNG               CONTROL ITEM COMPLETE
         LA    SR,CTLNXT
         C     R10,LCBSDLC             LAST SD?
         BNL   LMOTXEND                THAT'S ALL FOLKS
         LTR   QR,QR                   BLOCK FULL?
         BZ    LMOEOBTX
         CR    SR,TR
         BNH   LMOTXLP
         L     R1,LCBMOLC              ADJUST OLC AS WE DIDN'T GET
         SR    R1,QR                   AS FAR AS WE THOUGHT WE
         ST    R1,LCBMOLC              WOULD
         DROP  SR                      ##
         SPACE
LMOEOBTX L     R1,LCBMOCCW+4
         SR    R1,QR
         ST    R1,LCBMOCCW+4
         MVC   MRCCW,LCBMOCCW          PUT INTO CONTROL RECORD
         MVI   MRCCW,6
         MVI   MRCCW+4,X'40'
         SET   LCBMFCCW                CATCH CCW NEXT TIME
         ST    R10,LCBMOSD
         LR    RAR,SR
         LA    TR,MRRLD                START OF CONTROL DATA
         SR    SR,TR                   COUNT
         STH   SR,MRCTLCNT
         LR    R14,RAR                 NEXT RECORD POINTER
         B     LMOEOB
         SPACE
LMOTXEND SET   LCBMFTXT                TEXT COMPLETED
         L     R1,LCBRLD               FIRST RLD
         SH    R1,=Y(L'RLD)
         ST    R1,LCBMORLD             INITIALIZE FOR OUTPUT
LMRLDCHK IF    (R1,LE,LCBRLDLC),LMRLDNON
         USING RLD,R1                  ##
         IF    ('CLEAR RLDFN',NZ),LMOEOBTX RLDS EXIST
         DROP  R1                      ##
         SH    R2,=Y(L'RLD)
         B     LMRLDCHK
*
LMRLDNON OI    MRID,MREOSID+MREOMID    MARK MODULE END
         SET   LCBMFRLD                AND NO RLD'S
         B     LMOEOBTX
         EJECT
* PASS CCW BACK TO CALLER FOR WRITING TEXT
*
LMOCCW   LABEL ,
         LM    SR,TR,LCBMOCCW
         AL    SR,LCBCORE
         ST    SR,WAR1
         ST    TR,WAR0
         CLEAR LCBMFCCW
         B     EXIT
         EJECT
* CONSTRUCT RLD RECORDS
*
LMORLDGO L     R12,LCBMORLD            NEXT RLD TO OUTPUT
         IF    LCBMFRLD,LMOBYBY        RLD'S DONE?
         USING RLD,R12
LMORLREC LABEL ,
         ST    R12,LCBMORLD
         LA    SR,MRRLD-4              START OF RLD DATA
         SPACE
         LA    TR,MRRLD+8              END OF FIRST RLD ITEM
         CR    TR,15                   WILL ONE FIT?
         BH    LMOEOB                  NO
         SPACE
         CLEAR (MRC,MRRLD-MRC)
         MVI   MRID,MRRLDID            START RLD RECORD
         LA    TR,MRRLD+L'MRRLD        MAX RECORD LENGTH
         CR    TR,15                   WILL IT FIT
         IF    GT,'LR TR,R15'          DON'T BE FUSSY
         SH    TR,=Y(8)                RECORD END WARNINH
         SPACE
         CLEAR (LDWRANDP,4)
         SPACE
LMORLDLP C     R12,LCBRLDLC            ANY MORE RLDS?
         BL    LMORLEND                NO
         CR    SR,TR                   NEAR END?
         BH    LMOEORRL                YES
         CLEAR RLDFN
         BZ    LMORLNX1                FLAG IS ZERO: SKIP
         CLC   LDWRANDP(4),RLDR        SAME R&P AS LAST?
         BNE   LMORLNEW                NO
         SET   @SR.RLDFN               CHAIN THIS TO LAST
LMORLNXT LA    SR,@SR+4                NEXT FA SLOT
         MVC   @SR(4),RLDADDR          FA
LMORLNX1 SH    R12,=Y(L'RLD)
         B     LMORLDLP                NEXT...
         SPACE
LMORLNEW LH    R1,RLDP
         LCALL RNTF                    ADDRESS RNT FOR P
         USING RNT,XRNT
         IF    ^RNTFUSE,LMORLNX1       CSECT IN USE
         CR    SR,TR                   ENOUGH FOR R,P, AND ADDR TOO?
         BNL   LMOEORRL                CATCHA NEXT TIME
         LA    SR,@SR+4                NEXT ENTRY
         MVC   @SR+RLDP-RLD(2),RNTCSD   RENUMBER P
         LH    R1,RLDR
         LCALL RNTFU
         MVC   @SR+RLDR-RLD(2),RNTCSD
         DROP  XRNT                    ##
         MVC   LDWRANDP(4),RLDR
         B     LMORLNXT
         SPACE
LMORLEND SET   LCBMFRLD                END OF RLDS
         OI    MRID,MREOSID+MREOMID    END OF SEGMENT/MODULE
         LR    R15,SR                  FORCE END OF BLOCK
         SPACE
LMOEORRL LA    SR,@SR+4
         LR    RAR,SR
         LA    TR,MRRLD
         SR    SR,TR
         BZ    LMORLNUL                NULL RLD RECORD
         STH   SR,MRRLDCNT
LMDEORR1 LABEL ,
         C     R12,LCBRLDLC            OUT OF RLD'S YET?          RWC12
         BNH   LMDEORR2                YES
         CLEAR RLDFN                   TEST FOR NULL RLD          RWC12
         BNZ   LMDEORR3                NOT NULL
         SH    R12,=Y(L'RLD)           SKIP NULL                  RWC12
         B     LMDEORR1                TEST FOR RLD END
         SPACE ,                                                  RWC12
LMDEORR2 LABEL ,
         OI    MRID,MREOSID+MREOMID    MARK END OF SEGMENT/MODULE
         SET   LCBMFRLD                THAT'S ALL THE RLDS
LMDEORR3 LABEL ,
         LR    R14,RAR
         B     LMORLREC                NEXT RLD RECORD
         SPACE 1
LMORLNUL C     R14,WAR1                NULL BLOCK?
         BNE  LMOEOB                   OUTPUT BLOCK
         DROP  R12                     ##
         SPACE
LMOBYBY  L     RAR,WARAR               SIGNAL END OF OUTPUT
         LA    RAR,@RAR+4
         ST    RAR,WARAR
         B     EXIT
         DROP  R14                     ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
*  CSD SCAN ROUTINES
*
*
*   PREPARE FOR SCAN
*
LDSET    VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         MVC   LCBSRCH,LCBCSDH         POINT AT CSD
         B     EXIT
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
*
*    SCAN FOR NEXT ENTRY
*
LDNEXT   VENTER R0,R14,LDWASZ
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         CLEAR R15                     CODE IF NOTHING FOUND
         CLEAR (WAR0,8)
         LT    SR,LCBSRCH              POINT AT NEXT CSD
         BZ    EXITR15                 END OF SEARCH
         USING CSD,SR                  ##
LDFND    LABEL ,
         LA    R15,CSDNAME             PASS NAME
         CLEAR R1
         BCTR  R1,0                    PRESET UNDEFINED CODE (-1)
         L     R0,CSDLNG               AND LENGTH
         IF    ^CSDFDEF,LDNEX
         L3    R1,CSDADDR+1            LOCATION
         AL    R1,LCBCORE
LDNEX    STM   R0,R1,WAR0              RETURN REGS
         L     SR,CSDLINK
LDSRTN   ST    SR,LCBSRCH              FOR SUBSEQUENT SEARCH
         B     EXITR15
         DROP  SR                      ##
         DROP  BR,BRR,WAR,LCBR         ##
         EJECT
*  LOOK UP SYMBOL IN CSD
*
LDFIND   VENTER R0,R14,LDWASZ
*
*        R1 POINTS TO SYMBOL BEING SOUGHT
*        15 RETURNS CSDNAME POINTER
*        R1 RETURNS ADDRESS OF SYMBOL(-1 IF UNDEFINED)
*        R0 RETURNS LENGTH OF CSECT(IF ITEM IS SD)
*        R15 SET TO ZERO IF SYMBOL NOT FOUND
*
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         CLEAR R15                     INDICATE NOT FOUND
         LA    SR,LCBCSDH              GET CSD CHAIN
         USING CSD,SR                  ##
LSA      L     SR,CSDLINK              NEXT LINK
         CLC   CSDNAME,@R1             FOUND?
         BL    LSA                     KEEP LOOKINK
         BE    LDFND                   HIT ON THE NOSE
         B     LDSRTN
         DROP  SR                      ##
         EJECT
*  LOOK UP ADDRESS IN CSD
*
LDSECT   VENTER R0,R14,LDWASZ
*
*        1 CONTAINS ADDRESS BEING SOUGHT
*        15 RETURNS CSDNAME POINTER OF CSECT CONTAINING ADDRESS
*        R1 RETURNS ADDRESS OF CSECT
*        R0 RETURNS LENGTH OF CSECT
*        R15 SET TO ZERO IF CSECT NOT FOUND
*
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         CLEAR R15                     'NOT FOUND' CODE
         LA    SR,LCBCSDH              GET CSD CHAIN
         LR    QR,R1
         SL    QR,LCBCORE
         USING CSD,SR                  ##
LDSECT1  LABEL ,                       LOOP RETURN
         LT    SR,CSDLINK              NEXT LINK
         BZ    EXITR15                 GIVE BAD NEWS
         CLI   CSDTYP,ESDTSD           SECTION?
         BNE   LDSECT1                 NO
         L3    TR,CSDADDR+1
         CR    QR,TR                   ADDR AFTER SECTION START?
         BL    LDSECT1                 NO
         LR    R1,QR
         SR    R1,TR
         C     R1,CSDLNG
         BNL   LDSECT1                 NOT IN SECTION
         AL    TR,LCBCORE
         ST    TR,WAR1
         MVC   WAR0,CSDLNG
         LA    R15,CSDNAME
         B     EXITR15
         DROP  SR                      ##
*  LOOK UP ADDRESS IN CSD
*
LDENTRY  VENTER R0,R14,LDWASZ
*
*        1 CONTAINS ADDRESS BEING SOUGHT
*        15 RETURNS CSDNAME POINTER OF ENTRY CONTAINING ADDRESS
*        R1 RETURNS ADDRESS OF ENTRY
*        R15 SET TO ZERO IF CSECT NOT FOUND
*
         LM    BRR,BR,=A(BASE+4096,BASE)
         USING BASE,BR,BRR             ##
         USING LDWA,WAR                ##
         USING LCB,LCBR                ##
         SPACE
         CLEAR R15                     'NOT FOUND' CODE
         LA    SR,LCBCSDH              GET CSD CHAIN
         LR    QR,R1
         SL    QR,LCBCORE
         USING CSD,SR                  ##
LDENTRY0 LABEL ,                       LOOP RETURN
         LT    SR,CSDLINK              NEXT LINK
         BZ    EXITR15                 GIVE BAD NEWS
         CLI   CSDTYP,ESDTSD           SECTION?
         BNE   LDENTRY0                NO
         L3    RR,CSDADDR+1
         CR    QR,RR                   ADDR AFTER SECTION START?
         BL    LDENTRY0                NO
         LR    R1,QR
         SR    R1,RR
         C     R1,CSDLNG
         BNL   LDENTRY0                NOT IN SECTION
         CLEAR R0,R14
         LA    SR,LCBCSDH              GET CSD CHAIN
LDENTRY1 LABEL ,
         LT    SR,CSDLINK              NEXT LINK
         BZ    LDENTRY8
         CLI   CSDTYP,ESDTLD           ENTRY POINT?
         BE    LDENTRY5                YES
         CLI   CSDTYP,ESDTLR           ENTRY POINT?
         BNE   LDENTRY1                NO
LDENTRY5 LABEL ,
         L3    TR,CSDADDR+1
         CR    QR,TR                   AFTER ENTRY?
         BL    LDENTRY1                NO
         CR    TR,R0                   HIGHEST ENTRY THUS FAR?
         BL    LDENTRY1                NO
         CR    TR,RR                   ENTRY IN SECTION
         BNH   LDENTRY1                NO
         LR    R0,TR                   GET ADDRESS
         LR    R14,SR                  GET POINTER
         B     LDENTRY1                CONTINUE
LDENTRY8 LABEL ,
         LTR   R14,R14                 ENTRY POINT FOUND?
         BZ    EXITR15                 GIVE BAD NEWS
         LR    SR,R14
         AL    R0,LCBCORE
         ST    R0,WAR1
         LA    R15,CSDNAME
         B     EXITR15
         DROP  SR                      ##
         EJECT
*  CONSTANTS
*
         LTORG
         END   .
