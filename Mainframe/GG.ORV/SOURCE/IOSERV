IOSERV   TITLE 'ORVYL''S I/O Service Routines'
         COPY  HEADER
         EJECT
IOSERV   MODULE
         SPACE 2
*                                      ACB, RPL, DCB, DEB, UCB, DCE,
*                                      DVCT, PSA, ASCB, TCB, SRB,
*                                      TIOT, IOSB, IOCM, DYNALLOC,
         PRINT OFF                     JFCB
*GEN
         EJECT
         IEFZB4D0
         EJECT
         IEFZB4D2
         EJECT
         IFGACB
ACBSIZE  EQU   *-IFGACB
         EJECT
         IFGRPL
RPLSIZE  EQU   *-IFGRPL
         EJECT
         DCBD  DSORG=(PO,PS,DA),DEVD=(TA,DA)
         EJECT ,
         IEZDEB
         EJECT
         IECDIOSB
         EJECT
         IEFUCBOB LIST=NO,PREFIX=YES
         EJECT
         IECDDCE
         EJECT
         IHADVCT
         EJECT
         IECDIOCM
         EJECT
DSCB     DSECT
         IECSDSL1 1
         EJECT
TIOT     DSECT
         IEFTIOT1
         EJECT
JFCB     DSECT
         IEFJFCBN
         EJECT
         IHASRB
         EJECT ,
         IHAPSA
         EJECT
         CVT DSECT=YES
         EJECT ,
         IHAASCB
         EJECT
         IKJTCB
         EJECT
         IHASDWA VRAMAP=NO
         PRINT ON
*NOGEN
IOSERV   CSECT
         EJECT
         COPY  CBAT
         EJECT
         COPY  RTCB
         EJECT
         COPY  POOLPARM
         SPACE 3
         COPY  FIXPARM
         EJECT
         COPY  MEMPARM
         EJECT
         COPY  ESTAPARM
         EJECT
         COPY  SPNPARM
         SPACE 3
         COPY  SBTPARM
         SPACE 3
         COPY  CANPARM
         EJECT
         COPY  SEGPARM
         EJECT
         COPY  DUMPPARM
         EJECT
*******************************************************************
*                                                                 *
*    MSGPARM - Message routine calling parms                      *
*                                                                 *
*******************************************************************
         SPACE
         COPY  MSGPARM
         EJECT
         COPY  LOCKPARM
         SPACE 3
         COPY  WAITPARM
         SPACE 3
         COPY  POSTPARM
         EJECT
         COPY  IORPARM
         EJECT
*******************************************************************
*                                                                 *
*    IOCT - I/O Service Control Table                             *
*                                                                 *
*    Modified for Hiperspace support                              *
*                                                                 *
*******************************************************************
         SPACE
IOCT     RECORD BEGIN
         DC    CL4'IOCT'
IOCTIOCB DS    D                       Chain of all IOCB's
IOCTFIOB DS    D                       Chain of free IOCB's
IOCTCIOB DS    D                       Chain of complete IOCB's
*
IOCTSWPA DS    D                       Chain of available swap areas
IOCTSWPS DS    A                       Size of the swap area
*
IOCTDDBS DS    A                       Chain of DDB's
IOCTJDBS DS    A                       Chain of JDB's
IOCTPTHS DS    A                       Chain of SDB's
IOCTHDBS DS    A                       Chain of HDB's
IOCTSNDB DS    A                       Chain of SNAP DUMP SNDBs
*
IOCTDDBL DS    A                       DDB lock id
IOCTJDBL DS    A                       JDB lock id
IOCTPTHL DS    A                       SDB lock id
IOCTSNTL DS    A                       PATH notify lock id
IOCTHDBL DS    A                       HDB lock id
IOCTSNPL DS    A                       SNAP DD lock id
*
IOCTSTID DS    A                       SCOM task id
IOCTMTID DS    A                       MVS I/O task id
IOCTJTID DS    A                       JES I/O task id
IOCTHTID DS    A                       Hiperspace task id
*
IOCTSNFP DS    A                       SCOM notify chain forward
IOCTSNBP DS    A                       SCOM notify chain backward
*
IOCTCDL  DS    A                       Address of cache device list
IOCTAM24 DS    A                       Address of AMODE 24 routine
*
IOCTASCB DS    A                       ASCB pointer
IOCTASID DS    H                       ASCB ID
IOCTKEY  DS    X                       Protect key
IOCTTS   DS    X                       Hiperspace termination TS lock
*
IOCTMTCB DS    A                       MVS I/O task TCB
IOCTHSIZ DS    A                       Hiperspace max size
IOCTPGLM DS    H                       Page DS simulation limit
IOCTSWLM DS    H                       Swap DS simulation limit
IOCTPGNO DS    H                       Page DS simulation count
IOCTSWNO DS    H                       Swap DS simulation count
IOCTSNCT DS    H                       SNAP DD count
IOCTHSCT DS    H                       Hiperspace count
         DS    3A                      Spare
IOCTTTOK DS    CL16                    Jobstep TCB
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    IOT - I/O Service Task Table                                 *
*                                                                 *
*******************************************************************
         SPACE
IOT      RECORD BEGIN
         DC    CL4'IOT'
*
IOTSTMC  DS    A                       SCOM message channel id
IOTSBUFF DS    A                       SCOM buffer
IOTSBLEN DS    A                       SCOM buffer length
IOTMTMC  DS    A                       MVS I/O message channel id
IOTJTMC  DS    A                       JES I/O message channel id
IOTHTMC  DS    A                       HSPACE msg channel id
         END   ,
         SPACE 3
         COPY  GSTIPARM
         EJECT
*******************************************************************
*                                                                 *
*    IOCB - I/O Control Block                                     *
*                                                                 *
*******************************************************************
         SPACE
IOCB     RECORD BEGIN
         DS    CL4'RICB'               Id
IOCBMCHN DS    A                       Master chain
IOCBFCHN DS    A                       Free/complete chain
IOCBIOCT DS    A                       IOCT pointer
IOCBRQID DS    A                       Request ID
IOCBDDB  DS    A                       DDB address
IOCBSCCW DS    A                       Swap I/O CCW block chain
         DS    A                       Available
IOCBECB  DS    A                       ECB
IOCBSTK  DS    A                       Stack pointer
IOCBSTRT DS    D                       I/O start time
IOCBSTOP DS    D                       I/O stop time
IOCBCCW  DS    7D                      CCW area
IOCBIDAW DS    4A                      IDAW area
IOCBDEXD DS    XL16                    Data for Define Extent CCW
IOCBLCRD DS    XL16                    Data for Locate Record CCW
IOCBPDAT DS    XL10                    Data for Set Page Parm CCW
IOCBDBLK DS    XL2                     Data for Discard Block CCW
IOCBSECT DS    X                       Data for Set Sector CCW
IOCBFM   DS    X                       Data for Set Filemask CCW
IOCBFLG  FLAG  ,
         FLAG  IOCBPECB                Post ECB when I/O complete
         DS    0D
IOCBSRB  DS    XL(SRBSIZE)             SRB
IOCBIOSB DS    XL(L'IOSBSTD)           IOSB
         END   ,
         EJECT
*
* IRCB -- This control block represents an I/O request from the
*         guest machine.  Its address is stored in @IORRQID in
*         parameter area @IORB which was passed from GSTINTF
*         where it was created and mapped with an IOCB prefix
*         and assigned an acronym of IOCB.
*
IRCB     RECORD BEGIN
         DC    C'IOCB'
IRCBNEXT DS    A             Address of the next IRCB
IRCBGSTC DS    A             Address of the GSTCT
*
* Information from the Request
*
IRCBSCH  DS    A             Subchannel ID word
IRCBIPRM DS    A             Interruption parameter
IRCBIFLG DS    A             I/O flags
IRCBCPA  DS    A             Address of the channel program
IRCBORB  EQU   IRCBIPRM,*-IRCBIPRM,C'X'          The ORB
IRCBSTAT DS    A             Subchannel status word (from IOSERV)
*** SIMULATION CODE ***
IRCBHSP  DS    CL1           Hiperspace in use flag
         DS    0F
*** END OF SIMULATION CODE ***
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    BCHPARM - Block to CCHHR conversion parameters               *
*                                                                 *
*******************************************************************
         SPACE
@BCH     RECORD BEGIN
@BCHDSID DS    A                       Data Set ID
@BCHBLK  DS    A                       Block number
@BCHSECT DS    X                       Sector number
*
@BCHSKM  DS    X                       Extent number
@BCHSKBB DS    H                       Bin number
@BCHSKCC DS    H                       Cylinder
@BCHSKHH DS    H                       Head
@BCHSKR  DS    X                       Record
@BCHSEEK EQU   @BCHSKM                 Seek address
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    SIOPARM - Start I/O request parameters                       *
*                                                                 *
*******************************************************************
         SPACE
@SIO     RECORD BEGIN
@SIOIOCB DS    A                       I/O control block
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    BPTPARM - Calculate blocks per track request parameters      *
*                                                                 *
*******************************************************************
         SPACE
@CTRACK  RECORD BEGIN
@CTRUCB  DS    A                       UCB address
@CTRBSZ  DS    H                       Block size
@CTRKEY  DS    X                       Key length
         END
         SPACE 3
*******************************************************************
*                                                                 *
*    RPSPARM - Compute RPS value request parameters               *
*                                                                 *
*******************************************************************
         SPACE
@CRPS    RECORD BEGIN
@CRPUCB  DS    A                       UCB address
@CRPBLK  DS    H                       Block number
@CRPBSZ  DS    H                       Block size
@CRPKEY  DS    X                       Key length
         END
         EJECT
*****************************************************************
*                                                               *
*   COMDB  --  Common prefix for Descriptor Blocks              *
*                                                               *
*****************************************************************
         SPACE
COMDB    RECORD BEGIN
COMDBID  DS    CL4                     Id
COMDBRTN DS    A                       Service Routine
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*              JDB - JES data set Descriptor Block                *
*                                                                 *
*******************************************************************
         SPACE
JDB      RECORD BEGIN
         DS    XL(L'COMDB)             Room for common portion
JDBCHAIN DS    A                       Chain
JDBACB   DS    A                       ACB address
JDBDDNAM DS    CL8                     DD Name
         END
         EJECT
*******************************************************************
*                                                                 *
*              SNDB - Snap Dump Descriptor Block                  *
*                                                                 *
*   New for Snap Dump Processing of Guest areas                   *
*                                                                 *
*******************************************************************
         SPACE
SNDB      RECORD BEGIN
         DS    XL(L'COMDB)             Room for common portion
SNDBCHN  DS    A                       Chain
SNDBDCB  DS    A                       DCB address
SNDBDDN  DS    CL8                     DD Name
SNDBDCBE DS    A                       DCBE
         END
         EJECT
*******************************************************************
*                                                                 *
*              DDB - Data set Descriptor Block                    *
*                                                                 *
*******************************************************************
         SPACE
DDB      RECORD BEGIN
         DS    XL(L'COMDB)             Room for common portion
DDBCHAIN DS    A                       Chain
DDBDCB   DS    A                       DCB address
DDBDEB   DS    A                       DEB address
DDBRPS   DS    A                       RPS table
         DS    A                       Available
*
*  Statistical Information
*
DDBRDCT  DS    A                       Number of reads
DDBWRCT  DS    A                       Number of writes
DDBIOTIM DS    D                       Total I/O time
*
*  Data Set Information
*
DDBBLKCT DS    A                       Number of blocks
DDBBT    DS    A                       Blocks per track
DDBDDNAM DS    CL8                     DD name
DDBDSN   DS    CL44                    Data set name
DDBDMNAM DS    CL8                     Member name
*
*  Device Information
*
DDBTRC   DS    A                       Tracks per cylinder
DDBUCB   DS    A                       UCB address
DDBCUCBS DS    3A                      Caching controller exposures
DDBCUNXT DS    A                       Round robin index
DDBVOL   DS    CL6                     Volume ID
DDBFEAT  DS    X                       Features from DCE/Sense ID
*
*  DCB Information
*
DDBDSORG DS    X                       Data Set Organization
DDBRECFM DS    X                       Record Format
DDBKEYL  DS    X                       Key length
DDBLRECL DS    H                       Record length
DDBBLKSZ DS    H                       Block size
*
*  Disk Allocation Information
*
DDBALCU  DS    X                       Allocation units
DDBXTNT  DS    X                       Number of extents
DDBALQU  DS    A                       Allocation quantity
DDBTRKS  DS    H                       Number of tracks
*** SIMULATION CODE ***
DDBHDB   DS    A                       Address of HDB
*** END OF SIMULATION CODE ***
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*              HDB - Hiperspace Descriptor Block                  *
*                                                                 *
*  New for Hiperspace support                                     *
*                                                                 *
*******************************************************************
         SPACE
HDB      RECORD BEGIN
         DS    XL(L'COMDB)             Room for common portion
HDBCHAIN DS    A                       Chain
HDBHSNAM DS    CL8                     Hiperspace name
HDBORIG  DS    CL4                     Hiperspace origin
HDBALET  DS    CL4                     Hiperspace ALET
HDBTOKEN DS    CL8                     Hiperspace token
HDBHPSIZ DS    CL4                     Hiperspace size
HDBFLG   FLAG  ,
         FLAG  HDBSTND        STANDARD HIPERSPACE
         FLAG  HDBESO         EXTENDED STORE ONLY HSPACE
         FLAG  HDBPAGE        MIMICKING PAGE IO
         FLAG  HDBSWAP        MIMICKING SWAP IO
         FLAG  HDBOPEN        HIPERSPACE HAS BEEN OPENED
*
*  Statistical Information
*  Note that updates to these fields are not always serialized.
*  Take them with a grain of salt.
*
HDBRDFR  DS    A                       HSPACE frame reads done
HDBWRFR  DS    A                       HSPACE frame writes done
HDBMVRD  DS    A                       MVPG frame reads done
HDBMVWR  DS    A                       MVPG frame writes done
HDBRCT   DS    A                       Frame reads requested
HDBWCT   DS    A                       Frame writes requested
HDBRDCT  DS    A                       Read request count
HDBWRCT  DS    A                       Write request count
HDBRWRT  DS    A                       Rewrite to ESTOR count
HDBIOTIM DS    2A                      Total I/O time
HDBSTIMN DS    A                       Total min STIMER waits
HDBSTIMX DS    A                       Total max STIMER waits

*** SIMULATION CODE ***
HDBDDB   DS    CL4
*** END OF SIMULATION CODE ***
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*     SDB  -  SCOM Device Descriptor Block                        *
*                                                                 *
*******************************************************************
         SPACE
SDB  RECORD BEGIN
*
*  LOCAL FIELDS
*
         DS    XL(L'COMDB)             Room for common portion
SDBFP    DS    A                       PATH WAIT FORWARD CHAIN
SDBBP    DS    A                       PATH WAIT BACKWARD CHAIN
SDBRQID  DS    A                       USER REQUEST ID
SDBCHN   DS    A                       ACTIVE PATH CHAIN
SDBBUFS  DS    A                       SCOM BUFFER CHAIN WORD
SDBPFL   DS    X                       PATH POST FLAGS
SDBFLGS  FLAG  ,
         FLAG  SDBFNTFY                SDB ON NOTIFY CHAIN
         DS    AL2                     RESERVED
         DS    0D
         PATH  VERSION=2
         END
         EJECT
*******************************************************************
*                                                                 *
*    CCW - Channel Command Word - Format 1                        *
*                                                                 *
*******************************************************************
         SPACE
CCW      RECORD BEGIN
CCWCMD   DS    X                       CCW command code
*
CCWRD    EQU   X'06'                   Read data
CCWRKD   EQU   X'0E'                   Read key and data
CCWRCKD  EQU   X'1E'                   Read count, key and data
*
CCWWD    EQU   X'05'                   Write data
CCWWKD   EQU   X'0D'                   Write key and data
CCWWCKD  EQU   X'1D'                   Write count, key and data
CCWWU    EQU   X'85'                   Write update data
CCWWUKD  EQU   X'8D'                   Write update key and data
*
CCWSIDEQ EQU   X'31'                   Search id equal
CCWSTSEC EQU   X'23'                   Set sector
CCWSEEK  EQU   X'07'                   Seek
CCWTIC   EQU   X'08'                   Transfer in channel
CCWNOP   EQU   X'03'                   No-op
CCWSFM   EQU   X'1F'                   Set File Mask
*
CCWSTPP  EQU   X'8B'                   Set paging parameters
CCWDLBLK EQU   X'8F'                   Delete block
CCWDEFEX EQU   X'63'                   Define extent
CCWLOCRC EQU   X'47'                   Locate record
CCWMT    EQU   X'80'                   Multi-track mode flag
*
CCWFLAGS DS    X                       Flags
*
CCWDATCH EQU   X'80'                   Data chaining
CCWCMDCH EQU   X'40'                   Command chaining
CCWSLI   EQU   X'20'                   Ignore incorrect length
CCWSKIP  EQU   X'10'                   Suppress data transfer
CCWPCI   EQU   X'08'                   PCI
CCWIDA   EQU   X'04'                   IDAWs are supplied
CCWSUSP  EQU   X'02'                   Suspend channel program
*
CCWLEN   DS    H                       Data length
*
CCWADDR  DS    A                       Data address
         END   ,
         EJECT
         COPY  PARMPARM
*******************************************************************
*                                                                 *
*  HPRMWORK - Hiperspace initializion parameter work area         *
*                                                                 *
*******************************************************************
         SPACE
HPRMWORK  RECORD BEGIN
HPRMPARM DS    XL(L'PARMIN)            Parmin area
HPRMKEY1 DS    CL8                     Key 1
HPRMKEY2 DS    CL8                     Key 2
HPRMKEY3 DS    CL8                     Key 3
HPRMVAL  DS    A                       Integer value
HPRMSTR  DS    CL80                    String parameter area
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    IOTERM - I/O Termination routine pointed to by IOSPGAD in    *
*             the IOSB.  This routine is entered in SRB mode.     *
*                                                                 *
*                                                                 *
*     Input - R1 points at IOSB                                   *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
IOTERM   LABEL ,
         USING *,R9
         LR    R9,R15
         LR    R5,R1                   GET IOSB ADDRESS
         USING IOSB,R5
         L     R4,IOSUSE               GET IOCB ADDRESS
         USING IOCB,R4
         STCK  IOCBSTOP                I/O END TIME
         LR    R3,R14                  SAVE RETURN ADDRESS
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
*
*  GUARANTEE THE LOCAL LOCK
*
*GEN
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,LOCKOK)
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=IOTLOCK
*NOGEN
LOCKOK   LABEL ,
         EJECT
*
*  ENTER PURGE ROUTINE IF NECESSARY
*
         L     R1,IOSIPIB
         IF    (R1,NZ),BEGIN
         CLEAR R0                      INDICATE LOCAL LOCK HELD
         L     R15,CVTPTR
         WITH  (CVT,R15),'L R15,CVTIXAVL'   IOS VECTOR TABLE
         WITH  (IOCOM,R15),'ACALL IOCQCNT'   PURGE/QUIESCE
         END   ,
         MODESET KEYADDR=(2)           BACK TO OUR KEY
*
*  NOTIFY GUEST MACHINE
*
         IF    ^IOCBPECB,BEGIN
         L     WAR,IOCBSTK             SET UP
         LA    SPR,@WAR+8               STACK
         PSET  @GSTIIOT
         LH    R0,IOSTATUS             COMPLETION CODE
         IF    (R0,EQ,X'00000C00'),'CLEAR R0'   GOOD COMPLETION
         ST    R0,@GSTICS              COMPLETION STATUS
         MVC   @GSTIRQI,IOCBRQID       Request ID
         VCALL GSTIIOT                 NOTIFY THE USER
         DROP  R5
*
*  UPDATE DATA SET STATISTICS
*
         LM    R0,R1,IOCBSTOP
         SDL   R0,IOCBSTRT             ELAPSED TIME THIS I/O
         STM   R0,R1,IOCBSTOP
         L     R2,IOCBDDB              DDB POINTER
         USING DDB,R2
         LM    R0,R1,DDBIOTIM          CURRENT VALUE
         LOOP  BEGIN
         LR    R14,R0                  COPY
         LR    R15,R1                   CURRENT
         ADL   R14,IOCBSTOP            ADD INTERVAL
         CDS   R0,R14,DDBIOTIM          AND UPDATE
         UNTIL Z,END
         END   ,
         EJECT
*
*  BRANCH TO POST FOR HOST REQUESTS
*
         ELSE  BEGIN
         CLEAR IOCBPECB                CLEAR ECB POST
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
         LA    R11,IOCBECB             ECB address
         CLEAR R10
         L     R15,CVTPTR              CVT address
         WITH  (CVT,R15),'ACALL  CVT0PT02'   POST routine
         MODESET KEYADDR=(2)           BACK TO OUR KEY
         END   ,
*
*  ADD IOCB TO COMPLETE CHAIN
*
         L     R2,IOCBIOCT             IOCT POINTER
         USING IOCT,R2
         LM    R14,R15,IOCTCIOB        COMPLETE CHAIN & COUNT
         LOOP  BEGIN
         ST    R14,IOCBFCHN            OLD HEAD NOW NEXT IN LINE
         LA    R5,1
         ALR   R5,R15                  NEW COUNTER
         CDS   R14,R4,IOCTCIOB         UPDATE COMPLETE CHAIN
         UNTIL Z,END
         DROP  R2,R4
*
*  FREE THE LOCAL LOCK AND RETURN TO DISPATCHER
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
*GEN
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=IOTLOCK   RELEASE LOCK
*NOGEN
         MODESET KEYADDR=(2)           BACK TO OUR KEY
         BSM   0,R3                    RETURN TO DISPATCHER
         EJECT
         LTORG
         SPACE 2
         DS    0S(4096-(*-IOSERV))     LENGTH CHECK
         DROP  ,
         EJECT
*******************************************************************
*                                                                 *
*    IOSINIT - Initialize I/O service routines                    *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
IOSINIT  PROC  SCOPE=GLOBAL
*
*  CREATE THE I/O SERVICE CT
*
         POOLGET L'IOCT                CREATE THE I/O SERVICE CT
         LR    RY,RVR
         WITH  (IOCT,RY)
         MVC   IOCT(4),=CL4'IOCT'      SET NAME FIELD
         USING PSA,R0
         L     R15,PSAAOLD             OUR ASCB
         L     R14,PSATOLD              AND OUR TCB
         DROP  R0
         ST    R15,IOCTASCB            SET ASCB ADDRESS
         WITH  (ASCB,R15),'LH  R15,ASCBASID'
         STH   R15,IOCTASID            | AND ASCB ID
         WITH  (TCB,R14),'MVC  IOCTKEY,TCBPKF'   AND PROTECT KEY
         MVC   IOCTSWPS,=A(1024)       SET SWAP WORK AREA SIZE
         EJECT
*
*  Add IOCT pointer to CBAT
*
         WITH  (RTCB,RTCBR),'L  RS,RTCBCBAT'  GET CBAT POINTER
         WITH  (CBAT,RS),'ST  RY,CBATIOCT'   IOCT POINTER TO CBAT
*
*  SET UP AMODE 24 CAP ROUTINE
*
         POOLGET AM24CLEN,TYPE=(BELOW16M,GLOBAL)
         LR    RX,RVR
         ST    RX,IOCTAM24             SET LOCATION
         L     RS,=A(AM24CAP)          ROUTINE ADDRESS
         MVC   @RX(AM24CLEN),@RS       MOVE TO 24 BIT LOCATION
*
*  CREATE DDB CHAIN LOCK
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM,=CL16'DDB CHAIN'
         VCALL LOCKCRE
         ST    RVR,IOCTDDBL            SAVE THE LOCK ID
*
*   NEW FOR HIPERSPACE SUPPORT
*
*
*  CREATE HDB CHAIN LOCK
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM,=CL16'HDB CHAIN'
         VCALL LOCKCRE
         ST    RVR,IOCTHDBL            SAVE THE LOCK ID
*
*  CREATE JDB CHAIN LOCK
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM,=CL16'JDB CHAIN'
         VCALL LOCKCRE
         ST    RVR,IOCTJDBL            SAVE THE LOCK ID
*
*  CREATE SNDB CHAIN LOCK
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM,=CL16'SNDB CHAIN'
         VCALL LOCKCRE
         ST    RVR,IOCTSNPL            SAVE THE LOCK ID
*
*  CREATE SUSAN PATH CHAIN LOCK
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM,=CL16'SCOM CHAIN'
         VCALL LOCKCRE
         ST    RVR,IOCTPTHL            SAVE THE LOCK ID
*
*  CREATE SUSAN PATH NOTIFY CHAIN
*
         LA    RS,IOCTSNFP-(SDBFP-SDB)   SET DUMMY WAIT CHAIN
         ST    RS,IOCTSNFP               FORWARD AND
         ST    RS,IOCTSNBP               BACKWARD POINTERS
         EJECT
*
*  CREATE SUSAN PATH NOTIFY CHAIN LOCK
*
         PSET  @LOCKCRE
         MVC   @LOCKNAM,=CL16'SCOM NOTIFY'
         VCALL LOCKCRE
         ST    RVR,IOCTSNTL            SAVE THE LOCK ID
*
*  CREATE MVS I/O OPERATIONS SUB-TASK
*
         PSET  @SPAWN
         MVC   @SPNNAME,=CL8'MVSIOTSK'
         MVC   @SPNEP,=A(MVSIOTSK)
         ST    RY,@SPNPARM             IOCT ADDRESS IS THE PARM
         MVC   @SPNDPRI,=A(100)        SLIGHTLY HIGHER PRIORITY
         VCALL SPAWN                   START IT UP
         ST    RVR,IOCTMTID            SAVE TASK ID
*
*  CREATE SCOM SUB-TASK
*
         PSET  @SPAWN
         MVC   @SPNNAME,=CL8'SCOMTASK'
         MVC   @SPNEP,=A(SCOMTASK)
         ST    RY,@SPNPARM             IOCT ADDRESS IS THE PARM
         MVC   @SPNDPRI,=A(100)        SLIGHTLY HIGHER PRIORITY
         VCALL SPAWN                   START IT UP
         ST    RVR,IOCTSTID            SAVE TASK ID
*
*  CREATE JES I/O SUB-TASK
*
         PSET  @SPAWN
         MVC   @SPNNAME,=CL8'JESIOTSK'
         MVC   @SPNEP,=A(JESIOTSK)
         ST    RY,@SPNPARM             IOCT ADDRESS IS THE PARM
         MVC   @SPNDPRI,=A(100)        SLIGHTLY HIGHER PRIORITY
         VCALL SPAWN                   START IT UP
         ST    RVR,IOCTJTID            SAVE TASK ID
*
*  NEW FOR HIPERSPACE SUPPORT
*
         TCBTOKEN TTOKEN=IOCTTTOK,TYPE=JOBSTEP
*
*  CREATE HIPERSPACE SUB-TASK.
*
         PSET  @SPAWN
         MVC   @SPNNAME,=CL8'HSPCETSK'
         MVC   @SPNEP,=A(HSPCETSK)
         ST    RY,@SPNPARM           IOCT ADDRESS IS THE PARM
         MVC   @SPNDPRI,=A(100)      SLIGHTLY HIGHER PRIORITY
         VCALL SPAWN                 START IT UP
         ST    RVR,IOCTHTID          SAVE TASK ID
*
*  OBTAIN THE PARAMETER WORK AREA
*
         MEMGET L'HPRMWORK
         LR    RK,RVR
         WITH  (HPRMWORK,RK)
         WITH  (PARMIN,HPRMPARM)
*
*  OBTAIN THE  HIPERSPACE PARAMETERS
*
         MVC   HPRMKEY1,=CL8'HSPACE'   PRIMARY KEYWORD
*
*  GET HIPERSPACE SIZE FOR PAGE/SWAP DATA SET SIMULATION
*
         CLEAR HPRMKEY3
         CLEAR HPRMVAL
         CLEAR IOCTHSIZ
         CLEAR IOCTPGLM
         CLEAR IOCTSWLM
         PSET  @PARMDO
         MVC   HPRMKEY2,=CL8'MAXSIZE'  SECONDARY KEYWORD
         PMOV  @PARILOC,LA:PARMIN      PARMIN LOCATION
         PMOV  @PARILEN,LA:L'PARMIN+16 LENGTH OF INPUT
         PMOV  @PAROLOC,LA:HPRMVAL     LOCATION OF RETURN AREA
         PMOV  @PAROLEN,LA:L'HPRMVAL   LENGTH OF RETURN AREA
         SET   PARMFINT                INTEGER TO BE RETURNED
         VCALL PARMDO
         IF    (RVR,Z),BEGIN           IF HIPERSPACE MAXSIZE GIVEN
         L     RS,HPRMVAL
         FLOOR RS,=F'144000'           MIN = 1 CURR PAGE DS EXTENT
         CEIL  RS,=F'524288'           MAX HIPERSPACE = 2GB/4096
         ST    RS,IOCTHSIZ             SAVE FOR LATER USE
         END   ,                    OF IF HIPERSIZE MAXSIZE GIVEN
         MVC   HPRMKEY2,=CL8'PAGE'     SECONDARY KEYWORD
         PMOV  @PARILOC,LA:PARMIN      PARMIN LOCATION
         PMOV  @PARILEN,LA:L'PARMIN+16 LENGTH OF INPUT
         PMOV  @PAROLOC,LA:HPRMVAL     LOCATION OF RETURN AREA
         PMOV  @PAROLEN,LA:L'HPRMVAL   LENGTH OF RETURN AREA
         SET   PARMFINT                INTEGER TO BE RETURNED
         VCALL PARMDO
         IF    (RVR,Z),BEGIN           THERE'S LIMIT TO PAGE DS
         L     RS,HPRMVAL                HIPERSPACE SIMULATION
         FLOOR RS,=F'0'                SET DEFAULT TO 0
         STH   RS,IOCTPGLM
         END   ,                    OF THERE'S LIMIT TO SWAP DS
         MVC   HPRMKEY2,=CL8'SWAP'     SECONDARY KEYWORD
         PMOV  @PARILOC,LA:PARMIN      PARMIN LOCATION
         PMOV  @PARILEN,LA:L'PARMIN+16 LENGTH OF INPUT
         PMOV  @PAROLOC,LA:HPRMVAL     LOCATION OF RETURN AREA
         PMOV  @PAROLEN,LA:L'HPRMVAL   LENGTH OF RETURN AREA
         SET   PARMFINT                INTEGER TO BE RETURNED
         VCALL PARMDO
         IF    (RVR,Z),BEGIN           THERE'S LIMIT TO SWAP DS
         L     RS,HPRMVAL                HIPERSPACE SIMULATION
         FLOOR RS,=F'0'                SET DEFAULT TO 0
         STH   RS,IOCTSWLM
         END   ,                    OF THERE'S LIMIT TO SWAP DS
         QSNAP IOCT,L'IOCT-1
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    IOSTINIT - Initialize task based I/O service routines        *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
IOSTINIT PROC  SCOPE=GLOBAL
*
*  CREATE THE I/O TABLE
*
         MEMGET L'IOT,TYPE=LOCAL       CREATE THE I/O TABLE
         LR    RY,RVR
         WITH  (IOT,RY)
         MVC   IOT(4),=CL4'IOT'        SET NAME FIELD
*
*  Add IOT pointer to RTCB
*
         WITH  (RTCB,RTCBR),'ST  RY,RTCBIOT'  SET POINTER
*
*  CREATE MVS I/O OPERATIONS MESSAGE PATH
*
         MSGATT MVSIOTSK,TYPE=REQ      Open channel
         ST    RVR,IOTMTMC             MESSAGE CHANNEL ID
         EJECT
*
*  CREATE SCOM OPERATIONS MESSAGE PATH
*
         MSGATT SCOMTASK,TYPE=REQ      Open channel
         ST    RVR,IOTSTMC             MESSAGE CHANNEL ID
*
*  Create SCOM work buffer
*
         MVC   IOTSBLEN,=A(32)         Maximum of 32 segments
         L     RS,IOTSBLEN             Number of segments
         MH    RS,=Y(8)
         MEMGET (RS),TYPE=(FIX,GLOBAL)
         ST    RVR,IOTSBUFF
*
*  CREATE JES I/O OPERATIONS MESSAGE PATH
*
         MSGATT JESIOTSK,TYPE=REQ      Open channel
         ST    RVR,IOTJTMC             MESSAGE CHANNEL ID
*
* New for Hiperspace support
*
*  CREATE HIPERSPACE OPERATIONS MESSAGE PATH
*
         MSGATT HSPCETSK,TYPE=REQ      Open channel
         ST    RVR,IOTHTMC             MESSAGE CHANNEL ID
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DUMPWORK - DUMP I/O Service work area                        *
*                                                                 *
*******************************************************************
DUMPWORK RECORD BEGIN
DUMPADDR DS    A                       Address to be formatted
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   IOSDUMP - Dump I/O service task control blocks                *
*                                                                 *
*                                                                 *
*     Input - @DUMPPRM                                            *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
IOSDUMP  PROC  @DUMPPRM,DUMPWORK,SCOPE=GLOBAL
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         SEGEOR '*** I/O SERVICES ***',,@DUMPSCB
         SEGEOR ,
         EJECT
*
*  DUMP IOCT
*
         SEG   'IOCT at '
         ST    RY,DUMPADDR
         SEGHEX DUMPADDR
         SEGEOR  ,
         SEGCORE IOCT,L'IOCT,ID=IOCT,REPEAT=NO
         SEGEOR  ,
         EJECT
*
*  DUMP ERROR IOCB'S
*
         LA    RA,IOCTIOCB-(IOCBMCHN-IOCB)      MASTER CHAIN
         WITH  (IOCB,RA)
         WHILE ('LT  RA,IOCBMCHN',NZ),BEGIN
         IF    (IOCBRQID,Z),NEXT       SKIP IF NEVER USED
         LA    RS,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RS)
         IF    (IOSTATUS.X'0C',EQ),NEXT
         DROP  RS
         SEG   'IOCB at '
         ST    RA,DUMPADDR
         SEGHEX DUMPADDR
         SEGEOR  ,
         SEGCORE IOCB,L'IOCB-(SRBSIZE+L'IOSBSTD),ID=IOCB,REPEAT=YES
         SEGEOR  ,
*
*  DUMP THE SRB
*
         LA    RB,IOCBSRB              SRB POINTER
         WITH  (SRB,RB)
         SEG   'SRB at '
         ST    RB,DUMPADDR
         SEGHEX DUMPADDR
         SEGEOR  ,
         SEGCORE SRB,SRBSIZE,ID=SRB,REPEAT=YES
         SEGEOR  ,
         EJECT
*
*  DUMP THE IOSB
*
         LA    RB,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RB)
         SEG   'IOSB at '
         ST    RB,DUMPADDR
         SEGHEX DUMPADDR
         SEGEOR  ,
         SEGCORE IOSB,L'IOSBSTD,ID=IOSB,REPEAT=YES
         SEGEOR  ,
         DROP  RB
         EJECT
*
*  DUMP THE SWAP CCW BUFFERS
*
         LA    RB,IOCBSCCW             SWAP CCW BLOCKS POINTER
         WHILE ('LT  RB,@RB',NZ),BEGIN     SWAP CCWS POINTER
         SEG   'SWAP CCW''s at '
         ST    RB,DUMPADDR
         SEGHEX DUMPADDR
         SEGEOR  ,
         L     R15,IOCTSWPS            SIZE OF THE AREA
         SEGCORE (RB),(R15)
         SEGEOR  ,
         END   ,
         END   ,
         EJECT
*
*  ALL DONE
*
         SEGEOR '*** END OF I/O SERVICES ***'
         SEGEOB ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   IOSTERM - Terminate I/O service task                          *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
IOSTERM  PROC  SCOPE=GLOBAL
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
*
*  Close all SCOM paths
*
         L     RB,IOCTPTHS             SDB chain
         BEGIN
         IF    (RB,Z),EXIT
         WITH  (SDB,RB)
         SCOM  CLOSE,0,PATH            Send close request to scom
         L     RB,SDBCHN               Next on the list
         END   ,
*
*  CANCEL MVS I/O SUB-TASK
*
         PSET  @CANTASK,CLEAR=NO
         L     RS,IOCTMTID             TASK ID
         ST    RS,@CANTID              PASS IT ALONG
         VCALL CANTASK
*
*  CANCEL SCOM SUB-TASK
*
         PSET  @CANTASK,CLEAR=NO
         L     RS,IOCTSTID             TASK ID
         ST    RS,@CANTID              PASS IT ALONG
         VCALL CANTASK
*
*  CANCEL JES SUB-TASK
*
         PSET  @CANTASK,CLEAR=NO
         L     RS,IOCTJTID             TASK ID
         ST    RS,@CANTID              PASS IT ALONG
         VCALL CANTASK
*
*  New for Hiperspace support
*
*  CANCEL HIPERSPACE SUB-TASK
*
         PSET  @CANTASK,CLEAR=NO
         L     RS,IOCTHTID             TASK ID
         ST    RS,@CANTID              PASS IT ALONG
         VCALL CANTASK
*
*  RELEASE IOCBS
*
         LOOP  BEGIN
         STIMER WAIT,BINTVL==A(100)
         ACALL RELIOCB                 CLEAR OFF THE COMPLETE CHAIN
         IF    ('LT  RA,IOCTFIOB',Z),EXIT
         WHILE ('LT  RA,IOCTFIOB',NZ),BEGIN
         WITH  (IOCB,RA)
         L     RB,IOCTFIOB+4           FREE CHAIN COUNT
         LOOP  BEGIN
         L     R14,IOCBFCHN            NEXT IN LINE
         LA    R15,1
         ALR   R15,RB                  NEW COUNTER
         CDS   RA,R14,IOCTFIOB         UPDATE FREE CHAIN
         UNTIL Z,END
*
*  RELEASE THE IOCB, SRB AND IOSB
*
         POOLFREE L'IOCB,A=(RA),SUBPOOL=228
         END   ,
         END   ,
*
*  RELEASE SWAP WORK AREAS
*
SWAPCLN  LOOP  BEGIN
         LM    RA,RB,IOCTSWPA
         IF    (RA,Z),EXIT
         LOOP  BEGIN
         L     R14,@RA                 NEXT IN LINE
         LA    R15,1
         ALR   R15,RB                  NEW COUNTER
         CDS   RA,R14,IOCTSWPA         UPDATE FREE CHAIN
         UNTIL Z,END
         POOLFREE L:IOCTSWPS,A=(RA),SUBPOOL=228
         END   ,
         PEND
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    INITIALIZE DEVICE TYPE TABLE                                 *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
IDEVTAB  DC    A(0)
         DC    A(CRPAG)                PAGE DEVICE
         DC    A(CRSWP)                SWAP DEVICE
         DC    A(CRFIL)                FILE DEVICE
         DC    A(CRSDB)                SCOM
         DC    A(CRJDB)                JES DEVICE
*
* New for Hiperspace support
*
         DC    A(CRHSP)                HIPERSPACE STD
         DC    A(CRESO)                HIPERSPACE ESO
IDEVMAX  EQU   *-IDEVTAB-4             MAXIMUM
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @CRDDB - Parameters passed to DDB create routine             *
*                                                                 *
*******************************************************************
         SPACE
@CRDDB   RECORD BEGIN
@CRDSERV DS    A                       Device service routine
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    @CRHDB - Parameters passed to hDB create routine             *
*                                                                 *
*  New for Hiperspace support                                     *
*                                                                 *
*******************************************************************
         SPACE
@CRHDB   RECORD BEGIN
@CRHSERV DS    A                       Hspace service routine
@CRHSCNT DS    D                       Hspace count
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   CRPAG - Create page device control block                      *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRPAG    PROC  ,SCOPE=LOCAL
         PSET  @CRDDB
         MVC   @CRDSERV,=A(PAGEIO)
         ACALL CRDDB
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRSWP - Create swap device control block                      *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRSWP    PROC  ,SCOPE=LOCAL
         PSET  @CRDDB
         MVC   @CRDSERV,=A(SWAPIO)
         ACALL CRDDB
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRFIL - Create file device control block                      *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRFIL    PROC  ,SCOPE=LOCAL
         PSET  @CRDDB
         MVC   @CRDSERV,=A(FILEIO)
         ACALL CRDDB
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRHSP - Create Standard Hiperspace control block              *
*                                                                 *
*   New for Hiperspace support                                    *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRHSP    PROC  ,SCOPE=LOCAL
         PSET  @CRHDB
         MVC   @CRHSERV,=A(HSPIO)
         ACALL CRHDB
         LR    RA,RVR
         WITH  (HDB,RA)
         SET   (HDBFLG.HDBSTND)
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRESO - Create Standard Hiperspace control block              *
*                                                                 *
*   New for Hiperspace support                                    *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRESO    PROC  ,SCOPE=LOCAL
         PSET  @CRHDB
         MVC   @CRHSERV,=A(HSPIO)
         ACALL CRHDB
         LR    RA,RVR
         WITH  (HDB,RA)
         SET   (HDBFLG.HDBESO)
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRDDB - Create MVS data set device control block              *
*                                                                 *
*                                                                 *
*     Input - @CRDDB                                              *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
CRDDB    PROC  @CRDDB,SCOPE=LOCAL
*
*  BUILD DDB
*
         MEMGET L'DDB,TYPE=GLOBAL
         LR    RA,RVR
         WITH  (DDB,RA)
         CLEAR DDB
         WITH  (COMDB,RA),BEGIN
         MVC   COMDBID,=CL4'DDB'       SET ID
         MVC   COMDBRTN,@CRDSERV        AND ROUTINE
         END   ,
         EJECT
*
*  ADD DDB TO GLOBAL CHAIN
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LOCKOB IOCTDDBL               GET DDB CHAIN LOCK
         MVC   DDBCHAIN,IOCTDDBS       FORMER HEAD OF CHAIN
         ST    RA,IOCTDDBS             ADD THIS ONE TO CHAIN HEAD
         LOCKRL IOCTDDBL               RELEASE DDB CHAIN LOCK
         LR    RVR,RA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRHDB - Create Hiperspace device control block                *
*                                                                 *
*   New for Hiperspace support                                    *
*                                                                 *
*     Input - @CRHDB                                              *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*                                                                 *
************************************************************** ****
         SPACE 3
CRHDB    PROC  @CRHDB,SCOPE=LOCAL
*
*  BUILD HDB
*
         MEMGET L'HDB,TYPE=GLOBAL
         LR    RA,RVR
         WITH  (HDB,RA)
         CLEAR HDB
         WITH  (COMDB,RA),BEGIN
         MVC   COMDBID,=CL4'HDB'       SET ID
         MVC   COMDBRTN,@CRHSERV        AND ROUTINE
         END   ,
         EJECT
*
*  ADD HDB TO GLOBAL CHAIN
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LOCKOB IOCTHDBL               GET HDB CHAIN LOCK
         CLEAR RS
         ICM   RS,3,IOCTHSCT           Get Hiperspace count
         LA    RS,1(,RS)               Increment count
         STCM  RS,3,IOCTHSCT           Update count
         CVD   RS,@CRHSCNT             Convert to decimal
         MVC   HDBCHAIN,IOCTHDBS       FORMER HEAD OF CHAIN
         ST    RA,IOCTHDBS             ADD THIS ONE TO CHAIN
         LOCKRL IOCTHDBL               RELEASE HDB CHAIN LOCK
         UNPK  HDBHSNAM+3(5),@CRHSCNT+5(3) DEVELOP UNIQUE
         MVC   HDBHSNAM(3),=C'ORV'     HSPACE NAME USING
         OI    HDBHSNAM+7,X'F0'        IOCTHSCT
         LR    RVR,RA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRJDB - Create JES device control block                       *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRJDB    PROC  ,SCOPE=LOCAL
         MEMGET L'JDB,TYPE=GLOBAL
         LR    RA,RVR
         WITH  (JDB,RA)
         CLEAR JDB
         WITH  (COMDB,RA),BEGIN
         MVC   COMDBID,=CL4'JDB'       SET ID
         MVC   COMDBRTN,=A(JESIO)       AND SERVICE ROUTINE
         END   ,
         EJECT
*
*  ADD JDB TO CHAIN
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LOCKOB IOCTJDBL               GET DDB CHAIN LOCK
         MVC   JDBCHAIN,IOCTJDBS       FORMER HEAD OF CHAIN
         ST    RA,IOCTJDBS             ADD THIS ONE TO CHAIN HEAD
         LOCKRL IOCTJDBL               RELEASE JDB CHAIN LOCK
         LR    RVR,RA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   CRSDB - Create SCOM device control block                      *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*******************************************************************
         SPACE 3
CRSDB    PROC  ,SCOPE=LOCAL
         MEMGET L'SDB,TYPE=GLOBAL      GET SCOM DEVICE BLOCK
         LR    RA,RVR
         WITH  (SDB,RA)
         CLEAR SDB
         WITH  (COMDB,RA),BEGIN
         MVC   COMDBID,=CL4'SDB'       SET ID
         MVC   COMDBRTN,=A(SCOMIO)      AND SERVICE ROUTINE
         END   ,
         EJECT
*
*  ADD PATH TO CHAIN
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LOCKOB IOCTPTHL               GET PATH CHAIN LOCK
         MVC   SDBCHN,IOCTPTHS         FORMER HEAD OF CHAIN
         ST    RA,IOCTPTHS             ADD THIS ONE TO CHAIN HEAD
         LOCKRL IOCTPTHL               RELEASE PATH CHAIN LOCK
         LR    RVR,RA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   INITDEV - Create device control block                         *
*                                                                 *
*                                                                 *
*     Input - @INITDEV                                            *
*                                                                 *
*    Output - RVR contains device ID                              *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
INITDEV  PROC  @IOUPARM,SCOPE=GLOBAL
         L     RS,@IOUDEVT             DEVICE TYPE
         LR    RX,RS                   SAVE TYPE
         IF    (RS,Z),'KAPUT IDEVZ'
         IF    (RS,GT,IDEVMAX),'KAPUT IDEVHI'
         ACALL IDEVTAB(RS)             CALL CREATE ROUTINE
         LR    RA,RVR
         WITH  (DDB,RA)
*
*  NEW FOR HIPERSPACE SUPPORT
*
*  IF THE HSPACE KEYWORD WAS SPECIFIED IN THE ORVYL INIT PARAMETERS,
*  THIS CODE CONVERTS A PAGE OR SWAP OPERATION INTO A HIPERSPACE
*  REQUEST.  IN THIS ROUTINE WHEN A PAGE OR SWAP CONTROL BLOCK (DDB)
*  IS ALLOCATED, A CORRESPONDING HIPERSPACE CONTROL BLOCK (HDB) IS
*  CREATED.  THE HDB IS CHAINED TO THE DDB AND VICE VERSA.
*
*  THE MAXSIZE SUBPARAMETER OR A DEFAULT HAS BEEN PLACED INTO IOCTHSIZ
*  AT IOSINIT. IF A LIMIT TO THE NUMBER OF PAGE OR SWAP DATASETS TO
*  SIMULATE WAS ALSO SPECIFIED, THESE LIMITS WILL BE IN IOCTPGLM OR
*  IOCTSWLM.
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
HSPCECHK IF    (IOCTHSIZ,NZ),BEGIN     IF HIPERSPACE SIMULATION REQ'D
*
*  HSPACE WAS SPECIFIED IN INIT PARAMETERS
*
         IF    (RX,GT,8),EXIT,HSPCECHK WE ONLY WANT PAGE OR SWAP REQ'S
         IF    (RX,EQ,4),BEGIN         IF WE ARE PAGING
         IF    ((IOCTPGLM,Z),OR,(IOCTPGNO,GE,IOCTPGLM)),EXIT,HSPCECHK
         INCR  RVR,IOCTPGNO
         END   ,                    OF IF WE ARE PAGING
         IF    (RX,EQ,8),BEGIN         IF WE ARE SWAPPING
         IF    ((IOCTSWLM,Z),OR,(IOCTSWNO,GE,IOCTSWLM)),EXIT,HSPCECHK
         INCR  RVR,IOCTSWNO
         END   ,                    OF IF WE ARE SWAPPING
         LA    RS,24                   USE OFFSET TO CRHSP
         ACALL IDEVTAB(RS)
         ST    RVR,DDBHDB              CHAIN HDB TO DDB
         LR    RB,RVR
         WITH  (HDB,RB)
         IF    (RX,EQ,4),'SET (HDBFLG.HDBPAGE)'
         IF    (RX,EQ,8),'SET (HDBFLG.HDBSWAP)'
         MVC   HDBHPSIZ,IOCTHSIZ       PUT IN MAXIMUM HIPERSPACE SIZE
         ST    RA,HDBDDB               CHAIN DDB TO HDB
*** TEST CODE ***
         QSNAP DDB,L'DDB-1
*** END OF TEST CODE ***
         END   ,                    OF IF HIPERSPACE SIMULATION REQ'D
         LR    RVR,RA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    DOIOPARM - Parameters passed to I/O drivers                  *
*                                                                 *
*******************************************************************
         SPACE
@DOIO    RECORD BEGIN
@DOUPRM  DS    A                       USER PARM
@DODSID  DS    A                       DEVICE ID
@DOIORB  DS    A                       IORB
@DORC    DS    A                       RETURN CODE
         END   ,
*
*  New for Hiperspace support
*
*******************************************************************
*                                                                 *
*    IOCOMM - I/O Command Format                                   *
*                                                                 *
*******************************************************************
         SPACE
*
* Prefix for I/Oevery request
*
#IOCOM   RECORD BEGIN
#IOCMD   DS    A
*
* I/O command codes
*
#IOOPEN  EQU   4                       Open action code
#IOCLOSE EQU   8                       Close I/O code
#IOREAD  EQU   12                      Read I/O code
#IOWRITE EQU   16                      Write I/O code
#IORESET EQU   20                      Device reset code
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   DOIO    - SSCH Entry from ORVYL guest machines                *
*                                                                 *
*                                                                 *
*     Input - @IORB                                               *
*                                                                 *
*    Output - RVR contains Device Status                          *
*             SSCH condition code set                             *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DOIO     PROC  @IORB,SCOPE=GLOBAL
*
*  GET USER PARMS
*
         LA    RJ,@IORB                I/O REQUEST BLOCK
         WITH  (@IORB,RJ)
         L     RB,@IORSCH              DEVICE BLOCK POINTER
         L     RX,@IORPARM             USER PARM
         AL    RX,@IOROFF               TO MVS VIRTUAL
         PSET  @DOIO
         ST    RJ,@DOIORB              SEND IORB
         ST    RX,@DOUPRM               USER PARM
         ST    RB,@DODSID                AND DEVICE ID
         EJECT
*
*  Validate device block
*
         WITH  (COMDB,RB)
         CLC   COMDBID+1(3),=C'DB '    Might cause a program check
         IF    NE,'KAPUT  "COMDBID"'
*
*  New for Hiperspace support
*
*  IF THE DDB POINTS TO AN HDB WHICH POINTS BACK TO THE DDB, THIS
*  REPRESENTS A PAGE/SWAP REQUEST WHICH HAS BEEN CONVERTED TO USE
*  HIPERSPACE SERVICES.  FOR PAGE AND SWAP READ OR WRITE REQUESTS,
*  WE USE THE HIPERSPACE DRIVERS IN PLACE OF THE PAGE/SWAP DRIVERS.
*  THERE IS NO HIPERSPACE EQUIVALENT FOR A PAGE RESET SO AN IMMEDIATE
*  GOOD RETURN CODE IS FAKED OUT.  REAL PAGE AND SWAP OPEN AND CLOSE
*  REQUESTS ARE PERFORMED BECAUSE THE ORVYL GUEST CALLER EXPECTS SOME
*  DSCB INFO TO BE PASSED BACK IN #PFINFO.  HOWEVER, A HIPERSPACE
*  OPEN IS DONE WITH THE FIRST I/O REQUEST SIMULATED.
*
         WITH  (#IOCOM,RX)
         WITH  (DDB,COMDB)
HDBSRCH  IF    ('CLC COMDBID(4),=C"DDB "',EQ), DO WE HAVE A DDB?       *
               BEGIN
         IF    ('LT RA,DDBHDB',Z),     IF NO HDB, COULD BE FILE IO     *
               EXIT,HDBSRCH              BYPASS FURTHER PROCESSING
         WITH  (COMDB,RA)
         IF    ('CLC COMDBID(4),=C"HDB "',NE), IF HDB HAS NO ACRONYM   *
               'KAPUT NODDBHDB'          ABEND
         WITH  (HDB,COMDB)
         IF    (RB,NE,HDBDDB),         IF NO PTR TO DDB,               *
               'KAPUT NOHDBDDB'          ABEND
         IF    (#IOCMD,LE,#IOCLOSE),EXIT,HDBSRCH
         CLEAR @DORC
         LA    RVR,1                   PRELOAD IMMED. CODE
         IF    (#IOCMD,EQ,#IORESET),DONEIO HSPACE HAS NO RESET
         CLEAR RVR
         ST    RA,@DODSID              USE HDB IN PLACE
         LR    RB,RA                     OF DDB
         END   ,                    OF DO WE HAVE A DDB?
*
*  Route request to driver
*
         WITH  (COMDB,RB)
         ACALL COMDBRTN
*
*  Set condition code
*
DONEIO   SLL   RVR,4                   MOVE BITS TO PROPER LOCATION
         STC   RVR,@IORCC              RETURN CONDITION CODE
         NI    @IORCC,X'30'             AND ONLY CONDITION CODE
         L     RVR,@DORC               GET RETURN CODE
         PEND
         EJECT
         COPY  FIOPARM
         TITLE 'ORVYL''S File I/O Service Routines'
*******************************************************************
*                                                                 *
*    FILEWORK - FILE I/O work area                                *
*                                                                 *
*******************************************************************
FILEWORK RECORD BEGIN
FILECMD  DS    X                       CCW COMMAND SAVE
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    SKELETON FILE SYSTEM CCWS                                    *
*                                                                 *
*******************************************************************
         DATA  BEGIN
FCCWSEC  CCW1  CCWSTSEC,0,CCWCMDCH,1
*
FCCWSK   CCW1  CCWSEEK,0,CCWCMDCH,6
         CCW1  CCWSFM,0,CCWCMDCH,1
FCCWPFX  EQU   FCCWSK,*-FCCWSK,C'X'
*
FCCWA    CCW1  CCWSIDEQ,0,CCWCMDCH,5
         CCW1  CCWTIC,0,0,0
         CCW1  CCWRKD,0,CCWSLI,20
         CCW1  0,0,CCWIDA+CCWSLI,0
FCCWS    EQU   FCCWA,*-FCCWA,C'X'
*
FCCWPE   CCW1  CCWDEFEX,0,CCWCMDCH,16
         CCW1  CCWLOCRC,0,CCWCMDCH,16
         CCW1  CCWRKD,0,CCWSLI,20
         CCW1  0,0,CCWIDA+CCWSLI,0
FCCWEXT  EQU   FCCWPE,*-FCCWPE,C'X'
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   FILEIO  - ORVYL File System I/O Driver                        *
*                                                                 *
*                                                                 *
*     Input - #FIO                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
FILEIO   PROC  @DOIO,FILEWORK,SCOPE=LOCAL
         L     RY,@DOIORB              INTERFACE PARAMETERS
         WITH  (@IORB,RY)
         L     RX,@DOUPRM              USER PARAMETERS
         WITH  (#FIOCOM,RX)
         L     RB,@DODSID              DDB POINTER
         WITH  (DDB,RB)
         WITH  (COMDB,DDB),'CLC  COMDBID,=CL4"DDB"'
         IF    NE,'KAPUT FDBPTR'
         EJECT
*
*  SEND OPEN OR CLOSE REQUEST TO SUBTASK
*
         IF    (#FIOCMD,LE,#FCCLOSE),BEGIN
         WITH  (RTCB,RTCBR),'L  RJ,RTCBIOT'   IOT POINTER
         WITH  (IOT,RJ)
         MSGGBUF IOTMTMC,L'$MVIPSFO
         LR    RK,RVR                  MESSAGE BUFFER
         WITH  ($MVIOCOM,RK)
         ST    RB,$MVIDSID             SET DEVICE ID
         MVC   $MVIRQID,@IORRQID       Request ID
         MVC   $MVIOFF,@IOROFF         Offset (guest real to MVS)
*
*  OPEN REQUEST - PROVIDE PARAMETER ADDRESS
*
         IF    (#FIOCMD,EQ,#FCOPEN),BEGIN
         WITH  (#FIOOPEN,RX)           USER PARM
         WITH  ($MVIPSFO,RK)
         L     RS,#FIOALLO             ALLOCATION PARAMETERS
         AL    RS,@IOROFF               TO MVS VIRTUAL
         ST    RS,$MPFALLO             TO MESSAGE BUFFER
         L     RS,#FIOINFO             INFO RETURN AREA
         AL    RS,@IOROFF               TO MVS VIRTUAL
         ST    RS,$MPFINFO             TO MESSAGE BUFFER
         LA    RS,$MVIFPFO             NOTE OPEN REQUEST
         END   ,
         EJECT
*
*  MUST BE A CLOSE REQUEST
*
         ELSE  BEGIN
         IF    (#FIOCMD,NE,#FCCLOSE),'KAPUT PFOCODE'
         LA    RS,$MVIFPFC             CLOSE REQUEST
         END   ,
*
*  SEND MESSAGE
*
         ST    RS,$MVIFUNC             SET FUNCTION CODE
         MSGSEND IOTMTMC,(RK)
         CLEAR RVR                     SET CONDITION CODE
         EXIT  FILEIO                  DONE
         END   ,
*
*  SET UP IOCB
*
         ACALL GETIOCB                 GET AN I/O CONTROL BLOCK
         LR    RK,RVR
         WITH  (IOCB,RK)
         ST    RB,IOCBDDB              SET DDB POINTER
         MVC   IOCBRQID,@IORRQID        AND REQUEST ID
         EJECT
*
*  SET IO KEY AND INCREMENT I/O COUNT
*
         IF    (#FIOCMD,EQ,#FCREAD),BEGIN    FOR FILE READS
         IF    (@IORKEY,Z),'KAPUT FIOKEY'
         INCR  RS,DDBRDCT              INCREMENT READ COUNT
         MVI   FILECMD,CCWRKD          SET CCW COMMAND
         MVI   IOCBLCRD,X'06'          SET READ IN LOCATE RECORD
         END   ELSE,BEGIN
         IF    (#FIOCMD,NE,#FCWRITE),'KAPUT FIOCMD'
         CLEAR @IORKEY
         INCR  RS,DDBWRCT              INCREMENT WRITE COUNT
         MVI   FILECMD,CCWWKD          SET CCW COMMAND
         MVI   IOCBLCRD,X'01'          SET WRITE IN LOCATE RECORD
         END   ,
*
*  CALCULATE TRACK ADDRESS
*
         WITH  (#FIODO,RX)
         PSET  @BCH
         ST    RB,@BCHDSID             SET DATA SET ID
         MVC   @BCHBLK,#FIORBLK         AND BLOCK NUMBER
         ACALL BLKCCHHR                CONVERT TO DISK ADDRESS
         MVC   IOCBSECT,@BCHSECT       GET SECTOR
         EJECT
*
*  SET UP IOSB
*
         LA    RJ,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RJ)
         MVC   IOSEEK,@BCHSEEK         SET SEEK ADDRESS
         MVC   IOSEEKA,@BCHSEEK        SET SEEK ADDRESS
         MVC   IOSCKEY,@IORKEY         SET CCW AREA KEY
         MVC   IOSUCB,DDBUCB           UCB POINTER
         LA    RA,IOCBCCW              CCW AREA
*
*  DEVICE SUPPORTS EXTENDED CKD COMMANDS
*
         IF    DDBFEAT.DCEDEFLR,BEGIN
         MVC   IOSUCB,DDBUCB           UCB POINTER
         WITH  (CCW,RA)
         MVC   CCW(L'FCCWEXT),FCCWEXT  SKELETON CCWS
*
*  BUILD DEFINE EXTENT CCW AND PARAMETER
*
         LRA   RS,IOCBDEXD             DEFINE EXTENT AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*         IF    DDBFEAT.DCECACHE,'CLEAR IOCBDEXD+1.X"1C"'
         LC    RS,DDBKEYL              KEY LENGTH
         AH    RS,DDBBLKSZ              PLUS BLOCK SIZE
         STH   RS,IOCBDEXD+2             MAXIMUM BLOCK SIZE
         L     RS,DDBDEB               DEB
         WITH  (DEBBASIC,RS),'LA  RS,DEBBASND'  POINT AT EXTENT TABLE
         WITH  (DEBDASD,RS)
         MVC   IOCBDEXD+8(8),DEBSTRCC    SET EXTENT CCHH/CCHH
         DROP  RS
*
*  BUILD LOCATE RECORD CCW AND PARAMETER
*
         LRA   RS,IOCBLCRD             LOCATE RECORD AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         MVI   IOCBLCRD+3,1            SET NUMBER OF BLOCKS
         MVC   IOCBLCRD+4(4),IOSEEK+3  SET CCHH
         MVC   IOCBLCRD+8(5),IOSEEK+3  SET CCHHR ALSO
         MVC   IOCBLCRD+13(1),IOCBSECT  COPY SECTOR
*
*  FIX CCW COMMAND CODE
*
         IF    (FILECMD,EQ,CCWWKD),BEGIN
         MVI   FILECMD,CCWWUKD         CHANGE TO WRITE UPDATE
         END   ,
         END
         EJECT
*
*  BUILD SEEK CCW
*
         ELSE  BEGIN
         WITH  (CCW,RA)
         MVC   CCW(L'FCCWPFX),FCCWPFX  SKELETON CCWS
         LRA   RS,IOSEEK+1             SEEK ARGUMENT
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  BUILD SET FILE MASK CCW
*
         LRA   RS,IOCBFM               SEEK ARGUMENT
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  BUILD SET SECTOR CCW - IF NECESSARY
*
         IF    (IOCBSECT,NZ),BEGIN
         MVC   CCW,FCCWSEC             SKELETON CCW
         LRA   RS,IOCBSECT             SECTOR AREA
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         END   ,
*
*  BUILD OTHER CCWS
*
         MVC   CCW(L'FCCWS),FCCWS      FILE CCW SKELETONS
*
*  SET UP SEARCH ID CCW
*
         LRA   RS,IOSEEK+3             SEARCH ARGUMENT
         ST    RS,CCWADDR               TO CCW
         LRA   RS,CCW                  CCW ADDRESS FOR TIC
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  SET UP TIC CCW
*
         ST    RS,CCWADDR              SEARCH CCW ADDRESS FOR TIC
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         END   ,
         EJECT
*
*  SET UP HEADER CCW
*
         WITH  (CCW,RA)
         MVC   CCWCMD,FILECMD          SET READ OR WRITE
         L     RS,#FIOHDRR             HEADER LOCATION
         AL    RS,@IOROFF               TO MVS VIRTUAL
         LRA   RS,@RS                  AND THEN TO REAL
         IF    NZ,'KAPUT FIOHNFX'
         ST    RS,CCWADDR              SET
         L     R15,#FIOHDRL            HEADER LENGTH
         STH   R15,CCWLEN               SET IT
*
*  SET UP READ/WRITE DATA CCWS
*
         L     RS,#FIOIDALR            DATA ADDRESS LIST
         IF    (RS,NZ),BEGIN
         SET   CCWFLAGS.CCWDATCH       MARK DATA CHAIN IN HEADER CCW
         LA    RA,CCW+L'CCW            POINT AT READ DATA CCW
         LRA   R15,IOCBIDAW            IDAW AREA
         ST    R15,CCWADDR              TO R/W CCW
         L     RVR,#FIODATAL           TOTAL DATA LENGTH
         STH   RVR,CCWLEN               TO R/W CCW
*
*  SET UP IDAW LIST
*
         AL    RS,@IOROFF              DATA ADDRESS TO MVS VIRTUAL
         CLEAR R15                     IDAW INDEX
         LOOP  BEGIN
         S     RVR,@RS+4               LENGTH OF THIS SEGMENT
         L     R14,@RS                 ADDRESS OF THIS SEGMENT
         AL    R14,@IOROFF             CONVERT ADDRESS TO MVS VIRTUAL
         LRA   R14,@R14                 AND THEN TO REAL
         IF    NZ,'KAPUT FIONFIX'
         ST    R14,IOCBIDAW(R15)        AND THEN SET IN IDAW LIST
         EJECT
*
*  IF ADDRESS IS IN FIRST 2K OF PAGE CREATE A SECOND IDAW
*
         N     R14,=A(X'FFF')          OFFSET WITHIN PAGE
         IF    (R14,LT,2048),BEGIN
         L     R14,IOCBIDAW(R15)       GET ADDRESS
         N     R14,=X'7FFFF000'
         LA    R14,@R14+2048           TO 2K BOUNDARY
         LA    R15,@R15+4              POINT TO NEXT IDAW
         ST    R14,IOCBIDAW(R15)        AND THEN SET IN IDAW LIST
         END   ,
         IF    @RS.X'80',EXIT          ALL DONE
         LA    RS,@RS+8                TO NEXT LIST ENTRY
         LA    R15,@R15+4               AND NEXT IDAW
         END   ,
         IF    (RVR,NZ),'KAPUT FIOLEN'   DATA LENGTH ERROR
         END   ,
*
*  START THE ACTION
*
         PSET  @SIO,CLEAR=NO
         ST    RK,@SIOIOCB             SET IOCB POINTER
         ACALL STARTIO                 START IT GOING
         PEND
         EJECT
         LTORG
         EJECT
         TITLE 'ORVYL''S Page I/O Service Routine'
         COPY  PIOPARM
         EJECT
*******************************************************************
*                                                                 *
*    PAGEWORK - PAGE I/O work area                                *
*                                                                 *
*******************************************************************
PAGEWORK RECORD BEGIN
PAGECMD  DS    X                       CCW COMMAND SAVE
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    SKELETON PAGING CCWS                                         *
*                                                                 *
*******************************************************************
         DATA  BEGIN
PCCWM21  CCW1  CCWSTPP,0,CCWCMDCH,10
*
PCCWSEC  CCW1  CCWSTSEC,0,CCWCMDCH,1
*
PCCWSK   CCW1  CCWSEEK,0,CCWCMDCH,6
         CCW1  CCWSFM,0,CCWCMDCH,1
PCCWPFX  EQU   PCCWSK,*-PCCWSK,C'X'
*
PCCWB    CCW1  CCWSIDEQ,0,CCWCMDCH,5
         CCW1  CCWTIC,0,0,0
         CCW1  CCWRD,0,0,4096
PCCWS    EQU   PCCWB,*-PCCWB,C'X'
*
PCCWPE   CCW1  CCWDEFEX,0,CCWCMDCH,16
         CCW1  CCWLOCRC,0,CCWCMDCH,16
         CCW1  CCWRD,0,0,4096
PCCWEXT  EQU   PCCWPE,*-PCCWPE,C'X'
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   PAGEIO  - ORVYL Demand Page I/O Driver                        *
*                                                                 *
*                                                                 *
*     Input - #PIO                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PAGEIO   PROC  @DOIO,PAGEWORK,SCOPE=LOCAL
         L     RY,@DOIORB              INTERFACE PARAMETERS
         WITH  (@IORB,RY)
         L     RX,@DOUPRM              USER PARAMETERS
         WITH  (#PIOCOM,RX)
         L     RB,@DODSID             DDB POINTER
         WITH  (DDB,RB)
         WITH  (COMDB,DDB),'CLC  COMDBID,=CL4"DDB"'
         IF    NE,'KAPUT PDBPTR'
         EJECT
*
*  PROCESS OPEN, CLOSE AND RESET
*
         IF    ((#PIOCMD,NE,#PCREAD),AND,(#PIOCMD,NE,#PCWRITE)),BEGIN
         IF    (#PIOCMD,EQ,#PCRESET),BEGIN
         PSET  @PSRESET
         ST    RB,@PSRDDB              DDB POINTER
         LCALL PSRESET
         EXIT  PAGEIO
         END   ,
*
*  SEND REQUEST TO SUBTASK
*
         WITH  (RTCB,RTCBR),'L  RJ,RTCBIOT'   IOT POINTER
         WITH  (IOT,RJ)
         MSGGBUF IOTMTMC,L'$MVIPSFO
         LR    RK,RVR                  MESSAGE BUFFER
         WITH  ($MVIOCOM,RK)
         ST    RB,$MVIDSID             SET DEVICE ID
         MVC   $MVIRQID,@IORRQID       Request ID
         MVC   $MVIOFF,@IOROFF         Offset (guest real to MVS)
         EJECT
*
*  OPEN REQUEST - PROVIDE PARAMETER ADDRESS
*
         IF    (#PIOCMD,EQ,#PCOPEN),BEGIN
         WITH  (#PIOOPEN,RX)           USER PARM
         WITH  ($MVIPSFO,RK)
         L     RS,#PIOALLO             ALLOCATION PARAMETERS
         AL    RS,@IOROFF               TO MVS VIRTUAL
         ST    RS,$MPFALLO             TO MESSAGE BUFFER
         L     RS,#PIOINFO             INFO RETURN AREA
         AL    RS,@IOROFF               TO MVS VIRTUAL
         ST    RS,$MPFINFO             TO MESSAGE BUFFER
         LA    RS,$MVIFPFO             NOTE OPEN REQUEST
         END
*
*  MUST BE A CLOSE REQUEST
*
         ELSE  BEGIN
         IF    (#PIOCMD,NE,#PCCLOSE),'KAPUT PFOCODE'
         LA    RS,$MVIFPFC             CLOSE REQUEST
         END
*
*  SEND REQUEST TO SUB TASK
*
         ST    RS,$MVIFUNC             SET FUNCTION CODE
         MSGSEND IOTMTMC,(RK)
         IF    ((#PIOCMD,EQ,#PCCLOSE),AND,('LT RB,DDBHDB',NZ)),        *
               BEGIN                   IF CLOSING HIPERSPACED PAGE DS
         WITH  (HDB,RB)
         IF    (HDBFLG.HDBOPEN),BEGIN  IF HIPERSPACE HAS BEEN OPENED
*** TEST CODE ***
         QSNAP HDB,L'HDB-1
*** END OF TEST CODE ***
         PSET  @DOHSPC
         ST    RB,@DOHSHDB             HDB pointer
         ST    RX,@DOHSPRM             User parm addr
         ST    RY,@DOHSIRB             IORB Pointer
         ACALL HSCLOSE                 CALL CLOSE FUNCTION
         END   ,                    OF IF HIPERSPACE HAS BEEN OPENED
         END   ,                    OF IF CLOSING HIPERSPACED PAGE DS
         CLEAR RVR                     SET CONDITION CODE
         EXIT  PAGEIO                  DONE
         END   ,
         EJECT
*
*  SET UP IOCB
*
         ACALL GETIOCB                 GET AN I/O CONTROL BLOCK
         LR    RK,RVR
         WITH  (IOCB,RK)
         ST    RB,IOCBDDB              SET DDB POINTER
         MVC   IOCBRQID,@IORRQID        AND REQUEST ID
*
*  SET IO KEY AND INCREMENT I/O COUNT
*
         IF    (#PIOCMD,EQ,#PCREAD),BEGIN   FOR PAGE READS
         IF    (@IORKEY,Z),'KAPUT PIOKEY'
         INCR  RS,DDBRDCT              INCREMENT READ COUNT
         MVI   PAGECMD,CCWRD           SET CCW COMMAND
         MVI   IOCBLCRD,X'06'          SET READ IN LOCATE RECORD
         END   ELSE,BEGIN
         IF    (#PIOCMD,NE,#PCWRITE),'KAPUT PIOTYPE'
         CLEAR @IORKEY
         INCR  RS,DDBWRCT              INCREMENT WRITE COUNT
         MVI   PAGECMD,CCWWD           SET CCW COMMAND
         MVI   IOCBLCRD,X'01'          SET WRITE IN LOCATE RECORD
         END   ,
         EJECT
*
*  CALCULATE TRACK ADDRESS
*
         WITH  (#PIODO,RX)
         PSET  @BCH
         ST    RB,@BCHDSID             SET DATA SET ID
         MVC   @BCHBLK,#PIOBLK          AND BLOCK NUMBER
         ACALL BLKCCHHR                CONVERT TO DISK ADDRESS
         MVC   IOCBSECT,@BCHSECT       GET SECTOR
*
*  SET UP IOSB
*
         LA    RJ,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RJ)
         MVC   IOSEEK,@BCHSEEK         SET SEEK ADDRESS
         MVC   IOSEEKA,@BCHSEEK        SET SEEK ADDRESS
         MVC   IOSCKEY,@IORKEY         SET CCW AREA KEY
         LA    RA,IOCBCCW              CCW AREA
*
*  DEVICE SUPPORTS EXTENDED CKD COMMANDS
*
         IF    DDBFEAT.DCEDEFLR,BEGIN
         MVC   IOSUCB,DDBUCB           UCB POINTER
         WITH  (CCW,RA)
         MVC   CCW(L'PCCWEXT),PCCWEXT  SKELETON CCWS
*
*  BUILD DEFINE EXTENT CCW AND PARAMETER
*
         LRA   RS,IOCBDEXD             DEFINE EXTENT AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*         IF    DDBFEAT.DCECACHE,'SET  IOCBDEXD+1.X"08"'  MOD 23
         MVC   IOCBDEXD+2(2),DDBBLKSZ  BLOCK SIZE
         L     RS,DDBDEB               DEB
         WITH  (DEBBASIC,RS),'LA  RS,DEBBASND'  POINT AT EXTENT TABLE
         WITH  (DEBDASD,RS)
         MVC   IOCBDEXD+8(8),DEBSTRCC    SET EXTENT CCHH/CCHH
         DROP  RS
         EJECT
*
*  BUILD LOCATE RECORD CCW AND PARAMETER
*
         LRA   RS,IOCBLCRD             LOCATE RECORD AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         MVI   IOCBLCRD+3,1            SET NUMBER OF PAGES
         MVC   IOCBLCRD+4(4),IOSEEK+3  SET CCHH
         MVC   IOCBLCRD+8(5),IOSEEK+3  SET CCHHR ALSO
         MVC   IOCBLCRD+13(1),IOCBSECT  COPY SECTOR
*
*  FIX CCW COMMAND CODE
*
         IF    (PAGECMD,EQ,CCWWD),BEGIN
         MVI   PAGECMD,CCWWU           CHANGE TO WRITE UPDATE
         END   ,
         END
*
*  CACHED PAGING DEVICE - FIRST CREATE SET PAGE PARAMETER CCW
*
         ELSE  BEGIN
         IF    DDBFEAT.DCEPAGES,BEGIN
         WITH  (CCW,RA)
         MVC   CCW,PCCWM21             SKELETON CCW
         LRA   RS,IOCBPDAT             PAGE PARAMETER AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         MVC   IOCBPDAT+6(4),IOSEEK+3  SET CCHH IN PAGE PARAMETERS
         SET   (IOCBPDAT.X'00',EQ)     CLEAR FLAGS
         MVI   IOCBPDAT+1,0             AND NUMBER OF PAGES
*
*  SELECT NEXT EXPOSURE IN ROUND ROBIN
*
         L     RS,DDBCUNXT             NEXT EXPOSURE INDEX
         LOOP  BEGIN
         LA    R15,@RS+4                UPDATE
         IF    (R15,GT,8),'CLEAR  R15'  RECYCLE
         CS    RS,R15,DDBCUNXT          AND REPLACE INDEX
         UNTIL Z,END
         L     RS,DDBCUCBS(RS)         GET UCB ADDRESS
         ST    RS,IOSUCB                FOR IOSB
         SET   IOSFLC.IOSEXP           NOTE SPECIFIC EXPOSURE
         END   ,
         EJECT
*
*  STANDARD DISK/DRUM DEVICE - BUILD SEEK CCW
*
         ELSE  BEGIN
         WITH  (CCW,RA)
         MVC   CCW(L'PCCWPFX),PCCWPFX  SKELETON CCWS
         LRA   RS,IOSEEK+1             SEEK ARGUMENT
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  BUILD SET FILE MASK CCW
*
         LRA   RS,IOCBFM               SEEK ARGUMENT
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  BUILD SET SECTOR CCW - IF NECESSARY
*
         IF    (IOCBSECT,NZ),BEGIN
         MVC   CCW,PCCWSEC             SKELETON CCW
         LRA   RS,IOCBSECT             SECTOR AREA
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         END   ,
         MVC   IOSUCB,DDBUCB           UCB POINTER
         END   ,
*
*  SET UP STANDARD CCWS
*
         MVC   @RA(L'PCCWS),PCCWS      PAGE CCW SKELETONS
         WITH  (CCW,RA)
*
*  SET UP SEARCH ID CCW
*
         LRA   RS,IOSEEK+3             SEARCH ARGUMENT
         ST    RS,CCWADDR               TO CCW
*
*  SET UP TIC CCW
*
         LRA   RS,CCW                  ADDRESS FOR TIC
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         ST    RS,CCWADDR               ADDRESS TO CCW
         LA    RA,CCW+L'CCW            CCW LOCATION
         END   ,
         EJECT
*
*  SET UP READ/WRITE DATA CCW
*
         WITH  (CCW,RA),BEGIN
         MVC   CCWCMD,PAGECMD          SET READ OR WRITE
         L     R15,#PIOLOC             DATA LOCATION
         AL    R15,@IOROFF              TO MVS VIRTUAL
         LRA   R15,@R15                THEN CONVERT TO REAL
         IF    NZ,'KAPUT PIONFIX'
         ST    R15,CCWADDR             TO THE CCW
         END
*
*  START THE ACTION
*
         PSET  @SIO,CLEAR=NO
         ST    RK,@SIOIOCB             SET IOCB POINTER
         ACALL STARTIO                 START IT GOING
         PEND
         LTORG
         EJECT
         TITLE 'ORVYL''S Swap I/O Service Routines'
         COPY  SWAPPARM
         SPACE 3
*******************************************************************
*                                                                 *
*    SWAPWORK - SWAP work area                                    *
*                                                                 *
*******************************************************************
SWAPWORK RECORD BEGIN
SWAPCNT  DS    A                       NUMBER OF PAGES BEING SWAPPED
SWAPLIST DS    A                       LIST SUPPLIED BY CALLER
SWAPBLD  DS    A                       AREA TO BUILD SWAP CCWS
SWAPNUM  DS    A                       NUMBER OF PAGES PER WORK AREA
SWAPSEEK DS    A                       POINTER TO SEEK ADDRESSES
SWAPBLK  DS    A                       CURRENT BLOCK NUMBER
SWAPCCW  DS    2A                      CCW SAVE
SWAPFLG  FLAG  ,
         FLAG  SWPFBLK1                First swap block
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    SKELETON SWAPPING CCWS                                       *
*                                                                 *
*******************************************************************
         DATA  BEGIN
SCCWM21  CCW1  CCWSTPP,0,CCWCMDCH,10
*
SCCWSEC  CCW1  CCWSTSEC,0,CCWCMDCH,1
*
SCCWSK   CCW1  CCWSEEK,0,CCWCMDCH,6
         CCW1  CCWSFM,0,CCWCMDCH,1
SCCWPFX  EQU   SCCWSK,*-SCCWSK,C'X'
*
SCCWCE   CCW1  CCWDEFEX,0,CCWCMDCH,16
         CCW1  CCWLOCRC,0,CCWCMDCH,16
SCCWEXT  EQU   SCCWCE,*-SCCWCE,C'X'
*
SCCWRD   CCW1  CCWRD,0,CCWCMDCH,4096
*
SCCWRU   CCW1  CCWRD+CCWMT,0,CCWCMDCH,4096
*
SCCWWD   CCW1  CCWWD,0,CCWCMDCH,4096
*
SCCWWU   CCW1  CCWWU,0,CCWCMDCH,4096
*
SCCWD    CCW1  CCWSIDEQ+CCWMT,0,CCWCMDCH,5
         CCW1  CCWTIC,0,0,0
SCCWSW   EQU   SCCWD,*-SCCWD,C'X'
*
SCCWTIC  CCW1  CCWTIC,0,0,0
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   SWAPIO  - ORVYL Swap Page I/O Driver                          *
*                                                                 *
*                                                                 *
*     Input - #SWPIO                                              *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SWAPIO   PROC  @DOIO,SWAPWORK,SCOPE=LOCAL
         L     RY,@DOIORB              INTERFACE PARAMETERS
         WITH  (@IORB,RY)
         L     RX,@DOUPRM              USER PARAMETERS
         WITH  (#SWAPCOM,RX)
         L     RB,@DODSID              DDB POINTER
         WITH  (DDB,RB)
         WITH  (COMDB,DDB),'CLC  COMDBID,=CL4"DDB"'
         IF    NE,'KAPUT SWDBPTR'
         CLEAR SWAPFLG
         EJECT
*
*  PROCESS OPEN, CLOSE AND RESET
*
         IF    ((#SWAPCMD,NE,#SWCREAD),AND,                            *
               (#SWAPCMD,NE,#SWCWRIT)),BEGIN
         IF    (#SWAPCMD,EQ,#SWCRSET),BEGIN
         PSET  @PSRESET
         ST    RB,@PSRDDB              DDB POINTER
         LCALL PSRESET
         EXIT  SWAPIO
         END   ,
*
*  SEND REQUEST TO SUBTASK
*
         WITH  (RTCB,RTCBR),'L  RJ,RTCBIOT'   IOT POINTER
         WITH  (IOT,RJ)
         MSGGBUF IOTMTMC,L'$MVIPSFO
         LR    RK,RVR                  MESSAGE BUFFER
         WITH  ($MVIOCOM,RK)
         ST    RB,$MVIDSID             SET DEVICE ID
         MVC   $MVIRQID,@IORRQID       Request ID
         MVC   $MVIOFF,@IOROFF         Offset (guest real to MVS)
         EJECT
*
*  OPEN REQUEST - PROVIDE PARAMETER ADDRESS
*
         IF    (#SWAPCMD,EQ,#SWCOPEN),BEGIN
         WITH  (#SWPOPEN,RX)           USER PARM
         WITH  ($MVIPSFO,RK)
         L     RS,#SWPALLO             ALLOCATION PARAMETERS
         AL    RS,@IOROFF               TO MVS VIRTUAL
         ST    RS,$MPFALLO             TO MESSAGE BUFFER
         L     RS,#SWPINFO             INFO RETURN AREA
         AL    RS,@IOROFF               TO MVS VIRTUAL
         ST    RS,$MPFINFO             TO MESSAGE BUFFER
         LA    RS,$MVIFPFO             NOTE OPEN REQUEST
         END
*
*  MUST BE A CLOSE REQUEST
*
         ELSE  BEGIN
         IF    (#SWAPCMD,NE,#SWCCLOS),'KAPUT PFOCODE'
         LA    RS,$MVIFPFC             CLOSE REQUEST
         END
*
*  SEND REQUEST TO SUB TASK
*
         ST    RS,$MVIFUNC             SET FUNCTION CODE
         MSGSEND IOTMTMC,(RK)
         IF    ((#SWAPCMD,EQ,#SWCCLOS),AND,('LT RB,DDBHDB',NZ)),       *
               BEGIN                   IF CLOSING HIPERSPACED PAGE DS
         WITH  (HDB,RB)
         IF    (HDBFLG.HDBOPEN),BEGIN  IF HIPERSPACE HAS BEEN OPENED
*** TEST CODE ***
         QSNAP HDB,L'HDB-1
*** END OF TEST CODE ***
         PSET  @DOHSPC
         ST    RB,@DOHSHDB             HDB pointer
         ST    RX,@DOHSPRM             User parm addr
         ST    RY,@DOHSIRB             IORB Pointer
         ACALL HSCLOSE                 CALL CLOSE FUNCTION
         END   ,                    OF IF HIPERSPACE HAS BEEN OPENED
         END   ,                    OF IF CLOSING HIPERSPACED PAGE DS
         CLEAR RVR                     SET CONDITION CODE
         EXIT  SWAPIO                  DONE
         END   ,
         EJECT
*
*  MAKE SURE VALID SWAP REQUEST
*
         IF    (DDBXTNT,NE,1),'KAPUT SWPXTNT'   NOT SINGLE EXTENT
         WITH  (#SWPDO,RX),BEGIN
         IF    (#SWPCNT,GT,=Y(255)),'KAPUT SWPCNT'   TOO MANY PAGES
         END   ,
*
*  SET UP IOCB
*
         ACALL GETIOCB                 GET AN I/O CONTROL BLOCK
         LR    RK,RVR
         WITH  (IOCB,RK)
         ST    RB,IOCBDDB              SET DDB POINTER
         MVC   IOCBRQID,@IORRQID        AND REQUEST ID
         EJECT
*
*  SET IO KEY AND INCREMENT I/O COUNT
*
         IF    (#SWAPCMD,EQ,#SWCREAD),BEGIN   FOR SWAP INS
         IF    (@IORKEY,Z),'KAPUT SWPKEY'   CAN'T BE ZERO
         INCR  RS,DDBRDCT              INCREMENT READ COUNT
         IF    DDBFEAT.DCEDEFLR,'MVC  SWAPCCW,SCCWRU'
         ELSE  'MVC  SWAPCCW,SCCWRD'   SET CCW COMMAND
         MVI   IOCBLCRD,X'06'          SET READ IN LOCATE RECORD
         SET   (IOCBPDAT.X'C0',EQ)     SET PAGE PARAMETER FLAGS
         END   ELSE,BEGIN
         IF    (#SWAPCMD,NE,#SWCWRIT),'KAPUT SWPCMD'
         CLEAR @IORKEY
         INCR  RS,DDBWRCT              INCREMENT WRITE COUNT
         IF    DDBFEAT.DCEDEFLR,'MVC  SWAPCCW,SCCWWU'
         ELSE  'MVC  SWAPCCW,SCCWWD'   SET CCW COMMAND
         MVI   IOCBLCRD,X'01'          SET WRITE IN LOCATE RECORD
         SET   (IOCBPDAT.X'80',EQ)     SET PAGE PARAMETER FLAGS
         END   ,
         EJECT
*
*  CALCULATE TRACK ADDRESSES FOR FIRST AND LAST BLOCK
*
         DROP  RX
         WITH  (#SWPDO,RX)
         PSET  @BCH
         ST    RB,@BCHDSID             SET DATA SET ID
         L     RS,#SWPBLK              FIRST BLOCK
         AH    RS,#SWPCNT
         DECR  RS                      LAST BLOCK
         ST    RS,@BCHBLK              SET PARM
         ACALL BLKCCHHR                CONVERT TO DISK ADDRESS
         MVC   @BCHBLK,#SWPBLK         NOW DO FIRST BLOCK
         ACALL BLKCCHHR                CONVERT TO DISK ADDRESS
         MVC   IOCBSECT,@BCHSECT       GET SECTOR
*
*  SET UP IOSB
*
         LA    RJ,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RJ)
         MVC   IOSEEK,@BCHSEEK         SET SEEK ADDRESS
         MVC   IOSEEKA,@BCHSEEK        SET SEEK ADDRESS
         MVC   IOSCKEY,@IORKEY         SET CCW AREA KEY
         LA    RA,IOCBCCW              CCW AREA
*
*  DEVICE SUPPORTS EXTENDED CKD COMMANDS
*
         IF    DDBFEAT.DCEDEFLR,BEGIN
         MVC   IOSUCB,DDBUCB           UCB POINTER
         WITH  (CCW,RA)
         MVC   CCW(L'SCCWEXT),SCCWEXT  SKELETON CCWS
*
*  BUILD DEFINE EXTENT CCW AND PARAMETER
*
         LRA   RS,IOCBDEXD             DEFINE EXTENT PARAMETER AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         IF    (DDBFEAT.DCECACHE,AND,(IOCBLCRD,EQ,X'06')),BEGIN
*         SET   IOCBDEXD+1.X'08'        SWAP IN ON A MOD 23
         END   ,
         MVC   IOCBDEXD+2(2),DDBBLKSZ  BLOCK SIZE
         L     RS,DDBDEB               DEB
         WITH  (DEBBASIC,RS),'LA  RS,DEBBASND'  POINT AT EXTENT TABLE
         WITH  (DEBDASD,RS)
         MVC   IOCBDEXD+8(8),DEBSTRCC    SET EXTENT CCHH/CCHH
         DROP  RS
*
*  BUILD LOCATE RECORD CCW AND PARAMETER
*
         LRA   RS,IOCBLCRD             LOCATE RECORD PARAMETER AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         MVC   IOCBLCRD+3(1),#SWPCNT+1  SET NUMBER OF PAGES
         MVC   IOCBLCRD+4(4),IOSEEK+3  SET CCHH
         MVC   IOCBLCRD+8(5),IOSEEK+3  SET CCHHR ALSO
         MVC   IOCBLCRD+13(1),IOCBSECT  COPY SECTOR
         END
*
*  CACHED PAGING DEVICE - FIRST CREATE SET PAGE PARAMETER CCW
*
         ELSE  BEGIN
         IF    DDBFEAT.DCEPAGES,BEGIN
         WITH  (CCW,RA)
         MVC   CCW,SCCWM21             SKELETON CCW
         LRA   RS,IOCBPDAT             PAGE PARAMETER AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         MVC   IOCBPDAT+6(4),IOSEEK+3  SET CCHH IN PAGE PARAMETERS
         MVC   IOCBPDAT+1(1),#SWPCNT+1   AND NUMBER OF PAGES
*
*  SELECT NEXT EXPOSURE IN ROUND ROBIN
*
         L     RS,DDBCUNXT             NEXT EXPOSURE INDEX
         LOOP  BEGIN
         LA    R15,@RS+4                UPDATE
         IF    (R15,GT,8),'CLEAR  R15'  RECYCLE
         CS    RS,R15,DDBCUNXT          AND REPLACE INDEX
         UNTIL Z,END
         L     RS,DDBCUCBS(RS)         GET UCB ADDRESS
         ST    RS,IOSUCB                FOR IOSB
         SET   IOSFLC.IOSEXP           NOTE SPECIFIC EXPOSURE
         END   ,
*
*  STANDARD DISK/DRUM DEVICE - BUILD SEEK CCW
*
         ELSE  BEGIN
         WITH  (CCW,RA)
         MVC   CCW(L'SCCWPFX),SCCWPFX  SKELETON CCWS
         LRA   RS,IOSEEK+1             SEEK ARGUMENT
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  BUILD SET FILE MASK CCW
*
         LRA   RS,IOCBFM               SEEK ARGUMENT
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
*
*  BUILD SET SECTOR CCW - IF NECESSARY
*
         IF    (IOCBSECT,NZ),BEGIN
         MVC   CCW,SCCWSEC             SKELETON CCW
         LRA   RS,IOCBSECT             SECTOR AREA
         ST    RS,CCWADDR              SET IN CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         END   ,
         MVC   IOSUCB,DDBUCB           UCB POINTER
         END   ,
         END   ,
*
*  SET UP TO BUILD READ/WRITE CCWS
*
         CLEAR SWAPBLD
         CLEAR SWAPNUM
         MVC   SWAPBLK,#SWPBLK         STARTING BLOCK NUMBER
         LH    RS,#SWPCNT              NUMBER OF PAGES TO DO
         ST    RS,SWAPCNT               TO WORK AREA
         MVC   SWAPLIST,#SWPLIST       PAGE SWAP LIST
*
*  LOOP THROUGH SUPPLIED LIST AND BUILD CCW'S
*
         WHILE ('LT  RM,SWAPLIST',NZ),BEGIN
         AL    RM,@IOROFF              TO MVS VIRTUAL
         MVC   SWAPLIST,@RM            NEXT LIST
         LOOP  BEGIN
*
*  SET UP NEW SWAP CCW BLOCK
*
         IF    ('LT  RS,SWAPNUM',Z),BEGIN
         ACALL GETSWPA                 GET A SWAP WORK AREA
         LR    RS,RVR
         MVC   @RS(4),SWAPBLD          CHAIN UP
         ST    RS,SWAPBLD              POINTER TO CURRENT WORK AREA
*
*  BUILD TIC TO FIRST CCW IN WORK AREA
*
         WITH  (CCW,RA)
         MVC   CCW(8),SCCWTIC          TIC SKELETON
         LRA   R15,@RS+8               ADDRESS OF SWAP CCWS
         ST    R15,CCWADDR             SET IN TIC
         LA    RA,@RS+8                POINT TO SWAP CCW AREA
*
*  CALCULATE NUMBER OF CCWS TO BUILD IN THIS BLOCK
*
         L     R15,@RS+4               SIZE OF AREA
         LA    R14,@RS(R15)            END OF AREA
         SRL   R15,3                   DIVIDE BY 8
         DECR  R15                     LESS ONE FOR CHAIN & SIZE
         DECR  R15                     LESS ONE FOR TIC
         IF    ^DDBFEAT.DCEDEFLR,BEGIN    NOT EXTENDED CKD DEVICE
         SRL   R15,2                   DIVIDE BY 4 (3 CCWS PLUS SEEK)
         ST    R15,SWAPNUM             NUMBER OF CCWS THIS BLOCK
         SLL   R15,3                   BYTES OF SEEK ADDRESSES
         SR    R14,R15                 START OF SEEK AREA
         ST    R14,SWAPSEEK
         END   ,
         ELSE  BEGIN                   IS AN EXTENDED DEVICE
         ST    R15,SWAPNUM             NUMBER OF CCWS THIS BLOCK
         END
         END
*
*  BUILD CCW STRING FOR A PAGE
*
         WITH  (CCW,RA)
         LA    RM,@RM+4                NEXT PAGE ENTRY
         DECR  R0,SWAPCNT              UPDATE TOTAL COUNT
         IF    (R0,M),'KAPUT SWPCNT'
         DECR  R0,SWAPNUM               AND COUNT THIS BLOCK
         LA    R15,4095
         IF    ('N  R15,@RM',NZ),'KAPUT SWIOADDR'
         L     R15,@RM                 GET A PAGE POINTER
         AL    R15,@IOROFF              TO MVS VIRTUAL
         LRA   R15,@R15                THEN CONVERT TO REAL
         IF    NZ,'KAPUT SWPNFIX'
         L     R14,SWAPCCW             GET CCW SKELETON
*
*  STANDARD CKD DEVICE - FIRST SET UP SEARCH ID CCW
*
         IF    ^DDBFEAT.DCEDEFLR,BEGIN
         ST    R15,SWAPCCW+4           SAVE CCW ADDRESS
         MVC   CCW(L'SCCWSW),SCCWSW    SWAP CCW SKELETONS
         PSET  @BCH
         ST    RB,@BCHDSID             SET DATA SET ID
         MVC   @BCHBLK,SWAPBLK          AND BLOCK NUMBER
         ACALL BLKCCHHR                CONVERT TO DISK ADDRESS
         L     R15,SWAPSEEK
         MVC   @R15(L'IOSEEK),@BCHSEEK   SET SEEK ADDRESS
         LRA   R14,@R15+3              SEARCH ARGUMENT
         ST    R14,CCWADDR              TO CCW
         LA    R15,@R15+8              NEXT SEEK AREA
         ST    R15,SWAPSEEK
         INCR  R15,SWAPBLK             UPDATE BLOCK NUMBER
*
*  Turn off multi-track search for first ccw
*
         IF    ^SWPFBLK1,BEGIN
         CLEAR CCW.CCWMT               Remove multi-track
         SET   SWPFBLK1
         END   ,
*
*  SET UP TIC CCW
*
         LRA   R14,CCW                 ADDRESS FOR TIC
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         ST    R14,CCWADDR              ADDRESS TO CCW
*
*  NOW ADD READ/WRITE DATA CCW
*
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         LM    R14,R15,SWAPCCW         GET WRITE DATA CCW
         END   ,
         STM   R14,R15,CCW             SET THE READ/WRITE CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW
         UNTIL @RM.X'80',END           GO TO END OF LIST
         END   ,
*
*  FINISH UP CHANNEL PROGRAM
*
         L     RS,SWAPCNT              NUMBER OF PAGES LEFT
         IF    (RS,NZ),'KAPUT SWPLCNT'   DIDN'T COME OUT EVEN
         SH    RA,=Y(L'CCW)
         WITH  (CCW,RA),'CLEAR  CCWFLAGS.CCWCMDCH'  CLEAR COMM CHAIN
         MVC   IOCBSCCW,SWAPBLD        CHAIN OF SWAP WORK AREAS
*
*  START THE ACTION
*
         PSET  @SIO,CLEAR=NO
         ST    RK,@SIOIOCB             SET IOCB POINTER
         ACALL STARTIO                 START IT GOING
         PEND
         EJECT
         LTORG
         TITLE 'ORVYL''S Page/Swap/File I/O Service Subroutines'
*******************************************************************
*                                                                 *
*    @PSRESET - Parameters for page/swap device reset             *
*                                                                 *
*******************************************************************
         SPACE
@PSRESET RECORD BEGIN
@PSRDDB  DS    A                       DDB pointer
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    SKELETON RESET CCWS                                          *
*                                                                 *
*******************************************************************
         DATA  BEGIN
RCCWA    CCW1  CCWSTPP,0,CCWCMDCH,10
         CCW1  CCWDLBLK,0,CCWCMDCH,2
         CCW1  CCWNOP,0,CCWSLI,1
RCCWS    EQU   RCCWA,*-RCCWA,C'X'
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   PSRESET - Reset cached paging/swapping controller             *
*                                                                 *
*                                                                 *
*     Input - @PSRESET                                            *
*                                                                 *
*    Output - RVR contains I/O condition code                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PSRESET  PROC  @PSRESET,SCOPE=LOCAL
         L     RB,@PSRDDB              DDB POINTER
         WITH  (DDB,RB)
*
*  DEVICE ISN'T A CACHING CONTROLLER
*
         IF    ^DDBFEAT.DCEPAGES,BEGIN
         LA    RVR,1                   IMMEDIATE (GOOD) RETURN
         EXIT  PSRESET
         END   ,
*
*  SEE IF DEVICE IS ALREADY INITIALIZED
*
         L     RA,DDBUCB               UCB POINTER
         WITH  (UCBOB,RA),'LH  RA,UCBCHAN'     CHANNEL ID
         N     RA,=A(X'FE0')           UNIQUE ID
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LA    RX,IOCTCDL              CACHE DEVICE LIST ANCHOR
         EJECT
*
*  SEARCH LIST FOR THIS DEVICE
*
         WHILE ('LT  RX,@RX',NZ),BEGIN  SEARCH ALL LISTS
         LA    R14,@RX                 FIRST ENTRY
         LA    R15,@RX+(16*4)          LAST ENTRY
         LOOP  BEGIN
         LA    R14,@R14+4              NEXT ENTRY IN LIST
         IF    (R14,GE,R15),EXIT       DONE WITH THIS PORTION
*
*  DEVICE FOUND ON LIST - ALL DONE
*
         IF    (RA,EQ,@R14),BEGIN
         LA    RVR,1                   IMMEDIATE (GOOD) RETURN
         EXIT  PSRESET
         END   ,
         END   ,
         END   ,
*
*  THIS DEVICE NOT FOUND IN THE LIST - ADD IT
*
         LA    RX,IOCTCDL              LIST ANCHOR
PSRLOOP  LOOP  BEGIN
*
*  CREATE NEW CACHE DEVICE LIST
*
         IF    ('LT  RS,@RX',Z),BEGIN
         MEMGET 16*4,TYPE=GLOBAL       GET MEMORY
         LR    RS,RVR
         ST    RVR,@RX                 SET ADDRESS
         END   ,
         LR    RX,RS                   UPDATE POINTER
         EJECT
*
*  FIND EMPTY SLOT
*
         LA    R15,@RS+(16*4)          LAST ENTRY
         LOOP  BEGIN
         LA    RS,@RS+4                NEXT ENTRY
         IF    (RS,GE,R15),EXIT
         IF    ('OC @RS(4),@RS',Z),BEGIN
         ST    RA,@RS
         EXIT  PSRLOOP
         END   ,
         END   ,
         END   ,
*
*  FOUND A DEVICE TO RESET - FIRST SET UP IOCB
*
         ACALL GETIOCB                 GET AN I/O CONTROL BLOCK
         LR    RK,RVR
         WITH  (IOCB,RK)
         ST    RB,IOCBDDB              SET DDB POINTER
         SET   IOCBPECB                REQUEST ECB POST
*
*  SET UP IOSB
*
         LA    RJ,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RJ)
         L     RS,DDBCUCBS             GET UCB ADDRESS
         ST    RS,IOSUCB                FOR IOSB
         SET   IOSFLC.IOSEXP           NOTE SPECIFIC EXPOSURE
*
*  SET UP CHANNEL PROGRAM
*
         LA    RA,IOCBCCW              CCW AREA
         MVC   @RA(L'RCCWS),RCCWS      RESET CCW SKELETONS
*
*  Build SET PAGE PARAMETERS CCW
*
         WITH  (CCW,RA),BEGIN
         LRA   RS,IOCBPDAT             PAGE PARAMETER AREA
         ST    RS,CCWADDR              SET CCW
         LA    RA,CCW+L'CCW            TO NEXT CCW AREA
         CLEAR IOCBPDAT                CLEAR DATA AREA
         EJECT
*
*  Build DISCARD BLOCK CCW
*
         LRA   RS,IOCBDBLK             DISCARD BLOCK AREA
         ST    RS,CCWADDR              SET CCW
         CLEAR IOCBDBLK
         SET   IOCBDBLK.X'80'          SET DISCARD ALL
         END   ,
*
*  TURN OFF MISSING INTERRUPT HANDLER DURING CACHE RESET
*
         L     R14,DDBCUCBS            GET UCB ADDRESS
         WITH  (UCBOB,R14),'L  R14,UCBBASE'    UCB BASE ADDRESS
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
         USING UCB,R14
         SET   UCBMIHTI.UCBMIHPB,MODE=LOCKED,REF=UCB
         DROP  R14
         MODESET KEYADDR=(2)           BACK TO OUR KEY
*
*  START THE ACTION
*
         PSET  @SIO,CLEAR=NO
         ST    RK,@SIOIOCB             SET IOCB POINTER
         ACALL STARTIO                 START IT GOING
         FWAIT LA:IOCBECB
         IF    (IOSTATUS,NE,=X'0C00'),'KAPUT M21RESET'
         EJECT
*
*  TURN ON MISSING INTERRUPT HANDLER AFTER CACHE RESET
*
         L     R14,DDBCUCBS            GET UCB ADDRESS
         WITH  (UCBOB,R14),'L  R14,UCBBASE'    UCB BASE ADDRESS
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
         USING UCB,R14
         CLEAR UCBMIHTI.UCBMIHPB,MODE=LOCKED,REF=UCB
         DROP  R14
         MODESET KEYADDR=(2)           BACK TO OUR KEY
         LA    RVR,1                   IMMEDIATE POST
         PEND
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   GETIOCB - Obtain I/O Control block                            *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains pointer to IOCB                        *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GETIOCB  PROC  SCOPE=LOCAL
*
*  FIRST RELEASE ANY COMPLETED IOCBS
*
         ACALL RELIOCB
*
*  LOOK FOR AN IDLE IOCB
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LM    RA,RB,IOCTFIOB          FREE CHAIN & COUNT
         WITH  (IOCB,RA)
         LOOP  BEGIN
         IF    (RA,Z),EXIT             NONE ON THE CHAIN
         L     R14,IOCBFCHN            NEXT IN LINE
         LA    R15,1
         ALR   R15,RB                  NEW COUNTER
         CDS   RA,R14,IOCTFIOB         UPDATE FREE CHAIN
         UNTIL Z,END
         EJECT
*
*  NO IOCBS AVAILABLE, BUILD SOME
*
         IF    (RA,Z),BEGIN
         LA    RA,4096/L'IOCB*L'IOCB
         POOLGET (RA),SUBPOOL=228      CSA, FIXED, NO FETCH PROTECT
         LR    RJ,RVR                  START OF AREA
         LR    RA,RJ                   POINTER TO FIRST IOCB
         LA    RB,4096/L'IOCB          NUMBER WE'RE BUILDING
*
*  BUILD IOCB
*
         WHILE (RB,P),BEGIN
         WITH  (IOCB,RJ)
         MVC   IOCB(4),=CL4'RICB'
         ST    RY,IOCBIOCT             SAVE IOCT POINTER
         MEMGET 80*3,TYPE=GLOBAL       GET MEMORY FOR STACK
         ST    RVR,IOCBSTK
         MVC   IOCBDEXD(2),=AL1(X'80',X'C0')   FILE MASK + ECKD
         MVI   IOCBFM,X'80'            FILE MASK
*
*  BUILD AN SRB
*
         WITH  (SRB,IOCBSRB),BEGIN
         MVC   SRBID,=C'SRB '          IDENTIFICATION
         MVC   SRBASCB,IOCTASCB        SET ASCB
         MVC   SRBPASID,IOCTASID       | AND ASCB ID
         MVC   SRBPKF,IOCTKEY          | AND STORAGE KEY
         MVC   SRBPTCB,IOCTMTCB        | AND MVS I/O TASK TCB
         LA    R15,IOCBIOSB            IOSB POINTER
         ST    R15,SRBPARM              IS THE SRB PARM
         END   ,
         EJECT
*
*  BUILD AN IOSB
*
         WITH  (IOSB,IOCBIOSB),BEGIN
         LA    R15,IOCBSRB             SRB POINTER
         ST    R15,IOSSRB               TO THE IOSB
         MVI   IOSDVRID,IOSMISID       DRIVER ID: MISC
         MVC   IOSASID,IOCTASID        ASCB ID
         L     R15,=A(IOTERM+X'80000000')
         ST    R15,IOSPGAD             TERMINATION ROUTINE
         MVC   IOSPKEY,IOCTKEY         SET TERMINATION ROUTINE KEY
         SET   IOSPKEY.IOSLCL          SCHEDULE AT ASCB'S PRIORITY
         SET   IOSPKEY.IOSCHCMP        CHANNEL PROGRAM COMPLETE
         SET   IOSOPT2.IOSF            NOTE FORMAT 1 CCWS
         SET   IOSOPT.IOSBYP           BYPASS PREFIXING
         LA    RS,IOCBCCW              CCW AREA
         ST    RS,IOSVST               VIRTUAL CCW CHAIN START
         LRA   RS,@RS                   TO REAL
         ST    RS,IOSRST               SET REAL ADDRESS ALSO
         ST    RJ,IOSUSE               SET IOCB POINTER AS PARM
         L     R15,CVTPTR
         WITH  (CVT,R15),'LA  R15,CVTRCZRT'    DUMMY RETURN
         ST    R15,IOSNRM              NORMAL END APPENDAGE
         ST    R15,IOSABN              | AND ABNORMAL END APPENDAGE
         SET   IOSFMSK.X'80'           FILE MASK
         END   ,
*
*  ADD IOCB TO MASTER CHAIN
*
         LM    R14,R15,IOCTIOCB        MASTER CHAIN & COUNT
         LOOP  BEGIN
         ST    R14,IOCBMCHN            OLD HEAD NOW NEXT IN LINE
         LA    RK,1
         ALR   RK,R15                  NEW COUNTER
         CDS   R14,RJ,IOCTIOCB         UPDATE MASTER CHAIN
         UNTIL Z,END
*
*  IF NOT FIRST IOCB ADD IT TO AVAILABLE CHAIN
*
         IF    (RJ,NE,RA),BEGIN
         LM    R14,R15,IOCTFIOB        FREE CHAIN & COUNT
         LOOP  BEGIN
         ST    R14,IOCBFCHN            OLD HEAD NOW NEXT IN LINE
         LA    RK,1
         ALR   RK,R15                  NEW COUNTER
         CDS   R14,RJ,IOCTFIOB         UPDATE FREE CHAIN
         UNTIL Z,END
         END   ,
         DECR  RB
         LA    RJ,IOCB+L'IOCB          TO NEXT
         END   ,
         END   ,
         EJECT
*
*  Reset fields in IOCB and IOSB
*
         CLEAR IOCBFLG
         WITH  (IOSB,IOCBIOSB),BEGIN
         SET   (IOSFLA.IOSACHN,EQ)     SET CHAIN, CLEAR ERROR
         CLEAR IOSPROC                 CLEAR
         CLEAR IOSERP                   ERROR
         CLEAR IOSIPIB                   FIELDS
         CLEAR IOSFLC.IOSEXP           CLEAR SPECIFIC EXPOSURE
         END   ,
         LR    RVR,RA                  RETURN IOCB POINTER
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   RELIOCB - Move IOCBs from complete chain to free chain        *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
RELIOCB  PROC  SCOPE=LOCAL
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
*
*  First remove an IOCB from complete chain
*
RELOOP   WHILE ('LT  RA,IOCTCIOB',NZ),BEGIN    COMPLETE CHAIN
         WITH  (IOCB,RA)
         L     RB,IOCTCIOB+4           COMPLETE CHAIN COUNT
         LOOP  BEGIN
         IF    (RA,Z),EXIT,RELOOP
         L     R14,IOCBFCHN            NEXT IN LINE
         LA    R15,1
         ALR   R15,RB                  NEW COUNTER
         CDS   RA,R14,IOCTCIOB         UPDATE COMPLETE CHAIN
         UNTIL Z,END
         EJECT
*
*  THEN MOVE SWAP CCW AREA(S) TO FREE CHAIN
*
         WHILE ('LT  RJ,IOCBSCCW',NZ),BEGIN
         MVC   IOCBSCCW,@RJ            CHAIN WORD
         LM    R14,R15,IOCTSWPA        FREE CHAIN & COUNT
         LOOP  BEGIN
         ST    R14,@RJ                 OLD HEAD NOW NEXT IN LINE
         LA    RK,@R15+1               NEW COUNTER
         CDS   R14,RJ,IOCTSWPA         UPDATE FREE CHAIN
         UNTIL Z,END
         END
*
*  NOW ADD IOCB TO AVAILABLE CHAIN
*
         LM    R14,R15,IOCTFIOB        FREE CHAIN & COUNT
         LOOP  BEGIN
         ST    R14,IOCBFCHN            OLD HEAD NOW NEXT IN LINE
         LA    RB,1
         ALR   RB,R15                  NEW COUNTER
         CDS   R14,RA,IOCTFIOB         UPDATE FREE CHAIN
         UNTIL Z,END
         END
         PEND
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   GETSWPA - Obtain a swap CCW work area                         *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - RVR contains pointer to IOCB                        *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
GETSWPA  PROC  SCOPE=LOCAL
*
*  LOOK FOR AN IDLE WORK AREA
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY)
         LM    RA,RB,IOCTSWPA          FREE CHAIN & COUNT
         LOOP  BEGIN
         IF    (RA,Z),EXIT             NONE ON THE CHAIN
         L     R14,@RA                 NEXT IN LINE
         LA    R15,1
         ALR   R15,RB                  NEW COUNTER
         CDS   RA,R14,IOCTSWPA         UPDATE FREE CHAIN
         UNTIL Z,END
*
*  NO SWAP AREAS AVAILABLE, CREATE ONE
*
         IF    (RA,Z),BEGIN
         POOLGET L:IOCTSWPS,SUBPOOL=228  CSA, FIXED, NO FETCH PROT.
         LR    RA,RVR                  POINTER TO AREA
         MVC   @RA+4(4),IOCTSWPS       SIZE OF THE AREA
         END   ,
*
*  RETURN SWAP AREA TO CALLER
*
         LR    RVR,RA                  RETURN POINTER
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   BLKCCHHR - Convert relative block to disk address             *
*                                                                 *
*                                                                 *
*     Input - @BCH                                                *
*                                                                 *
*    Output - @BCH                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
BLKCCHHR PROC  @BCH,SCOPE=LOCAL
         L     RX,@BCHDSID             GET DDB POINTER
         WITH  (DDB,RX)
         L     RB,@BCHBLK
         IF    (RB,GE,DDBBLKCT),'KAPUT BLKCT'
*
*  PARAMETERS OK, CONVERT TO TTR
*
         CLEAR RA
         D     RA,DDBBT                CALCULATE TTR
         L     RS,DDBRPS               RPS SECTOR TABLE
         IF    (RS,NZ),BEGIN           FOR RPS DEVICES
         IC    RS,@RS(RA)              GET PROPER SECTOR NUMBER
         STC   RS,@BCHSECT              AND PUT IN PARM AREA
         END   ,
         INCR  RA                      BUMP (CAN'T USE ZERO)
         STC   RA,@BCHSKR              SET BLOCK NUMBER
         EJECT
*
*  FIND PROPER DEB EXTENT
*
         L     RA,DDBDEB               DEB
         USING DEBBASIC,RA
         LC    R15,DEBNMEXT            NUMBER OF EXTENTS
         LA    RA,DEBBASND             POINT AT EXTENT TABLE
         USING DEBDASD,RA
         CLEAR RS
SEEKLOOP L2    RJ,DEBNMTRK             TRACK COUNT THIS EXTENT
         IF    (RB,LT,RJ),SETSEEK      BLOCK IS IN THIS EXTENT
         SR    RB,RJ                   DECREMENT BY NUMBER OF TRACKS
         LA    RA,DEBDASDE             POINT AT NEXT EXTENT
         INCR  RS                       AND COUNT IT
         BCT   R15,SEEKLOOP            KEEP LOOKING
         KAPUT TTR                     OY!
SETSEEK  MVC   @BCHSKBB(6),DEBBINUM    SET EXTENT STARTING BBCCHH
         DROP  RA                      ##
*
*  CALCULATE SEEK ADDRESS
*
         STC   RS,@BCHSKM              SET EXTENT NUMBER
         CLEAR RA
         D     RA,DDBTRC               DIVIDE BY TRACKS/CYLINDER
         AH    RA,@BCHSKHH             CALCULATE PROPER TRACK
         IF    (RA,GE,DDBTRC),BEGIN    NEXT CYLINDER?
         S     RA,DDBTRC               DECREMENT TRACK NUMBER
         INCR  RB                       AND INCREMENT CYLINDER
         END   ,
         STH   RA,@BCHSKHH             SET CORRECT TRACK
         AH    RB,@BCHSKCC             CALCULATE
         STH   RB,@BCHSKCC              AND SAVE PROPER CYLINDER
         PEND
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   STARTIO - Initiate I/O request                                *
*                                                                 *
*                                                                 *
*     Input - @SIO                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
STARTIO  PROC  @SIO,SCOPE=LOCAL
         L     RX,@SIOIOCB             IOCB POINTER
         WITH  (IOCB,RX)
         LA    RB,IOCBIOSB             IOSB POINTER
         WITH  (IOSB,RB)
*
*  FIRST GET KEY ZERO AND LOCAL LOCK
*
*GEN
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,RELATED=SIO
         EJECT
*
*  ISSUE STARTIO
*
         STM   R0,R15,@R13             SAVE REGS
         STCK  IOCBSTRT                TIME
         LA    R1,IOCBSRB              SRB POINTER
         STARTIO SRB=(1),TCB=SRB
         LM    R0,R15,@R13             RESTORE REGS
*
*  FREE LOCAL LOCK AND GO BACK TO NORMAL KEY
*
         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,RELATED=SIO
         MODESET KEYADDR=(2)           BACK TO OUR KEY
*NOGEN
         CLEAR RVR                     RETURN CODE
         PEND
         LTORG
         EJECT
         TITLE 'ORVYL''S SCOM I/O Service Routines'
         COPY  SCOMPARM
         EJECT
*******************************************************************
*                                                                 *
*     SCIOWORK - SCOM operations work area                        *
*                                                                 *
*******************************************************************
         SPACE
SCIOWORK RECORD BEGIN
SCIOPATH DS    A                       Address of path to be opened
SCIOINBL DS    A                       Buffer list for INFO request
SCIOINFO DS    5A                      SCOM info answer area
SCIOCMD  DS    X                       SCOM command code
         SCOM  TABLE                   SCOM Operation codes
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @SCOMDB - SCOM close work area                               *
*                                                                 *
*******************************************************************
         SPACE
@SCOMDB  RECORD BEGIN
@SCOMSDB DS    A                       PATH ID
         END
         SPACE 3
*******************************************************************
*                                                                 *
*    @DOSCOM - Parameters passed to SCOM drivers                  *
*                                                                 *
*******************************************************************
         SPACE
@DOSCOM  RECORD BEGIN
@DOSCPRM DS    A                       User parm pointer
@DOSCSDB DS    A                       SDB Pointer
@DOSCIRB DS    A                       IORB Pointer
@DOSCRC  DS    A                       Return code
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SCOM FUNCTION TABLE                                          *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
SCOMTAB  DC    A(0)
         DC    A(SCOPEN)               OPEN
         DC    A(SCCLOSE)              CLOSE
         DC    A(SCSEND)               SEND
         DC    A(SCRECV)               RECEIVE
         DC    A(0)                    RESERVED
         DC    A(0)                    RESERVED
         DC    A(0)                    RESERVED
         DC    A(SCPOST)               POST
         DC    A(SCINFO)               GET INFO
         DC    A(SCNTFY)               NOTIFY
SCOMMAX  EQU   *-SCOMTAB-4             MAXIMUM
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   SCOMIO  - Do SCOM Transactions                                *
*                                                                 *
*                                                                 *
*     Input - @DOIO                                               *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOMIO   PROC  @DOIO,SCOPE=LOCAL
         L     RX,@DODSID              PATH BLOCK POINTER
         WITH  (COMDB,RX),BEGIN
         IF    (COMDBID,NE,=CL4'SDB'),'KAPUT SCOMIO'
         END   ,
*
*  VALIDATE COMMAND CODE
*
         L     RY,@DOUPRM              USER PARAMETERS
         WITH  (#SCOMCMD,RY),'L  RS,#SCCMD'    FUNCTION CODE
         IF    ((RS,NP),OR,(RS,GT,SCOMMAX)),'KAPUT SCOMCMD'
         EJECT
*
*  Send request to driver
*
         PSET  @DOSCOM
         ST    RX,@DOSCSDB             SDB pointer
         ST    RY,@DOSCPRM             User parameter address
         MVC   @DOSCIRB,@DOIORB        IORB Pointer
         ACALL SCOMTAB(RS)             CALL FUNCTION ROUTINE
         MVC   @DORC,@DOSCRC           Set return code
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCOPEN  - Process SCOM Open request                           *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOPEN   PROC  @DOSCOM,SCIOWORK,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         L     RY,@DOSCPRM             USER PARAMETERS
         WITH  (#SCOPEN,RY)
*
*  SET UP USER SUPPLIED FIELDS
*
         MVC   PATHMY(8),#SCOME        GET NAMES
         MVC   PATHYOU(8),#SCOYOU
         MVC   PATHPASS(4),#SCOPASS     AND PASSWORD
         CLC   PATHYOU,=8X'FF'         SPECIFIC YOURNAME?
         IF    NE,'SET  PATHMFL.PATHMNAM'    YES, NOTE IT
         MVC   PATHBUF,#SCOBUFL        SET BUFFER SIZE
*
*  If Caller has set up Info area copy it in
*
         IF    ('LT RA,#SCOINFO',NZ),BEGIN    INFO POINTER
         L     RB,@DOSCIRB
         WITH  (@IORB,RB),'AL  RA,@IOROFF'    TO MVS VIRTUAL ADDRESS
         LA    RB,4
         AL    RB,@RA                  First word is length
         MEMGET (RB),TYPE=GLOBAL
         LR    RS,RVR
         DEX   RB,'MVC  @RS(0),@RA'    Copy the Data
         ST    RS,PATHPINP             Address TO PATH BLOCK
         END   ,
*
*  SET UP INTERNAL FIELDS
*
         SET   PATHMFL.PATHVER2        NOTE MODE 2 OPERATION
         LA    RS,SDBPFL               POST FLAG
         ST    RS,PATHECBF              SET
*
*  Create message buffer and send to subtask
*
         WITH  (RTCB,RTCBR),'L  RJ,RTCBIOT'   IOT POINTER
         WITH  (IOT,RJ)
         MSGGBUF IOTSTMC,L'$SCMIMSG
         LR    RK,RVR                  MESSAGE BUFFER
         WITH  ($SCMIMSG,RK)
         ST    RX,$SCMSDB              SDB pointer
         L     RB,@DOSCIRB             INTERFACE PARAMETERS
         WITH  (@IORB,RB)
         MVC   $SCMRQID,@IORRQID       Request ID
         MVC   $SCMOFF,@IOROFF         Offset (guest real to MVS)
         MVC   $SCMKEY,@IORKEY         Protect key
         MVC   $SCMFUNC,=A(#SCCOPEN)   Function code
         MSGSEND IOTSTMC,(RK)
         CLEAR RVR                     CONDITION CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCCLOSE - Process SCOM Close request                          *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCCLOSE  PROC  @DOSCOM,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         L     RY,@DOSCPRM             USER PARAMETERS
         WITH  (#SCCLOSE,RY)
         IF    (PATHMY,NZ),BEGIN
         SCOM  CLOSE,0,PATH            SEND CLOSE REQUEST TO SCOM
         ST    R15,@DOSCRC             SET RETURN
         IF    (R15,NZ),'KAPUT SCMOOPS'
         EJECT
*
*  PATH IS CLOSED - IS IT ON THE NOTIFY QUEUE?
*
         WITH  (RTCB,RTCBR),'L  RJ,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RJ),'L  RJ,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RJ)
         LOCKOB IOCTSNTL               GET NOTIFY CHAIN LOCK
*
*  REMOVE PATH FROM THE NOTIFY QUEUE
*
         IF    SDBFNTFY,BEGIN
         SET   SDBPFL.PATHFCLS         PRETEND PARTNER CLOSED TOO
         PSET  @SCOMDB
         ST    RX,@SCOMSDB             SDB POINTER
         ACALL SCOMNTFY                NOTIFY COMPLETE
         END   ,
         LOCKRL IOCTSNTL               RELEASE NOTIFY CHAIN LOCK
         END   ,
         PSET  @SCOMDB
         ST    RX,@SCOMSDB             PATH ID
         ACALL SCOMCLS
         LA    RVR,1                   CONDITION CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCSEND  - Process SCOM Send request                           *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCSEND   PROC  @DOSCOM,SCIOWORK,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         L     RY,@DOSCPRM             USER PARAMETERS
         WITH  (#SCSR,RY)
*
*  GET WORK AREA FOR SEND REQUESTS
*
         WITH  (RTCB,RTCBR),'L  RA,RTCBIOT'    IOT POINTER
         WITH  (IOT,RA),BEGIN
         IF    (#SCSRCT,GT,IOTSBLEN),'KAPUT SCOMSEGS'   Check count
         L     RJ,IOTSBUFF             Get work area pointer
         END
         LR    RS,RJ
*
*  COPY USER BUFFER LIST POINTERS AND FIX ADDRESSES
*
         L     RK,@DOSCIRB             INTERFACE PARAMETERS
         WITH  (@IORB,RK),BEGIN
         L     R15,#SCSRCT             NUMBER OF SEGMENTS
         LA    R14,#SCSRSEG            LOCATION OF SEGMENTS
         LOOP  BEGIN
         LM    RA,RB,@R14              USER PARAMETER
         AL    RA,@IOROFF               ADD OFFSET
         STM   RA,RB,@RS               PUT IN LIST
         DECR  R15
         IF    (R15,Z),EXIT
         LA    R14,@R14+8              UPDATE LIST
         LA    RS,@RS+8                 POINTERS
         END   ,
         SET   @RS.X'80'               MARK END OF CHAIN
         END   ,
*
*  SEND REQUEST TO SCOM
*
         SCOM  SEND,(RJ),PATH          SEND REQUEST TO SCOM
         ST    R15,@DOSCRC             SET RETURN CODE
*
*  CHECK RETURN CODE
*
         IF    (R15,NZ),BEGIN
         IF    ((R15,GE,12),OR,(R15,LE,24)),EXIT
         KAPUT SCMOOPS
         END
*
*  ALL DONE - RETURN TO CALLER
*
         LA    RVR,1                   IMMEDIATE RETURN
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCRECV  - Process SCOM Receive request                        *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCRECV   PROC  @DOSCOM,SCIOWORK,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         L     RY,@DOSCPRM             USER PARAMETERS
         WITH  (#SCSR,RY)
*
*  RECEIVE REQUEST - CLEAR NEW INFO FLAG ON
*
         CLEAR SDBPFL.PATHFNI,MODE=LOCKED,REF=SDB
*
*  GET BUFFER WORK AREA
*
         WITH  (RTCB,RTCBR),'L  RA,RTCBIOT'    IOT POINTER
         WITH  (IOT,RA),BEGIN
         IF    (#SCSRCT,GT,IOTSBLEN),'KAPUT SCOMSEGS'   Check count
         L     RJ,IOTSBUFF             Get work area pointer
         END
         LR    RS,RJ
*
*  COPY USER BUFFER LIST POINTERS AND FIX ADDRESSES
*
         L     RK,@DOSCIRB             INTERFACE PARAMETERS
         WITH  (@IORB,RK),BEGIN
         L     R15,#SCSRCT             NUMBER OF SEGMENTS
         LA    R14,#SCSRSEG            LOCATION OF SEGMENTS
         LOOP  BEGIN
         LM    RA,RB,@R14              USER PARAMETER
         AL    RA,@IOROFF               ADD OFFSET
         STM   RA,RB,@RS               PUT IN LIST
         DECR  R15
         IF    (R15,Z),EXIT
         LA    R14,@R14+8              UPDATE LIST
         LA    RS,@RS+8                 POINTERS
         END   ,
         SET   @RS.X'80'               MARK END OF CHAIN
         END   ,
*
*  SEND REQUEST TO SCOM
*
         SCOM  GET,(RJ),PATH           SEND REQUEST TO SCOM
         ST    R15,@DOSCRC             SET RETURN CODE
*
*  CHECK RETURN CODE
*
         IF    (R15,NZ),BEGIN
         IF    ((R15,GE,12),OR,(R15,LE,24)),EXIT
         KAPUT SCMOOPS
         END
*
*  SET BUFFER LENGTH
*
         ST    R1,#SCSRRLN             RETURN BUFFER LENGTH
*
*  ALL DONE - RETURN TO CALLER
*
         LA    RVR,1                   IMMEDIATE RETURN
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCPOST  - Process SCOM Post request                           *
*                                                                 *
*                                                                 *
*     Input - @DOSCOM                                             *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCPOST   PROC  @DOSCOM,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         SCOM  POST,0,PATH             SEND POST REQUEST TO SCOM
         ST    R15,@DOSCRC             SET RETURN
         LA    RVR,1
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCINFO  - Process SCOM Info request                           *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCINFO   PROC  @DOSCOM,SCIOWORK,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         L     RY,@DOSCPRM             USER PARAMETERS
         WITH  (#SCINFO,RY)
         LA    RS,SCIOINFO             ANSWER AREA
         ST    RS,SCIOINBL              TO LIST
         LA    RS,5*4                  LENGTH
         ST    RS,SCIOINBL+4            TO LIST
         SET   SCIOINBL.X'80'          ONLY ONE ELEMENT
         SCOM  INFO,SCIOINBL,PATH      GET INFO
         ST    RVR,@DOSCRC             RETURN CODE
         IF    (RVR,Z),BEGIN
         L     RK,@DOSCIRB             INTERFACE PARAMETERS
         WITH  (@IORB,RK)
         L     RA,#SCIPART             PLACE TO PUT PARTNER NAME
         AL    RA,@IOROFF               TO MVS VIRTUAL
         MVC   @RA(8),SCIOINFO+2*4     GET PARTNERS PATH NAME
         L     RA,#SCIASCB             PLACE TO PUT ASCB POINTER
         AL    RA,@IOROFF               TO MVS VIRTUAL
         MVC   @RA(4),SCIOINFO+0*4     GET PARTNERS ASCB POINTER
         END   ,
         LA    RVR,1                   CONDITION CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCNTFY  - Process SCOM Notify request                         *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCNTFY   PROC  @DOSCOM,SCIOWORK,SCOPE=LOCAL
         L     RX,@DOSCSDB             SDB POINTER
         WITH  (SDB,RX)
         L     RY,@DOSCPRM             USER PARAMETERS
         WITH  (#SCNOTE,RY)
         WITH  (RTCB,RTCBR),'L  RJ,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RJ),'L  RJ,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RJ)
         LOCKOB IOCTSNTL               GET NOTIFY CHAIN LOCK
*
*  CALLER IS ALREADY ON THE NOTIFY QUEUE
*
         IF    SDBFNTFY,BEGIN
         KAPUT SCNTFY                  ALREADY ON NOTIFY QUEUE
         END   ,
*
*  SOME POST FLAGS ALREADY SET - POST IMMEDIATE
*
         IF    (SDBPFL,NZ),BEGIN       SOME POST FLAGS ALREADY SET
         PSET  @SCOMDB,CLEAR=NO
         ST    RX,@SCOMSDB             PATH BLOCK POINTER
         ACALL SCOMFLG                 POST FLAGS RETURNED IN R0
         ST    RVR,@DOSCRC             RETURN FLAGS TO CALLER
         LA    RA,1                    IMMEDIATE END
         END
*
*  USER MUST WAIT FOR POST - ADD TO END OF NOTIFY CHAIN
*
         ELSE  BEGIN
         LA    RS,IOCTSNFP-(SDBFP-SDB)   END OF CHAIN ANCHOR
         ST    RS,SDBFP                  IS NEXT ELEMENT
         L     RS,IOCTSNBP             LAST ELEMENT IN CHAIN
         ST    RS,SDBBP                 IS PREVIOUS ELEMENT
         WITH  (SDB,RS),'ST  RX,SDBFP'   AND THIS ONE HIS NEXT
         ST    RX,IOCTSNBP             THIS ONE IS AT THE END
         L     RK,@DOSCIRB             INTERFACE PARAMETERS
         WITH  (@IORB,RK)
         MVC   SDBRQID,@IORRQID        USER'S REQUEST ID
         SET   SDBFNTFY                MARK ON NOTIFY QUEUE
         CLEAR RA                      DEFERRED COMPLETION
         END   ,
         LOCKRL IOCTSNTL               RELEASE NOTIFY CHAIN
         LR    RVR,RA                  SET CONDITION CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCOMCLS - Do SCOM Close                                       *
*                                                                 *
*                                                                 *
*     Input -  @SCOMDB                                            *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOMCLS  PROC  @SCOMDB,SCOPE=LOCAL
         L     RA,@SCOMSDB             PATH ID
         WITH  (SDB,RA)
         WITH  (COMDB,SDB),'CLEAR  COMDBID'    SDB no longer valid
         WITH  (RTCB,RTCBR),'L  RX,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RX),'L  RX,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RX)
         LOCKOB IOCTPTHL               GET SCOM CHAIN LOCK
         LA    RS,IOCTPTHS             SCOM CHAIN
         SH    RS,=Y(SDBCHN-SDB)       OFFSET
         EJECT
*
*  FIND SDB ON THE CHAIN
*
         LOOP  BEGIN
         WITH  (SDB,RS)
         IF    (RA,EQ,SDBCHN),EXIT     FOUND
         L     RS,SDBCHN
         IF    (RS,Z),'KAPUT SCOMCLS'
         END   ,
*
*  NOW DISCONNECT IT AND FREE THE CHAIN LOCK
*
         L     R14,SDBCHN              NEXT IN CHAIN
         WITH  (SDB,RS),'ST  R14,SDBCHN'    UPDATE FREE CHAIN
         LOCKRL IOCTPTHL               RELEASE SCOM CHAIN LOCK
         DROP  RX
*
*  RELEASE THE MEMORY
*
         WITH  (SDB,RA),'CLEAR SDB'    CLEAR THE SDB
         MEMFREE L'SDB,A=(RA),TYPE=GLOBAL   RELEASE SDB BLOCK
         PEND
         LTORG
         TITLE 'ORVYL''S Hiperspace Service Routines'
         COPY  HSPCPARM
         SPACE 3
*******************************************************************
*
*    HSPDO - Hiperspace page/swap simulation control block
*
*******************************************************************
HSPDO    RECORD BEGIN
HSPDID   DS    CL4            'HSPD' ACRONYM
HSPDLEN  DS    CL4            LENGTH FOR MEMFREE
HSPDHDB  DS    CL4            POINTER TO HDB
HSPDIOFF DS    CL4            POINTER TO MVS OFFSET
HSPDPIO  DS    CL4            POINTER TO #PIODO
HSPDEND  EQU   *
         END
*******************************************************************
*
*    HSPCWORK - Hiperspace work area
*
*******************************************************************
HSPCWORK RECORD BEGIN
HSPCCNT  DS    A              NUMBER OF PAGES TO PROCESS
HSPCLIST DS    A              LIST SUPPLIED BY CALLER
HSPCRWWK DS    A              ADDRESS OF HSRWWORK
HSPCIOFF DS    A              ADDRESS OF MVS OFFSET
HSPCRQID DS    A              USER PARM AREA
HSPCFLG  FLAG  ,
         FLAG  HSPCWRIT       HIPERSPACE WRITE REQUEST
         FLAG  HSPCREAD       HIPERSPACE READ REQUEST
         END   ,
         SPACE 3
*******************************************************************
*
*    @DOHSPC - Parameters passed to Hiperspace drivers
*
*******************************************************************
         SPACE
@DOHSPC  RECORD BEGIN
@DOHSPRM DS    A                       User parm pointer
@DOHSHDB DS    A                       HDB Pointer
@DOHSIRB DS    A                       IORB Pointer
@DOHSRC  DS    A                       Return code
         END   ,
         SPACE 3
*
*  @HSRDWRT - Parameters passed to Hiperspace common routine
*
@HSRDWRT RECORD BEGIN
@HSWKADR DS    A                       Ptr to HSPCWORK
@HSHDBAD DS    A                       Ptr to HDB
@HSPSEND EQU   *
         END   ,
         EJECT
*******************************************************************
*
*    STANDARD HIPERSPACE FUNCTION TABLE
*
*******************************************************************
         SPACE
         DATA  BEGIN
HSPCTAB  DC    A(0)
         DC    A(HSOPEN)               OPEN
         DC    A(HSCLOSE)              CLOSE
         DC    A(HSIO)                 READ
         DC    A(HSIO)                 WRITE
HSPCMAX  EQU   *-HSPCTAB-4             MAXIMUM
         END   ,
         EJECT
*******************************************************************
*
*   HSPIO  - Do Standard Hiperspace Transactions
*
*
*     Input - @DOIO
*
*    Output -
*
*
*******************************************************************
         SPACE 3
HSPIO    PROC  @DOIO,SCOPE=LOCAL
         L     RX,@DODSID              PATH BLOCK POINTER
         WITH  (COMDB,RX)
         WITH  (HDB,COMDB)
         IF    (COMDBID,NE,=CL4'HDB'),'KAPUT HSPIO'
         L     RJ,@DOIORB
         WITH  (@IORB,RJ)
         L     RY,@DOUPRM              USER PARAMETERS
         WITH  (#HSPCCMD,RY)
         CLEAR RS
         IC    RS,#HSCCODE             FUNCTION CODE
         IF    (RS,NP),'KAPUT HSPCCMD'
         IF    (RS,GT,HSPCMAX),'KAPUT HSPCMAX'
* Must also be a multiple of 4
         IF    ('TM #HSCCODE,3',NZ),'KAPUT HSPCJUNK'
*** SIMULATION CODE ***
*
*  IF WE ARE SIMULATING A PAGE OR SWAP OPERATION, WE HAVE A USER
*  PARM IN THE FORMAT OF #PIODO FOR PAGE OR #SWPDO FOR SWAP.  WE
*  WILL COPY THE PARM TO A NEW AREA CALLED HSPDO WHICH WILL ALSO
*  CONTAIN A SECTION FORMATTED AS #HSPDO, THE PARM EXPECTED FOR A
*  DIRECT HIPERSPACE REQUEST, SINCE THE HIPERSPACE OPERATION MUST
*  PROCEED SIMULTANEOUSLY WITH BUT INDEPENDENTLY OF THE PAGE/SWAP
*  I/O OPERATION.
*
         IF    ((RS,EQ,#HSREAD),OR,    IF READ OR WRITE                *
               (RS,EQ,#HSWRIT)),         OPERATION                     *
               BEGIN
*
*  IF SIMULATING A PAGE/SWAP I/O, HIPERSPACE OPEN WAS NOT MIMICKED
*  AT PAGE/SWAP OPEN BECAUSE THE MAXIMUM BLOCK COUNT WHICH IS
*  REQUIRED FOR DSPSERV HAS NOT BEEN COMPUTED UNTIL PAGE/SWAP OPEN
*  PROCESSING COMPLETES IN THE PAGE/SWAP I/O SUBTASK.
*
         IF    (HDBFLG.HDBOPEN,Z),BEGIN IF OPEN HAS NOT BEEN ISSUED
         PSET  @DOHSPC
         ST    RX,@DOHSHDB             HDB pointer
         ST    RY,@DOHSPRM             User parm addr
         ST    RJ,@DOHSIRB             IORB Pointer
         ACALL HSOPEN                  CALL OPEN FUNCTION
*** TEST CODE ***
         QSNAP HDB,L'HDB-1
*** END OF TEST CODE ***
         END   ,                    OF IF OPEN HAS NOT BEEN ISSUED
         LR    RA,RY                   CHNG ORIG PARM BASE
         IF    HDBFLG.HDBPAGE,BEGIN    IF MIMICKING A PAGE IO
         WITH  (#PIODO,RA)               USE #PIODO PARM DSECT
*
*  GET NEW STORAGE FOR HSPDO.  AREA WILL CONTAIN HSPDO + #HSPDO +
*  A 12-BYTE PAGE LIST CONTAINING ONE PAGE/BLOCK ENTRY.
*
         LA    RVR,L'HSPDO+L'#HSPDO+L'#HSPL CALCULATE STORAGE LEN
         LR    RB,RVR                  SAVE FOR LATER
*        MEMGET (RB),TYPE=GLOBAL       GET MEMORY
HSPDOOB1 STORAGE OBTAIN,LENGTH=(RVR),SP=10,RELATED=HSPDORL
         LR    RY,RS                   USE ASSIGNED BASE REG
         WITH  (#HSPDO,RY)      **ESO**
         WITH  (#HSPL,#HSPEND)  **ESO**
         WITH  (HSPDO,#HSPLEND) **ESO**
         CLEAR HSPDO
         MVC   HSPDID,=C'HSPD'         MOVE IN ACRONYM
         ST    RB,HSPDLEN              STORE LENGTH FOR FREEMAIN
         ST    RX,HSPDHDB              SAVE HDB ADDRESS
         MVC   HSPDIOFF,@IOROFF        AND MVS OFFSET
         ST    RA,HSPDPIO                AND #SWPDO
         CLEAR #HSPDO
         MVC   #HSPDCMD,#PIODCMD       COPY ORIGINAL PARM
         LA    RVR,1                   WE WILL BE MOVING 1
         STH   RVR,#HSPCNT                PAGE ONLY
         CLEAR #HSPRC                  ZERO RETURN CODE
*
*  WE ARE USING A HOST-BASED VIRTUAL PAGE LIST IN PLACE OF A GUEST
*  REAL LIST.  HOST ADDRESSES DO NOT UNDERGO TRANSLATION BUT FOR
*  COMPATILIBITY WITH SUBSEQUENT HIPERSPACE ROUTINES WHICH EXPECT A
*  GUEST REAL ADDRESS, WE MUST SUBTRACT THE GUEST'S @IOROFF OFFSET
*  NOW SINCE IT WILL BE ADDED LATER ON BY THE SUBSEQUENT ROUTINES.
*
         LA    RVR,#HSPL                 INT TO PAGE LIST
         SL    RVR,@IOROFF             SUBTRACT MVS OFFSET
         ST    RVR,#HSPLIST            STORE LIST AT END OF DSECT
*
*  NOW WE FORMAT THE PAGE LIST
*
         CLEAR RVR                     INSERT ZEROES IN
         ST    RVR,#HSPLNXT              NEXT LIST POINTER
         MVC   #HSPLPGE,#PIOBLK+4      COPY PAGE AND
         MVC   #HSPLBLK,#PIOBLK          BLOCK POINTERS
         OI     #HSPLPGE,X'80'          TURN ON END-OF-LIST FLAG
         END   ,                    OF IF MIMICKING A PAGE IO
         ELSEIF (HDBFLG.HDBSWAP),BEGIN   IF MIMICKING A SWAP IO
*
*  WE ARE SIMULATING A SWAP OPERATION.  THE #SWPDO PARAMETER LIST
*  CONTAINS A VARIABLE NUMBER OF SUBLISTS OF GUEST PAGES.  EACH
*  SUBLIST CONTAINS A NEXT-LIST POINTER WHICH CHAINS IT TO THE NEXT
*  SUBLIST. THE LAST NEXT-LIST POINTER CONTAINS ZEROES. EACH SUBLIST
*  CONTAINS A VARIABLE NUMBER OF FULLWORD ENTRIES DESCRIBING GUEST
*  REAL PAGE ADDRESSES, THE END OF WHICH IS MARKED BY A X'80' IN THE
*  HIGH ORDER BYTE.  THE SWAP DATA SET SLOTS ARE INDICATED BY A
*  BEGINNING BLOCK NUMBER AND ASSIGNED SEQUENTIALLY AS INDICATED BY
*  #SWPCNT.  THIS LIST MUST BE CONVERTED TO THE #HSPDO FORMAT
*  EXPECTED BY MODULE HSRDWRT.  THIS IS SIMILAR TO THE FORMAT FOR
*  PAGE SIMULATION PERFORMED ABOVE BUT SWAPS INVOLVE MULTIPLE PAGE
*  AND BLOCK ENTRIES WHEREAS PAGE SIMULATION CONTAINS ONLY ONE PAGE
*  AND BLOCK ENTRY.
*
         WITH  (#SWPDO,RA)             USE SWAP IO PARM DSECT
         LH    RB,#SWPCNT              GET SWAP COUNT
         SLL   RB,3                    CNT*8=PAGE/BLOCK ENTRY SIZE
         LA    RB,L'#HSPDO+4(,RB)      GET STORAGE FOR #HSPDO+LIST
         LA    RVR,HSPDEND-HSPDO(,RB)  INCLUDE HSPDO AREA
         LR    RB,RVR                  SAVE LENGTH FOR LATER
*        MEMGET (RB),TYPE=GLOBAL       GET #HSPDO
HSPDOOB2 STORAGE OBTAIN,LENGTH=(RVR),SP=10,RELATED=HSPDORL
         LR    RY,RS                   USE ASSIGNED BASE REG
         WITH  (#HSPDO,RY)      **ESO**
         WITH  (#HSPL,#HSPEND)  **ESO**
         WITH  (HSPDO,#HSPLEND) **ESO**
         CLEAR HSPDO            **ESO**
         MVC   HSPDID,=C'HSPD'         MOVE IN ACRONYM
         ST    RB,HSPDLEN              STORE LENGTH FOR FREEMAIN
         ST    RX,HSPDHDB              SAVE HDB ADDRESS
         MVC   HSPDIOFF,@IOROFF        AND MVS OFFSET
         ST    RA,HSPDPIO                AND #SWPDO
         CLEAR #HSPDO
         MVC   #HSPDCMD,#SWPDCMD       COPY ORIGINAL PARM
         MVC   #HSPCNT,#SWPCNT           AND PAGE COUNT
         CLEAR #HSPRC                  ZERO RETURN CODE
*
*  MAKE SURE THERE IS A SWAP LIST
*
         IF    ('LT RK,#SWPLIST',Z),'KAPUT NOSWPLST'
         ST    RK,#HSPLIST             SAVE SWAP LIST
         L     RB,#SWPBLK              GET STARTING BLOCK NO.
*
*  ZERO OUT THE NEXT LIST POINTER IN OUR NEW LIST BECAUSE WE WILL
*  CONSOLIDATE ALL SUBLISTS FROM THE OLD LIST INTO ONE LIST IN THE
*  NEW ONE.
*
         CLEAR RK                      ZERO OUT POINTER TO NEXT
         ST    RK,#HSPLNXT             LIST, WE ONLY HAVE ONE
*
*  ROUTINE TO FORMAT THE NEW SWAP LIST
*        RM = POINTER TO PAGE ENTRY IN OLD LIST
*        RK = INDEX TO NEW LIST PAGE ENTRY
*        RB = GENERATES SEQUENTIAL BLOCK NO FOR NEW LIST
*        #HSPLIST USED AS A TEMPORARY WORK AREA WITHIN LOOP
*
         WHILE ('LT  RM,#HSPLIST',NZ),BEGIN SWAP LIST REBUILD
         AL    RM,@IOROFF              TO MVS VIRTUAL
         MVC   #HSPLIST,@RM            NEXT LIST
         LOOP  BEGIN                   SWAP LIST SEARCH LOOP
         LA    RM,@RM+4                NEXT PAGE ENTRY
*
*  IF TOTAL PAGE COUNT GOES NEGATIVE BEFORE LOOP ENDS, THERE IS A
*  MISMATCH BETWEEN THE COUNT AND THE NUMBER OF PAGES IN THE LIST.
*
         DECR  R0,#HSPCNT              DECREMENT TOTAL COUNT
         IF    (R0,M),'KAPUT SWPCNT'   ABEND ON A MISMATCH
         LA    R15,4095                PAGE MUST BE ON PAGE BNDRY
         IF    ('N  R15,@RM',NZ),'KAPUT SWIOADDR' ELSE ABEND
         L     R15,@RM                 GET A GUEST REAL PAGE POINTER
         AL    R15,@IOROFF             TRANSLATE TO MVS VIRTUAL
         LRA   R15,@R15                MAKE SURE IT IS BACKED BY A
         IF    NZ,'KAPUT SWPNFIX'        REAL PAGE ELSE ABEND
         ST    RB,#HSPLBLK(RK)         STORE BLOCK NO IN NEW
         L     R15,@RM                 GET SWAP BUFFER POINTER
         SLL   R15,1                   CLEAR END-OF-LIST FLAG
         SRL   R15,1                     IN HIGH-ORDER BIT
         ST    R15,#HSPLPGE(RK)        STORE IN NEW SWAP LIST
         LA    R15,#HSPLPGE(RK)        SAVE CURR PTR FOR END-OF-LIST
         LA    RK,@RK+8                BUMP TO NEXT SLOT IN NEW
         LA    RB,1(,RB)               ASSIGN NEXT HSPCE BLK NO
         UNTIL @RM.X'80',END           RETURN TO SEARCH LOOP
         END   ,                    OF SWAP LIST REBUILD
         OI    @R15,X'80'
         MVC   #HSPCNT,#SWPCNT         REFRESH PAGE COUNT
         LA    RVR,#HSPL               POSITION RK TO NEW LIST
         SL    RVR,@IOROFF             SUBTRACT MVS OFFSET
         ST    RVR,#HSPLIST            REFRESH LIST POINTER
         END   ,                    OF IF MIMICKING A SWAP IO
         END   ,                    OF IF READ OR WRITE
*** END OF SIMULATION CODE ***
*
*  Send request to driver
*
         L     RX,@DODSID              PATH BLOCK POINTER
         L     RJ,@DOIORB
         PSET  @DOHSPC
         ST    RX,@DOHSHDB             HDB pointer
         CLEAR RS
         WITH  (#HSPCCMD,RY)     **ESO**
         WITH  (#HSPDO,#HSPCCMD) **ESO**
         WITH  (#HSPL,#HSPEND)   **ESO**
         WITH  (HSPDO,#HSPLEND)  **ESO**
         IC    RS,#HSPDCMD+3           FUNCTION CODE
         ST    RY,@DOHSPRM             Copied user parm addr
         ST    RJ,@DOHSIRB             IORB Pointer
         ACALL HSPCTAB(RS)             CALL FUNCTION ROUTINE
         IF    (RS,NE,#HSCLOS),BEGIN   IF NOT CLOSE
         LR    RM,RVR                  PRESERVE RC FROM MVPG
         MVC   @DORC,@DOHSRC           Set return code
*
*  FOR A PAGE OR SWAP WE OBTAINED AN AREA FOR HSPDO.  WE MUST
*  FREE THIS AREA NOW.
*
         IF    (COMDBID,NE,=CL4'HDB'),'KAPUT HSPIO'
         IF    ((HDBFLG.HDBPAGE),OR,(HDBFLG.HDBSWAP)),                 *
               BEGIN                   DID WE MIMIC A PAGE/SWAP
         L     RK,@IORRQID             GET POINTER TO IRCB
         WITH  (IRCB,RK)
         IF    (HSPDID,NE,=C'HSPD'),'KAPUT NOHSPDID'
         L     RB,HSPDLEN              GET LENGTH FOR MEMFREE
         MVI   HSPDID,C' '             CLEAR EYECATCHER
*        MEMFREE (RB),A=(RY),TYPE=GLOBAL FREE #HSPDO
HSPDORL  STORAGE RELEASE,ADDR=(RY),LENGTH=(RB),                        *
               SP=10,RELATED=HSPDOOB
         END   ,                    OF DID WE MIMIC A PAGE/SWAP
         LR    RVR,RM                  RESTORE RC FROM  VPG
         END   ,                    OF IF NOT CLOSE
         PEND
         EJECT
*******************************************************************
*
*   HSOPEN  - Process Standard Hiperspace Open request
*
*
*     Input -
*
*    Output -
*
*
*******************************************************************
         SPACE 3
HSOPCL   RECORD BEGIN
DSPLIST  DSPSERV MF=(L,DSPPARM)
ALELIST  ALESERV MF=L
         END
         EJECT
*
*  THIS ROUTINE INITIALIZES THE HIPERSPACE.  THE GUEST CALLER CAN
*  INVOKE THIS ROUTINE DIRECTLY BUT IN SIMULATION MODE THIS CODE
*  IS DEFERRED UNTIL THE FIRST I/O REQUEST IS RECEIVED TO ENSURE
*  THAT THE PAGE/SWAP DATA SET OPEN HAS COMPLETED AND THAT DDBBLKCT
*  HAS BEEN UPDATED.  THIS VALUE MAY BE OBTAINED FROM THE DSCB OF
*  A REAL PAGE DATA SET AND IS USED TO DETERMINE THE MAXIMUM SIZE OF
*  THE HIPERSPACE BEING OPENED WHEN IN SIMULATION MODE.  ON A
*  DIRECT INVOCATION, THE VALUE IS GIVEN IN #HSPSIZE BY THE CALLER.
*
HSOPEN   PROC  @DOHSPC,HSPCWORK,SCOPE=LOCAL
         L     RX,@DOHSHDB             HDB POINTER
         WITH  (HDB,RX)
         L     RY,@DOHSPRM             USER OPEN PARM PTR
         WITH  (#HSPOPEN,RY)
         IF    HDBFLG.HDBOPEN,'KAPUT HSPOPEN'  OPEN RECURSION IS BAD
         IF    ((HDBHPSIZ,Z),AND,(#HSPSIZE,NZ)),                       *
               'MVC HDBHPSIZ,#HSPSIZE'   DIRECT INVOCATION     **ESO**
         IF    ((HDBHPSIZ,Z),OR,(HDBHPSIZ,GT,=F'524288')),             *
               'KAPUT BADHPSIZ'  BY NOW HDPHPSIZ MUST HAVE A GOOD VALUE
         MEMGET L'HSOPCL               GET WORKSPACE
         LR    RB,RVR
         WITH  (HSOPCL,RB)
         WITH  (RTCB,RTCBR),'L  RA,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RA),'L  RA,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RA)
         IF    (HDBFLG.HDBSTND),BEGIN  STANDARD HIPERSPACE
*
*  CREATE STANDARD HIPERSPACE
*
         L     RAR,=A(DSPEND+X'80000000') POINT TO PR RET
         BAKR  RAR,0                   USE HARDWARE STACK
         DSPSERV CREATE,TYPE=HIPERSPACE,HSTYPE=SCROLL,TTOKEN=IOCTTTOK, *
               ORIGIN=HDBORIG,BLOCKS=HDBHPSIZ,NAME=HDBHSNAM,           *
               STOKEN=HDBTOKEN,SHARE=YES,MF=(E,DSPLIST,COMPLETE)
         IF    (EPAR,NZ),'KAPUT DSPSVERR'
         END   ,                    OF STANDARD HIPERSPACE
         ELSEIF (HDBFLG.HDBESO),BEGIN  ESO HIPERSPACE
*
*  CREATE ESO HIPERSPACE
*
         L     RAR,=A(DSPEND+X'80000000') POINT TO PR RET
         BAKR  RAR,0                   USE HARDWARE STACK
         DSPSERV CREATE,TYPE=HIPERSPACE,HSTYPE=CACHE,TTOKEN=IOCTTTOK,  *
               ORIGIN=HDBORIG,BLOCKS=HDBHPSIZ,NAME=HDBHSNAM,           *
               STOKEN=HDBTOKEN,CASTOUT=YES,                            *
               MF=(E,DSPLIST,COMPLETE)
         IF    (EPAR,NZ),'KAPUT DSPSVERR'
         END   ,                    OF ESO HIPERSPACE
         ELSE  'KAPUT NOHSFLAG'        NO FLAG IS ON
         ALESERV ADD,STOKEN=HDBTOKEN,ALET=HDBALET,                     *
               AL=PASN,MF=(E,ALELIST)
         IF    (EPAR,NZ),'KAPUT ALESVERR'
         IF    (HDBFLG.HDBESO),BEGIN   ESO HIPERSPACE
         QSNAP HDB,L'HDB-1
         END   ,
         PR                            RESTORE FROM STACK
DSPEND   EQU   *                         AND BR HERE
         MEMFREE L'HSOPCL,A=(RB)
         SET (HDBFLG.HDBOPEN)
         LA    RVR,1                   IMMEDIATE COMPLETION
         PEND
         LTORG
         EJECT
*******************************************************************
*
*   HSCLOSE  - Process both ESO and Standard Hiperspace Close
*              requests.
*
*     Input -
*
*    Output -
*
*
*******************************************************************
HSCLOSE  PROC  @DOHSPC,HSPCWORK,SCOPE=LOCAL
         L     RK,@DOHSHDB             HDB POINTER
         WITH  (HDB,RK)
         QSNAP '***** HSCLOSE *****'
         QSNAP HDB,L'HDB-1
         IF    (HDBFLG.HDBOPEN,Z),'KAPUT HSPOPEN'
*        L     RS,HDBBUFAD             GET BUFFER ADDRESS
*        STORAGE RELEASE,LENGTH=4096,ADDR=(RS)
         MEMGET L'HSOPCL               GET WORKSPACE
         LR    RB,RVR
         WITH  (HSOPCL,RB)
         WITH  (RTCB,RTCBR),'L  RA,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RA),'L  RA,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RA)
*
*  DELETE HIPERSPACE AND ITS ALET
*
         L     RAR,=A(HSCLSEND+X'80000000') POINT TO PR RET
         BAKR  RAR,0                   USE HARDWARE STACK
         ALESERV DELETE,ALET=HDBALET,MF=(E,ALELIST)
         IF    (EPAR,NZ),'KAPUT ALESVERR'
         DSPSERV DELETE,STOKEN=HDBTOKEN,TTOKEN=IOCTTTOK,               *
               MF=(E,DSPLIST,COMPLETE)
         IF    (EPAR,NZ),'KAPUT DSPSVERR'
         PR                            EXIT TO HSEND
HSCLSEND EQU   *
         MEMFREE L'HSOPCL,A=(RB)
*
*  UNCHAIN HDB
*
         WITH  (RTCB,RTCBR),'L  RX,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RX),'L  RX,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RX)
         LOCKOB IOCTHDBL               GET HDB CHAIN LOCK
         LA    RS,IOCTHDBS             HDB CHAIN
         SH    RS,=Y(HDBCHAIN-HDB)     OFFSET
         LOOP  BEGIN
         WITH  (HDB,RS)
         IF    (RK,EQ,HDBCHAIN),EXIT   FOUND
         L     RS,HDBCHAIN
         END   ,
         L     R14,HDBCHAIN            NEXT IN CHAIN
         WITH  (HDB,RS),'ST  R14,HDBCHAIN' UPDATE FREE CHAIN
         LOCKRL IOCTHDBL               RELEASE HDB CHAIN LOCK
         DROP  RX
         EJECT
*
*  RELEASE HDB THEN RETURN
*
         CLEAR HDB                     CLEAR THE HDB
         MEMFREE L'HDB,A=(RK),TYPE=GLOBAL
         LA    RVR,1                   IMMEDIATE COMPLETION
         PEND
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   HSIO - Process Standard Hiperspace request                    *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
HSIO     PROC  @DOHSPC,HSPCWORK,SCOPE=LOCAL
         L     RX,@DOHSHDB             HDB POINTER
         WITH  (HDB,RX)
         L     RY,@DOHSPRM             USER PARAMETERS
         WITH  (#HSPDO,RY)
         CLEAR HSPCWORK
         LH    RA,#HSPCNT            USE PAGE COUNT
         ST    RA,HSPCCNT            SAVE IN HSPCWORK
         MVC   HSPCLIST,#HSPLIST     ALSO COPY PAGE LIST
         L     RA,@DOHSIRB           GET IORB
         WITH  (@IORB,RA)
         MVC   HSPCRQID,@IORRQID     SAVE IRCB FOR IO END
         LA    RS,HSPCWORK           SAVE HSPCWORK
         PSET  @HSRDWRT                IN PARAMETER PASSED
         ST    RX,@HSHDBAD           SAVE FROM HSRDWRT PARM
         ST    RS,@HSWKADR             TO @HSRDWRT PARM
         MVC   HSPCIOFF,@IOROFF      COPY MVS OFFSET
         CLEAR RS
         IC    RS,#HSPCODE
         EJECT
         IF    (RS,EQ,#HSWRIT),BEGIN
         SET   (HSPCFLG.HSPCWRIT,EQ)
         L     RAR,HDBWCT            INCREMENT
         LOOP  BEGIN
         L     R15,HSPCCNT             REQUESTED WRITE
         ALR   R15,RAR                 FRAME COUNT
         CS    RAR,R15,HDBWCT          SERIALIZED
         UNTIL Z,END                   IN HDB
         L     RAR,HDBWRCT             INCREMENT
         LOOP  BEGIN
         LA    R15,1
         ALR   R15,RAR
         CS    RAR,R15,HDBWRCT
         UNTIL Z,END                   IN HDB
         END   ,
         ELSEIF    (RS,EQ,#HSREAD),BEGIN
         L     RAR,HDBRCT            INCREMENT
         LOOP  BEGIN
         L     R15,HSPCCNT             REQUESTED READ
         ALR   R15,RAR                 FRAME COUNT
         CS    RAR,R15,HDBRCT          SERIALIZED
         UNTIL Z,END                   IN HDB
         L     RAR,HDBRDCT             INCREMENT
         LOOP  BEGIN
         LA    R15,1
         ALR   R15,RAR
         CS    RAR,R15,HDBRDCT
         UNTIL Z,END                   IN HDB
         SET   (HSPCFLG.HSPCREAD,EQ)
         END   ,
         ELSE  'KAPUT NOTRDWRT'
         ACALL HSRDWRT               PERFORM WRITE
         PEND
         TITLE 'ORVYL''S ESO Hiperspace Service Routines'
         SPACE 3
*******************************************************************
*
*    HSRWWORK - Hiperspace read/write work area
*
*******************************************************************
HSRWWORK RECORD BEGIN
HSRWID   DS    A              HSRW ACRONYM
HSRWLEN  DS    A              LENGTH OF THIS W/A
HSRWMBUF DS    A              ADDRESS OF MSG BUF
HSRWHDB  DS    A              ADDRESS OF HDB
HSRWCNT  DS    A              PAGE COUNT
HSRWRQID DS    A              USER PARM/REQ ID
HSRWRTCD DS    F              HSPSERV RETCODE AREA
HSRWRC   DS    C              RETURN CODE FOR HSPSERV/MVPG
HSRWFLG  DS    C              READ/WRITE FLAG
HSRWRSCD DS    F              HSPSERV REASON CODE AREA
HSRWKEYS DS    F              MODESET KEY SAVE
HSRWSTOD DS    D              HSRDWRT START TIMESTAMP
HSRWPTOD DS    D              HSRDWRT STOP TIMESTAMP
HSRWINTV DS    D              STIMERM INTERVAL
HSRWTMID DS    F              STIMERM ID
HSRWRNGL DS    A              POINTS TO HSRWPGAD
* NEXT 3 FULLWORDS ARE THE RANGELIST FOR HSPSERV
HSRWPGAD DS    A              MVS VIRTUAL ADDR OF CURR PAGE
HSRWHLOC DS    A              HIPERSPACE BLOCK LOCATION
HSRWNBLK DS    A              # OF BLOCKS (ALWAYS 1)
HSRWTIMR STIMERM SET,MF=L
HSRWSERV HSPSERV PLISTVER=1,MF=(L,HSPLIST)
HSRWSAVE DS    40F            HSPSERV SAVE AREA
HSRWREND EQU   *              TRANSLATED LIST STARTS HERE
         END   ,
*
*  THE FORMAT FOR EACH PAGE/BLOCK ENTRY IN THE NEW LIST IS AS
*
HSRWPLST RECORD BEGIN
HSRWPPGE DS    F              PAGE VIRTUAL ADDRESS IN CENTRAL STOR
HSRWPBLK DS    F              HIPERSPACE BLOCK ESTOR VIRTUAL ADDR
HSRWPCDE DS    F              THIS ENTRY'S MVPG/HSPSERV ERROR CODE
         ORG   HSRWPCDE
HSRWFLAG FLAG  ,
         FLAG  HSRWERR
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    HSRDWRT - Common Hiperspace Read/Write routine               *
*                                                                 *
*                                                                 *
*    Input - @HSRDWRT                                             *
*                                                                 *
*******************************************************************
         SPACE 3
*
*  THIS ROUTINE PERFORMS PAGE MOVEMENT BETWEEN CENTRAL STORAGE
*  AND HIPERSPACE EXPANDED STORAGE.  HIPERSPACE CAN BE EITHER
*  STANDARD OR EXPANDED STORAGE ONLY (ESO).  STANDARD HSPACE
*  WILL BE PAGED OUT TO AUXILIARY STORAGE WHEN MVS RSM DETECTS
*  A SHORTAGE OF EXPANDED STORAGE, THUS ITS DATA INTEGRITY IS
*  ALWAYS ASSURED.  AN ESO HSPACE ACTS ONLY AS A CACHE AND
*  THE USER IS EXPECTED TO KEEP A COPY OF THE DATA ELSEWHERE
*  BECAUSE IF DATA IN ESO IS DISCARDED BY RSM IT CAN NEVER BE
*  RETRIEVED FROM ESTOR UNTIL IT IS WRITTEN ONCE AGAIN INTO
*  HIPERSPACE.
*
*  PAGE MOVEMENT IS FIRST ATTEMPTED WITH A DIRECT MVPG INSTRUCTION.
*  A DIRECT MVPG SUCCEEDS ONLY WHEN BOTH A CENTRAL AND EXTENDED
*  STORAGE FRAME CURRENTLY BACK UP THE VIRTUAL PAGE AND HIPERSPACE
*  BLOCK MVPG OPERANDS.  THUS, A MVPG WRITE TO A HIPERSPACE BLOCK
*  WILL FAIL UNTIL AN HSPSERV WRITE HAS BEEN PERFORMED TO ASSIGN AN
*  ESTOR FRAME FOR THE BLOCK.  LIKEWISE, A MVPG READ FROM A
*  PAGED-OUT HIPERSPACE BLOCK WILL ALSO FAIL. IN THESE CASES EXCEPT
*  FOR A DISCARDED ESO PAGE, THE OPERATION MUST BE RETRIED WITH AN
*  HSPSERV REQUEST IN ORDER TO ASSIGN AN ESTOR FRAME TO A NEW BLOCK
*  OR RECALL A PAGED-OUT FRAME.
*
*  ALTHOUGH IT IS NOT MENTIONED IN THE IBM MANUALS, A CENTRAL
*  STORAGE FRAME TO BE USED IN A MVPG OR HSPSERV OPERATION MAY NOT
*  BE PAGE-FIXED.  THUS ORVYL PAGES MAY NOT BE DIRECTLY USED IN A
*  MVPG OR HSPSERV OPERATION. OTHERWISE A CONDITION CODE OF 1 OR AN
*  01D ABEND WITH REASON CODE XXXX10XX WILL RESULT.  THE FOLLOWING
*  HIPERSPACE ROUTINES WILL USE A STORAGE MACRO TO OBTAIN STORAGE
*  FOR A PAGE BUFFER.
*
         EJECT
HSRDWRT  PROC  @HSRDWRT,SCOPE=LOCAL
         WITH  (RTCB,RTCBR)
         IF    ('LT RS,RTCBBUFR',Z),BEGIN IF NO MVPG BUFFER ASSIGNED
         STORAGE OBTAIN,LENGTH=4096,BNDRY=PAGE GET BUFFER FOR MVPG
         ST    RS,RTCBBUFR             STORE BUFFER ADDR IN RTCB
         END   ,                    OF IF NO MVPG BUFFER ASSIGNED
         L     RX,@HSWKADR             GET HSPCWORK
         WITH  (HSPCWORK,RX)
         L     RY,@HSHDBAD             GET HDB
         WITH (HDB,RY)
         L     RJ,HSPCCNT              USER'S PAGE COUNT
         IF    (RJ,GT,255),'KAPUT HSPCNT' TOO MANY PAGES
*
*  OBTAIN MEMORY FOR AN HSPSERV WORK AREA (HSRWWORK). HSRWWORK
*  WILL CONTAIN HSPSERV PARAMETER LIST AND A LIST OF PAGE/BLOCK
*  PAIRS TRANSLATED FROM THE CALLER'S LIST.  NOTE THAT WHILE
*  THE CALLER'S LIST MAY CONTAIN SEVERAL CONCATENATED SUBLISTS
*  THE HSRWWORK LIST WE WILL BUILD FOR THIS ROUTINE CONSISTS OF
*  A SINGLE CONSOLIDATED LIST.
*
         LR    RA,RJ                   PAGE/BLOCK LIST LENGTH IS
         MH    RA,=H'12'                 PAGE COUNT * 12
         LA    RA,L'HSRWWORK(RA)         PLUS HSRWWORK LENGTH
*        MEMGET (RA),TYPE=GLOBAL         = MEMGET LENGTH
         LR    RVR,RA
HSRWOB   STORAGE OBTAIN,LENGTH=(RVR),SP=10,RELATED=HSRWRL
         LR    RM,RS                   ASSIGN HSRWWORK BASE REG
         ST    RS,HSPCRWWK             SAVE ADDR FOR MEMFREE
         WITH  (HSRWWORK,RM)
         WITH  (HSRWPLST,HSRWREND)
         CLEAR HSRWWORK
         MVC   HSRWID,=C'HSRW'         MOVE IN ACRONYM
         ST    RA,HSRWLEN              SAVE LENGTH FOR FREE
         ST    RY,HSRWHDB              SAVE HDB
         ST    RJ,HSRWCNT              SAVE PAGE COUNT
         L     RA,HSPCRQID             SAVE
         ST    RA,HSRWRQID               PARM
         MVC   HSRWFLG,HSPCFLG        SAVE READ/WRITE FLAG
         LA    RS,HSRWPGAD             FORMAT HSPSERV
         ST    RS,HSRWRNGL               RANGELIST
         LA    RA,1                    WE SUBMIT ONLY ONE PAGE
         ST    RA,HSRWNBLK               AT A TIME TO HSPSERV
*
* THE FOLLOWING ROUTINE FORMATS THE TRANSLATED PAGE/BLOCK LIST.
* SOME VALIDATION OF PAGE/BLOCK PAIRS IS PERFORMED.
*
         WHILE ('LT RB,HSPCLIST',NZ),  WHILE THERE'S A NEXT LIST       *
               BEGIN
         AL    RB,HSPCIOFF             TRANSLATE TO VIRTUAL
         WITH  (#HSPL,RB)              OLD LIST
         MVC   HSPCLIST,#HSPLNXT       PRIME NEXT SUBLIST
         CLEAR RA                      RA WILL BE NEW LIST INDEX REG
         CLEAR RK                      RK WILL BE OLD LIST INDEX REG
         EJECT
         LOOP  BEGIN
*
*  PAGE COUNT CANNOT GO NEGATIVE UNTIL END OF LIST HAS BEEN
*  REACHED.
*
         DECR  RJ                      DECREMENT COUNT BY 1
         IF    (RJ,M),'KAPUT HSPCCNT'
*
*  ADDRESSES IN PAGE LIST MUST BE ON A PAGE BOUNDARY
*
         LA    RS,4095
         IF    ('N  RS,#HSPLPGE(RK)',NZ),'KAPUT HSNPGBDY'
*
*  PAGE MUST BE BACKED BY A REAL PAGE FRAME
*
         L     RS,#HSPLPGE(RK)        GET A PAGE POINTER
         SLL   RS,1                   CLEAR END-OF-LIST FLAG
         SRL   RS,1                      IN HIGH-ORDER BIT
         AL    RS,HSPCIOFF            MAKE IT MVS VIRTUAL
         LRA   RVR,@RS                MAKE SURE REAL IS IN
         IF    NZ,'KAPUT HSPNFIX'
         ST    RS,HSRWPPGE(RA)        SAVE IN HSRWPLST SLOT
*
*  BLOCK NUMBER CANNOT BE GREATER THAN MAXIMUM REQUESTED AT
*  OPEN TIME IN DSPSERV REQUEST.
*
         L     RS,#HSPLBLK(RK)        NOW GET BLOCK NUMBER
         IF    (RS,GT,HDBHPSIZ),'KAPUT GTHPSIZ'
*
*  RELATIVE BLOCK NUMBER MUST BE CONVERTED TO A VIRTUAL
*  ADDRESS REQUIRED BY MVPG OR HSPSERV.
*
         SLL   RS,12                  CONVERT TO VIRTUAL ADDR
         A     RS,HDBORIG             ADD OFFSET TO HSP START
         ST    RS,HSRWPBLK(RA)        STORE IN HSRWPLST
         CLEAR #HSPLFLG               RESET #HSPL ERROR FLG**ESO1**
         LA    RS,#HSPLFLG            SAVE ADDR FOR PASSING**ESO1**
         ST    RS,HSRWPCDE(RA)          BACK ERROR CODE    **ESO1**
         LA    RS,HSRWPPGE(RA)        SAVE CURR PGE PTR FOR END
         LA    RAR,#HSPLPGE(RK)       SAVE OLD PAGE PTR FOR END
         LA    RA,@RA+12              BUMP INDEX FOR NEXT NEW ENTRY
         LA    RK,@RK+8               BUMP INDEX FOR NEXT ENTRY
         UNTIL @RAR.X'80',END         OLD LIST HAS ENDED
         CLEAR RK                     POINT TO NEXT OLD LIST IF ANY
         END   ,                   OF WHILE THERE'S NEXT LIST
         OI    @RS,X'80'              TURN ON END FLAG IN NEW LIST
*
*  HSRWWORK HAS BEEN FORMATTED.  HSRWPLST CONTAINS PAGE/BLOCK
*  ENTRIES TO BE USED BY MVPG OR HSPSERV.
*
*  HIPERSPACE SERVICES REQUIRE USE OF A LINKAGE STACK.   NOTE
*  THAT HSPSERV WILL REQUIRE THAT R13 POINT TO A 144-BYTE SAVE
*  AREA.  WE HAVE RESERVED THIS AREA IN HSRWWORK.
*
         L     RAR,=A(HSRWEND+X'80000000') PR WILL GO TO HSRWEND
         BAKR  RAR,0                     FOR AR MODE SWITCHING
*
*  FOR MVPG, R2 POINTS TO CENTRAL STORAGE PAGE
*            AR2 CONTAINS A ZERO VALUE FOR PRIMARY ADDR SPACE
*            R3 POINTS TO HIPERSPACE BLOCK IN EXPANDED STORAGE
*            AR3 CONTAINS ALET KEPT IN HDBALET FROM DSPSERV
*            R0 REQUIRED BY S/390 ARCHITECTURE TO CONTAIN X'100'
*
         L     RJ,HSPCCNT              COUNT OF LIST ENTRIES
         CLEAR RK                      CLEAR PAGE LIST INDEX
         CLEAR RA                      LOAD HOME ADDRSPC
         SAR   RA,RA                     ALET OF 0 INTO AR2
         LAM   RB,RB,HDBALET           LOAD HDBALET INTO AR3
*
*  NOW A MVPG IS MADE ON EACH PAGE/BLOCK PAIR IN THE LIST.
*  HSRWRC IS INITIALLY SET TO ZERO.  IF ANY MVPG ERRORS ARE
*  ENCOUNTERED, IT IS SET TO NON-ZERO AND THE ERROR FLAG FOR
*  THE PAGE/BLOCK IN THE CALLER'S LIST IS TURNED ON.  LATER,
*  IN ROUTINE HSPRETRY, IF HSRWRC IS NON-ZERO, A RESCAN OF THE
*  LIST IS PERFORMED AND FOR EACH PAGE/BLOCK ENTRY FLAGGED
*  IN ERROR, A RETRY OF THE OPERATION WILL BE SCHEDULED IN
*  SUBTASK HSPCETSK VIA HSPSERV.
*
         WHILE (RJ,NZ),BEGIN           WHILE PAGES LEFT TO DO
         CLEAR HSRWRC                  ZERO RETURN CODE
         CLEAR RVR                     ZERO RETURN CODE REG
*
*  KEY ZERO IS NEEDED WHEN ACCESSING A BUFFER PROVIDED BY THE
*  GUEST.
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
         ST    RA,HSRWKEYS             SAVE OLD KEY IN R1
         L     RVR,=F'256'             LOAD R0 PARM FOR MVPG
*
* ESO HIPERSPACE REQUESTS USE CALLER'S AREA DIRECTLY.
*
         IF (HDBFLG.HDBESO),'L RA,HSRWPPGE(RK)'            **ESO1**
*
* STANDARD HIPERSPACE REQUESTS MUST USE A NON-PAGE-FIXED BUFFER
*
         ELSE  'L RA,RTCBBUFR'  ELSE  GET BUFFER FROM RTCB **ESO1**
*
*  BEGIN A WRITE OPERATION
*
         IF (HSPCFLG.HSPCWRIT),BEGIN   MVPG WRITE
         L     RB,=F'4096'             GET PAGE LEN FOR MVCL
         LR    EPAR,RB                   LENGTH REGISTERS
         IF    (HDBFLG.HDBSTND),BEGIN  IF STANDARD HSPACE  **ESO1**
         L     RAR,HSRWPPGE(RK)        GET A PAGE ENTRY
         SLL   RAR,1                   REMOVE
         SRL   RAR,1                     HIGH BIT
         MVCL  RA,RAR                  MOVE TO BUFFER
         L     RA,RTCBBUFR             MVCL WIPED OUT BUFAD
         END   ,                    OF IF STANDARD HSPACE  **ESO1**
         L     RB,HSRWPBLK(RK)         HSPACE BLOCK NUMBER
         SAC   512                     ENTER ASC MODE
         MVPG  RB,RA                   WRITE INTO HIPERSPACE
         SAC   0                       SWITCH MODE BACK
         IF    (NZ),BEGIN              MVPG WRITE FAILED
*
*  MVPG WRITE FAILED
*
         LA    RVR,8                   WE HAD A REAL
         STC   RVR,HSRWRC                MVPG ERROR
         END   ,                    OF MVPG WRITE FAILED
         ELSE  BEGIN                   MVPG WRITE OK
*
*  MVPG WRITE WAS OK
*
         L     RS,HDBMVWR              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     MVPG
         ALR   R15,RS                    WRITE COUNT
         CS    RS,R15,HDBMVWR            SERIALIZED
         UNTIL Z,END                     IN HDB
         L     RS,HDBWRFR              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     FRAME
         ALR   R15,RS                    WRITE COUNT
         CS    RS,R15,HDBWRFR            SERIALIZED
         UNTIL Z,END                     IN HDB
         CLEAR RVR                     ZERO RC
         END   ,                    OF MVPG WRITE OK
         END   ,                    OF MVPG WRITE
         ELSEIF (HSPCFLG.HSPCREAD),BEGIN  MVPG READ
*
*  BEGIN A READ OPERATION
*
         L     RB,HSRWPBLK(RK)         HSPACE BLOCK NUMBER
         L     RAR,HSRWPPGE(RK)        GET A PAGE ENTRY
         SAC   512                     ENTER ASC MODE
         MVPG  RA,RB                   READ FROM HIPERSPACE
         SAC   0
         IF    (NZ),BEGIN              MVPG READ FAILED
*
*  MVPG READ FAILED
*
         LA    RVR,8
         STC   RVR,HSRWRC
         END   ,                    OF MVPG READ FAILED
         ELSE  BEGIN                   MVPG READ OK
*
*  MVPG READ WAS OK
*
         L     RS,HDBMVRD              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     MVPG
         ALR   R15,RS                    READ COUNT
         CS    RS,R15,HDBMVRD            SERIALIZED
         UNTIL Z,END                     IN HDB
         L     RS,HDBRDFR              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     FRAME
         ALR   R15,RS                    READ COUNT
         CS    RS,R15,HDBRDFR            SERIALIZED
         UNTIL Z,END                     IN HDB
         IF    (HDBFLG.HDBSTND),BEGIN  IF STANDARD HSPACE  **ESO1**
         L     RA,RTCBBUFR             MVCL WIPED OUT BUFAD
         L     RB,=F'4096'                 GET PAGE LEN FOR MVCL
         LR    EPAR,RB                   LENGTH REGISTERS
         L     RAR,HSRWPPGE(RK)        GET A PAGE ENTRY
         SLL   RAR,1                   REMOVE
         SRL   RAR,1                     HIGH BIT
         MVCL  RAR,RA                  MOVE TO BUFFER
         L     RAR,HSRWPPGE(RK)        GET A PAGE ENTRY
         END   ,                    OF IF STANDARD HSPACE  **ESO1**
         XR    RVR,RVR                 ZERO RC
         END   ,                    OF MVPG READ OK
         END   ,                    OF MVPG READ
         ELSE  'KAPUT HSPCNOPR'        ABEND HSPCNOPR
*
*  END OF MVPG READ OR WRITE
*
         L     RA,HSRWKEYS             RESTORE KEY
         LR    RAR,RVR                 SAVE R0
         MODESET KEYADDR=(2)           BACK TO OUR KEY
*
*  FOR REAL ERRORS, SAVE ERROR CODE IN THE PAGE/BLOCK ENTRY
*
         IF    (RAR,NZ),BEGIN          IF THERE ARE ERRORS **ESO1**
         L     RAR,HSRWPCDE(RK)        GET #HSPLFLG ADDR   **ESO1**
         WITH  (#HSPLFLG,RAR),'SET #HSPLERR' AND SET       **ESO1**
         LA     RAR,HSRWPCDE(RK)        GET ADDR OF CALLER **ESO1**
         WITH  (HSRWPCDE,RAR),'SET HSRWERR' ERROR CODE     **ESO1**
         END   ,                    OF IF THERE ARE ERRORS **ESO1**
         DECR  RJ
         LA    RK,@RK+12               BUMP TO NEXT PAGE
         END   ,                    OF WHILE PAGES LEFT TO DO
         PR                            POP OUT OF STACK
HSRWEND  EQU *
*
*  A MVPG HAS BEEN PERFORMED ON THE ENTIRE PAGE/BLOCK LIST.
*  IF NO ERRORS WERE ENCOUNTERED THE OPERATION IS COMPLETE.
*  A RETURN CODE OF 1 IS SIGNALLED TO THE CALLER (THE ORVYL
*  GUEST) INDICATING THE I/O WAS COMPLETED IMMEDIATELY BY
*  THE START SUBCHANNEL PROCESSING.  OTHERWISE, IF ANY PAGE
*  ENTRIES ENCOUNTERED A MVPG ERROR, THE ENTIRE LIST IS
*  RE-SCANNED SO THAT AN HSPSERV OPERATION CAN BE ATTEMPTED
*  UNLESS THE FAILED MVPG WAS A READ FOR AN ESO HIPERSPACE.
*
         LA    RVR,1                   ASSUME IMMEDIATE CODE
HSPRETRY IF (HSRWRC,NZ),BEGIN          IF ANY MVPG ERRORS?
*
*  NOW WE PERFORM A RE-SCAN OF THE LIST AND WILL SCHEDULE AN
*  HSPSERV RETRY FOR ANY PAGE/BLOCK WITH A MVPG ERROR FLAG.
*  BECAUSE HSPSERV MIGHT REQUIRE A REAL DASD OPERATION, WE
*  WILL NOT RISK PUTTING THE MOTHER TASK TO SLEEP BY DOING
*  THE REQUEST HERE.  RATHER WE WILL SIGNAL THE HIPERSPACE
*  SUBTASK TO DO THIS FOR US ASYNCHRONOUSLY.  A CODE OF ZERO
*  IS RETURNED TO THE REQUESTOR INDICATING THAT THE REQUEST
*  HAS BEEN DEFERRED AND THE CALLER MUST CHECK FOR I/O
*  COMPLETION LATER.
*
         CLEAR HSRWRC                  CLEAR RC FOR HSPSERV
*
*  IF AN ESO READ FAILED, THAT MEANS THAT THE PAGE HAS BEEN
*  DISCARDED AND RETRY SHOULD NOT BE ATTEMPTED.
*
         IF    ((HSPCFLG.HSPCREAD),AND,(HDBFLG.HDBESO)),               *
               BEGIN                   IF ESO READ
         LA    RVR,1                   POST IMMED. COMPLETION
         EXIT HSPRETRY                 EXIT
         END   ,                    OF IF ESO READ
*
*  WE WILL PERFORM THE HSPSERV RETRY IN THE HIPERSPACE SUBTASK.
*
         WITH  (RTCB,RTCBR),'L  RJ,RTCBIOT'   IOT POINTER
         WITH  (IOT,RJ)
*
*  OBTAIN A MESSAGE BUFFER FOR SUBTASK COMMUNICATION
*
         MSGGBUF IOTHTMC,4
         LR    RK,RVR                  MESSAGE BUFFER
*
*  PASS HSRWWORK AS THE PARAMETER FOR HSPCETSK SUBTASK.
*  NOTE: DO NOT REFERENCE HSRWWORK AFTER MSGSEND BECAUSE
*  SUBTASK HSPCETSK CAN RELEASE HSRWWORK BEFORE CODE THAT
*  FOLLOWS MSGSEND GETS TO RUN.
*
         ST    RK,HSRWMBUF             SAVE ADDR IN HSRWWORK
         ST    RM,@RK                  SAVE HSRWWORK IN BUFFER
         L     RA,HSPCRQID             GET IRCB
         WITH  (IRCB,RA),'MVI IRCBHSP,1' INDICATE IOCB IN USE
         STCK  HSRWSTOD                TIMESTAMP START OF REQUEST
*
*  SIGNAL SUBTASK
*
         MSGSEND IOTHTMC,(RK)
*
*  INDICATE TO THE GUEST THAT I/O HAS BEEN DEFERRED AND THAT AN
*  INDICATION OF COMPLETION WILL BE SIGNALLED BY THE SUBTASK.

         CLEAR RVR                     SIGNAL DEFERRED COMPLETION
         END   ,                    OF IF ANY MVPG ERRORS?
         IF    (RVR,EQ,1),BEGIN        IF IMMEDIATE RC
         IF    (HSRWID,NE,=C'HSRW'),'KAPUT BADHSRW'
         CLEAR HSRWID
         L     RA,HSRWLEN                MEMFREE
*        MEMFREE (RA),A=(RM),TYPE=GLOBAL HSRWWORK
HSRWRL1  STORAGE RELEASE,ADDR=(RM),LENGTH=(RA),                        *
               SP=10,RELATED=HSRWOB
         LA    RVR,1                   RELOAD IMMED. RC
         END   ,                    OF IF IMMEDIATE RC
         PEND
         LTORG
         TITLE 'ORVYL''S JES I/O Service Routines'
         COPY  JESPARM
         EJECT
*******************************************************************
*                                                                 *
*    JESIO  - ORVYL JES I/O Driver                                *
*                                                                 *
*                                                                 *
*     Input - @DOIO                                               *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESIO    PROC  @DOIO,SCOPE=LOCAL
         L     RY,@DOIORB              INTERFACE PARAMETERS
         WITH  (@IORB,RY)
         L     RX,@DOUPRM              USER PARAMETERS
         WITH  (#JESCOM,RX)
         L     RB,@DODSID              JDB POINTER
         WITH  (JDB,RB)
         WITH  (COMDB,JDB),'CLC  COMDBID,=CL4"JDB"'    Validate
         IF    NE,'KAPUT JDBPTR'
         EJECT
*
*   Prepare to send JES request to subtask
*
         WITH  (RTCB,RTCBR),'L  RA,RTCBIOT'   IOT POINTER
         WITH  (IOT,RA)
         MSGGBUF IOTJTMC,L'$JESMSG
         LR    RK,RVR                  MESSAGE BUFFER
         WITH  ($JESMSG,RK)
*
*  Pass user parms for open request
*
         IF    (#JESCMD,EQ,#JCOPEN),BEGIN
         WITH  (#JESOPEN,RX)           USER PARM
         MVC   $JESPARM(L'#JESOPEN),#JESOPEN
         END   ,
*
*  Pass user parms for close request
*
         ELSEIF (#JESCMD,EQ,#JCCLOSE),BEGIN
         WITH  (#JESCLOS,RX)           USER PARM
         MVC   $JESPARM(L'#JESCLOS),#JESCLOS
         END   ,
*
*  Pass user parms for write request
*
         ELSEIF (#JESCMD,EQ,#JCWRITE),BEGIN
         WITH  (#JESWRIT,RX)           USER PARM
         MVC   $JESPARM(L'#JESWRIT),#JESWRIT
         END   ,
         EJECT
*
*  Pass user parms for job end request
*
         ELSEIF (#JESCMD,EQ,#JCJBND),BEGIN
         WITH  (#JESJBND,RX)           USER PARM
         MVC   $JESPARM(L'#JESJBND),#JESJBND
         END   ,
*
*  Invalid request
*
         ELSE  BEGIN
         KAPUT JESCODE
         END   ,
*
*  Complete message buffer and send to subtask
*
         ST    RB,$JESJDB              JDB pointer
         MVC   $JESRQID,@IORRQID       Request ID
         MVC   $JESOFF,@IOROFF         Offset (guest real to MVS)
         MVC   $JESKEY,@IORKEY         Protect key
         MSGSEND IOTJTMC,(RK)
         CLEAR RVR                     SET CONDITION CODE
         PEND
         TITLE 'ORVYL''S MVS File I/O Service Routines'
*******************************************************************
*                                                                 *
*    OSFIO  - ORVYL O/S File I/O Driver
*                                                                 *
*                                                                 *
*     Input - @DOIO                                               *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
OSFIO    PROC  @DOIO,SCOPE=LOCAL
         L     RY,@DOIORB              INTERFACE PARAMETERS
         WITH  (@IORB,RY)
         L     RX,@DOUPRM              USER PARAMETERS
*         WITH  (@OSFIO,RX)
         L     RB,@DODSID              DDB POINTER
         WITH  (DDB,RB)
         WITH  (COMDB,DDB),'CLC  COMDBID,=CL4"DDB"'
         IF    NE,'KAPUT ODBPTR'
*
*   Send OS File request to subtask
*
         WITH  (RTCB,RTCBR),'L  RA,RTCBIOT'   IOT POINTER
         WITH  (IOT,RA),BEGIN
         MSGGBUF IOTMTMC,L'$MVIOCOM
         LR    RK,RVR                  MESSAGE BUFFER
         WITH  ($MVIOCOM,RK)
         ST    RB,$MVIDSID             SET DEVICE ID
         MVC   $MVIRQID,@IORRQID       Request ID
         MVC   $MVIOFF,@IOROFF         Offset (guest real to MVS)
         ST    RS,$MVIFUNC             SET FUNCTION CODE
         MSGSEND IOTMTMC,(RK)
         END
         CLEAR RVR                     SET CONDITION CODE
         PEND
         EJECT
         LTORG
         TITLE 'ORVYL''S Parameter File I/O Service Routines'
*******************************************************************
*                                                                 *
*    Parameter file DCB and End of data exit                      *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
*GEN
PRMFDCB  DCB   DSORG=PS,MACRF=(GL),DDNAME=PARMS,BFTEK=A
*NOGEN
         SPACE 3
*******************************************************************
*                                                                 *
*       24 bit mode End of Data routine                           *
*                                                                 *
*******************************************************************
         SPACE 2
         DS    0H
PRMFE24  BALR  R15,0
         WITH  (*,15),'L  R15,PRMFEAD'   Address of actual routine
         BSM   0,R15                   Go do it
         SPACE
PRMFEAD  DC    A(PRMIOEOD+X'80000000')
PRMFEOD  EQU   PRMFE24,*-PRMFE24,C'X'
         SPACE 2
*
*  WORK AREA ANCHOR
*
PRMFWRK  DC    A(0)                    WORK AREA ANCHOR
         END   ,
         EJECT
         COPY  PRDPARM
         SPACE 3
*******************************************************************
*                                                                 *
*    Parameter file work area                                     *
*                                                                 *
*******************************************************************
         SPACE
PARMWORK RECORD BEGIN
PRMWDCB  DS    XL(DCBLNGQS)            DCB
         DS    0D
PRMWJFCB DS    XL(JFCBLGTH)            JFCB
PRMWEXL  DS    A                       DCB EXIT LIST
PRMWEOD  DS    ((L'PRMFEOD+3)/4)A      END OF DATA ROUTINE
PRMWOPN  DS    A                       OPEN/CLOSE PARAMETER LIST
PRMWBUFF DS    A                       LOCAL BUFFER
PRMWBFL  DS    A                        AND LENGTH
PRMWA24  DS    5D                      AMODE 24 CAP ROUTINE
PRMW@A24 DS    0D                      CAP ROUTINE PARAMETERS
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   PRMIOPEN - Open parameter file                                *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PRMIOPEN PROC  @PRMIOPN,SCOPE=GLOBAL
         L     RY,PRMFWRK              PARM WORK AREA
         WITH  (PARMWORK,RY)
*
*  Parameter file work area not yet created
*
         IF    (RY,Z),BEGIN
         MEMGET L'PARMWORK+L'@AM24,TYPE=BELOW16M
         LR    RY,RVR
         ST    RY,PRMFWRK              Save work area pointer
         EJECT
*
*  Set up DCB
*
         MVC   PRMWDCB(DCBLNGQS),PRMFDCB      COPY DCB SKELETON
         WITH  (IHADCB,PRMWDCB)
         LA    RS,PRMWEOD              END OF DATA ROUTINE
         ST3   RS,DCBEODA               TO DCB
         LA    RS,PRMWEXL              DCB EXIT LIST ADDRESS
         ST3   RS,DCBEXLSA              TO DCB
*
*  Set up SVC and DCB parameters
*
         LA    RS,PRMWDCB              SET UP
         ST    RS,PRMWOPN               OPEN PARAMETER
         SET   PRMWOPN.X'80'             LIST
         LA    RS,PRMWJFCB             JFCB POINTER
         ST    RS,PRMWEXL              SET UP DCB
         MVI   PRMWEXL,X'87'            EXIT LIST
*
*  Set up 24 bit mode cap and end of data exit
*
         L     RS,=A(AM24CAP)          CAP ROUTINE
         MVC   PRMWA24(AM24CLEN),@RS
         MVC   PRMWEOD(L'PRMFEOD),PRMFEOD    END OF DATA ROUTINE
         END   ,
*
*  DCB ALREADY OPENED
*
         WITH  (IHADCB,PRMWDCB)
         IF    DCBOFLGS.DCBOFOPN,BEGIN
         LA    RVR,4
         EXIT  PRMIOPEN
         END   ,
*
*  SET STAE EXIT AND GET JFCB
*
         ESTAEON PRMOERR               CATCH ABENDS
         RDJFCB MF=(E,PRMWOPN)
         IF    (R15,NZ),BEGIN
         LA    RVR,12                  ERROR CODE
         EXIT  PRMIOPEN
         END   ,
         WITH  (JFCB,PRMWJFCB)
         EJECT
*
*  SET MEMBER NAME
*
         IF    (@PRMIONM,NZ),BEGIN
         IF    ('CLI  JFCBELNM,C"A"',L),EXIT    NOT A PDS
*
*  GET LENGTH OF REQUESTED MEMBER NAME
*
         LA    R15,L'@PRMIONM          MAXIMUM NAME LENGTH
         LA    R14,@PRMIONM+L'@PRMIONM-1   LAST CHARACTER
         WHILE (R15,P),BEGIN
         IF    ('CLI  @R14,C" "',NE),EXIT
         DECR  R15
         DECR  R14
         END   ,
         IF    (R15,Z),EXIT            NO NAME WAS SUPPLIED
*
*  MOVE IN THE NAME
*
         MVC   JFCBELNM,=CL8' '        BLANK OUT PREVIOUS
         DEX   R15,'MVC  JFCBELNM(0),@PRMIONM'   NEW MEMBER NAME
         END   ,
*
*  DO OPEN
*
         OPEN  MF=(E,PRMWOPN),TYPE=J   DO IT
         ESTAEOFF ,                    CLEAR ABEND INTERCEPT
         IF    DCBOFLGS.DCBOFOPN,'CLEAR  RA'   OPEN WAS SUCCESSFUL
         ELSE  'L  RA,=F"-4"'          OPEN FAILED
*
*  ESTAE RETRY ROUTINE
*
         BEGIN
         EXIT
PRMOERR  LABEL ,
         LR    RA,RVR                  ESTAE INFO POINTER
         END   ,
         EJECT
*
*  GET LOCAL BUFFER
*
         IF    ('LT  RB,PRMWBUFF',Z),BEGIN
         LH    R15,DCBLRECL            LRECL
         LA    R15,@R15+4              ROOM FOR RDW
         ST    R15,PRMWBFL              NOTE LENGTH
         MEMGET  (R15)
         ST    RVR,PRMWBUFF            SET BUFFER POINTER
         END   ,
*
*  DIS-ALLOW RECFM U
*
         IF    DCBRECFM.DCBRECU,BEGIN
         LCALL PRMIOCLS                CLOSE THE FILE
         LA    RVR,8                   ERROR CODE
         EXIT  PRMIOPEN
         END   ,
*
*  RETURN TO CALLER
*
         LR    RVR,RA
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   PRMIORD - Read parameter file                                 *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PRMIORD  PROC  ,SCOPE=GLOBAL
         L     RY,PRMFWRK              PARM WORK AREA
         WITH  (PARMWORK,RY)
         WITH  (IHADCB,PRMWDCB)
*
*  Parameter file not opened
*
         IF    ((RY,Z),OR,^DCBOFLGS.DCBOFOPN),BEGIN
         CLEAR RVR
         EXIT  PRMIORD
         END   ,
         EJECT
*
*  Branch to GET routine in 24 bit mode
*
         LOOP  BEGIN
         GET   PRMWDCB
         ORG   *-2
         WITH  (@AM24,PRMW@A24)
         CLEAR @AM24
         STM   R15,R1,@AM24RGS         Set parameter regs
         LA    R1,PRMW@A24             Set cap parameter pointer
         LA    EPAR,PRMWA24            GO TO AMODE 24
         BASSM RAR,EPAR
*
*  Determine length of record
*
         LR    RA,R1                   Record pointer
         IF    DCBRECFM.DCBRECF,'LH  R15,DCBLRECL'   Lrecl
         ELSE  BEGIN
         LH    R15,@RA                 RDW length
         SH    R15,=Y(4)               Data length
         LA    RA,@RA+4                Point at data portion
         END   ,
*
*  Strip trailing blanks
*
         LA    RS,@RA(R15)             Point at end
         DECR  RS                       of record
         WHILE (R15,P),BEGIN
         IF    ('CLI  @RS,C" "',NE),EXIT   Found a non-blank
         DECR  RS
         DECR  R15
         END   ,
         UNTIL (R15,NZ),END            Find a non-blank record
*
*  Move record to local area
*
         L     R14,PRMWBUFF            Local buffer
         LA    RS,@R15+4               Create RDW
         STH   RS,@R14
         LA    R14,@R14+4              Point at data area
         LR    RB,R15                  Copy length
         MVCL  R14,RA                  Move the data
         L     RVR,PRMWBUFF
         LR    RS,RVR
         EXIT  PRMIORD
         EJECT
*
*  Process end of data condition
*
PRMIOEOD LABEL ,
         LCALL PRMIOCLS                CLOSE THE DCB
         CLEAR RVR
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   PRMIOEND - Terminate parameter file processing                *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PRMIOEND PROC  ,SCOPE=GLOBAL
         L     RY,PRMFWRK              PARM WORK AREA
         IF    (RY,NZ),BEGIN
         CLEAR PRMFWRK                 PARMS ARE LONGER AVAILABLE
         WITH  (PARMWORK,RY)
         WITH  (IHADCB,PRMWDCB)
*
*  Free the local buffer
*
         L     RB,PRMWBUFF             BUFFER POINTER
         IF    (RB,NZ),BEGIN
         L     R15,PRMWBFL             BUFFER LENGTH
         MEMFREE (R15),A=(RB)          FREE IT
         END   ,
*
*  Close the data set and release the buffer pool
*
         IF    DCBOFLGS.DCBOFOPN,'LCALL PRMIOCLS'
         EJECT
*
*  N.B.  The FREEPOOL macro is not intended to run in 31-bit mode
*        however if we first clear the high order byte of the
*        buffer control block field in the DCB it will, in fact,
*        work properly.  Now, can I interest you in a bridge?
*
         MVI   DCBBUFCB,0
*GEN
         FREEPOOL PRMWDCB
*NOGEN
*
*  Deallocate the data set
*
         PSET  @DUNALLO
         MVC   @DUNDDN,=CL8'PARMS'     SET DDNAME
         ACALL DUNALLO
*
*  Release the work area
*
         MEMFREE L'PARMWORK+L'@AM24,A=(RY),TYPE=BELOW16M
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   PRMIOCLS - Close parameter file                               *
*                                                                 *
*                                                                 *
*     Input - None                                                *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PRMIOCLS PROC  ,SCOPE=LOCAL
         L     RY,PRMFWRK              PARM WORK AREA
         WITH  (PARMWORK,RY)
*
*  SET STAE AND CLOSE DCB
*
         ESTAEON PRMFCLS               CATCH ABENDS
         CLOSE MF=(E,PRMWOPN)          DO IT
         LR    RA,R15                  RETURN CODE
         ESTAEOFF ,                    CLEAR ABEND INTERCEPT
         EJECT
*
*  ESTAE RETRY ROUTINE
*
         BEGIN
         EXIT
PRMFCLS  LABEL ,
         LR    RA,RVR                  ESTAE INFO POINTER
         END   ,
         LR    RVR,RA                  SET RETURN CODE
         PEND
         LTORG
         EJECT
         TITLE 'ORVYL''S SCOM I/O Subtask'
*******************************************************************
*                                                                 *
*    SCSTWORK - SCOM sub-task work area                           *
*                                                                 *
*******************************************************************
         SPACE
SCSTWORK RECORD BEGIN
SCTMCHN  DS    A                       MESSAGE CHANNEL ID
SCTMECBP DS    A                       MESSAGE CHANNEL ECB ADDRESS
SCTPECBP DS    A                       PATH POST ECB ADDRESS
SCTECBL  EQU   SCTMECBP                ECB LIST
SCTPECB  DS    A                       PATH ECB
SCTIOCT  DS    A                       IOCT ADDRESS
SCTETAB  DS    A                       EVENT TABLE ADDRESS
SCTPATH  DS    A                       Address of path to be opened
         END
         SPACE 3
*******************************************************************
*                                                                 *
*     $SCMIMSG - SCOM Subtask Services Message Buffer             *
*                                                                 *
*******************************************************************
         SPACE
$SCMIMSG RECORD BEGIN
$SCMSDB  DS    A                       Device ID
$SCMUPRM DS    A                       User parameter
$SCMRQID DS    A                       Request ID
$SCMFUNC DS    A                       Function code
$SCMOFF  DS    A                       Offset to convert address
$SCMKEY  DS    X                       Protect key
         END
         SPACE 3
*******************************************************************
*                                                                 *
*    @SCOMDO   - Parameters passed to SCOM drivers                *
*                                                                 *
*******************************************************************
         SPACE
@SCOMDO  RECORD BEGIN
@SCMDMSG DS    A                       Message buffer pointer
@SCMDWRK DS    A                       Work area pointer
         END   ,
         EJECT
         TITLE 'ORVYL''S Hiperspace Subtask'
*******************************************************************
*                                                                 *
*    HSPCETSK - HIPERSPACE sub-task work area                     *
*                                                                 *
*******************************************************************
         SPACE
HSPWORK  RECORD BEGIN
HSPMCHN  DS    A                       MESSAGE CHANNEL ID
HSPMECB  DS    A                       MESSAGE CHANNEL ECB
HSPIOCT  DS    A                       IOCT ADDRESS
HSPMESS  DS    A                       MESSAGE ADDRESS
         END
         SPACE 3
*******************************************************************
*                                                                 *
*      MVIOMSG - MVS I/O Services Message Buffers                 *
*                                                                 *
*******************************************************************
         SPACE
$HSRDWKA RECORD BEGIN
$HSRWKAD DS    A                       Ptr to HSPCWORK
$HSRHDB  DS    A                       Ptr to HDB
$HSROFF  DS    A                       Ptr to MVS OFFSET
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   HSPCETSK - HIPERSPACE WAIT service                            *
*                                                                 *
*  THIS TASK IS ONLY REQUIRED FOR STANDARD HIPERSPACE REQUESTS    *
*  WHICH CAN NECESSITATE I/O TO DASD FOR PAGED-OUT FRAMES AND     *
*  AND WILL COMPLETE ASYNCHRONOUOSLY.  THIS REQUEST IS STARTED    *
*  IN A SUBTASK SO THAT THE MOTHER TASK WILL NOT BE PUT TO SLEEP  *
*  WAITING FOR THE I/O TO COMPLETE.  ESO HIPERSPACES DO NOT       *
*  INVOLVE I/O TO DASD HENCE WILL ALWAYS COMPLETELY SYNCHRONOUSLY *
*  IN THE MAIN TASK, ALONG WITH STANDARD HIPERSPACE WRITES.       *
*                                                                 *
*     Input -  SBTPARM                                            *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
HSPCETSK PROC  SBTPARM,SCOPE=LOCAL
         WITH  (RTCB,RTCBR)
         IF    ('LT RS,RTCBBUFR',Z),BEGIN IF NO MVPG BUFFER ASSIGNED
         STORAGE OBTAIN,LENGTH=4096,BNDRY=PAGE GET BUFFER FOR MVPG
         ST    RS,RTCBBUFR             STORE BUFFER ADDR IN RTCB
         END   ,                    OF IF NO MVPG BUFFER ASSIGNED
         MEMGET L'HSPWORK,TYPE=LOCAL   GET WORK AREA
         IF    ('LTR RY,RVR',Z),'KAPUT HSPWORK'
         WITH  (HSPWORK,RY)
         L     RA,SBTDATA              IOCT pointer
         ST    RA,HSPIOCT              Save it
         MSGATT HSPCETSK,TYPE=SERV     Open channel
         ST    RVR,HSPMCHN             MESSAGE CHANNEL ID
         L     RS,@MSGCECB             MESSAGE ECB
         ST    RS,HSPMECB              SET POINTER
         EJECT
*
*  HIPERSPACE TASK LOOP
*
         LOOP  BEGIN                   HIPERSPACE TASK LOOP
         FWAIT HSPMECB                 FAST WAIT (BRANCH ENTRY)
         L     RS,HSPMECB              ECB POINTER
         CLEAR (@RS,4)                 CLEAR IT
         LOOP  BEGIN                   MSGRECV LOOP
         MSGRECV HSPMCHN               RECEIVE A MESSAGE
         IF    ('LTR  RM,RVR',Z),EXIT  NO MORE TO GET
         ST    RM,HSPMESS              SAVE MESSAGE ADDR
*
*  WE HAVE BEEN POSTED.  MSGBUFF POINTS TO HSRWWORK FROM A
*  PAGE/SWAP REQUEST LIST WITH SOME UNSUCCESSFUL MVPG.
*
         IF    ('LT RM,@RM',Z),'KAPUT NOHSPTR'
         WITH  (HSRWWORK,RM)           POINT TO HSRWWORK
         WITH  (HSRWPLST,HSRWREND)
         IF    (HSRWID,NE,=C'HSRW'),'KAPUT NOHSRWWORK'
         L     RX,HSRWHDB              GET HDB
         WITH  (HDB,RX)
         WITH  (COMDB,HDB)
         IF    (COMDBID,NE,=C'HDB'),'KAPUT BADHDB'
         L     RAR,=A(HSPVEND+X'80000000') POINT TO PR EXIT
         BAKR  RAR,0                   USE HARDWARE STACK
*
*  HSPSERV EXPECTS A 144-BYTE SAVE AREA FOR SAVING BOTH GP AND
*  AR REGS.
*
         L     RJ,HSRWCNT              USER'S PAGE COUNT
         CLEAR RK                      CLEAR PAGE LIST INDEX
         WHILE (RJ,NZ),BEGIN           WHILE WE'VE HSPSERV TO DO
         LA     RA,HSRWPCDE(RK)        GET ADDR OF CALLER **ESO1**
         WITH  (HSRWPCDE,RA)               ERROR CODE     **ESO1**
         IF    HSRWERR,BEGIN        IF MVPG HAD AN ERROR  **ESO1**
         DROP  RA                                         **ESO1**
*
*  THIS PARTICULAR PAGE/BLOCK HAD A MVPG ERROR.  SET UP HSPSERV
*  PARAMETERS
*
         L     RA,HSRWPBLK(RK)         HSPACE BLOCK NUMBER
         ST    RA,HSRWHLOC               RANGELIST
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET INTO KEY ZERO
         ST    RA,HSRWKEYS             SAVE OLD KEY IN R1
         CLEAR RVR                     ZERO RETURN CODE REG
         L     RA,RTCBBUFR             GET BUFFER ADDR FROM RTCB
         ST    RA,HSRWPGAD             UPDATE HSPSERV RANGELIST
         IF (HSRWFLG.HSPCWRIT),BEGIN   IF MVPG WRITE
         L     RB,=F'4096'             GET PAGE LEN FOR MVCL
         LR    EPAR,RB                   LENGTH REGISTERS
         L     RAR,HSRWPPGE(RK)        GET A PAGE ENTRY
         SLL   RAR,1                   REMOVE
         SRL   RAR,1                     HIGH BIT
         MVCL  RA,RAR                  MOVE TO BUFFER
         LR    RA,SPR                  SAVE R13
         LA    SPR,HSRWSAVE            POINT TO 36F S/A
         IF (HDBFLG.HDBSTND),BEGIN     IF STANDARD WRITE
*
*  DO AN SWRITE
*
         HSPSERV SWRITE,STOKEN=HDBTOKEN,RANGLIST=HSRWRNGL,             *
               HSPALET=HDBALET,RETCODE=HSRWRTCD,                       *
               RSNCODE=HSRWRSCD,                                       *
               MF=(E,HSRWSERV,COMPLETE)
*
*  IF SWRITE FAILED, ABORT.  GUEST CANNOT HANDLE THIS CONDITION
*
         IF    (HSRWRTCD,NZ),'KAPUT BADSWRITE'
         LR    SPR,RA                  RESTORE R13
         CLEAR RVR                     ZERO RETURN CODE REG
*
*  SWRITE WAS OK
*
         L     RS,HDBWRFR              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     FRAME
         ALR   R15,RS                    WRITE COUNT
         CS    RS,R15,HDBWRFR            SERIALIZED
         UNTIL Z,END                     IN HDB
*** SYSD TEST CODE ***
*        IF    (HDBWRFR,LGT,HDBWCT),'KAPUT BADWRCT'
*** END OF SYSD TEST CODE ***
         CLEAR RVR                     ZERO RETURN CODE REG
         END   ,                    OF IF STANDARD WRITE
         ELSEIF (HDBFLG.HDBESO),BEGIN  ELSEIF ESO WRITE
*
*  DO A CWRITE
*
         HSPSERV CWRITE,STOKEN=HDBTOKEN,RANGLIST=HSRWRNGL,             *
               HSPALET=HDBALET,RETCODE=HSRWRTCD,                       *
               RSNCODE=HSRWRSCD,                                       *
               MF=(E,HSRWSERV,COMPLETE)
         CLEAR RVR                     ZERO RETURN CODE REG
         LR    SPR,RA                  RESTORE R13
         L  RA,HSRWPCDE                GET SAVED #HSPLFLG  **ESO1**
         WITH (#HSPLFLG,RA),'CLEAR #HSPLERR' CLEAR ERROR   **ESO1**
         IF    (HSRWRTCD,NZ),BEGIN     IF HSPSERV CWRITE FAILED
*
*  CWRITE FAILED
*
         LA RVR,4
         STC   RVR,HSRWRC              STORE ERROR CODE
         WITH (#HSPLFLG,RA),'SET #HSPLERR' SET ERROR FLAG  **ESO1**
         END   ,                    OF IF HSPSERV CWRITE FAILED
         ELSE BEGIN                    ELSE CWRITE OK
*
*  WRITE OK
*
         L     RS,HDBWRFR              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     REQUESTED
         ALR   R15,RS                    WRITE COUNT
         CS    RS,R15,HDBWRFR            SERIALIZED
         UNTIL Z,END                     IN HDB
         CLEAR RVR                     ZERO RETURN CODE REG
         END   ,                    OF ELSE CWRITE OK
         END   ,                    OF ELSEIF ESO WRITE
         ELSE  'KAPUT NOWRITETYPE'
         END   ,                    OF IF MVPG WRITE
         ELSEIF (HSRWFLG.HSPCREAD),BEGIN IF MVPG READ
         LR    RA,SPR                  SAVE R13
         LA    SPR,HSRWSAVE            POINT TO 36F S/A
         HSPSERV SREAD,STOKEN=HDBTOKEN,RANGLIST=HSRWRNGL,              *
               HSPALET=HDBALET,RETCODE=HSRWRTCD,                       *
               RSNCODE=HSRWRSCD,                                       *
               MF=(E,HSRWSERV,COMPLETE)
         LR    SPR,RA                  RESTORE R13
         IF    (HSRWRTCD,NZ),'KAPUT BADHSPREAD'
*
*  SREAD COMPLETED OK, NOW MOVE PAGE TO CALLER'S AREA
*
         L     RB,=F'4096'             GET PAGE LENGTH FOR MVCL
         LR    EPAR,RB                   LENGTH REGISTERS
         L     RA,RTCBBUFR             GET BUFFER FROM RTCB
         L     RAR,HSRWPPGE(RK)        GET A PAGE ENTRY
         MVCL  RAR,RA                  MOVE TO BUFFER
         L     RS,HDBRDFR              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     FRAME
         ALR   R15,RS                    READ COUNT
         CS    RS,R15,HDBRDFR            SERIALIZED
         UNTIL Z,END                     IN HDB
*
*  IF MVPG READ FAILED IN HSRDWRT BUT HSPSERV SREAD NOW SUCCEEDS,
*  THIS INDICATES THAT THE PAGE HAD BEEN MIGRATED TO AUX STORAGE.
*  ONCE THIS HAPPENS, IT NEVER GETS BACK TO ESTOR EVEN AFTER THE
*  SREAD UNLESS ORVYL REWRITES IT.  SINCE IT HAS JUST BEEN
*  REFERENCED, NOW IS A GOOD A TIME TO REWRITE IT TO ESTOR.
*
         LA     RA,HSRWPCDE(RK)        GET ADDR OF CALLER **ESO1**
         WITH  (HSRWPCDE,RA)               ERROR CODE     **ESO1**
         IF    HSRWERR,BEGIN     IF MVPG HAD AN ERROR  **ESO1**
         L     RA,HSRWPBLK(RK)         HSPACE BLOCK NUMBER
         ST    RA,HSRWHLOC               RANGELIST
         L     RA,RTCBBUFR             GET BUFFER ADDR FROM RTCB
         ST    RA,HSRWPGAD             UPDATE HSPSERV RANGELIST
         LA    RA,1                    WE SUBMIT ONLY ONE PAGE
         ST    RA,HSRWNBLK               AT A TIME TO HSPSERV
         LR    RA,SPR                  SAVE R13
         LA    SPR,HSRWSAVE            POINT TO 36F S/A
*
*  DO AN SWRITE
*
         HSPSERV SWRITE,STOKEN=HDBTOKEN,RANGLIST=HSRWRNGL,             *
               HSPALET=HDBALET,RETCODE=HSRWRTCD,                       *
               RSNCODE=HSRWRSCD,                                       *
               MF=(E,HSRWSERV,COMPLETE)
*
*  IF SWRITE FAILED, ABORT.  GUEST CANNOT HANDLE THIS CONDITION
*
         IF    (HSRWRTCD,NZ),'KAPUT BADSWRITE'
         LR    SPR,RA                  RESTORE R13
         L     RS,HDBRWRT              INCREMENT
         LOOP  BEGIN
         LA    R15,1                     REWRITE
         ALR   R15,RS                    COUNT
         CS    RS,R15,HDBRWRT            SERIALIZED
         UNTIL Z,END                     IN HDB
         END   ,                    OF IF MVPG READ HAD AN ERROR
         CLEAR RVR                     ZERO RETURN CODE REG
         END   ,                    OF IF MVPG READ
         ELSE  'KAPUT NOTRDORWRT'
         STC   RVR,HSRWPCDE(RK)        CLEAR HSRW ERROR CODE
         L     RA,HSRWKEYS             RESTORE KEY
         MODESET KEYADDR=(2)           BACK TO OUR KEY
         END   ,                    OF IF MVPG READ ERROR
         DECR  RJ
         LA    RK,@RK+12               BUMP TO NEXT PAGE
         END   ,                    OF WHILE WE'VE HSPSERV TO DO
         PR
HSPVEND  EQU   *
*
*  THE FOLLOWING CODE MAKES SURE THAT WE DO NOT SIGNAL MODULE
*  GSTINTF TO DO I/O BACK-END PROCESSING UNTIL WE ARE NOTIFIED
*  THAT THE ORIGINAL FRONT-END PROCESSING STARTED BY SSCH HAS
*  ENDED.  OTHERWISE, DUE TO MULTIPROCESSING EFFECTS WHICH WILL
*  NOT HAPPEN WITH REAL PAGE OR SWAP I/O, THE GUEST MACHINE CAN
*  BE POSTED FOR THE I/O INTERRUPT BEFORE IT GETS CONTROL FROM
*  THE SSCH.  WE WILL TRY TO AVOID THIS IF POSSIBLE BY INTRODUCING
*  AN STIMERM DELAY.
*
         L     RA,HSRWRQID
*
*  IRCBHSP IS TURNED ON IN ROUTINE HSRDWRT BEFORE OUR SUBTASK WAS
*  AWAKENED.  WHEN HSRDWRT RETURNS TO THE CALLER (GSTINTF ROUTINE
*  IXSSCH), GSTINTF TURNS IT  OFF.  IF WE ARE DISPATCHED BEFORE
*  THIS HAPPENS, WE WILL TRY TO DEFER SIGNALLING GSTINTF BACK-END.
*
         WITH  (IRCB,RA),'NC IRCBHSP,IRCBHSP'
         IF    NZ,BEGIN                 STILL NO SIGNAL FROM GSTINTF
*
*  WE WAIT FOR A MINIMUM INTERVAL.
*
         WITH  (IRCB,RA),'CLEAR IRCBHSP'
         INCR  RB,HDBSTIMX       COUNT TOTAL TIMES WE DO STIMER MAX
         CLEAR HSRWINTV
         MVC   HSRWINTV+4(4),STIMRMAX
         STIMERM SET,ID=HSRWTMID,WAIT=YES,MICVL=HSRWINTV,              *
               MF=(E,HSRWTIMR)
         END  ,                     OF NO SIGNAL FROM GSTINTF YET
*
*
*  NOTIFY GUEST MACHINE OF COMPLETION
*
         PSET  @GSTIIOT
         CLEAR @GSTICS                 Completion status
         MVC   @GSTIRQI,HSRWRQID       Request ID
         VCALL GSTIIOT                 NOTIFY THE USER
         EJECT
*
*  FREE THE MESSAGE BUFFER
*
         L     RJ,HSPMESS
         MSGFREE HSPMCHN,(RJ)          FREE MESSAGE BUFFER
         IF    (HSRWID,NE,=C'HSRW'),'KAPUT NOHSRWWORK'
         CLEAR HSRWID
         L     RA,HSRWLEN                MEMFREE
*        MEMFREE (RA),A=(RM),TYPE=GLOBAL   HSRWWORK
HSRWRL2  STORAGE RELEASE,ADDR=(RM),LENGTH=(RA),                        *
               SP=10,RELATED=HSRWOB
         END   ,                    OF MSGRECV LOOP
         END   ,                    OF HIPERSPACE TASK LOOP
         PEND
         DS    0F
STIMRMIN DC    X'007D0000'            2 MILLISECONDs
STIMRMAX DC    X'02710000'           10 MILLISECONDS
         LTORG
         EJECT
         COPY  PFINFO
         EJECT
*******************************************************************
*                                                                 *
*   SCOMTASK - SUZAN Path wait service                            *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOMTASK PROC  SBTPARM,SCOPE=LOCAL
         MEMGET L'SCSTWORK,TYPE=LOCAL   GET WORK AREA
         IF    ('LTR RY,RVR',Z),'KAPUT SCMORK'
         WITH  (SCSTWORK,RY)
         CLEAR SCSTWORK
         MVC   SCTIOCT,SBTDATA         SAVE IOCT pointer
         MSGATT SCOMTASK,TYPE=SERV     Open channel
         ST    RVR,SCTMCHN             MESSAGE CHANNEL ID
         L     R15,@MSGCECB            MESSAGE ECB ADDRESS
         ST    R15,SCTMECBP            SET POINTER
         LA    RS,SCTPECB              PATH POST ECB
         ST    RS,SCTPECBP             SET POINTER IN ECBLIST
         SET   SCTPECBP.X'80'           END OF LIST
         EJECT
*
*  SCOM I/O TASK LOOP
*
         LOOP  BEGIN
         WAIT  ECBLIST=SCTECBL         WAIT FOR SOMETHING
         L     RS,SCTMECBP             MESSAGE ECB POINTER
         IF    @RS.X'40',BEGIN         MESSAGE ECB POSTED
         CLEAR (@RS,4)                 CLEAR MESSAGE ECB
         LOOP  BEGIN
         MSGRECV SCTMCHN               RECEIVE A MESSAGE
         IF    ('LTR  RJ,RVR',Z),EXIT   NO MORE MESSAGES
         WITH  ($SCMIMSG,RJ)
         PSET  @SCOMDO
         ST    RJ,@SCMDMSG             PASS MESSAGE POINTER
         ST    RY,@SCMDWRK              AND WORK AREA POINTER
         L     RS,$SCMFUNC             FUNCTION CODE
         IF    (RS,Z),'KAPUT SCMFUNZ'
         IF    (RS,GT,SCMFMAX),'KAPUT SCMFUNHI'
         ACALL SCOMFUNC(RS)            FUNCTION ROUTINE
*                                      RETURN CODE IS IN RVR
*
*  NOTIFY GUEST MACHINE OF COMPLETION
*
         PSET  @GSTIIOT
         ST    RVR,@GSTICS             Completion status
         MVC   @GSTIRQI,$SCMRQID       Request ID
         VCALL GSTIIOT                 NOTIFY THE USER
*
*  FREE THE MESSAGE BUFFER
*
         MSGFREE SCTMCHN,(RJ)          FREE MESSAGE BUFFER
         END   ,
         END   ,
         EJECT
*
*  PATH POST HAS OCCURRED FIND OUT WHICH ONE
*
         IF    SCTPECB.X'40',BEGIN     PATH POST ECB POSTED
         CLEAR SCTPECB                 CLEAR PATH POST ECB
         L     RK,SCTIOCT              GET IOCT POINTER
         WITH  (IOCT,RK)
         LOCKOB IOCTSNTL               GET NOTIFY CHAIN LOCK
         L     RX,IOCTSNFP             FIRST ELEMENT IN CHAIN
         WITH  (SDB,RX)
         LA    RA,IOCTSNFP-(SDBFP-SDB)   END OF CHAIN ANCHOR
         WHILE (RX,NE,RA),BEGIN        DO ENTIRE CHAIN
         L     RB,SDBFP                NEXT PATH TO INSPECT
*
*  POST PATH WITH NOTIFY COMPLETION
*
         IF    (SDBPFL,NZ),BEGIN       THIS ONE POSTED
         PSET  @SCOMDB
         ST    RX,@SCOMSDB             SDB POINTER
         ACALL SCOMNTFY                NOTIFY COMPLETE
         END   ,
         LR    RX,RB                   NEXT SDB TO CHECK
         END   ,
         LOCKRL IOCTSNTL               RELEASE NOTIFY CHAIN LOCK
         END   ,
         END   ,
         PEND
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*    FUNCTION TABLE                                               *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
SCOMFUNC DC    A(0)
         DC    A(SCOMOPEN)
SCMFMAX  EQU   *-SCOMFUNC-4            MAXIMUM
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*    SCOMOPEN - Open SCOM paths                                   *
*                                                                 *
*                                                                 *
*     Input -  @SCOMDO                                            *
*                                                                 *
*    Output -  Return code in RVR                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOMOPEN PROC  @SCOMDO,SCOPE=LOCAL
         L     RJ,@SCMDMSG             Message
         WITH  ($SCMIMSG,RJ)
         L     RY,@SCMDWRK             WORK AREA
         WITH  (SCSTWORK,RY)
         L     RK,$SCMSDB              SDB POINTER
         WITH  (SDB,RK)
         WITH  (COMDB,SDB),'CLC  COMDBID,=CL4"SDB"'    Validate
         IF    NE,'KAPUT SDBPTR'
*
*  SET UP ECB
*
         LA    RS,SCTPECB              ECB Pointer
         ST    RS,PATHECB               SET
*
*  ISSUE SCOM SVC
*
         LA    RS,PATH                 PATH BLOCK
         ST    RS,SCTPATH               TO PARAMETER LIST
         SET   SCTPATH.X'80'           END OF LIST
         SCOM  OPEN,SCTPATH            TRY OPENING IT
         LR    RA,R15                  Save return code
*
*  Release Info area (if there is one)
*
         IF    ('LT  RB,PATHPINP',NZ),BEGIN
         LA    RS,4
         AL    RS,@RB                  Area length
         MEMFREE (RS),A=(RB),TYPE=GLOBAL
         CLEAR PATHPINP
         END
*
*  If Path open failed - release PATH block
*
         IF    (RA,NZ),BEGIN
         PSET  @SCOMDB
         ST    RK,@SCOMSDB             PATH ID
         ACALL SCOMCLS                 RELEASE PATH BLOCK
         END   ,
         LR    RVR,RA                  CONDITION CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCOMFLG  - SUZAN Path post flag routine                       *
*                                                                 *
*                                                                 *
*     Input -  @SCOMDB                                            *
*                                                                 *
*    Output -  RVR contains path post flags from SDBPFL           *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOMFLG  PROC  @SCOMDB,SCOPE=LOCAL
         L     RX,@SCOMSDB             PATH BLOCK
         WITH  (SDB,RX)
         LA    R15,1
         LCR   R14,R15
         SLL   R15,3-((SDBPFL-SDB)-(((SDBPFL-SDB)/4)*4))
         EX    R15,'ICM  R14,0,=X"00"'
         L     R15,SDB+((SDBPFL-SDB)/4*4)
         LOOP  BEGIN
         LR    RS,R15
         NR    RS,R14
         CS    R15,RS,SDB+((SDBPFL-SDB)/4*4)
         UNTIL Z,END
         SRL   R15,8*(3-((SDBPFL-SDB)-(((SDBPFL-SDB)/4)*4)))
         LA    RVR,255
         NR    RVR,R15                 RETURN CLEARED FLAGS
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   SCOMNTFY - SUZAN Path notify routine                          *
*                                                                 *
*                                                                 *
*     Input -  @SCOMDB                                            *
*              Path notify lock held                              *
*                                                                 *
*    Output -  None                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
SCOMNTFY PROC  @SCOMDB,SCOPE=LOCAL
         L     RX,@SCOMSDB             PATH BLOCK
         WITH  (SDB,RX)
         LM    R14,R15,SDBFP           FORWARD AND BACKWARD POINTERS
         WITH  (SDB,R14),'ST  R15,SDBBP'  NEXT POINTS TO PREV
         WITH  (SDB,R15),'ST  R14,SDBFP'  PREV POINTS TO NEXT
         CLEAR (SDBFP,8)               ZERO POINTERS
         CLEAR SDBFNTFY                TAKEN OFF THE NOTIFY QUEUE
*
*  GET POST FLAGS
*
         PSET  @SCOMDB,CLEAR=NO
         ST    RX,@SCOMSDB             PATH BLOCK POINTER
         ACALL SCOMFLG                 POST FLAGS RETURNED IN RVR
*
*  NOTIFY GUEST MACHINE OF COMPLETION
*
         PSET  @GSTIIOT
         ST    RVR,@GSTICS             Completion status
         MVC   @GSTIRQI,SDBRQID        Request ID
         VCALL GSTIIOT                 NOTIFY THE USER
         PEND
         EJECT
         LTORG
         TITLE 'ORVYL''S JES I/O Subtask'
*******************************************************************
*                                                                 *
*    JESWORK - JES I/O sub-task work area                         *
*                                                                 *
*******************************************************************
         SPACE
JESWORK  RECORD BEGIN
JESMCHN  DS    A                       MESSAGE CHANNEL ID
JESMECB  DS    A                       MESSAGE CHANNEL ECB
JESIOCT  DS    A                       IOCT ADDRESS
JESRPL   DS    A                       RPL POINTER
JESWBUFF DS    A                       WRITE BUFFER POINTER
         END
         SPACE 3
*******************************************************************
*                                                                 *
*      JESMSG - JES I/O Services Message Buffer                   *
*                                                                 *
*******************************************************************
         SPACE
$JESMSG  RECORD BEGIN
$JESJDB  DS    A                       Device ID
$JESRQID DS    A                       Request ID
$JESOFF  DS    A                       Offset to convert address
$JESKEY  DS    X                       Protect key
$JESPARM DS    4A                      User parameter area
         ORG   $JESPARM
         DS    XL(L'#JESOPEN)
         ORG   $JESPARM
         DS    XL(L'#JESCLOS)
         ORG   $JESPARM
         DS    XL(L'#JESWRIT)
         ORG   $JESPARM
         DS    XL(L'#JESOPEN)
         ORG   ,
         END
         EJECT
*******************************************************************
*                                                                 *
*    @JESDO   - Parameters passed to JES drivers                  *
*                                                                 *
*******************************************************************
         SPACE
@JESDO   RECORD BEGIN
@JESDMSG DS    A                       Message buffer pointer
@JESDWRK DS    A                       Work area pointer
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @JESCLS  - Parameters for JES close routine                  *
*                                                                 *
*******************************************************************
         SPACE
@JESCLS  RECORD BEGIN
@JESCJDB DS    A                       JES device block pointer
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    FUNCTION TABLE                                               *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
JESFUNC  DC    A(0)
         DC    A(JESOPEN)
         DC    A(JESCLOSE)
         DC    A(JESWRITE)
         DC    A(JESJBEND)
JESFMAX  EQU   *-JESFUNC-4             MAXIMUM
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   JESIOTSK - JES I/O service sub-task                           *
*                                                                 *
*                                                                 *
*     Input -  None                                               *
*                                                                 *
*    Output -  None                                               *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESIOTSK PROC  SBTPARM,SCOPE=LOCAL
         MEMGET L'JESWORK,TYPE=LOCAL   GET WORK AREA
         IF    ('LTR RY,RVR',Z),'KAPUT JESWORK'
         WITH  (JESWORK,RY)
         MVC   JESIOCT,SBTDATA         IOCT pointer
         MSGATT JESIOTSK,TYPE=SERV     Open channel
         ST    RVR,JESMCHN             MESSAGE CHANNEL ID
         L     RS,@MSGCECB             MESSAGE ECB
         ST    RS,JESMECB              SET POINTER
         EJECT
*
*  CREATE RPL
*
         MEMGET RPLSIZE,TYPE=BELOW16M   FIRST GET
         LR    RA,RVR                   RPL AREA
         ST    RA,JESRPL               SET POINTER
         MEMGET GENRPL,TYPE=BELOW16M    THEN GET SOME
         LR    RB,RVR                    WORK AREA
*GEN
         GENCB BLK=RPL,OPTCD=(ADR,SEQ,SYN,NUP,MVE),WAREA=(RA),         *
               LENGTH=RPLSIZE,MF=(G,(RB),GENRPL)
*NOGEN
         MEMFREE GENRPL,A=(RB),TYPE=BELOW16M    RELEASE WORK AREA
*
*  JES I/O TASK LOOP
*
         LOOP  BEGIN
         FWAIT JESMECB                 FAST WAIT (BRANCH ENTRY)
         L     RS,JESMECB              ECB POINTER
         CLEAR (@RS,4)                 CLEAR IT
         MSGRECV JESMCHN               RECEIVE A MESSAGE
         IF    ('LTR  RJ,RVR',Z),NEXT   NO MORE TO GET
         WITH  ($JESMSG,RJ)
         PSET  @JESDO
         ST    RJ,@JESDMSG             PASS MESSAGE POINTER
         ST    RY,@JESDWRK              AND WORK AREA POINTER
         WITH  (#JESCOM,$JESPARM)
         L     RS,#JESCMD              FUNCTION CODE
         IF    (RS,Z),'KAPUT JESFUNZ'
         IF    (RS,GT,JESFMAX),'KAPUT JESFUNHI'
         ACALL JESFUNC(RS)             FUNCTION ROUTINE
*                                      RETURN CODE IS IN RVR
         EJECT
*
*  NOTIFY GUEST MACHINE OF COMPLETION
*
         PSET  @GSTIIOT
         ST    RVR,@GSTICS             Completion status
         MVC   @GSTIRQI,$JESRQID       Request ID
         VCALL GSTIIOT                 NOTIFY THE USER
*
*  FREE THE MESSAGE BUFFER
*
         MSGFREE JESMCHN,(RJ)          FREE MESSAGE BUFFER
         END
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    JESOPEN - Open JES data sets                                 *
*                                                                 *
*                                                                 *
*     Input -  @JESDO                                             *
*                                                                 *
*    Output -  Return code in RVR                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESOPEN  PROC  @JESDO,SCOPE=LOCAL
         L     RJ,@JESDMSG             Message
         WITH  ($JESMSG,RJ)
         WITH  (#JESOPEN,$JESPARM)
         L     RK,$JESJDB              JDB POINTER
         WITH  (JDB,RK)
         WITH  (COMDB,JDB),'CLC  COMDBID,=CL4"JDB"'    Validate
         IF    NE,'KAPUT JDBPTR'
*
*  FIRST DO ALLOCATE
*
         PSET  @JSDALLO
         L     RS,#JESALLO             Pointer to allocation parms
         AL    RS,$JESOFF               Convert to MVS virtual
         ST    RS,@JSDPARM
         ACALL JSALLO                  Go do allocate
         WITH  (@JSALLO,RS),'MVC  JDBDDNAM,@JSDDNM'  GET DDNAME
         EJECT
*
*  ALLOCATE WAS SUCCESSFUL - CREATE ACB
*
         IF    ('LTR RX,RVR',Z),BEGIN
         MEMGET ACBSIZE,TYPE=BELOW16M  GET ACB AREA
         LR    RB,RVR
         ST    RB,JDBACB               SAVE ACB POINTER
         MEMGET GENACB,TYPE=BELOW16M
         LR    RA,RVR
*GEN
         GENCB BLK=ACB,MACRF=(ADR,OUT,AMODE31),LENGTH=ACBSIZE,         *
               WAREA=(RB),DDNAME=(*,JDBDDNAM),MF=(G,(RA),GENACB)
*NOGEN
         IF    (R15,NZ),'KAPUT GENACB'
         MEMFREE GENACB,A=(RA),TYPE=BELOW16M
*
*  SET UP PARAMETER LIST AND DO OPEN
*
         MEMGET 4,TYPE=BELOW16M        SET UP
         LR    RA,RVR                   OPEN
         ST    RB,@RA                    PARAMETER
         OI    @RA,X'80'                  LIST
         ESTAEON ACBOERR               CATCH ABENDS
         OPEN  MF=(E,(RA))             DO IT
         LR    RX,R15                  RETURN CODE
         ESTAEOFF ,                    CLEAR ABEND INTERCEPT
*
*  ESTAE RETRY ROUTINE
*
         BEGIN
         EXIT
ACBOERR  LABEL ,
         LR    RX,RVR                  ESTAE INFO POINTER
         END   ,
         EJECT
*
*  FREE THE OPEN PARAMETER LIST
*
         MEMFREE 4,A=(RA),TYPE=BELOW16M   FREE PARAMETER LIST
*
*  IF OPEN FAILED RELEASE THE ACB
*
         IF    (RX,NZ),BEGIN
         CLEAR JDBACB                  REMOVE ACB POINTER
         MEMFREE ACBSIZE,A=(RB),TYPE=BELOW16M
         END   ,
         END   ,
*
*  IF ALLOCATION OR OPENED FAILED FREE THE JDB
*
         IF    (RX,NZ),BEGIN
         PSET  @JESCLS
         ST    RK,@JESCJDB             JDB POINTER
         ACALL JESCLS
         END   ,
         LR    RVR,RX                  SET RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    JESCLOSE - Close JES data sets                               *
*                                                                 *
*                                                                 *
*     Input -  @JESDO                                             *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESCLOSE PROC  @JESDO,SCOPE=LOCAL
         L     RJ,@JESDMSG             Message
         WITH  ($JESMSG,RJ)
         WITH  (#JESCLOS,$JESPARM)
         L     RK,$JESJDB              JDB POINTER
         WITH  (JDB,RK)
         WITH  (COMDB,JDB),'CLC  COMDBID,=CL4"JDB"'    Validate
         IF    NE,'KAPUT JDBPTR'
         PSET  @JESCLS
         ST    RK,@JESCJDB             JDB is parm
         LCALL JESCLS
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    JESCLS - Close a JES device                                  *
*                                                                 *
*                                                                 *
*     Input -  @JESCLS                                            *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESCLS   PROC  @JESCLS,SCOPE=LOCAL
         L     RK,@JESCJDB             JDB Pointer
         WITH  (JDB,RK)
         WITH  (COMDB,JDB),BEGIN
         CLC   COMDBID,=CL4'JDB'       Validate
         IF    NE,'KAPUT JDBPTR'
         CLEAR (COMDBID,4)             JDB no longer valid
         END   ,
         L     RJ,JDBACB               GET ACB POINTER
         EJECT
*
*  SET UP PARAMETER LIST AND CLOSE IT
*
         IF    (RJ,NZ),BEGIN
         MEMGET 4,TYPE=BELOW16M        SET UP
         LR    RB,RVR                   CLOSE
         ST    RJ,@RB                    PARAMETER
         OI    @RB,X'80'                  LIST
         ESTAEON CLSJERR               CATCH ABENDS
         CLOSE MF=(E,(RB))             DO IT
         ESTAEOFF ,                    CLEAR ABEND INTERCEPT
*
*  ESTAE RETRY ROUTINE
*
         BEGIN
         EXIT
CLSJERR  LABEL ,
         LR    RA,RVR                  ESTAE INFO POINTER
         END   ,
         MEMFREE 4,A=(RB),TYPE=BELOW16M   FREE PARAMETER LIST
*
*  RELEASE ACB
*
         MEMFREE ACBSIZE,A=(RJ),TYPE=BELOW16M
         END   ,
         EJECT
*
*  DATA SET NOT OPENED - DEALLOCATE IT
*
         ELSE  BEGIN
         IF    (JDBDDNAM,Z),EXIT       ALLOCATION INCOMPLETE
         PSET  @DUNALLO
         MVC   @DUNDDN,JDBDDNAM        SET DDNAME
         ACALL DUNALLO
         LR    RA,RVR                  Return code
         END   ,
*
*  UNCHAIN JDB
*
         WITH  (RTCB,RTCBR),'L  RX,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RX),'L  RX,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RX)
         LOCKOB IOCTJDBL               GET JDB CHAIN LOCK
         LA    RS,IOCTJDBS             JDB CHAIN
         SH    RS,=Y(JDBCHAIN-JDB)     OFFSET
         LOOP  BEGIN
         WITH  (JDB,RS)
         IF    (RK,EQ,JDBCHAIN),EXIT   FOUND
         L     RS,JDBCHAIN
         END   ,
         L     R14,JDBCHAIN            NEXT IN CHAIN
         WITH  (JDB,RS),'ST  R14,JDBCHAIN'    UPDATE FREE CHAIN
         LOCKRL IOCTJDBL               RELEASE JDB CHAIN LOCK
         EJECT
*
*  RELEASE JDB THEN RETURN
*
         MEMFREE L'JDB,A=(RK),TYPE=GLOBAL
         LR    RVR,RA                  SET RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    JESWRITE - Write data to JES                                 *
*                                                                 *
*                                                                 *
*     Input -  @JESDO                                             *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESWRITE PROC  @JESDO,SCOPE=LOCAL
         L     RJ,@JESDMSG             Message
         WITH  ($JESMSG,RJ)
         L     RY,@JESDWRK             WORK AREA
         WITH  (JESWORK,RY)
         WITH  (#JESWRIT,$JESPARM)
         L     RK,$JESJDB              JDB POINTER
         WITH  (JDB,RK)
         WITH  (COMDB,JDB),'CLC  COMDBID,=CL4"JDB"'    Validate
         IF    NE,'KAPUT JDBPTR'
         EJECT
*
*  GET LOCAL BUFFER AND MOVE IN USER DATA
*
         L     RA,#JESWLEN             TOTAL LENGTH OF DATA
         MEMGET (RA),TYPE=BELOW16M     GET LOCAL BUFFER
         LR    RA,RVR                  BUFFER POINTER
         ST    RA,JESWBUFF             SAVE BUFFER POINTER
         L     RS,#JESWLST             USER BUFFER LIST
         AL    RS,$JESOFF               TO MVS VIRTUAL
         L     R15,#JESWLEN            TOTAL LENGTH
         LOOP  BEGIN
         L     R14,@RS                 ADDRESS OF SEGMENT
         AL    R14,$JESOFF              TO MVS VIRTUAL
         L     RB,@RS+4                LENGTH OF SEGMENT
         MVCL  RA,R14                  MOVE THIS SEGMENT
         IF    @RS.X'80',EXIT          DONE IF END OF LIST
         LA    RS,@RS+8                NEXT LIST ENTRY
         END   ,
*
*  LENGTHS DIDN'T MATCH
*
         IF    (R15,NZ),'KAPUT JESWLEN'
*
*  SEND RECORDS TO JES
*
         L     RB,JESWBUFF
         WHILE (RB,LT,RA),BEGIN
         L     RX,#JESWLRC             LRECL
*
*  VARIABLE LENGTH RECORDS ARE SELF DESCRIBING
*
         IF    (RX,Z),BEGIN
         LH    RX,@RB                  LENGTH OF THIS RECORD
         LA    RB,@RB+4                ACTUAL DATA START
         SH    RX,=Y(4)                ACTUAL DATA LENGTH
         END   ,
         EJECT
*
*  SET RPL FIELDS
*
         L     RS,JESRPL               RPL POINTER
         WITH  (IFGRPL,RS),BEGIN
         ST    RB,RPLAREA              RECORD LOCATION
         ST    RX,RPLRLEN               AND LENGTH
         ST    RX,RPLBUFL              BUFFER LENGTH
         MVC   RPLDACB,JDBACB          ACB POINTER
         END   ,
*
*  ISSUE PUT
*
*         PUT   RPL=(RS)                DO THE ACTUAL PUT
         PSET  @AM24RTN
         MVC   @AM24R0,=A(1)           "PUT" CODE IN R0
         ST    RS,@AM24R1              RPL IN R1
         L     R15,JDBACB              ACB POINTER TO R15
         WITH  (IFGACB,R15),'MVC  @AM24R15,ACBINRTN'
         ACALL AM24RTN
         L     R15,@AM24R15
         IF    (R15,NZ),'KAPUT JESWPUT'
         LA    RB,@RB(RX)              NEXT RECORD
         END   ,
         EJECT
*
*  Release buffer and return
*
         L     RA,JESWBUFF             BUFFER ADDRESS
         L     RB,#JESWLEN              AND LENGTH
         MEMFREE (RB),A=(RA),TYPE=BELOW16M    FREE LOCAL BUFFER
         CLEAR RVR
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    JESJBEND - End job stream being sent to JES                  *
*                                                                 *
*                                                                 *
*     Input -  @JESDO                                             *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JESJBEND PROC  @JESDO,SCOPE=LOCAL
         L     RJ,@JESDMSG             Message
         WITH  ($JESMSG,RJ)
         L     RY,@JESDWRK             WORK AREA
         WITH  (JESWORK,RY)
         WITH  (#JESJBND,$JESPARM)
         L     RK,$JESJDB              JDB POINTER
         WITH  (JDB,RK)
         WITH  (COMDB,JDB),'CLC  COMDBID,=CL4"JDB"'    Validate
         IF    NE,'KAPUT JDBPTR'
*
*  SET RPL FIELDS
*
         L     RA,JESRPL               RPL POINTER
         WITH  (IFGRPL,RA)
         MVC   RPLDACB,JDBACB          ACB POINTER
         EJECT
*
*  SIGNAL JES
*
*         ENDREQ RPL=(RA)
         PSET  @AM24RTN
         MVC   @AM24R0,=A(4)           "END" CODE IN R0
         ST    RA,@AM24R1              RPL IN R1
         L     R15,JDBACB              ACB POINTER TO R15
         WITH  (IFGACB,R15),'MVC  @AM24R15,ACBINRTN'
         ACALL AM24RTN
         L     R15,@AM24R15
         IF    (R15,NZ),'KAPUT JSJBEND'
*
*  RETRIEVE JOB NUMBER
*
         L     RB,RPLRBAR+4            ANSWER AREA
         L     RX,#JESNLOC             USER LOCATION
         AL    RX,$JESOFF               TO MVS VIRTUAL
         ST    RB,@RX                  TO USER AREA
         CLEAR RVR
         PEND
         EJECT
         COPY  JSALPARM
         EJECT
*******************************************************************
*                                                                 *
*    JSALWORK - JES device allocation data                        *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
JSTULIST DC    12A(0)
*
JSTUDDN  DC    AL2(DALDDNAM,1,8)       DDNAME - KEY, NUMBER, LENGTH
         DC    CL8' '                  DDNAME - STRING
*
JSTUFREE DC    AL2(DALCLOSE,0)         FREE=CLOSE - KEY AND NUMBER
*
JSTUSYSO DC    AL2(DALSYSOU,0,1)       SYSOUT - KEY, NUMBER, LENGTH
         DC    C' '                    SYSOUT - STRING
*
JSTUWRTN DC    AL2(DALSPGNM,1)         PROGRAM NAME - KEY AND NUMBER
         DC    AL2(6)                  PROGRAM NAME - LENGTH
         DC    CL6'INTRDR'             PROGRAM NAME - STRING
*
JSTUFORM DC    AL2(DALSFMNO,1,4)       FORMS - KEY, NUMBER, LENGTH
         DC    CL4' '                  FORMS - STRING
*
JSTUFLSH DC    AL2(DALFFORM,1,4)       FORM FLASH - KEY, NUMBER, LEN
         DC    CL4' '                  FORM FLASH - STRING
*
JSTUDEST DC    AL2(DALSUSER,1,8)       DESTINATION - KEY, NUMBER, LEN
         DC    CL8' '                  DESTINATION - STRING
*
JSTUFCB  DC    AL2(DALFCBIM,1,4)       FCB - KEY AND NUMBER
         DC    CL4' '                  FCB - STRING
*
JSTUCOPY DC    AL2(DALCOPYS,1,1)       COPIES - KEY AND NUMBER
         DC    C' '                    COPIES - STRING
*
JSTUHOLD DC    AL2(DALSHOLD,0)         OUTPUT HOLD - KEY AND NUMBER
*
JSTUCHAR DC    AL2(DALCHARS,1)         CHARS - KEY AND NUMBER
         DC    AL2(4),CL4' '           CHARS - LENGTHS AND STRINGS
         DC    AL2(4),CL4' '
         DC    AL2(4),CL4' '
         DC    AL2(4),CL4' '
*
JSALWORK EQU   JSTULIST,*-JSTULIST
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   JSALLO - JES Sysout and Intrdr Device Allocation              *
*                                                                 *
*                                                                 *
*     Input - @JSDALLO                                            *
*                                                                 *
*    Output - RVR contains return code from SVC 99                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
JSALLO   PROC  @JSDALLO,SCOPE=GLOBAL
         L     RY,@JSDPARM             USER PARAMETERS
         WITH  (@JSALLO,RY)
*
*  FIRST SET UP WORK AREA
*
         MEMGET L'JSALWORK             WORK AREA
         LR    RX,RVR                   POINTER
         MVC   @RX(L'JSALWORK),JSALWORK  COPY PARAMETERS
         WITH  (JSALWORK,RX)
         LA    RK,JSTULIST             LIST POINTER
         EJECT
*
*  BUILD COMMON TEXT UNITS - START WITH FREE=CLOSE
*
         LA    RS,JSTUFREE             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
*
*  BUILD DDNAME/RETURN DDNAME UNIT
*
         LA    RS,JSTUDDN              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),BEGIN
         IF    (@JSDDNM,Z),'MVC  S99TUKEY,=AL2(DALRTDDN)'
         ELSE  'MVC  S99TUPAR(8),@JSDDNM'   PUT IN DDNAME
         END   ,
*
*  BUILD SYSOUT UNIT
*
         LA    RS,JSTUSYSO             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         IF    (@JSCLAS,NZ),BEGIN
         WITH  (S99TUNIT,RS)
         MVC   S99TUNUM,=AL2(1)        NUMBER OF PARAMETERS
         MVC   S99TUPAR(1),@JSCLAS     PUT IN CLASS
         END
*
*  PROCESS INTRDR REQUESTS - BUILD PROGRAM NAME UNIT
*
         IF    @JSINTR,BEGIN
         LA    RS,JSTUWRTN             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
         EJECT
*
*  REQUEST IS FOR SYSOUT -  START WITH COPIES
*
         ELSE  BEGIN
         IF    (@JSCOPY,NZ),BEGIN
         LA    RS,JSTUCOPY             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         MVC   S99TUPAR(L'@JSCOPY),@JSCOPY   PUT IN COPIES
         END   ,
*
*  BUILD FORMS UNIT
*
         IF    (@JSFORM,NZ),BEGIN
         LA    RS,JSTUFORM             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         MVC   S99TUPAR(4),@JSFORM     PUT IN FORMS
         END   ,
*
*  BUILD CHARS UNIT
*
         IF    (@JSCHAR,NZ),BEGIN
         LA    RS,JSTUCHAR             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         MVC   S99TUPAR(4),@JSCHAR     PUT IN CHARS
         END   ,
*
*  BUILD FLASH UNIT
*
         IF    (@JSFLAS,NZ),BEGIN
         LA    RS,JSTUFLSH             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         MVC   S99TUPAR(4),@JSFLAS     PUT IN FLASH
         END   ,
         EJECT
*
*  BUILD FCB UNIT
*
         IF    (@JSFCB,NZ),BEGIN
         LA    RS,JSTUFCB              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         MVC   S99TUPAR(4),@JSFCB      PUT IN FLASH
         END   ,
*
*  BUILD DEST UNIT
*
         IF    (@JSDEST,NZ),BEGIN
         LA    RS,JSTUDEST             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         MVC   S99TUPAR(8),@JSDEST     PUT IN DESTINATION
         END   ,
*
*  BUILD HOLD UNIT
*
         IF    @JSHOLD,BEGIN
         LA    RS,JSTUHOLD             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
         END   ,
*
*  MARK END OF LIST AND DO DYNAMIC ALLOCATE
*
         SET   @RK.S99TUPLN            NOTE LIST END
         PSET  @DYNALLO
         LA    RS,JSTULIST             LIST POINTER
         ST    RS,@DYNTXTU             SET LIST ADDRESS
         ACALL DYNALLO
         STH   RVR,@JSRTN              SAVE RETURN CODE
*
*  IF ERROR IN DYNAMIC ALLOCATE SET ERROR CODES
*
         IF    ('LTR  RK,RVR',NZ),BEGIN
         MVC   @JSERR,@DYNERR          COPY ERROR CODE
         MVC   @JSRSN,@DYNRSN           AND REASON CODE
         END   ,
         EJECT
*
*  ALLOCATE SUCCESSFUL - RETURN DDNAME
*
         ELSE  BEGIN
         IF    (@JSDDNM,NE,=XL8'00'),EXIT
         LA    RS,JSTUDDN              POINTER TO DDNAME TEXT UNIT
         WITH  (S99TUNIT,RS)
         MVC   @JSDDNM,S99TUPAR        COPY DDNAME
         END   ,
         DROP  RX
*
*  RELEASE WORK AREA AND RETURN
*
         MEMFREE L'JSALWORK,A=(RX)     RELEASE WORK AREA
         LR    RVR,RK
         PEND
         LTORG
         EJECT
*
* SNAP DUMP PARAMETER RECORD
*
@SNDPPRM RECORD BEGIN
@SNDADDR DS    A                       SNAP DUMP LINE TO WRITE
@SNDLEN  DS    A                       SNAP DUMP LINE LENGTH
@SNDTOKN DS    A                       SNAP DUMP DATA SET ID
         END   ,

         EJECT
*******************************************************************
*                                                                 *
*     SNDPALLO - Routine to dynamically allocate and open a       *
*                SNAPDUMP sysout data set.                        *
*                                                                 *
*                                                                 *
*      Input - none                                               *
*                                                                 *
*     Output - Token representing SNAPDUMP data set created.      *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 2
SNDPALLO PROC  @SNDPPRM,SCOPE=GLOBAL
         MEMGET L'@JSALLO
         LR    RK,RVR
         WITH  (@JSALLO,RK)
         MEMGET L'SNDB,TYPE=GLOBAL     Get storage for an SNDB
         LR    RM,RVR
         WITH  (SNDB,RM)
         CLEAR SNDB
         WITH  (COMDB,RM),BEGIN        Set ID
         MVC   COMDBID,=CL4'SNDB'       to SNDB
         END   ,                       OF Set ID
         EJECT
*
*  ASSIGN A DDNAME SUFFIX USING COUNT FROM SNDB
*
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT pointer
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT pointer
         WITH  (IOCT,RY)
         LOCKOB IOCTSNPL               Get SNDB chain lock
         SR    RS,RS                   Init count to zero
*
*  IF SNDBS ARE IN CHAIN, THERE IS A COUNT TO BE USED
*
         LH    RS,IOCTSNCT
         LA    RS,1(,RS)              Increment count
         IF    (RS,GT,999),'LA RS,1'  If count > 999 start over
         STH   RS,IOCTSNCT            Update count
         CVD   RS,@JSDDNM             Convert count to decimal
         LOCKRL IOCTSNPL              Release SNDB chain lock
         EJECT
*
*  BUILD THE DYNAMIC ALLOCATION PARAMETER AREA STARTING
*  WITH DDNAME.
*
         UNPK  @JSDDNM(3),@JSDDNM+6(2) Make count alphanumeric
         MVC   @JSDDNM+5(3),@JSDDNM    Shift right to form suffix
         OI    @JSDDNM+7,X'F0'         Clear sign
         MVC   @JSDDNM(5),=C'SNAPD'    Move in DDNAME prefix
         SET   @JSHOLD                 Output hold
         MVI   @JSCLAS,C'A'            SYSOUT=A
         MVC   SNDBDDN,@JSDDNM         Save DDN in SNDB
*
*  Do the dynamic allocation
*
         PSET  @JSDALLO                Point to
         ST    RK,@JSDPARM             Allocation parameter area
         VCALL JSALLO                  Call JES allocation
*
*  IF ALLOCATION FAILED LOG THE ERROR AND FREE SNDB
*
         IF    ('LTR RX,RVR',NZ),BEGIN Allocation failed
         WTO   'Unable to allocate SNAPDUMP',ROUTCDE=11
         QSNAP @JSRTN,6
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'DTALFAIL'
         MEMFREE L'SNDB,A=(RM)         FREE SNDB
         END   ,                       OF Allocation failed
*
*  FREE THE DYNAMIC ALLOCATION PARAMETER AREA
*
         MEMFREE L'@JSALLO,A=(RK)
         DROP  RK
*
*  IF ALLOCATION SUCCEEDED, GET AN AREA FOR THE ACB
*
         IF    (RX,Z),BEGIN            Allocation succeeded
*
*  CREATE DCBE
*
         MEMGET SNAPDELN               Get storage for DCBE
         LR    RK,RVR                  Save DCBE pointer
         ST    RK,SNDBDCBE              into SNDB for MEMFREE
         MVC   0(SNAPDELN,RK),SNAPDCBE Copy model DCBE to real
*
*  CREATE DCB
*
         MEMGET SNAPDLEN,TYPE=BELOW16M Get storage for DCB
         LR    RA,RVR                  Save DCB pointer
         ST    RA,SNDBDCB               into SNDB
         WITH  (IHADCB,RA)
         MVC   IHADCB(SNAPDLEN),SNAPDCB   COPY DCB
         MVC   DCBDDNAM,SNDBDDN        SET DD NAME
         ST    RK,DCBDCBE              SET DCBE
*
*  SET UP PARAMETER LIST AND DO OPEN
*
         MEMGET 8                      Set up
         LR    RK,RVR                   Open
         XC    0(4,RK),0(RK)
         ST    RA,@RK+4                  Parameter
         MVI   @RK,143                    List
*NOEDIT
         OPEN  MF=(E,(RK)),MODE=31     Do it
*EDIT
         LR    RX,R15                  Return code
         EJECT
*
*  FREE THE OPEN PARAMETER LIST
*
         MEMFREE 8,A=(RK)                 Free OPEN parm list
*
*  IF OPEN FAILED RELEASE THE DCB, DCBE AND SNDB
*
         IF    (RX,NZ),BEGIN           OPEN failed
         WTO   'OPEN SNAPDUMP failed',ROUTCDE=11
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'DTOPFAIL'
*
*  RELEASE DCB
*
         MEMFREE SNAPDLEN,A=(RK),TYPE=BELOW16M
*
*  RELEASE DCBE
*
         L     RK,SNDBDCBE
         MEMFREE SNAPDELN,A=(RK)
*
*  RELEASE SNDB
*
         MEMFREE L'SNDB,A=(RM)         FREE SNDB
         END   ELSE,BEGIN          END OF OPEN failed; BEGIN OPEN OK
*
*  OPEN WAS SUCCESSFUL, STORE SNDB INTO CHAIN ANCHORED AT
*  IOCTSNDB.
*
         LOCKOB IOCTSNPL
         MVC   SNDBCHN,IOCTSNDB        Get SNDB chain lock
         ST    RM,IOCTSNDB             Former head of chain
         LOCKRL IOCTSNPL               Add this one to chain head
         ST    RM,@SNDTOKN             Pass back SNDB addr as token
         SR    RVR,RVR                 Return cond code 0
         END   ,                       of OPEN OK
*
*  END OF ALLOCATION AND OPEN PROCESSING.  IF SUCCESSFUL
*  R15 ALREADY HAS RC 0.
*
         END   ,                       OF Allocation succeeded
         IF (RX,NZ),'LA RVR,4'         For any errors, RC = 4
         PEND
         LTORG
SNAPDCBE DCBE RMODE31=BUFF
SNAPDELN EQU *-SNAPDCBE
SNAPDCB  DCB DDNAME=SNAPDUMP,DSORG=PS,MACRF=PM,                        X
               LRECL=133,RECFM=FB,BLKSIZE=1330
SNAPDLEN EQU *-SNAPDCB
         EJECT
*******************************************************************
*                                                                 *
*     SNDPWRT  - Routine to write a line to a SNAPDUMP JES2       *
*                sysout data set.                                 *
*                                                                 *
*                                                                 *
*     Input - @SNDPPRM contains line to write, length and token   *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
SNDPWRT  PROC  @SNDPPRM,SCOPE=GLOBAL
         WITH  (RTCB,RTCBR),'L  RX,RTCBCBAT'   CBAT pointer
         WITH  (CBAT,RX),'L  RX,CBATIOCT'      IOCT pointer
         WITH  (IOCT,RX)
         L     RA,@SNDTOKN             Get token (SNDB ptr)
         LA    RJ,4                    Preload bad return code
         LOCKOB IOCTSNPL               Get SNDB chain lock
         L     RS,IOCTSNDB             Get SNDB chain anchor
LOOP1    LOOP  BEGIN                   Run SNDB chain
         WITH  (SNDB,RS)
         IF    (RS,Z),EXIT             End of chain
         IF    (RA,EQ,RS),'SR RJ,RJ;EXIT LOOP1' Found match
         L     RS,SNDBCHN              Get next entry
         END   ,                       OF Run SNDB chain
         LOCKRL IOCTSNPL               Release SNDB chain lock
         EJECT
*
* IF THE SNDB WAS FOUND, THEN PREPARE TO DO THE WRITE TO JES
*
         WITH  (SNDB,RA)
SNDBOK   IF (RJ,Z),BEGIN               SNDB found; write to JES
         WITH (COMDB,SNDB),'CLC COMDBID,=CL4"SNDB"' Check ID
         IF NE,BEGIN                   No matching SNDB ID
         WTO   'NO SNDB ID MATCH AT PUT TIME',ROUTCDE=11
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT  'SNDB PTR'
         EXIT   SNDBOK
         END    ,                      OF No matching SNDB ID
*
*  SET RPL FIELDS
*
         L     RS,SNDBDCB              DCB pointer
         IF    (RS,Z),BEGIN            No DCB found
         WTO   'NO DCB FOUND AT PUT TIME',ROUTCDE=11
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'NO DCB'
         EXIT   SNDBOK
         END   ,                       No DCB found
         L     RVR,@SNDADDR            Record Location
*
*  ISSUE PUT
*
         PUT  (RS),(RVR)               Do the actual PUT
         END   ,                       OF SNDB found; write to JES
         LR    RVR,RJ                  Pass return code to caller
         PEND
         EJECT
*******************************************************************
*                                                                 *
*     SNDPCLS  - Routine to CLOSE a SNAPDUMP sysout data set.     *
*                                                                 *
*                                                                 *
*     Input - @SNDPPRM contains token for snap dump data set to   *
*             be closed                                           *
*                                                                 *
*     Output - none                                               *
*                                                                 *
*                                                                 *
*******************************************************************
SNDPCLS  PROC  @SNDPPRM,SCOPE=GLOBAL
         WITH  (RTCB,RTCBR),'L  RX,RTCBCBAT'   CBAT pointer
         WITH  (CBAT,RX),'L  RX,CBATIOCT'      IOCT pointer
         WITH  (IOCT,RX)
*
*  VALIDATE INPUT TOKEN WHICH IS THE SNDB ADDRESS AGAINST THE SNDB
*  CHAIN ANCHORED ON IOCTSNPL.
*
         L     RA,@SNDTOKN             Get token (SNDB ptr)
         LA    RJ,4                    Preload bad return code
         LOCKOB IOCTSNPL               Get SNDB chain lock
         L     RS,IOCTSNDB             SNDB chain
LOOP2    LOOP  BEGIN                   Run SNDB chain
         WITH  (SNDB,RS)
*
*  IF SNDB NOT IN CHAIN BYPASS FURTHER PROCESSING.  RETURN
*  CODE IN RJ WILL BE PASSED BACK TO CALLER.
*
        IF    (RS,Z),EXIT              End of chain
*
*  IF SNDB FOUND, EXIT LOOP WITH A GOOD RETURN CODE AND
*  CONTINUE CLOSE PROCESSING.
*
         IF    (RA,EQ,RS),'SR RJ,RJ;EXIT LOOP2'
         L     RS,SNDBCHN
         END   ,                       OF Run SNDB chain
         LOCKRL IOCTSNPL               Release SNDB chain lock
         EJECT
*
* IF THE SNDB WAS FOUND AND VALIDATED, THEN GO CLOSE AND
* DEALLOCATE SNAP DUMP
*
         WITH (SNDB,RA)
         IF (RJ,NZ),BEGIN              No SNDB found
         WTO   'SNDB NOT FOUND',ROUTCDE=11
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'NO SNDB AT CLOSE'
         END ELSE,BEGIN     END OF No SNDB FOUND; ELSE Check ID
         WITH (COMDB,SNDB),'CLC COMDBID,=CL4"SNDB"'
         IF NE,BEGIN                   No SNDB ID
         WTO   'NO SNDB ID FOUND AT CLOSE',ROUTCDE=11
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'SNDB PTR'
         END   ,                       OF No SNDB ID
         END   ,                       OF Check ID
         L     RK,SNDBDCB              Get DCB pointer
         IF    (RK,Z),BEGIN            No DCB POINTER
         WTO   'NO SNAPDUMP DCB PTR AT CLOSE',ROUTCDE=11
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'NO SNDBDCB AT CLOSE'
         END   ,                       OF No DCB POINTER
         MEMGET 8                      Set up
         LR    RB,RVR                   CLOSE
         XC    0(4,RB),0(RB)
         ST    RK,@RB+4                  Parameter
         OI    @RB,X'80'                  List
*NOEDIT
         CLOSE MF=(E,(RB)),MODE=31     Do it
*EDIT
         IF ('LTR RJ,R15',NZ),BEGIN    SNAPDUMP Close Failed
         WTO   'SNAPDUMP CLOSE FAILED'
*** FOR THE SHORT TERM, ABEND ORVYL WITH DUMP FOR DEBUGGING
         KAPUT 'DTCLFAIL'
         END   ,                       OF SNAPDUMP Close Failed
*
*  RELEASE CLOSE PARAMETER LIST
*
         MEMFREE 8,A=(RB)                 Free parameter list
*
*  RELEASE DCB
*
         MEMFREE SNAPDLEN,A=(RK),TYPE=BELOW16M
         CLEAR SNDBDCB                  DCB pointer
*
*  RELEASE DCBE
*
         L     RK,SNDBDCBE
         MEMFREE SNAPDELN,A=(RK)
         CLEAR SNDBDCBE
         EJECT
*
*  UNCHAIN SNDB
*
         LOCKOB IOCTSNPL               Get SNDB chain lock
         LA    RS,IOCTSNDB             SNDB chain anchor
         SH    RS,=Y(SNDBCHN-SNDB)     Offset
         LOOP  BEGIN                   Chase SNDB chain
         WITH  (SNDB,RS)               Look for ptr to our SNDB
         IF    (RA,EQ,SNDBCHN),EXIT    FOUND
         L     RS,SNDBCHN
         END   ,                       OF Chase SNDB chain
         L     R14,SNDBCHN             Remove current SNDB
         WITH  (SNDB,RS),'ST  R14,SNDBCHN'    from chain
         LOCKRL IOCTSNPL               Release SNDB chain lock
*EDIT
         EJECT
*
*  RELEASE SNDB THEN RETURN
*
         MEMFREE L'SNDB,A=(RA),TYPE=GLOBAL
         LR    RVR,RJ                  SET RETURN CODE
         PEND
         EJECT
         TITLE 'ORVYL''S MVS Data Set Subtask'
*******************************************************************
*                                                                 *
*    MVIWORK - MVS I/O sub-task work area                         *
*                                                                 *
*******************************************************************
         SPACE
MVIWORK  RECORD BEGIN
MVIMCHN  DS    A                       MESSAGE CHANNEL ID
MVIMECB  DS    A                       MESSAGE CHANNEL ECB
MVIIOCT  DS    A                       IOCT ADDRESS
         END
         SPACE 3
*******************************************************************
*                                                                 *
*      MVIOMSG - MVS I/O Services Message Buffers                 *
*                                                                 *
*******************************************************************
         SPACE
$MVIOCOM RECORD BEGIN
$MVIDSID DS    A                       Device ID
$MVIRQID DS    A                       Request ID
$MVIOFF  DS    A                       Offset to convert addresses
$MVIFUNC DS    A                       Function code
*
$MVIFPFO EQU   4                       Page or file open
$MVIFPFC EQU   8                       Page or file close
$MVIFPFR EQU   12                      Page or file reset
$MVIFOSO EQU   16                      OS file open
$MVIFOSC EQU   20                      OS file close
$MVIFOSR EQU   24                      OS file read
$MVIFOSW EQU   28                      OS file write
         END   ,
*
*  Message for Page, Swap, and File Opens
*
$MVIPSFO RECORD BEGIN
         DS    XL(L'$MVIOCOM)
$MPFALLO DS    A                       Page/file allocate parms
$MPFINFO DS    A                       Page/file info block
         END
         EJECT
*******************************************************************
*                                                                 *
*    MVIOPARM - Parameters passed to I/O drivers                  *
*                                                                 *
*******************************************************************
         SPACE
@MVIO    RECORD BEGIN
@MVIMSG  DS    A                       MESSAGE BUFFER POINTER
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    FUNCTION TABLE                                               *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
FUNCTAB  DC    A(0)
         DC    A(PFOPEN)
         DC    A(PFCLOSE)
*         DC    A(PFRESET)
*         DC    A(OSFOPEN)
*         DC    A(OSFCLOSE)
*         DC    A(OSFREAD)
*         DC    A(OSFWRITE)
FUNCMAX  EQU   *-FUNCTAB-4             MAXIMUM
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   MVSIOTSK - MVS I/O services                                   *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
MVSIOTSK PROC  SBTPARM,SCOPE=LOCAL
         MEMGET L'MVIWORK,TYPE=LOCAL   GET WORK AREA
         IF    ('LTR RY,RVR',Z),'KAPUT MVIWORK'
         WITH  (MVIWORK,RY)
         L     RA,SBTDATA              IOCT pointer
         ST    RA,MVIIOCT              Save it
         WITH  (IOCT,RA),BEGIN
         WITH  (RTCB,RTCBR)
         MVC   IOCTMTCB,RTCBTCB        Save TCB pointer
         END
         MSGATT MVSIOTSK,TYPE=SERV     Open channel
         ST    RVR,MVIMCHN             MESSAGE CHANNEL ID
         L     RS,@MSGCECB             MESSAGE ECB
         ST    RS,MVIMECB              SET POINTER
         EJECT
*
*  MVS I/O TASK LOOP
*
         LOOP  BEGIN
         FWAIT MVIMECB                 FAST WAIT (BRANCH ENTRY)
         L     RS,MVIMECB              ECB POINTER
         CLEAR (@RS,4)                 CLEAR IT
         MSGRECV MVIMCHN               RECEIVE A MESSAGE
         IF    ('LTR  RJ,RVR',Z),NEXT   NO MORE TO GET
         PSET  @MVIO
         ST    RJ,@MVIMSG              PASS MESSAGE BUFFER POINTER
         WITH  ($MVIOCOM,RJ)
         L     RS,$MVIFUNC             FUNCTION CODE
         IF    (RS,Z),'KAPUT MVIOFNZ'
         IF    (RS,GT,FUNCMAX),'KAPUT MVIOFNHI'
         ACALL FUNCTAB(RS)             FUNCTION ROUTINE
*
*  NOTIFY GUEST MACHINE OF COMPLETION
*
         PSET  @GSTIIOT
         ST    RVR,@GSTICS             Completion status
         MVC   @GSTIRQI,$MVIRQID       Request ID
         VCALL GSTIIOT                 NOTIFY THE USER
         EJECT
*
*  FREE THE MESSAGE BUFFER
*
         MSGFREE MVIMCHN,(RJ)          FREE MESSAGE BUFFER
         END
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    PFODCB - ORVYL Page and File System DCB                      *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
*GEN
PFDCB    DCB   MACRF=(E)
*NOGEN
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   PFOPEN  - Open ORVYL Page and File System data sets           *
*                                                                 *
*                                                                 *
*     Input - @PFALLO                                             *
*                                                                 *
*    Output - #PFINFO                                             *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PFOPEN   PROC  @MVIO,SCOPE=LOCAL
         L     RY,@MVIMSG              USER PARAMETERS
         WITH  ($MVIOCOM,RY)
         L     RK,$MVIDSID             DDB POINTER
         WITH  (DDB,RK)
         WITH  (COMDB,DDB),'CLC  COMDBID,=CL4"DDB"'
         IF    NE,'KAPUT DDBPTR'
*
*  FIRST DO ALLOCATE
*
         WITH  ($MVIPSFO,RY)
         L     RX,$MPFALLO             ALLOCATION PARMS
         WITH  (@DSALLO,RX)
         PSET  @DSDALLO
         ST    RX,@DSDPARM
         ACALL DSALLO                  GO TO ALLOCATE
         EJECT
*
*  ALLOCATION SUCCESSFUL - NOW FILL IN DDB
*
         IF    ('LTR RA,RVR',Z),BEGIN
         MVC   DDBDDNAM,@DSDDN         COPY DDNAME TO DDB
         MVC   DDBDSN,@DSDSN           FILL IN DSNAME ALSO
*
*  GET UCB ADDRESS
*
         PSET  @TSPARM
         MVC   @TSDDN,DDBDDNAM         SUPPLY DD NAME
         ACALL TIOTSRCH                GO GET IT
         IF    (RVR,Z),'KAPUT TIOTNTRY'
         ST    RVR,DDBUCB              SET UCB POINTER
         LR    RS,RVR
         WITH  (UCBCMSEG,RS)
         MVC   DDBVOL,UCBVOLI          SET VOLUME NAME
         IF    UCBTBYT3.UCB3DACC,BEGIN    DIRECT ACCESS
*
*  HAVE A DISK DEVICE - GET DEVICE CHARACTERISTICS
*
         L     RS,UCBTYP               GET UCB TYPE
         DROP  RS
         N     RS,=A(DVCTYPMK)         CONVERT TO OFFSET
         L     R15,CVTPTR              CVT
         WITH  (CVT,R15),'L  R15,CVTZDTAB'   DEVICE CHAR. TABLE
         WITH  (DVCTI,R15),'IC  RS,DVCTIOFF(RS)'  GET INDEX
         AR    R15,RS                  ADDRESS OF APPROPRIATE ENTRY
         WITH  (DVCT,R15),'LH  RS,DVCTRK'    TRACKS PER CYLINDER
         ST    RS,DDBTRC               TO DDB
*
*  NOW GET DSCB INFO
*
         MEMGET DS1END-IECSDSL1        GET DSCB BUFFER
         LR    RB,RVR
         PSET  @RDDSCB
         LA    RS,DDBDSN               DSNAME
         ST    RS,@RDDDSN               SET POINTER
         LA    RS,DDBVOL               VOLID
         ST    RS,@RDDVOL               SET POINTER
         ST    RB,@RDDDATA             POINTER TO DATA AREA
         ACALL READDSCB                GO READ THE DSCB
         WITH  (DS1FMTID,RB)
*
*  GET DCB INFORMATION
*
         MVC   DDBDSORG,DS1DSORG       COPY DSORG
         MVC   DDBRECFM,DS1RECFM       RECFM
         MVC   DDBLRECL,DS1LRECL       LRECL
         MVC   DDBBLKSZ,DS1BLKL        BLOCKSIZE
         MVC   DDBKEYL,DS1KEYL         AND KEY LENGTH
*
*  GET ALLOCATION INFORMATION
*
         MVC   DDBALCU,DS1SCAL1        ALLOCATION UNITS
         MVC   DDBALQU+1(3),DS1SCAL3    AND QUANTITY
         DROP  RB
         MEMFREE  DS1END-IECSDSL1,A=(RB)  FREE DSCB BUFFER
         END   ,
*
*  CREATE DCB
*
         MEMGET DCBLNGXE,TYPE=BELOW16M
         LR    RJ,RVR
         ST    RJ,DDBDCB               SAVE DCB POINTER
         WITH  (IHADCB,RJ)
         MVC   IHADCB(DCBLNGXE),PFDCB   COPY DCB
         MVC   DCBDDNAM,DDBDDNAM       SET DD NAME
*
*  SET UP PARAMETER LIST AND DO IT
*
         MEMGET 4,TYPE=BELOW16M        SET UP
         LR    RB,RVR                   OPEN
         ST    RJ,@RB                    PARAMETER
         OI    @RB,X'80'                  LIST
         ESTAEON OPENERR               CATCH ABENDS
         OPEN  MF=(E,(RB))             DO IT
         ESTAEOFF ,                    CLEAR ABEND INTERCEPT
         IF    DCBOFLGS.DCBOFOPN,'CLEAR  RA'   OPEN WAS SUCCESSFUL
         ELSE  'L  RA,=F"-4"'          OPEN FAILED
*
*  ESTAE RETRY ROUTINE
*
         BEGIN
         EXIT
OPENERR  LABEL ,
         LR    RA,RVR                  ESTAE INFO POINTER
         END   ,
         EJECT
*
*  FREE THE OPEN PARAMETER LIST
*
         MEMFREE 4,A=(RB),TYPE=BELOW16M   FREE PARAMETER LIST
*
*  IF OPEN FAILED RELEASE THE DCB
*
         IF    (RA,NZ),BEGIN
         CLEAR DDBDCB                  REMOVE DCB POINTER
         MEMFREE DCBLNGXE,A=(RJ),TYPE=BELOW16M
         END   ,
*
*  OTHERWISE, COMPLETE DDB AND RETURN INFO
*
         ELSE  BEGIN
         L     RX,$MPFINFO             POINTER TO INFO BLOCK
         WITH  (#PFINFO,RX)
         EJECT
*
*  COMPUTE NUMBER OF TRACKS
*
         L3    R15,DCBDEBA             DEB ADDRESS
         ST    R15,DDBDEB              TO DDB
         WITH  (DEBBASIC,R15),BEGIN
         LC    RVR,DEBNMEXT            NUMBER OF EXTENTS
         STC   RVR,DDBXTNT              TO DDB
         LA    R15,DEBBASND            DEVICE DEPENDENT SECTION
         END   ,
         WITH  (DEBDASD,R15),BEGIN
         CLEAR RS                      TRACK COUNTER
CNTTRK   L2    R14,DEBNMTRK            NO. TRACKS IN THIS EXTENT
         AR    RS,R14
         IF    (DEBUCBA,NE,DDBUCB+1),'KAPUT DEBEXTS'   ONE VOLUME
         LA    R15,DEBDASDE            NEXT EXTENT AREA
         BCT   RVR,CNTTRK               NEXT EXTENT
         STH   RS,DDBTRKS              SAVE NUMBER OF TRACKS
         END   ,
*
*  GET DEVICE FEATURE BYTE
*
         L     RS,DDBUCB               UCB ADDRESS
         WITH  (UCBCMSEG,RS),'L  RS,UCBEXTPT'   POINTER TO UCB EXT.
         WITH  (UCBCMEXT,RS),'L  RS,UCBCLEXT'   POINTER TO CLASS EXT.
         WITH  (DCE,RS),'MVC  DDBFEAT,DCEFEAT1'   FEATURE BYTE TO DDB
         EJECT
*
*   DO SPECIAL SET-UP IF DEVICE IS A CACHING CONTROLLER
*
         IF    DDBFEAT.DCEPAGES,BEGIN
         L     RS,DDBUCB               UCB ADDRESS
         WITH  (UCBOB,RS),'L  RS,UCBNEXP'   FIRST EXPOSURE
         LR    RA,RS
         CLEAR R14                     INDEX
         LOOP  BEGIN
         WITH  (UCB,RA)
         LA    R15,UCBOB               PAST PREFIX
         ST    R15,DDBCUCBS(R14)       SAVE HIGH SPEED UCB
         LA    R14,@R14+4
         IF    (R14,GT,8),EXIT         ONLY TAKING 3
         L     RA,UCBNEXP              NEXT DEVICE ADDRESS
         UNTIL (RA,EQ,RS),END
         END
*
*  GET BLOCKS PER TRACK
*
         PSET  @CTRACK
         MVC   @CTRUCB,DDBUCB          UCB ADDRESS
         MVC   @CTRBSZ,DDBBLKSZ        BLOCK SIZE
         MVC   @CTRKEY,DDBKEYL         KEY LENGTH
         ACALL CALCTRK
         ST    RVR,DDBBT               TO DDB
         ST    RVR,#PFIBTK              AND INFO AREA
*
*  GET TOTAL NUMBER OF BLOCKS
*
         LH    R15,DDBTRKS             NUMBER OF TRACKS
         MR    R14,RVR                 NUMBER OF BLOCKS
*** SIMULATION CODE ***
*
*  IF WE ARE SIMULATING IN HIPERSPACE, WE DON'T CARE ABOUT ACTUAL
*  PAGE/SWAP DATA SET SIZES.  WE WILL USE THE SIZE VALUE OBTAINED
*  FROM MAXSIZE.
*
         IF    ('LT RA,DDBHDB',NZ),BEGIN IF HIPERSPACE SIMULATION
         WITH  (RTCB,RTCBR),'L  RA,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RA),'L  RA,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RA)
         L     R15,IOCTHSIZ
         END   ,                    OF IF HIPERSPACE SIMULATION
         IF    (R15,Z),'KAPUT BADBLKCT'
*** END OF SIMULATION CODE ***
         ST    R15,DDBBLKCT            TO DDB
         ST    R15,#PFIBKS              AND INFO AREA
         EJECT
*
*  BUILD RPS TABLE
*
         L     RS,DDBUCB               UCB POINTER
         WITH  (UCBCMSEG,RS)
         IF    UCBTBYT2.UCBRPS,BEGIN
         L     RA,DDBBT                GET BLOCKS PER TRACK
         MEMGET (RA),TYPE=GLOBAL       GET MEMORY
         ST    RVR,DDBRPS              TABLE POINTER
         LR    RB,RVR
         CLEAR RA
         WHILE (RA,LT,DDBBT),BEGIN
         PSET  @CRPS
         MVC   @CRPUCB,DDBUCB          UCB  ADDRESS
         MVC   @CRPBSZ,DDBBLKSZ        BLOCK SIZE
         MVC   @CRPKEY,DDBKEYL         KEY LENGTH
         LA    RS,@RA+1                BLOCK NUMBER
         STH   RS,@CRPBLK
         ACALL CALCRPS
         STC   RVR,@RB(RA)             ADD TO TABLE
         INCR  RA
         END
         END
         EJECT
*
*  COPY DDB FIELDS TO INFO AREA
*
         MVC   #PFIDSO,DDBDSORG        COPY DSORG
         MVC   #PFIRFM,DDBRECFM         RECFM
         MVC   #PFILRC+2(2),DDBLRECL    LRECL
         MVC   #PFIBLK+2(2),DDBBLKSZ    BLKSIZE
         MVC   #PFIKEY,DDBKEYL          AND KEY LENGTH
         MVC   #PFITCY,DDBTRC          TRACKS / CYLINDER
         IF    DDBALCU.DS1CYL,'SET  #PFOCYL'   NOTE CYLINDER ALLOC
         IF    DDBALCU.DS1AVRND,'SET  #PFOCYL'   AVG BLK, ROUND SAME
         IF    (DDBXTNT,EQ,1),'SET  #PFOCNTG'   NOTE SINGLE EXTENT
         CLEAR RA
         END   ,
         END   ,
*
*  IF ALLOCATION OR OPEN FAILED FREE THE DDB
*
         IF    (RA,NZ),BEGIN
         PSET  @DSCLOSE
         ST    RK,@DSCDDB              DDB POINTER
         ACALL DSCLOSE
         END   ,
         LR    RVR,RA                  SET RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   PFCLOSE - Close ORVYL Page and File System data sets          *
*                                                                 *
*                                                                 *
*     Input -                                                     *
*                                                                 *
*    Output -                                                     *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
PFCLOSE  PROC  @MVIO,SCOPE=LOCAL
         PSET  @DSCLOSE
         L     RY,@MVIMSG
         WITH  ($MVIOCOM,RY)
         MVC   @DSCDDB,$MVIDSID        PASS DDB
         ACALL DSCLOSE                 DO CLOSE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    @DSCLOSE - Close data set request parameters                 *
*                                                                 *
*******************************************************************
         SPACE
@DSCLOSE RECORD BEGIN
@DSCDDB  DS    A                       DDB pointer
         END   ,
         SPACE 3
         COPY  DSALPARM
         EJECT
*******************************************************************
*                                                                 *
*    DSALWORK - Data set dynamic allocation skeletons             *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
DSTULIST DC    20A(0)                  TEXT UNIT POINTER LIST
*
DSTUDDN  DC    AL2(DALDDNAM,1,8)       DDNAME - KEY, NUMBER, LENGTH
         DC    CL8' '                  DDNAME - STRING
*
DSTUFREE DC    AL2(DALCLOSE,0)         FREE=CLOSE - KEY AND NUMBER
*
DSTUDSN  DC    AL2(DALDSNAM,1,44)      DSNAME - KEY, NUMBER, LENGTH
         DC    CL44' '                 DSNAME - STRING
*
DSTUMEM  DC    AL2(DALMEMBR,1,8)       MEMBER - KEY, NUMBER, LENGTH
         DC    CL8' '                  MEMBER - STRING
*
DSTUSTAT DC    AL2(DALSTATS,1,1)       STATUS - KEY, NUMBER, LENGTH
         DC    X'01'                   STATUS - STRING (OLD)
*
DSTUVOL  DC    AL2(DALVLSER,1,6)       VOLUME - KEY, NUMBER, LENGTH
         DC    CL6' '                  VOLUME - STRING
*
DSTUUNIT DC    AL2(DALUNIT,1,8)        UNIT - KEY, NUMBER, LENGTH
         DC    CL8'SYSALLDA'           UNIT - STRING
*
DSTUDISP DC    AL2(DALNDISP,1,1)       DISPOSITION - KEY, NUMBER, LEN
         DC    X'02'                   DISPOSITION - VALUE (CATALOG)
*
DSTUATRK DC    AL2(DALTRK,0)           TRACK ALLOC - KEY AND NUMBER
*
DSTUACYL DC    AL2(DALCYL,0)           CYLINDER ALC - KEY AND NUMBER
*
DSTUABLN DC    AL2(DALBLKLN,1,3)       AVG BLK - KEY, NUMBER, LENGTH
         DC    AL3(0)                  AVG BLK - VALUE
*
DSTURLSE DC    AL2(DALRLSE,0)          RELEASE - KEY AND NUMBER
*
DSTURND  DC    AL2(DALROUND,0)         ROUND - KEY AND NUMBER
*
DSTUCNTG DC    AL2(DALSPFRM,1,1)       CONTIG - KEY, NUMBER, LENGTH
         DC    X'08'                   CONTIG - VALUE
*
DSTUAPRM DC    AL2(DALPRIME,1,3)       PRIMARY - KEY, NUMBER, LENGTH
         DC    AL3(0)                  PRIMARY - VALUE
*
DSTUASEC DC    AL2(DALSECND,1,3)       SECONDARY - KEY, NUMBER, LEN
         DC    AL3(0)                  SECONDARY - VALUE
*
DSTUADBL DC    AL2(DALDIR,1,3)         DIR BLKS - KEY, NUMBER, LENGTH
         DC    AL3(0)                  DIR BLKS - VALUE
*
DSTUDCBD DC    AL2(DALDCBDS,1,15)      DCB DSN - KEY, NUMBER, LENGTH
         DC    CL15'SYS3.PROTO.DSCB'   DCB DSN - STRING
*
DSALWORK EQU   DSTULIST,*-DSTULIST
         END
         EJECT
*******************************************************************
*                                                                 *
*   DSALLO - System data set Allocation                           *
*                                                                 *
*                                                                 *
*     Input - @DSALLO                                             *
*                                                                 *
*    Output - RVR contains return code from SVC 99                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DSALLO   PROC  @DSDALLO,SCOPE=GLOBAL
         L     RY,@DSDPARM             USER PARAMETERS
         WITH  (@DSALLO,RY)
*
*  VOLUME NOT SPECIFIED FOR EXISTING DATA SET - GET IT FROM CATALOG
*
         IF    (^@DSNEW,AND,(@DSVOL,EQ,=XL6'00')),BEGIN
         PSET  @CATSRCH
         LA    R15,@DSDSN              USER SUPPLIED DSNAME
         ST    R15,@CATSDSN
         ACALL CATSRCH                 GO FIND IT
*
*  CATALOG SEARCH FAILED - RETURN ERROR INDICATION
*
         IF    (RVR,NZ),BEGIN
         MVC   @DSRTN,=Y(4)            SET RETURN CODE
         MVI   @DSERR,X'17'             AND REASON CODE
         STC   RVR,@DSERR+1
         MVC   @DSVOL,=CL6'??????'     WHO'S TO SAY WHERE IT IS
         EXIT  DSALLO                  THEN BACK TO CALLER
         END
         MVC   @DSVOL,@CATSVOL         SET VOLUME ID
         END
*
*  NOW SET UP WORK AREA
*
         MEMGET L'DSALWORK             WORK AREA
         LR    RX,RVR                   POINTER
         LA    R14,DSALWORK            DYN ALLO PARAMETER SKELETONS
         LA    R15,L'DSALWORK           LENGTH
         LR    RA,RX                   Destination
         LR    RB,R15                  Copy length
         MVCL  RA,R14                  Skeletons out of the closet
         WITH  (DSALWORK,RX)
         LA    RK,DSTULIST             LIST POINTER
*
*  BUILD COMMON TEXT UNITS - START WITH FREE=CLOSE
*
         LA    RS,DSTUFREE             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
*
*  BUILD DDNAME/RETURN DDNAME UNIT
*
         LA    RS,DSTUDDN              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),BEGIN
         IF    (@DSDDN,EQ,=XL8'00'),'MVC  S99TUKEY,=AL2(DALRTDDN)'
         ELSE  'MVC  S99TUPAR(8),@DSDDN'   PUT IN DDNAME
         END   ,
*
*  BUILD DSNAME UNIT
*
         LA    RS,DSTUDSN              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR(44),@DSDSN'   PUT IN DSN
*
*  BUILD MEMBER UNIT
*
         IF    (@DSMEM,NE,=XL8'00'),BEGIN
         LA    R15,8                   Maximum length
         LA    R14,@DSMEM+7
         LOOP  BEGIN                   Determine name length
         IF    ('CLI  @R14,C" "',NE),EXIT
         DECR  R15
         UNTIL (BCT,R14),END
         IF    (R15,Z),EXIT            No member name after all
         LA    RS,DSTUMEM              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS)
         STH   R15,S99TULNG            Length of the member name
         DROP  RX
         DEX   R15,'MVC  S99TUPAR(0),@DSMEM'   PUT IN MEMBER NAME
         END   ,
         WITH  (DSALWORK,RX)
*
*  BUILD VOLUME UNIT
*
         IF    (@DSVOL,NE,=XL6'00'),BEGIN
         LA    RS,DSTUVOL              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR(6),@DSVOL'   PUT IN VOL
*
*  BUILD UNIT UNIT FOR "SYSALLDA"
*
         LA    RS,DSTUUNIT             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END
*
*  BUILD DATA SET STATUS UNIT
*
         LA    RS,DSTUSTAT             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),BEGIN
         IF    @DSSHR,'MVI  S99TUPAR,X"08"'   SET SHARED
         IF    @DSNEW,'MVI  S99TUPAR,X"04"'   SET NEW
         END   ,
*
*  SET UP TEXT UNITS FOR NEW DATA SET - START WITH DISPOSITION
*
         IF    @DSNEW,BEGIN
         LA    RS,DSTUDISP             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),BEGIN
         IF    @DSNOCAT,'MVI  S99TUPAR,X"08"'   SET KEEP
         END   ,
*
*  VOLUME NOT SPECIFIED - BUILD UNIT UNIT FOR "DISK"
*
         IF    (@DSVOL,EQ,=XL6'00'),BEGIN
         LA    RS,DSTUUNIT             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR(8),=CL8"DISK"'
         END
*
*  BUILD SPACE TYPE UNIT - TRY CYLINDER FIRST
*
         IF    @DSACYL,BEGIN           HAVE CYLINDER SPECIFICATION
         LA    RS,DSTUACYL             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
*
*  NOT CYLINDER - TRY AVERAGE BLOCK LENGTH
*
         ELSEIF  @DSABLK,BEGIN         HAVE AVG BLK SPECIFICATION
         LA    RS,DSTUABLN             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR+1(2),@DSABL+2'   SET QTY
*
*  AVERAGE BLOCK - BUILD ROUND UNIT IF NECESSARY
*
         IF    @DSARND,BEGIN           RELEASE REQUESTED
         LA    RS,DSTURND              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
         END   ,
*
*  BUILD TRACK ALLOCATION UNIT - WHICH IS THE DEFAULT
*
         ELSE  BEGIN                   DEFAULT IS TRACK SPECIFICATION
         LA    RS,DSTUATRK             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
*
*  BUILD PRIMARY SPACE ALLOCATION UNIT
*
         LA    RS,DSTUAPRM              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR(3),@DSPTQ+1'   PUT IN QTY
*
*  BUILD SECONDARY SPACE ALLOCATION UNIT
*
         LA    RS,DSTUASEC              POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR(3),@DSSTQ+1'   PUT IN QTY
*
*  BUILD DIRECTORY BLOCK ALLOCATION UNIT
*
         LA    RS,DSTUADBL             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         WITH  (S99TUNIT,RS),'MVC  S99TUPAR(3),@DSDBQ+1'   PUT IN QTY
*
*  BUILD RELEASE UNIT
*
         IF    @DSARLSE,BEGIN          RELEASE REQUESTED
         LA    RS,DSTURLSE             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
*
*  BUILD CONTIGUOUS UNIT
*
         IF    @DSACNTG,BEGIN          RELEASE REQUESTED
         LA    RS,DSTUCNTG             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
*
*  BUILD DCB UNIT FOR GDG'S
*
         IF    @DSGDG,BEGIN            GDG ALLOCATION
         LA    RS,DSTUDCBD             POINTER TO TEXT UNIT
         ST    RS,@RK                  ADD TO LIST
         LA    RK,@RK+4                UPDATE LIST POINTER
         END   ,
         END
*
*  MARK END OF LIST AND DO DYNAMIC ALLOCATE
*
         SET   @RK.S99TUPLN            NOTE LIST END
         PSET  @DYNALLO
         LA    RS,DSTULIST             LIST POINTER
         ST    RS,@DYNTXTU             SET LIST ADDRESS
         ACALL DYNALLO
         STH   RVR,@DSRTN              SAVE RETURN CODE
*
*  IF ERROR IN DYNAMIC ALLOCATE SET ERROR CODES
*
         IF    ('LTR  RK,RVR',NZ),BEGIN
         MVC   @DSERR,@DYNERR          COPY ERROR CODE
         MVC   @DSRSN,@DYNRSN           AND REASON CODE
         END   ,
*
*  ALLOCATE SUCCESSFUL - RETURN DDNAME
*
         ELSE  BEGIN
         IF    (@DSDDN,NE,=XL8'00'),EXIT
         LA    RS,DSTUDDN              POINTER TO DDNAME TEXT UNIT
         WITH  (S99TUNIT,RS)
         MVC   @DSDDN,S99TUPAR         COPY DDNAME
         END   ,
         DROP  RX
*
*  RELEASE WORK AREA AND RETURN
*
DSADONE  MEMFREE L'DSALWORK,A=(RX)     RELEASE WORK AREA
         LR    RVR,RK                  RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   DSCLOSE - Close data sets                                     *
*                                                                 *
*                                                                 *
*     Input - @DSCLOSE                                            *
*                                                                 *
*    Output - None                                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DSCLOSE  PROC  @DSCLOSE,SCOPE=LOCAL
         L     RK,@DSCDDB              DDB POINTER
         WITH  (DDB,RK)
         WITH  (COMDB,DDB),BEGIN
         CLC   COMDBID,=CL4'DDB'       VALIDATE
         IF    NE,'KAPUT DDBPTR'
         CLEAR (COMDBID,4)             DDB no longer valid
         END   ,
         L     RJ,DDBDCB               GET DCB POINTER
         EJECT
*
*  SET UP PARAMETER LIST AND CLOSE IT
*
         IF    (RJ,NZ),BEGIN
         MEMGET 4,TYPE=BELOW16M        SET UP
         LR    RB,RVR                   CLOSE
         ST    RJ,@RB                    PARAMETER
         OI    @RB,X'80'                  LIST
         ESTAEON CLOSERR               CATCH ABENDS
         CLOSE MF=(E,(RB))             DO IT
         ESTAEOFF ,                    CLEAR ABEND INTERCEPT
*
*  ESTAE RETRY ROUTINE
*
         BEGIN
         EXIT
CLOSERR  LABEL ,
         LR    RA,RVR                  ESTAE INFO POINTER
         END   ,
         MEMFREE 4,A=(RB),TYPE=BELOW16M   FREE PARAMETER LIST
*
*  RELEASE DCB
*
         MEMFREE DCBLNGXE,A=(RJ),TYPE=BELOW16M
         END   ,
         EJECT
*
*  DATA SET NOT OPENED - DEALLOCATE IT
*
         ELSE  BEGIN
         IF    (DDBDDNAM,Z),EXIT       ALLOCATION INCOMPLETE
         PSET  @DUNALLO
         MVC   @DUNDDN,DDBDDNAM        SET DDNAME
         ACALL DUNALLO
         LR    RA,RVR
         END   ,
*
*  UNCHAIN DDB
*
         WITH  (RTCB,RTCBR),'L  RX,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RX),'L  RX,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RX)
         LOCKOB IOCTDDBL               GET DDB CHAIN LOCK
         LA    RS,IOCTDDBS             DDB CHAIN
         SH    RS,=Y(DDBCHAIN-DDB)     OFFSET
         LOOP  BEGIN
         WITH  (DDB,RS)
         IF    (RK,EQ,DDBCHAIN),EXIT   FOUND
         L     RS,DDBCHAIN
         END   ,
         L     R14,DDBCHAIN            NEXT IN CHAIN
         WITH  (DDB,RS),'ST  R14,DDBCHAIN'    UPDATE FREE CHAIN
         LOCKRL IOCTDDBL               RELEASE DDB CHAIN LOCK
         DROP  RX
         EJECT
*
*  RELEASE DDB THEN RETURN
*
         CLEAR DDB                     CLEAR THE DDB
         MEMFREE L'DDB,A=(RK),TYPE=GLOBAL
         LR    RVR,RA                  SET RETURN CODE
         PEND
         EJECT
         LTORG
         EJECT ,
*******************************************************************
*                                                                 *
*    CTRKPARM - CALCTRK parameter list                            *
*                                                                 *
*******************************************************************
         SPACE
CTRKPARM RECORD BEGIN
TRKLIST  TRKCALC MF=D
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @CTRKWRK - CALCTRK and CALCRPS work area                     *
*                                                                 *
*******************************************************************
         SPACE
@CTRWORK RECORD BEGIN
@CTRREGS DS    3A                      Register save
@CTRSECT DS    X                       Sector
         END   ,
         EJECT
*******************************************************************
*                                                                 *
*   CALCTRK - Calculate blocks per track                          *
*                                                                 *
*                                                                 *
*     Input - @CTRACK                                             *
*                                                                 *
*    Output - RVR contains blocks per track                       *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
CALCTRK  PROC  @CTRACK,@CTRWORK,SCOPE=LOCAL
*
*  FIRST CREATE TALKCALC PARAMETER LIST
*
         MEMGET L'CTRKPARM,TYPE=BELOW16M
         LR    RX,RVR
         WITH  (CTRKPARM,RX)
         MVC   STARDL,@CTRBSZ          SET DATA LENGTH
         MVC   STARKL,@CTRKEY          SET KEY LENGTH
         MVI   STARR,1                 SET RECORD NUMBER
         MVC   STARUCBA,@CTRUCB        SET UCB
         SET   STARFLGS.STARFUNC+X'04'   FLAGS
         EJECT
*
*  PARAMETERS SET NOW CALL THE ROUTINE
*
         STM   R9,R11,@CTRREGS         SAVE REGS TRKCALC TRASHES
         TRKCALC  MF=(E,TRKLIST)
         LM    R9,R11,@CTRREGS
         LR    RA,RVR                  SAVE ANSWER
         MEMFREE L'CTRKPARM,A=(RX),TYPE=BELOW16M    FREE
         LR    RVR,RA
         PEND                          RETURN
         EJECT ,
*******************************************************************
*                                                                 *
*   CALCRPS - Calculate RPS values                                *
*                                                                 *
*                                                                 *
*     Input - @CRPS                                               *
*                                                                 *
*    Output - RVR contains sector number                          *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
CALCRPS  PROC  @CRPS,@CTRWORK,SCOPE=LOCAL
         LH    RB,@CRPBLK              BLOCK NUMBER
         IF    (RB,NZ),BEGIN           NOTHING TO DO FOR RECORD 0
*
*  SET PARAMETERS
*
         L     RS,@CRPUCB              UCB POINTER
         WITH  (UCBCMSEG,RS),'IC  RS,UCBTYP+3'  DEVICE TYPE
         LR    R0,RB                   SET RECORD NUMBER
         ICM   R0,B'1100',@CRPBSZ      SET DATA LENGTH
         ICM   R0,B'0010',@CRPKEY      SET KEY LENGTH
         LA    R2,@CTRSECT             AREA TO PUT SECTOR
         EJECT
*
*  SAVE REGISTERS AND CALL THE ROUTINE
*
         STM   R9,R11,@CTRREGS         SAVE REGS SECTOR CALC TRASHES
         LA    R11,X'FF'
         NR    R11,RS                  SET DEVICE TYPE
         L     R15,CVTPTR              CVT POINTER
         WITH  (CVT,R15),'L  R15,CVT0SCR1'   SECTOR CONVERT ROUTINE
         BAS   R14,@R15+16             CALL 31 BIT VERSION
         LM    R9,R11,@CTRREGS
         IC    RB,@CTRSECT             GET ANSWER
         END   ,
         LR    RVR,RB
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    @TSPARM - Find TIOT entry parameters                         *
*                                                                 *
*******************************************************************
         SPACE
@TSPARM  RECORD BEGIN
@TSDDN   DS    CL8                     DD name
         END
         EJECT ,
*******************************************************************
*                                                                 *
*   TIOTSRCH - Search TIOT for DDNAME                             *
*                                                                 *
*                                                                 *
*     Input - @TSPARM                                             *
*                                                                 *
*    Output - RVR contains UCB address                            *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
TIOTSRCH PROC  @TSPARM,SCOPE=LOCAL
         USING PSA,R0
         L     RB,PSATOLD              TCB
         DROP  R0
         WITH  (TCB,RB),'L  RB,TCBTIO'   TIOT POINTER
         WITH  (TIOT,RB),'LA  RB,TIOENTRY'    FIRST DD ENTRY
         WITH  (TIOENTRY,RB)
         CLEAR RVR
TSLOOP   LOOP  BEGIN
         IF    (TIOEDDNM,EQ,@TSDDN),'L3  RVR,TIOEFSRT; EXIT TSLOOP'
         IC    RVR,TIOELNGH             ENTRY LENGTH
         ALR   RB,RVR                   TO NEXT
         UNTIL (RVR,Z),END             END OF TIOT
         PEND
         EJECT
*******************************************************************
*                                                                 *
*   @CATSRCH - Catalog search routine parameters                  *
*                                                                 *
*******************************************************************
         SPACE
@CATSRCH RECORD BEGIN
@CATSDSN DS    A
@CATSVOL DS    CL6
         END
         SPACE 3
*******************************************************************
*                                                                 *
*    MODELCTL - MVS Catalog Locate parameter list model           *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
*GEN
CATLOC   CAMLST NAME,0,,0              CATALOG LOCATE OF DATA SET
*NOGEN
MODELCTL EQU   CATLOC,*-CATLOC,C'X'
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*   CTLPARM   - MVS Catalog locate work area                      *
*                                                                 *
*******************************************************************
         SPACE
CTLPARM  RECORD BEGIN
CTLCAML  DS    XL(L'MODELCTL)          PARAMETER AREA
CTLDSNP  EQU   CTLCAML+4,4,C'X'        PARAMETER 2
CTLRESR  EQU   CTLCAML+8,4,C'X'        PARAMETER 3 (Not used)
CTLANSP  EQU   CTLCAML+12,4,C'X'       PARAMETER 4
*
CTLDSN   DS    CL44                    Data set name
CTLAREA  DS    0D                      Answer area
CTLVOLCT DS    H                       Volume count
CTLDEVID DS    AL4                     Device type code
CTLVOLID DS    CL6                     Volume Id
CTLSEQ   DS    H                       Sequence number
         DS    XL(265-(*-CTLAREA))
         END
         EJECT ,
*******************************************************************
*                                                                 *
*   CATSRCH - Search MVS catalog for data set                     *
*                                                                 *
*                                                                 *
*     Input - @CATSRCH                                            *
*                                                                 *
*    Output - VOLID in caller's data area                         *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
CATSRCH  PROC  @CATSRCH,SCOPE=LOCAL
         MEMGET L'CTLPARM,TYPE=BELOW16M
         LR    RB,RVR
         WITH  (CTLPARM,RB)
         L     RS,@CATSDSN             Pointer to data set name
         MVC   CTLDSN,@RS              Move it to work area
*
*  INITIALIZE CAMLST
*
         MVC   CTLPARM(L'MODELCTL),MODELCTL
         LA    RS,CTLDSN               Dsname pointer
         ST    RS,CTLDSNP
         LA    RS,CTLAREA              Answer area pointer
         ST    RS,CTLANSP
         LOCATE CTLCAML                Do locate
         IF    ('LTR  RA,R15',Z),BEGIN   Catalog return code
         IF    (CTLVOLCT,NE,1),EXIT
         MVC   @CATSVOL,CTLVOLID       Return the volume
         END
         MEMFREE L'CTLPARM,A=(RB),TYPE=BELOW16M
         LR    RVR,RA                  Return code
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    @RDDSCB - Read DSCB routine parameters                       *
*                                                                 *
*******************************************************************
         SPACE
@RDDSCB  RECORD BEGIN
@RDDDSN  DS    A
@RDDVOL  DS    A
@RDDDATA DS    A
         END
         SPACE 3
*******************************************************************
*                                                                 *
*    MODELOBT - MVS OBTAIN parameter list model                   *
*                                                                 *
*******************************************************************
         SPACE
         DATA  BEGIN
*GEN
OBTAINL  CAMLST SEARCH,0,0,0           OBTAIN TYPE = SEARCH
*NOGEN
MODELOBT EQU   OBTAINL,*-OBTAINL,C'X'
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    OBTAIN   - MVS OBTAIN work area                              *
*                                                                 *
*******************************************************************
         SPACE
OBTPARM  RECORD BEGIN
OBTCAML  DS    XL(L'MODELOBT)          PARAMETER AREA
OBTDSNP  EQU   OBTCAML+4,4,C'X'        PARAMETER 2
OBTVOLP  EQU   OBTCAML+8,4,C'X'        PARAMETER 3
OBTAREA  EQU   OBTCAML+12,4,C'X'       PARAMETER 4
*
OBTDSN   DS    CL44
OBTVOL   DS    CL6
         DS    0D
OBTDATA  DS    XL(DS1END-IECSDSL1)     AREA LOCATE READS INTO
         END
         EJECT ,
*******************************************************************
*                                                                 *
*   READDSCB - Read DSCB from VTOC                                *
*                                                                 *
*                                                                 *
*     Input - @RDDSCB                                             *
*                                                                 *
*    Output - DSCB (data portion) in caller's data area           *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
READDSCB PROC  @RDDSCB,SCOPE=LOCAL
         MEMGET L'OBTPARM,TYPE=BELOW16M
         LR    RB,RVR
         WITH  (OBTPARM,RB)
*
*  INITIALIZE CAMLST
*
         MVC   OBTPARM(L'MODELOBT),MODELOBT
         LA    RS,OBTDSN               POINT TO
         ST    RS,OBTDSNP               DSNAME
         LA    RS,OBTVOL               POINT TO
         ST    RS,OBTVOLP               VOLSER
         LA    RS,OBTDATA              POINT TO
         ST    RS,OBTAREA               OBTAIN AREA
         EJECT
*
*  COPY DSNAME AND VOLID
*
         L     RS,@RDDDSN              SUPPLIED DSNAME
         MVC   OBTDSN,@RS               TO PARM AREA
         L     RS,@RDDVOL              SUPPLIED VOLID
         MVC   OBTVOL,@RS               TO PARM AREA
         OBTAIN OBTCAML                DO OBTAIN
         IF    (R15,NZ),'KAPUT OBTAIN'
         L     RA,@RDDDATA             CALLER'S DATA AREA
         MVC   @RA(L'OBTDATA),OBTDATA   RETURN DATA TO CALLER
         MEMFREE L'OBTPARM,A=(RB),TYPE=BELOW16M
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    ENQWORK - ENQ/DEQ work area                                  *
*                                                                 *
*******************************************************************
         SPACE
ENQWORK  RECORD BEGIN
         DS    4A                      PREFIX AREA
ENQ      ENQ   (,,E,,SYSTEM),RET=USE,MF=L
         END   ,
         SPACE 3
         COPY  MVSPARM
         EJECT
*******************************************************************
*                                                                 *
*   MVSENQ - MVS enqueue/dequeue service                          *
*                                                                 *
*                                                                 *
*     Input - @MVSENQ                                             *
*                                                                 *
*    Output - RVR contains condition code returned                *
*                 from MVS service                                *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
MVSENQ   PROC  @MVSENQ,ENQWORK,SCOPE=GLOBAL
         CLEAR ENQWORK
         OI    ENQ,X'C0'               SET LIST END
         L     RA,@MVNQRNM             RESOURCE NAME LOCATION
         L     RB,@MVNQRNL             RESOURCE NAME LENGTH
         LA    RJ,@MVNQQNM             QUEUE NAME
*
*  GET JOB STEP TCB
*
         USING PSA,R0
         L     R15,PSATOLD              TCB
         DROP  R0
         WITH  (TCB,R15),'L  R15,TCBJSTCB'   JOB STEP TCB POINTER
         IF    @MVNQENQ,BEGIN          ENQUEUE OPERATION
*GEN
         ENQ   ((RJ),(RA),E,(RB),SYSTEM),RET=USE,TCB=(R15),MF=(E,ENQ)
*NOGEN
         END   ELSE,BEGIN
*GEN
         DEQ   ((RJ),(RA),(RB),SYSTEM),RET=HAVE,TCB=(R15),MF=(E,ENQ)
*NOGEN
         END
         IF    ('LTR RVR,R15',NZ),'LC  RVR,@R15+3'   SET RETURN CODE
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    AM24 - AMODE 24 Cap routine request parameters               *
*                                                                 *
*******************************************************************
         SPACE
@AM24    RECORD BEGIN
@AM24SVA DS    18A                     Save area
@AM24RGS DS    5A                      Parameters for MVS service
@AM24CRS DS    16A                     Caller's registers
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    @AM24RTN - AMODE 24 routine request parameters               *
*                                                                 *
*******************************************************************
         SPACE
@AM24RTN RECORD BEGIN
@AM24R15 DS    A                       Parameter register 15
@AM24R0  DS    A                       Parameter register 0
@AM24R1  DS    A                       Parameter register 1
@AM24R2  DS    A                       Parameter register 2
@AM24OFF DS    A                       Offset for branch address
         END
         EJECT
*******************************************************************
*                                                                 *
*   AM24RTN - Interface to AMODE 24 service                       *
*                                                                 *
*                                                                 *
*                                                                 *
*     Input - @AM24RTN                                            *
*                                                                 *
*    Output - As defined by MVS service                           *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
AM24RTN  PROC  @AM24RTN,SCOPE=LOCAL
*
*  CREATE AMODE 24 ROUTINE PARAMETER LIST
*
         MEMGET L'@AM24,TYPE=BELOW16M
         LR    RK,RVR
         WITH  (@AM24,RK),BEGIN
         LM    R15,R2,@AM24R15
         STM   R15,R2,@AM24RGS         PASS PARAMETERS
         END   ,
         EJECT
*
*  NOW CALL THE ROUTINE
*
         LR    R1,RK                   SET CAP PARAMETERS
         WITH  (RTCB,RTCBR),'L  RY,RTCBCBAT'   CBAT POINTER
         WITH  (CBAT,RY),'L  RY,CBATIOCT'      IOCT POINTER
         WITH  (IOCT,RY),'L  EPAR,IOCTAM24'    GO TO AMODE 24
         BASSM RAR,EPAR
         STM   R15,R1,@AM24R15         SAVE ANSWERS
         MEMFREE L'@AM24,A=(RK),TYPE=BELOW16M    FREE
         L     RVR,@AM24R0
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    @DYNALLO - Dynamic allocation parameter list                 *
*                                                                 *
*******************************************************************
         SPACE
@DYNALLO RECORD BEGIN
@DYNTXTU DS    A                       Pointer to text unit pointers
*
@DYNERR  DS    H                       SVC error code
@DYNRSN  DS    H                       SVC reason code
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    DYNALLOC - Dynamic allocation work area                      *
*                                                                 *
*******************************************************************
         SPACE
DYNALLOC RECORD BEGIN
DARBPTR  DS    A                       SVC 99 REQUEST BLOCK ADDRESS
DAREQB   DS    ((S99RBEND-S99RB+3)/4)A    SVC 99 REQUEST BLOCK
         END
         EJECT
*******************************************************************
*                                                                 *
*   DYNALLO -  Dynamic Allocation Service Routine                 *
*                                                                 *
*                                                                 *
*     Input - @DYNALLO                                            *
*                                                                 *
*    Output - RVR contains return code                            *
*             @DYNALLO                                            *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DYNALLO  PROC  @DYNALLO,DYNALLOC,SCOPE=LOCAL
*
*  INITIALIZE DYNAMIC ALLOCATION REQUEST BLOCK
*
         LA    RX,DAREQB               REQUEST BLOCK
         ST    RX,DARBPTR              SET
         SET   DARBPTR.S99RBPND        SET END MARKER
         WITH  (S99RB,RX),BEGIN
         CLEAR (S99RB,S99RBEND-S99RB)   CLEAR AREA
         MVI   S99RBLN,S99RBEND-S99RB   SET LENGTH
         MVI   S99VERB,S99VRBAL        DSNAME ALLOCATION
         MVI   S99FLG11,S99NOCNV+S99NOMNT  NO SPECIAL MOUNTS
         MVC   S99TXTPP,@DYNTXTU       POINTER TO TEXT UNIT POINTERS
         END   ,
*
* DO ALLOCATION
*
         LA    R1,DARBPTR              SET POINTER
         DYNALLOC ,
         EJECT
*
*  SET RETURNS
*
         IF    ('LTR  RVR,R15',NZ),BEGIN    COPY & CHECK RETURN CODE
         WITH  (S99RB,RX)
         MVC   @DYNERR,S99ERROR         ERROR CODE
         MVC   @DYNRSN,S99INFO           AND REASON CODE
         END   ,
         PEND
         EJECT
*******************************************************************
*                                                                 *
*    @DUNALLO - Dynamic un-allocation parameter list              *
*                                                                 *
*******************************************************************
         SPACE
@DUNALLO RECORD BEGIN
@DUNDDN  DS    CL8                     DD name to be un-allocated
*
@DUNERR  DS    H                       SVC error code
@DUNRSN  DS    H                       SVC reason code
         END   ,
         SPACE 3
*******************************************************************
*                                                                 *
*    DUNALLOC - Dynamic un-allocation work area                   *
*                                                                 *
*******************************************************************
         SPACE
DUNALLOC RECORD BEGIN
DURBPTR  DS    A                       SVC 99 REQUEST BLOCK ADDRESS
DUREQB   DS    ((S99RBEND-S99RB+3)/4)A    SVC 99 REQUEST BLOCK
DUTXPTL  DS    2A                      TEXT POINTER LIST
DUTXTU   DS    (S99TUENT-S99TUNIT)X    UNALLOC TEXT UNIT
DUTXTUD  DS    (S99TUPAR-S99TUNIT)X    DDNAME TEXT UNIT
DUTXTPM  DS    CL8                      AND PARAMETER
         END
         EJECT
*******************************************************************
*                                                                 *
*   DUNALLO -  Dynamic Un-allocation Service Routine              *
*                                                                 *
*                                                                 *
*     Input - @DUNALLO                                            *
*                                                                 *
*    Output - RVR contains return code                            *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
DUNALLO  PROC  @DUNALLO,DUNALLOC,SCOPE=LOCAL
*
*  BUILD UN-ALLOCATION TEXT UNITS
*
         MVC   DUTXTU(4),=AL2(DUNUNALC,0)    UNALLOC TEXT UNIT
         LA    RS,DUTXTU               TEXT UNIT START
         ST    RS,DUTXPTL              SET UP TEXT UNIT LIST
         MVC   DUTXTUD(6),=AL2(DUNDDNAM,1,8)    DDNAME TEXT UNIT
         MVC   DUTXTPM(8),@DUNDDN      SET DDNAME
         LA    RS,DUTXTUD              TEXT UNIT END
         ST    RS,DUTXPTL+4            SET UP TEXT UNIT LIST
         SET   DUTXPTL+4.S99TUPLN       WITH TWO ENTRIES
         LA    RX,DUREQB               REQUEST BLOCK
         ST    RX,DURBPTR              SET
         SET   DURBPTR.S99RBPND        SET END MARKER
*
*  INITIALIZE DYNAMIC ALLOCATION REQUEST BLOCK
*
         WITH  (S99RB,RX),BEGIN
         CLEAR (S99RB,S99RBEND-S99RB)   CLEAR AREA
         MVI   S99RBLN,S99RBEND-S99RB   SET LENGTH
         MVI   S99VERB,S99VRBUN        UNALLOCATION
         MVI   S99FLG11,S99NOCNV+S99NOMNT  NO SPECIAL MOUNTS
         LA    RS,DUTXPTL              POINTER TO TEXT UNIT POINTERS
         ST    RS,S99TXTPP             SET
         END   ,
         EJECT
*
* DO DE-ALLOCATION
*
         LA    R1,DURBPTR              SET POINTER
         DYNALLOC ,
*
*  SET RETURNS
*
         IF    ('LTR  RVR,R15',NZ),BEGIN    COPY & CHECK RETURN CODE
         WITH  (S99RB,RX)
         MVC   @DUNERR,S99ERROR         ERROR CODE
         MVC   @DUNRSN,S99INFO           AND REASON CODE
         KAPUT DUNALLO
         END   ,
         PEND
         EJECT
         LTORG
         EJECT
*******************************************************************
*                                                                 *
*   AM24CAP - Cap routine for MVS I/O services which must be      *
*             entered in AMODE 24.                                *
*                                                                 *
*                                                                 *
*     Input - @AM24 in R1                                         *
*                                                                 *
*    Output - As defined by MVS service                           *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE 3
AM24CAP  LABEL ,
         USING @AM24,R1
         STM   R0,R15,@AM24CRS         Save caller's registers
         LR    R13,R1                  Establish save area pointer
         LM    R15,R3,@AM24RGS         MVS service parms
         DROP  R1
         ALR   R3,R15                  Effective address
         BALR  R14,R3                  Branch to MVS service
         USING @AM24,R13
         LM    R2,R14,@AM24CRS+8       Restore caller's registers
         DROP  R13
         BSM   0,R14                   Return to caller
         SPACE 2
         LTORG
         SPACE 2
AM24CLEN EQU   *-AM24CAP               Length of capping routine
         EJECT
*******************************************************************
*                                                                 *
*   IOSHTERM - Terminate hiperspaces                              *
*                                                                 *
*******************************************************************
IOSHTERM PROC  SCOPE=GLOBAL
         WITH  (RTCB,RTCBR),'L  RA,RTCBCBAT'  CBAT pointer
         WITH  (CBAT,RA),'L  RA,CBATIOCT'     IOCT pointer
         WITH  (IOCT,RA),BEGIN                IOCT addressabitity
         TS    IOCTTS                         One time only
         BNZ   IOSHTERX                       Exit
         QSNAP '***** IOSHTERM *****'
         L     RAR,=A(IOSHTERX+X'80000000')   Point to PR return
         BAKR  RAR,0                          Use hardware stack
         L     RB,IOCTHDBS                    First HDB pointer
         WITH  (HDB,RB),BEGIN                 HDB addressabitity
         STORAGE OBTAIN,LENGTH=L'HSOPCL       Get workarea
         LR    RJ,RS
         WITH  (HSOPCL,RJ),BEGIN              Workspace addressability
         WHILE (RB,NZ),BEGIN                  Release all hiperspaces
         QSNAP HDB,L'HDB-1
         IF    (HDBALET,NZ),BEGIN             ALET exists
         ALESERV DELETE,ALET=HDBALET,MF=(E,ALELIST)
         IF    (EPAR,NZ),BEGIN                ALESERV ERROR
         QSNAP '***** ALESERV ERROR *****'
         QSNAP (R15)
         QSNAP HSOPCL,L'HSOPCL
         PR    ,                              Return to caller
         END   ,                              ALESERV ERROR
         IF    (HDBTOKEN,NZ),BEGIN            TOKEN exists
         DSPSERV DELETE,STOKEN=HDBTOKEN,TTOKEN=IOCTTTOK,               *
               MF=(E,DSPLIST,COMPLETE)
         IF    (EPAR,NZ),BEGIN                DSPSERV ERROR
         QSNAP '***** DSPSERV ERROR *****'
         QSNAP (R15)
         QSNAP HSOPCL,L'HSOPCL
         PR    ,                              Return to caller
         END   ,                              DSPSERV ERROR
         END   ,                              TOKEN exists
         END   ,                              ALET exists
         L     RB,HDBCHAIN                    Next in line
         END   ,                              Release all hiperspaces
         STORAGE RELEASE,ADDR=(RJ),LENGTH=L'HSOPCL
         END   ,                              Workspace addressability
         END   ,                              HDB addressabitity
         END   ,                              IOCT addressabitity
         PR    ,                              Return to caller
IOSHTERX LABEL ,
         PEND  ,
         LTORG
         END   .
