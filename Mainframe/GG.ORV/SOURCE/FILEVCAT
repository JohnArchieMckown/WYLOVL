FILEVCAT TITLE 'Orvyl File Catalog Routines'
         COPY  VCATNOTE
*
* This module is the old VCAT module from the last version of ORVYL
* which included the file system rewrite. It is the only module
* remaining as all the others were rewritten. FILECAT is a layer
* above this module to act as an interface from the file system
* rewrite to this catalog handling module. This module has only
* a couple of minor changes from VCAT.
*
*******************************************************************
*                                                                 *
*     ORVYL/370 - Release IV - Class I - Stanford Proprietary     *
*                                                                 *
*******************************************************************
         SPACE 2
         HIBAL ,
         SPACE 2
FILEVCAT MODULE TRCNUM=12,ID=VC
         SPACE 2
         GBLB  &DEBUG,&CHKOFF,&NOBACK
&DEBUG   SETB  1                       THIS IS THE DEBUG PASS
&CHKOFF  SETB  0                       DO EXTRA CHECKS FOR NOW...
&NOBACK  SETB  0                       DO BACKUP I/O FOR NOW...
         TITLE 'Definitions'
         REGS  ,,SR,TR,QR,RQBR,FBR,BR,WAR,RAR,FSBR,SCBR,CTR,WR
*********************************************************************
* VFIL regs statement                                               *
*********************************************************************
         SPACE 2
         REGS  MIX,IX,,NOD,,,,,CHKR,,,,,,CNT,PTR
*********************************************************************
* DSK POINTS TO THE START OF THE DISK BLOCK IN MEMORY               *
* NOD POINTS TO THE CURRENT NODE                                    *
* IX IS AN INDEX REGISTER                                           *
*********************************************************************
         SPACE 2
         REGS  ,,DSK,LAS,CUR,,,,,,,,,,NEW,SIZ
*********************************************************************
*                    Disk management regs                           *
* DSK Provides addressability to the disk block DSECT               *
* LAS IS A POINTER TO THE LAST (PREVIOUS) MEMORY BLOCK              *
* CUR IS A POINTER TO THE CURRENT MEMORY BLOCK                      *
* NEW IS A POINTER TO THE NEW MEMORY BLOCK                          *
* SIZ IS THE SIZE OF THE CURRENT BLOCK                              *
*********************************************************************
         SPACE 2
*        PRINT OFF                     VCAT MACROS
         MACRO ,                        DIRSAV
.********************************************************************
.*   Save (noncontiguous) registers in the RQBL stack.
.* BR    When optionally specified, indicates that this register
.*       is also to be used as a base register.  If the register
.*       is to be saved, it must be in the SYSLIST as well.
.* ENTRY When optionally specified as YES, then &L is set as an
.*       entry point.
.********************************************************************
&L       DIRSAV &BR=NO,&ENTRY=NO
         GBLB  &SIMUL
&N       SETA  1
&NILCNT  SETA  0
&NUM     SETA  N'&SYSLIST
         AIF   ('&ENTRY' EQ 'NO').NOENT
         ENTRY &L
.NOENT   ANOP
&L       LABEL ,
.LOOP    ANOP                           Save loop
         AIF   ('&SYSLIST(&N)' EQ '').NILPARM
         ST    &SYSLIST(&N),(4*(&N-&NILCNT-1))(,WR)
         AGO   .NONILPA
.NILPARM ANOP
&NILCNT  SETA  &NILCNT+1
.NONILPA ANOP
         AIF   (&N GE N'&SYSLIST).INCR
&N       SETA  &N+1
         AGO   .LOOP
.INCR    ANOP
         LA    WR,((&NUM-&NILCNT)*4)(,WR)
         AIF   ('&BR' EQ 'NO').NOBASR
         BASE  &BR
.NOBASR  ANOP
         MEND
         MACRO ,                        DIREST
.********************************************************************
.*   Restore registers (noncontiguous) from RQBL stack.
.* ADDR  YES = addressability is available to use an ADCON
.*       NO    no addressability for example, loading the
.*             base register
.* REST  Actually restore registers?  If set to NO, then the stack
.*       pointer is decremented, but the specified registers
.*       aren't restored.
.********************************************************************
&L       DIREST &ADDR=YES,&REST=YES
&N       SETA  1
&NUM     SETA  N'&SYSLIST
&L       LABEL ,
         AIF   ('&ADDR' NE 'YES').NOADDR
         SH    WR,=Y(&NUM*4)
         AGO   .ADDR
.NOADDR  ANOP  ,
         LA    &SYSLIST(1),&NUM*4
         SR    WR,&SYSLIST(1)
.ADDR    ANOP  ,
         AIF   ('&REST' EQ 'NO').DECR
.LOOP    ANOP
         L     &SYSLIST(&N),(4*(&N-1))(,WR)
         AIF   (&N GE N'&SYSLIST).DECR
&N       SETA  &N+1
         AGO   .LOOP
.DECR    ANOP
         MEND
         MACRO ,                        DIRENT
.********************************************************************
.*   Register save macro, which automatically uses the first
.* register of the SYSLIST as a base register, and only saves
.* 2 registers.
.* ENTRY When optionally specified, sets up &L as an entry point.
.********************************************************************
&L       DIRENT &ENTRY=NO
&L       DIRSAV &SYSLIST(1),&SYSLIST(2),BR=&SYSLIST(1),ENTRY=&ENTRY
         MEND
         MACRO ,                       DREAD
.********************************************************************
.*   Read a catalog block.
.* BLK   Relative block number to read.
.* LOCK  Whether or not the block is to be locked in core.
.* PTR   The suffix of Checkpoint block pointer slots which will be
.*       filled if this parm is specified.
.* TAG   The suffix of Checkpoint tag slot for this block.
.* ERR   Branch location on error.
.********************************************************************
&L       DREAD &BLK,&LOCK=NO,&PTR=NO,&TAG=NO,&ERR=
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
         AIF   ('&LOCK' NE 'YES').NOLOCK
         LA    R15,1                   INDICATE READ-RESERVE
         AGO   .RES
.NOLOCK  ANOP
         CLEAR R15                     INDICATE READ-NO_RESERVE
.RES     ANOP
         LCALL DREAD
.*                                      No error returns now
*        IF     NZ,&ERR
         AIF   ('&PTR' EQ 'NO').NOPTR
&POINT   SETC  'CHK&PTR.A'
         ST    DSK,&POINT
.NOPTR   ANOP  ,
         AIF   ('&TAG' EQ 'NO').NOTAG
         MVC   CHKI&TAG,DSKTAG
.NOTAG   ANOP  ,
         MEND
         SPACE 2
         MACRO ,                       DWRITE
.********************************************************************
.*   Write a catalog block.
.* BLK   Relative block number to read.
.* REL   Whether or not the block buffer is to be released after
.*       writing.
.* ERR   Branch location on error.
.********************************************************************
&L       DWRITE &BLK,&REL=YES,&ERR=
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
         AIF   ('&REL' NE 'YES').NOREL
         CLEAR R15                     INDICATE WRITE-RELEASE
         AGO   .REL
.NOREL   ANOP
         LA    R15,1                   INDICATE WRITE-NO_RELEASE
.REL     ANOP
         LCALL DWRITE
.*                                      No error returns now
*        IF     NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       DDREAD
.********************************************************************
.*   Read a catalog double write block.
.* DBLK  Double write block number (1..3)
.* BLK   Catalog block num in the double write block.
.* ERR   Branch location on error.
.********************************************************************
&L       DDREAD &DBLK,&BLK,&ERR=
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
        $LA    R15,&DBLK               DOUBLE BLOCK NUMBER
         LCALL DDREAD
.*                                      No error returns now
*        IF     NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       DDWRITE
.********************************************************************
.*   Write a catalog double write block.
.* DBLK  Double write block number (1..3)
.* BLK   Catalog block num to be written in the double write block.
.* ERR   Branch location on error.
.********************************************************************
&L       DDWRITE &DBLK,&BLK,&ERR=
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
        $LA    R15,&DBLK
         LCALL DDWRITE
.*                                      No error returns now
*        IF    NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       IWRITE
&L       IWRITE &ERR=                  WRITE INTENTIONS BLOCK
.********************************************************************
.*   Write catalog chepoint (intentions) block.
.* ERR   Branch location on error.
.********************************************************************
&L       LABEL ,
         LCALL IWRITE
*        IF    NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       DRELBUF
.********************************************************************
.*   Release catalog block.
.* BLK   Catalog block num to be released.
.* ERR   Branch location on error.
.********************************************************************
&L       DRELBUF &BLK,&ERR=            UNLOCK A BLOCK BUFFER
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
         LCALL DRELBUF
*        IF     NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       DLOKBUF
.********************************************************************
.*   Lock a catalog block in core.
.* BLK   Catalog block num to be locked.
.* TAG   The suffix of Checkpoint tag slot for this block.
.* ERR   Branch location on error.
.********************************************************************
&L       DLOKBUF &BLK,&TAG=NO,&ERR=    LOCK A BLOCK BUFFER
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
         LCALL DLOKBUF
*        IF     NZ,&ERR
         AIF   ('&TAG' EQ 'NO').NOTAG
         MVC   CHKI&TAG,DSKTAG
.NOTAG   ANOP  ,
         MEND
         SPACE 2
         MACRO ,                       LKINCORE
.********************************************************************
.*   -- LOW LEVEL CATALOG BUFFER MANAGEMENT --
.*   Look for a block in Catalog buffer core.
.* BLK   Catalog block number to look for.
.* CUR   Register which will point to current slot in buffer table.
.* LAS   Register which will point to last slot in buffer table.
.********************************************************************
&L       LKINCORE &BLK,&CUR=R4,&LAS=R3
&L       BLKL  R0,&BLK                 LOAD BLOCK NUMBER
         LCALL LKINCORE
        $L     &CUR,(R4)               R4 POINTS TO CUR
        $L     &LAS,(R3)               R3 POINTS TO LAST SLOT
         MEND
         SPACE 2
         MACRO ,                       LRUBUF
.********************************************************************
.*   -- LOW LEVEL CATALOG BUFFER MANAGEMENT --
.*   Mark current Catalog block as Least Recently Used (LRU)
.* CUR   Current slot in buffer table.
.* LAS   Last slot in buffer table.
.********************************************************************
&L       LRUBUF &CUR,&LAS
&L       LABEL ,
        $L     R4,&CUR                 R4 SHOULD POINT TO CUR
        $L     R3,&LAS                 R3 SHOULD POINT TO LAST SLOT
         LCALL LRUBUF
         MEND
         SPACE 2
         MACRO ,                       DSKINIT
.********************************************************************
.*   -- LOW LEVEL SPACE MANAGEMENT ROUTINE --
.*   Initialize space management pointers on a disk block.
.* BLK   Block number (catalog relative) for initialization
.* BUF   Buffer address for block location in core
.********************************************************************
&L       DSKINIT &BLK,&BUF
&L       LABEL ,
         AIF   ('&BLK' EQ '').NOBLK
         BLKL  R0,&BLK                 LOAD BLOCK NUMBER
.NOBLK   ANOP  ,
         AIF   ('&BUF' EQ '').NOBUF
        $L     DSK,&BUF
.NOBUF   ANOP  ,
         ACALL DSKINIT
         MEND
         SPACE 2
         MACRO ,                       ALLOC
.********************************************************************
.*   -- LOW LEVEL SPACE MANAGEMENT ROUTINE --
.*   Allocate space from a disk block
.* HEAD  points to the space management header on the disk block
.* AMT   is the space requested
.********************************************************************
&L       ALLOC &HEAD,&AMT,&ERR=
&L      $L     R1,&HEAD
        $LA    R0,&AMT
         ACALL DSKGET
         IF    (NZ,AND,(R15,NE,CDSKSERR)),BEGIN
         O     R15,=A(CDIRDGM)         OR IN DSKGET MODULE NUMBER
         B     &ERR
         END   ,
         MEND
         SPACE 2
         MACRO ,                       DSKFREE
.********************************************************************
.*   -- LOW LEVEL SPACE MANAGEMENT ROUTINE --
.*   Free space on disk block  -  registers assumed to be set up
.********************************************************************
&L       DSKFREE ,
&L       LABEL ,
         ACALL DSKFREE
         MEND
         SPACE 2
         MACRO ,                       GETBLOCK
.********************************************************************
.*   -- LOW LEVEL SPACE MANAGEMENT ROUTINE --
.*   Get a block from the free block pool
.********************************************************************
&L       GETBLOCK &ERR=
&L       ACALL GETBLOCK
         IF    NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       GETNODE
.********************************************************************
.*   Allocate a node from block pool.
.* PTRS  Suffix of the pointer slots in the checkpoint block.
.* DATA  Indicates if the allocation is for an index block or a
.*       data block.  See the GETNODE routine to see the
.*       requirements of this parm.  Must be full specification
.*       (not suffix or prefix of location).
.* LOCK  Should the node be locked in core after allocating it?
.* TAG   Suffix of tag location in checkpoint block if the tag is
.*       to be saved.
.* ERR   Branch location on error.
.********************************************************************
&L       GETNODE &PTRS=,&DATA=NO,&LOCK=NO,&TAG=NO,&ERR=
&L       LABEL ,
         AIF   ('&DATA' EQ 'NO').NODATA
         LA    R14,1
         BLKL  R15,&DATA               Load data block number
         AGO   .DATA
.NODATA  ANOP
         CLEAR R14
.DATA    ANOP
         ACALL GETNODE
         IF    NZ,&ERR
         ST    DSK,CHK&PTRS.A          Buffer address
         STH   R0,CHK&PTRS.B           Block number
         STH   R1,CHK&PTRS.N           Node offset
         AIF   ('&TAG' EQ 'NO').NOTAG
         MVC   CHKI&TAG,DSKTAG
.NOTAG   ANOP  ,
         AIF   ('&LOCK' EQ 'NO').NOLOCK
         DLOKBUF (R0),ERR=&ERR
.NOLOCK  MEND
         SPACE 2
         MACRO ,                       RELNODE
.********************************************************************
.*   Release a node and put space back in free pool.
.* RELAD Relative address (in block) of node to be released.
.* LEN   Length of node begin freed.
.* BUFAD Address of buffer that contains the node.
.* ERR   Branch location on error.
.********************************************************************
&L       RELNODE &RELAD,&LEN,&BUFAD,&ERR=
&L      $L     R15,&RELAD,OP=LH        REL START ADDR
        $L     R0,&LEN,OP=LH           NODE LEN
        $L     R1,&BUFAD               BUFFER ADDR
         ACALL RELNODE
         IF    NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       NTRYMOV
.********************************************************************
.*   Move an entry/entrys from one node to another.
.* SRC   Suffix of source node pointers in checkpoint block.
.* DEST  Suffix of destination node pointers in checkpoint block.
.* DELSRC      Delete entry in source node?  Sets parameter.
.********************************************************************
&L       NTRYMOV &SRC=,&DEST=,&DELSRC=YES
&L       LABEL ,
         AIF   ('&DELSRC' EQ 'YES').DEL
         LH    RAR,CHKBDLN
         LCR   RAR,RAR
         STH   RAR,CHKBDLN
.DEL     ANOP
         LH    R1,CHK&SRC.N
         AL    R1,CHK&SRC.A
         LH    R15,CHK&DEST.N
         AL    R15,CHK&DEST.A
         ACALL NTRYMOV
         MEND
         SPACE 2
         MACRO ,                       NTRYCHG
.********************************************************************
.*   Change and entry in a node.
.* DEST  Checkpoint suffix of node to be modified.
.* DELXTND     Delete extended data portion?
.* INSXTND     Insert extended data portion?
.* ERR   Branch location on error.
.********************************************************************
&L       NTRYCHG &DEST=,&DELXTND=YES,&INSXTND=YES,&ERR=
&L       LABEL ,
         AIF   ('&DELXTND' EQ 'YES').DELXTND
         LCR   R14,R14
.DELXTND ANOP  ,
         AIF   ('&INSXTND' EQ 'YES').INSXTND
         LCR   R0,R0
.INSXTND ANOP  ,
&DPT     SETC  'CHK'.'&DEST'.'P'
         MVC   CHK2WRP,&DPT
         ACALL NTRYCHG
         IF    NZ,&ERR
         MEND
         SPACE 2
         MACRO ,                       TOCOM
.********************************************************************
.*   Return to common routines
.* SAVE  Prepare for subsequent return? (saves return address...)
.********************************************************************
&L       TOCOM &SAVE=YES               RETURN TO COMMON ROUTINES
&L       LABEL ,
         AIF   ('&SAVE' NE 'YES').NOSAV
         LCALL DIRCOMSV                PREPARE FOR RET
         MEXIT
.NOSAV   ANOP  ,
         B     DIRCOM                  DON'T PREPARE FOR RET
         MEND
         SPACE 2
         MACRO ,                       COMIO
.********************************************************************
.*   Call common I/O routines
.* ROUTINE     Name of common routine to call
.********************************************************************
&L       COMIO &ROUTINE                CALL COMMON I/O ROUTINES
&L       L     R14,=V(&ROUTINE)
         LCALL COMIO
         MEND
         SPACE 2
         MACRO ,                       CATENT
.********************************************************************
.*   Define Catalog Routines sub-entry (from VCATENT)
.********************************************************************
&L       CATENT &ENTRY=NO              DEFINE CATALOG ENTRY
         AIF   ('&ENTRY' EQ 'NO').NOENT
         ENTRY &L
.NOENT   ANOP  ,
&L       LABEL ,
         MEND
         SPACE 2
         MACRO ,                       CHKPUSH
.********************************************************************
.*   Push the tree searching stack, leaving addressability in ADDRREG
.* ADDRREG     Register which will point to top of stack.
.* ERR         Branch location on error (stack overflow).
.********************************************************************
&L       CHKPUSH &ADDRREG=,&ERR=
         GBLB  &CHKOFF                 Turn off unnecessary checks
&L       LABEL ,
         AIF   (&CHKOFF).NOSTOV
         INCR  &ADDRREG,CHKSTKP
         IF    (&ADDRREG,GT,CCHKSTK),BEGIN
         LA    R15,DIRSTOV
         BAS   R14,&ERR
         END   ,
.NOSTOV  ANOP  ,
         MH    &ADDRREG,=Y(L'CHKDSTK)  ADDR TO STACK ENTRY
         LA    &ADDRREG,CHKSTAK-L'CHKDSTK(&ADDRREG)
         CLEAR CHKSTFLG                INIT ENTRY
         MEND
         SPACE 2
         MACRO ,                       TRESTKAD
.********************************************************************
.*   Tree traversal stack addressability.
.* ADDRREG     Register which will point to top of tree traversal
.*             stack.
.********************************************************************
&L       TRESTKAD &ADDRREG
&L       LH    &ADDRREG,CHKSTKP
         MH    &ADDRREG,=Y(L'CHKDSTK)  ADDR TO STACK ENTRY
         LA    &ADDRREG,CHKSTAK-L'CHKDSTK(&ADDRREG)
         MEND
         SPACE 2
         MACRO ,                       REGCH
.********************************************************************
.*   Check symbolic registers for equalness.
.* The parameter string is a list of register pairs ie, (R2,SR)
.* which are meant to match.  This will check on assumptions which
.* could be changed by an unknowing change to a REGS statement.
.********************************************************************
         REGCH
&N       SETA  1
.REGNEX  AIF   (L'&SYSLIST(&N,1) NE &SYSLIST(&N,2)).REGER
.INCR    AIF   (&N GE N'&SYSLIST).REGX
&N       SETA  &N+1
         AGO   .REGNEX
.REGER   ANOP
 MNOTE  8,'&SYSLIST(&N,1) is not register &SYSLIST(&N,2)'
         AGO   .INCR
.REGX    MEND
         MACRO ,                       BLKL
.********************************************************************
.*   Load block pointer into register.  (Checks halfword/fullword)
.* REG   Register to be loaded.
.* LOC   Location to load from.
.********************************************************************
&L       BLKL  &REG,&LOC
         GBLA  &BL
&OP      SETC  'L'
         AIF   (&BL NE 2).LEN4
&OP      SETC  '&OP.H'
.LEN4    ANOP
&L      $L     &REG,&LOC,OP=&OP        GET BLOCK NUMBER
         MEND
         SPACE 2
         MACRO ,                       BUGNTRY
.*  Create an entry point if in debug mode
         BUGNTRY &NTRYPT
         GBLB  &DEBUG
         AIF   (NOT &DEBUG).DONE
         ENTRY &NTRYPT
.DONE    MEND
*        PRINT ON
         SPACE 2
         COPY  PZERO
         TITLE 'File System Constants'
         COPY  FILCONST
         TITLE 'File block header definition'
         COPY  FBHDR
         TITLE 'FSB Definition'
         COPY  FSB
         TITLE 'Checkpoint Block Definition'
         COPY  CHKPNT
         TITLE 'RQB Definition'
         COPY  CATRQBL
         TITLE 'DSKBLK Definition'
         COPY  DSKBLK                  CONTROL BLOCK
         TITLE 'DSKBLK Chain Definitions'
LAST     RECORD BEGIN
         DSKCHN PFX=LAS
         END   ,
         SPACE 2
CURRENT  RECORD BEGIN
         DSKCHN PFX=CUR
         END   ,
         SPACE 2
NEWCHAIN RECORD BEGIN
         DSKCHN PFX=NEW
         END   ,
         TITLE 'Node Definition'
         COPY  NODE
         TITLE 'File System Privilege Flag Codes'
         COPY  FPC
         TITLE 'Entry Definition'
         COPY  NTRY
         TITLE 'Generate VCAT constants'
         GENCAT CONST
         TITLE ' '
FILEVCAT CSECT ,
         USING FSB,FSBR                FSB ADDRESSABILITY
         USING RQB,RQBR                RQB ADDRESSABILITY
         USING CHKPNT,CHKR             ADDR TO CHECKPOINT BUFFER
         USING DSKBLK,DSK              ADDRESSABLILTY TO DISK BLOCKS
         TITLE 'Catalog Management Entry'
*********************************************************************
* ON ENTRY :                                                        *
*        FSBR points to the proper FSB                              *
*        RQBR points to the proper RQB                              *
*        R14/R1 are set up for the proper entry call                *
*        R2   contains the VCAT request code                        *
*        WR   points to the VFIL/VCAT stack                         *
*********************************************************************
         ENTRY VCATENT
VCATENT  ST    BR,RQBLBR2              SAVE REGS
         ST    WAR,RQBLWAR             |
         DIRSAV FBR,RAR                |
         REGCH (WAR,8),(CHKR,8)
         L     CHKR,FSBCHKA            CHECKPOINT BUFFER ADDRESS
         BASE  BR                      Common routines addressability
*               R2 = function code (R0,R14,R15 = general parms)
         BUGNTRY VCATCOM
VCATCOM  LABEL ,
         XTRC  R14,R2,CATENT
         LR    FBR,R2
         GENCAT TABLE,REG=FBR          FUNCTION BRANCH TABLE
         TITLE 'Directory Read'
*********************************************************************
* ON ENTRY: R0  = Relative block # to be read                       *
*           IF R15 ^ 0                                              *
*             Indicates that block is to be locked in memory        *
* ON EXIT:  CC = 0                                                  *
*             DSK = Buffer address                                  *
*             R0  = Relative block # just read                      *
*********************************************************************
         BUGNTRY DREAD
DREAD    DIRSAV RAR
* Look for block already in core
         LKINCORE (R0),CUR=R4,LAS=R3   LOOK FOR BLOCK IN CORE
         IF    ZERO,BEGIN              FOUND
         IF    (R15,NZ),'OC @R4+CFSBBL(4),=A(VIOLOCK) '
         LRUBUF (R4),(R3)              PUT @ END (LEAST RECENTLY USED)
         N     DSK,=A(VIOFREE)         ALIGN
         IF    (R3,ZERO),BEGIN         COUNT ROOT BLOCK "READS"
         INCR  QR,FSBCTRRD             ONE MORE ROOT READ
         END   ,                       OF COUNT ROOT BLOCK "READS"
         INCR  QR,FSBCTCRD             ONE MORE BUFFERED READ
         END   ELSE,BEGIN              NOT FOUND
* Not in core, so look for a free buffer
         LA    R2,CFSBPL               INDEX INCREMENT
         L     R3,FSBBLKTOP            UPPER LIMIT
         LA    R4,FSBBLK1              STARTING ADDRESS
DRAVCORE CLI   @R4+CFSBPL-1,X'00'      IS THIS BUFFER AVAILABLE?
         IF    EQUAL,BEGIN             AVAILABLE BUFFER FOUND
         IF    (R15,NZ),'OC @R4+CFSBBL(4),=A(VIOLOCK) ' LOCK
         ST    R0,@R4
         LRUBUF (R4),(R3)              PUT @ END (LEAST RECENTLY USED)
         N     DSK,=A(VIOFREE)         ALIGN
         B     DRDDO                   DO READ
         END   ,                       OF AVAILABLE BUFFER FOUND
         BXLE  R4,R2,DRAVCORE          CONT LOOKING FOR AVAILABLE CORE
* No available I/O space.  Indicate error.
         ABORT  CATIOS,(FSBR),(RQBR),(R0),(WR)
* Read in new block
DRDDO    LABEL ,
*         INCR  QR,CTCATRCT             ONE MORE CAT READ
         INCR  QR,FSBCTRD              |
         ST    DSK,RQBLR14             BUFFER ADDRESS
         AL    R0,FSBCATSB             ABSOLUTE ORVYL BLOCK NUMBER
         ST    R0,RQBLR1               |
*        COMIO GETDEVW                 GET AN RPB
         LH    R0,FSBDSZ               LENGTH OF WRITE
         COMIO SETREAD1
         IF    RQFIOER,CATRDERR
*        COMIO FREEDEV                 FREE THE RPB
         L     R0,RQBLR1               BLOCK NUMBER
         S     R0,FSBCATSB             | RELATIVE
         L     DSK,RQBLR14             ADDRESS
         END   ,                       OF NOT FOUND
         LH    R14,FSBDTAGX            ADDR OF END DISK TAG
         LA    R14,DSKBLK(R14)         |
         IF    ('CLC DSKTAG(4),@R14+4',NE),BEGIN
         ABORT  CATTAG,(FSBR),(RQBR),(R0),(DSK) TAG MISMATCH
         END   ,
         IF    ('CH R0,DSKBNUM',NE),BEGIN
         ABORT  CATBLK,(FSBR),(RQBR),(R0),(DSK) BLK MISMATCH
         END   ,
         CLEAR R15
DREADX   DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Directory Write'
*********************************************************************
* ON ENTRY: R0  = Relative block # to be written                    *
*           IF R15 = 0 Then this block can be freed                 *
*                      Otherwise the block will stay locked in core *
* ON EXIT:  CC = 0                                                  *
*             Block has been written                                *
*             DSK and RQBLR14 = the address of the I/O buffer       *
*             R0  = Relative block number just written              *
*********************************************************************
         BUGNTRY DWRITE
DWRITE   DIRSAV RAR
         LKINCORE (R0),CUR=R4,LAS=R3   LOOK FOR BLOCK IN CORE
         IF    NZ,BEGIN                I/O BUFFER NOT FOUND
         ABORT  CATIONF,(FSBR),(RQBR),(R0),(WR)
         END   ,
         IF    (R15,ZERO),'NC @R4+CFSBBL(4),=A(VIOFREE) '
         L     DSK,@R4+CFSBBL          GET BUFFER ADDR
         N     DSK,=A(VIOFREE)         |
         IF  ('CH R0,DSKBNUM',NE),BEGIN         BLOCK DOESN'T MATCH
         ABORT  CATBLK,(FSBR),(RQBR),(R0),(DSK)
         END   ,                       OF BLOCK DOESN'T MATCH
         LH    R14,FSBDTAGX            PUT CLOCK IN AS END TAG
         LA    R14,DSKBLK(R14)         |
         STCK  @R14                    |
         STH   R0,@R14+6               | REP 2 LOW BYTES BY REL BLK #
         IF    ('CLC @R14+4(2),DSKTAG',EQ),BEGIN        UNIQUE
         XI    @R14+5,X'01'            | INVERT Least Sig Bit
         END   ,                       | OF INSURE UNIQUENESS
         MVC   DSKTAG(4),@R14+4        | DUPLICATE LAST 4 BYTES AS TAG
         IF    ^DSKFMOD,DWRDONE        DON'T WRITE UNMODIFIED BLOCK
         CLEAR DSKFMOD                 MODS TAKEN CARE OF
*         INCR  QR,CTCATWCT             ONE MORE CAT WRITE
         INCR  QR,FSBCTWR              |
         ST    DSK,RQBLR14             ADDRESS
         AL    R0,FSBCATSB             ABSOULUTE ORVYL BLOCK NUMBER
         ST    R0,RQBLR1               |
*        COMIO GETDEVW                 GET AN RPB
         LH    R0,FSBDSZ               LENGTH OF WRITE
         LA    R15,FBHTCAT             CATALOG BLOCK ID
         COMIO SETWRIT1
         IF    RQFIOER,CATWRERR
*        COMIO FREEDEV                 FREE THE RPB
         L     R0,RQBLR1               BLOCK NUMBER
         S     R0,FSBCATSB             | RELATIVE
         L     DSK,RQBLR14             ADDRESS
DWRDONE  CLEAR R15                     DSK & R0 are set up
DWRITEX  DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Lock an I/O Buffer'
*********************************************************************
* ON ENTRY: R0  = Relative block number to lock                     *
* ON EXIT:  CC = 0                                                  *
*             The block was locked against future I/O               *
*             R0  = Relative block number just locked               *
*             DSK and RQBLR14 = Buffer addr of block just locked    *
*********************************************************************
DLOKBUF  DIRSAV RAR
* Look for block already in core
         LKINCORE (R0),CUR=R4,LAS=R3   LOOK FOR BLOCK IN CORE
         IF    NZ,BEGIN                I/O BUFFER NOT FOUND
         ABORT  CATIONF,(FSBR),(RQBR),(R0),(WR)
         END   ,                       OF I/O BUFFER NOT FOUND
         OC    @R4+CFSBBL(4),=A(VIOLOCK)        LOCK BUFFER
         L     DSK,@R4+CFSBBL          BUFFER ADDRESS
         N     DSK,=A(VIOFREE)         |
         ST    DSK,RQBLR14             |
         CLEAR R15
DLOKX    DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Release an I/O Buffer'
*********************************************************************
* ON ENTRY: R0  = Relative block number to release                  *
* ON EXIT:  CC = 0                                                  *
*             The block was made available for future I/O           *
*             R0  = Relative block number just released             *
*             DSK and RQBLR14 = Buffer addr of block just released  *
*********************************************************************
         BUGNTRY DRELBUF
DRELBUF  DIRSAV RAR
* Look for block already in core
         LKINCORE (R0),CUR=R4,LAS=R3   LOOK FOR BLOCK IN CORE
         IF    NZ,BEGIN                I/O BUFFER NOT FOUND
         ABORT  CATIONF,(FSBR),(RQBR),(R0),(WR)
         END   ,                       OF I/O BUFFER NOT FOUND
         NC    @R4+CFSBBL(4),=A(VIOFREE)        FREE BUFFER
         L     DSK,@R4+CFSBBL          BUFFER ADDRESS
         ST    DSK,RQBLR14             |
DRELFND  CLEAR R15
DRELX    DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Nullify Buffer Contents'
*********************************************************************
* ON ENTRY:  Addressability to FSB and CHKPNT                       *
* ON EXIT:                                                          *
*            CC = 0                                                 *
*               All buffers are set to available and empty          *
*               The root node is read into its buffer to insure     *
*                 that the copy in memory is the most recent valid  *
*                 copy                                              *
*********************************************************************
         BUGNTRY NILBUF
NILBUF   DIRSAV RAR
         LA    R2,CFSBPL               EMPTY BUFFER SLOTS (INCR)
         L     R3,FSBBLKTOP            | UPPER LIMIT
         LA    R4,FSBBLK1              | STARTING ADDR
NILLOOP  MVC   @R4(CFSBBL),=&L.AL1(NIL)         BUFFER N EMPTY
         NC    @R4+CFSBBL(4),=A(VIOFREE)        BUFFER N AVAILABLE
         BXLE  R4,R2,NILLOOP           DO ALL SLOTS
*         INCR  QR,CTCATRCT             ONE MORE CAT READ
         INCR  QR,FSBCTRD              |
         MVC   RQBLR14,FSBROOTA        ROOT BUFFER ADDRESS
         L     R0,FSBROOTB             ROOT BLOCK
         AL    R0,FSBCATSB             ABSOLUTE ORVYL BLOCK NUMBER
         ST    R0,RQBLR1               |
*        COMIO GETDEVW                 GET AN RPB
         LH    R0,FSBDSZ               LENGTH OF WRITE
         COMIO SETREAD1
         IF    RQFIOER,CATRDERR
*        COMIO FREEDEV                 FREE THE RPB
         L     R0,RQBLR1               BLOCK NUMBER
         S     R0,FSBCATSB             | RELATIVE
         L     DSK,RQBLR14             ADDRESS
         LH    R14,FSBDTAGX            ADDR OF END DISK TAG
         LA    R14,DSKBLK(R14)         |
         IF    ('CLC DSKTAG(4),@R14+4',NE),BEGIN
         ABORT  CATTAG,(FSBR),(RQBR),(R0),(DSK) TAG MISMATCH
         END   ,
         IF    ('CH R0,DSKBNUM',NE),BEGIN
         ABORT  CATBLK,(FSBR),(RQBR),(R0),(DSK) BLK MISMATCH
         END   ,
         CLEAR R15
NILBUFX  DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Double Read'
*********************************************************************
* ON ENTRY: R0  = Relative block # in double write block            *
*           R15 = Double write block #                              *
* ON EXIT:  CC = 0                                                  *
*             DSK = Buffer address                                  *
*             R0  = Relative block # just read                      *
*********************************************************************
DDREAD   DIRSAV RAR
* Look for block already in core
         IF    (R0,EQ,FSBROOTB),BEGIN  READ ROOT EVEN IF IN MEM
         L     DSK,FSBROOTA            BUFFER ADDRESS
         B     DDRDDO                  DO READ
         END   ,                       OF READ ROOT EVEN IF IN MEM
         LKINCORE (R0),CUR=R4,LAS=R3   LOOK FOR BLOCK IN CORE
         IF    ZERO,BEGIN              FOUND
         LRUBUF (R4),(R3)              PUT @ END (LEAST RECENTLY USED)
         N     DSK,=A(VIOFREE)         ALIGN
         IF    (R3,ZERO),BEGIN         COUNT ROOT BLOCK "READS"
         INCR  QR,FSBCTRRD             ONE MORE ROOT READ
         END   ,                       OF COUNT ROOT BLOCK "READS"
         INCR  QR,FSBCTCRD             ONE MORE BUFFERED READ
         END   ELSE,BEGIN              NOT FOUND
* Not in core, so look for a free buffer
         LA    R2,CFSBPL               INDEX INCREMENT
         L     R3,FSBBLKTOP            UPPER LIMIT
         LA    R4,FSBBLK1              STARTING ADDR
DDRAVCOR CLI   @R4+CFSBPL-1,X'00'      IS THIS BUFFER AVAILABLE?
         IF    EQUAL,BEGIN             AVAILABLE BUFFER FOUND
         ST    R0,@R4
         LRUBUF (R4),(R3)              PUT @ END (LEAST RECENTLY USED)
         N     DSK,=A(VIOFREE)         ALIGN
         B     DDRDDO                  DO READ
         END   ,                       OF AVAILABLE BUFFER FOUND
         BXLE  R4,R2,DDRAVCOR          CONT LOOKING FOR AVAILABLE CORE
* No available I/O space.  Indicate error.
         ABORT  CATIOS,(FSBR),(RQBR),(R0),(WR)
* Read in new block
DDRDDO   LABEL ,
         DIRSAV R0                     SAVE BLOCK NUMBER
*         INCR  QR,CTCATRCT             ONE MORE CAT READ
         INCR  QR,FSBCTRD              |
         ST    DSK,RQBLR14             BUFFER ADDRESS
         AH    R15,CHKDWRT             ABSOLUTE ORVYL BLOCK NUMBER
         DECR  R15                     | RANGE 0..N-1
         AL    R15,FSBCATSB            |
         ST    R15,RQBLR1              |
*        COMIO GETDEVW                 GET AN RPB
         LH    R0,FSBDSZ               LENGTH OF WRITE
         COMIO SETREAD1
         IF    RQFIOER,CATRDERR
*        COMIO FREEDEV                 FREE THE RPB
         DIREST R0                     RESTORE BLOCK NUMBER
         L     DSK,RQBLR14             ADDRESS
         END   ,                       OF NOT FOUND
         LH    R14,FSBDTAGX            ADDR OF END DISK TAG
         LA    R14,DSKBLK(R14)         |
         IF    ('CLC DSKTAG(4),@R14+4',NE),BEGIN
         ABORT  CATDTAG,(FSBR),(RQBR),(R0),(DSK)        TAG MISMATCH
         END   ,
         IF    ('CH R0,DSKBNUM',NE),BEGIN
         ABORT  CATDBLK,(FSBR),(RQBR),(R0),(DSK)        BLK MISMATCH
         END   ,
         CLEAR R15
DDREADX  DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Double Write'
*********************************************************************
* ON ENTRY: R0  = Relative block # to be written                    *
*           R15 = Double write block number (1..3)                  *
* ON EXIT:  CC = 0                                                  *
*             Block has been written                                *
*             DSK and RQBLR14 = the address of the I/O buffer       *
*********************************************************************
DDWRITE  DIRSAV RAR
* Look for block already in core
         LKINCORE (R0),CUR=R4,LAS=R3   LOOK FOR BLOCK IN CORE
         IF    NZ,BEGIN                I/O BUFFER NOT FOUND
         ABORT  CATDIONF,(FSBR),(RQBR),(R0),(WR)
         END   ,                       OF I/O BUFFER NOT FOUND
         L     DSK,@R4+CFSBBL          BUFFER ADDRESS
         N     DSK,=A(VIOFREE)         | ALIGN
         IF ('CH R0,DSKBNUM',NE),BEGIN BLOCK DOESN'T MATCH
         ABORT  CATBLK,(FSBR),(RQBR),(R0),(DSK)
         END   ,                       OF BLOCK DOESN'T MATCH
         LH    R14,FSBDTAGX            PUT CLOCK IN AS END TAG
         LA    R14,DSKBLK(R14)         |
         STCK  @R14                    |
         STH   R0,@R14+6               | 2 LOW BYTES = REL BLOCK #
         MVC   DSKTAG(4),@R14+4        | DUPLICATE LAST 4 BYTES AS TAG
         AIF   (&NOBACK).DDWRISK
*         INCR  QR,CTCATWCT             ONE MORE CAT WRITE
         INCR  QR,FSBCTDWR             |
         ST    DSK,RQBLR14             ADDRESS
         DECR  R15                     DOUBLE WRITE - RANGE (0..N-1)
         AH    R15,CHKDWRT             |
         AL    R15,FSBCATSB            ABSOULUTE ORVYL BLOCK NUMBER
         ST    R15,RQBLR1              |
*        COMIO GETDEVW                 GET AN RPB
         LH    R0,FSBDSZ               LENGTH OF WRITE
         LA    R15,FBHTCAT             CATALOG BLOCK ID
         COMIO SETWRIT1
         IF    RQFIOER,CATWRERR
*        COMIO FREEDEV                 FREE THE RPB
         L     R0,RQBLR1               BLOCK NUMBER
         S     R0,FSBCATSB             | RELATIVE
         L     DSK,RQBLR14             ADDRESS
.DDWRISK ANOP  ,
         CLEAR R15
DDWRITEX DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Write Intentions Block'
*********************************************************************
* ON ENTRY: Addressability to FSB, CHKPNT, RQB                      *
* ON EXIT:  CC = 0                                                  *
*             Intentions block has been written                     *
*********************************************************************
IWRITE   DIRSAV RAR
         CLEAR R0                      BLOCK 0 = INTENTIONS
         LR    DSK,CHKR                BUFFER ADDRESS
         STCK  CHKTIME                 INDICATE TIME OF WRITE
         LH    R14,FSBDTAGX            PUT CLOCK IN AS END TAG
         LA    R14,DSKBLK(R14)         |
         MVC   @R14(8),CHKTIME         |
*         INCR  QR,CTCATWCT             ONE MORE CAT WRITE
         INCR  QR,FSBCTIWR             | INTENTIONS
         ST    DSK,RQBLR14             ADDRESS
         AL    R0,FSBCATSB             ABSOULUTE ORVYL BLOCK NUMBER
         ST    R0,RQBLR1               |
*        COMIO GETDEVW                 GET AN RPB
         LH    R0,FSBDSZ               LENGTH OF WRITE
         LA    R15,FBHTCAT             CATALOG BLOCK ID
         COMIO SETWRIT1
         IF    RQFIOER,CATWRERR
*        COMIO FREEDEV                 FREE THE RPB
         L     R0,RQBLR1               BLOCK NUMBER
         S     R0,FSBCATSB             | RELATIVE
         L     DSK,RQBLR14             ADDRESS
         CLEAR R15
IWRITEX  DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'I/O Buffer management'
*********************************************************************
* ON ENTRY                                                          *
*       R0 contains the block number to look for                    *
* ON EXIT                                                           *
*       R0 unchanged                                                *
*       IF CC = 0                                                   *
*         R3 points to the last slot                                *
*            IF R3 = 0, the block is the root block                 *
*         R4 points to the current slot                             *
*       IF CC ^ 0                                                   *
*         Block was not found                                       *
*********************************************************************
LKINCORE LABEL ,
         CLEAR R14                     ASSUME FOUND - UNTIL NOT
         IF    (R0,EQ,FSBROOTB),BEGIN  ROOT BLOCK?
         LA    R4,FSBROOTB             SLOT ADDRESS
         CLEAR R3                      | INDICATE ROOT
         END   ,                       OF ROOT BLOCK?
         ELSE  BEGIN                   NOT ROOT BLOCK
         LA    R2,CFSBPL               INDEX INCREMENT
         L     R3,FSBBLKTOP            UPPER LIMIT
         LA    R4,FSBBLK1              STARTING ADDR
INCORE   C     R0,@R4                  IS THIS THE DESIRED BLOCK?
         IF    EQUAL,EXIT              BUFFER FOUND IN CORE
         BXLE  R4,R2,INCORE            CONT LOOKING FOR BUF IN CORE
         LA    R14,1                   INDICATE NOT FOUND
         END   ,                       OF NOT ROOT BLOCK
         LTR   R14,R14
         BR    RAR
         EJECT ,
*********************************************************************
* ON ENTRY                                                          *
*       R3 points to the last slot                                  *
*          IF R3 = 0, it is root, so dont move it                   *
*       R4 points to the current slot                               *
* ON EXIT                                                           *
*       R3 points to current slot (R3 = 0 if root block)            *
*       DSK contains the buffer address (not aligned)               *
*********************************************************************
LRUBUF   LABEL ,
         L     DSK,@R4+CFSBBL          GET ADDRESS OF BUFFER
         L     R0,@R4                  | AND BLOCK
         IF    ((R3,NZ),AND,(R3,NE,R4)),BEGIN
         LR    R1,R3                   MOVE THIS TO END OF LIST (LRU)
         SR    R1,R4                   | LENGTH OF SHIFT
         DEX   R1,'MVC @R4(0),@R4+CFSBPL '
         ST    DSK,@R3+CFSBBL          PUT CURRENT BUFFER PTR AT END
         ST    R0,@R3                  | AND BLOCK NUMBER
         END   ,
         BR    RAR
         TITLE 'Return to Common I/O'
COMIO    LABEL ,
         DIRSAV BR,RAR                 SAVE REGS (FBR saved auto)
         L     BR,RQBLBR2              VFIL REGS
         L     WAR,RQBLWAR             |
         BASR  RAR,R14                 OFF TO COMMON
         SPACE 2
         ST    WAR,RQBLWAR             |
         ST    BR,RQBLBR2              |
         DIREST BR,RAR,ADDR=NO         BACK FROM COMMON - SAVE REGS
         REGCH (WAR,8),(CHKR,8)
         L     CHKR,FSBCHKA            RESTORE CHECKPOINT ADDR
         BR    RAR
         TITLE 'Catalog Driver Routines - Entry Look'
*********************************************************************
* On entry: RQBLNAME contains the search key                        *
*             IF R0 = 0: Indicates an account search                *
*             IF R0 = 4: Indicates a file search                    *
*           IF R14 = 0: Only return fixed portions of entries       *
*           IF R14 ^= 0: Variable permits are returned in entry     *
*             copy.                                                 *
*             THEN IF R15 ^ 0: Indicates an attempt to modify an    *
*               entry length (note that this is only valid for      *
*               a permit-included search)                           *
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*        R1  = Address of the requested entry                       *
*        R0  = Size of the entry                                    *
*        RAR = Address to return to after working w/ entry          *
*      IF CC ^ 0                                                    *
*        IF R15 =  4, Entry not found                               *
*        IF R15 = 28, No more room in catalog                       *
*        No subsequent return                                       *
* ON SUBSEQUENT RETURN FROM CALLER:                                 *
*      RAR = Return Address                                         *
*      IF R15 = 0                                                   *
*        The entry was not modified, no rewrite needed              *
*      IF R15 > 0                                                   *
*        The entry was modified but the size of the entry is the    *
*          same, so simply rewrite the block                        *
*      IF R15 < 0                                                   *
*        The entry was modified and the size was changed.           *
*        R1  = Address of new entry (in a buffer)                   *
*        R0  = Size of new entry                                    *
* ON FINAL RETURN TO CALLER:                                        *
*      IF CC = 0                                                    *
*        Action complete                                            *
*      IF CC ^ 0                                                    *
*        IF R15 = 16, Invalid entry size                            *
*        IF R15 = 20, Can't modify entry len w/out MODS mode        *
*        IF R15 = 28, No more room in catalog                       *
*********************************************************************
CATLOOK  CATENT ,
*
         LCALL CATNAME                 SETUP NAME (NO DOTS & LEN)
         CLEAR CHKFLGS                 NEW SEARCH
         IF    (R14,NZ),BEGIN          SET PERMITS = YES
         SET   CHKFPER                 |
         IF    (R15,NZ),BEGIN          SET LEN_MOD = YES
         IF    (FSBCATNLM+FSBCATNIN),BEGIN      Inserts Blocked
         LA    R15,DIRNMR              |
         BAS   R14,CATERROR            |
         END   ,                       OF Inserts Bloked
         SET   CHKFMOD+CHKFINS+CHKFDEL
         END   ,                       OF SET LEN_MOD = YES
         END   ,                       OF SET PERMITS = YES
         LCALL CATSRCH                 LOOK FOR ENTRY
         IF    NZ,BEGIN                ENTRY NOT FOUND
         LA    R15,DIRNFER             RETURN CODE - ACCOUNT NOT FOUND
         BAS   R14,CATERROR
         END   ,                       OF ENTRY NOT FOUND
         ACALL NTRYLOOK
         IF    NZ,CATERROR
         TOCOM ,                       RETURN TO COMMON
         ACALL NTRYLAFT                CALL NEXT IN LIST
         IF    NZ,CATERROR
         TOCOM SAVE=NO
         TITLE 'Catalog Driver Routines - Entry Insert'
*********************************************************************
* On entry: RQBLNAME contains the search key                        *
*             IF R0 = 0: Indicates an account search                *
*             IF R0 = 4: Indicates a file search                    *
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*        R1  = Address of the requested entry                       *
*        R0  = Size of the entry space                              *
*        RAR = Address to return to after working w/ entry          *
*      IF CC ^ 0                                                    *
*        IF R15 =  8, Can't insert duplicate entry                  *
*        IF R15 = 28, No more room in catalog                       *
* ON SUBSEQUENT RETURN FROM CALLER:                                 *
*      RAR = Return Address                                         *
*      R1  = Address of new entry (no change)                       *
*      R0  = Length of new entry                                    *
*      Entry data should be formatted properly                      *
* ON FINAL RETURN TO CALLER:                                        *
*      IF CC = 0                                                    *
*        Insert done                                                *
*      IF CC ^ 0                                                    *
*        IF R15 = 16, Invalid entry size                            *
*********************************************************************
CATINS   CATENT ,
         IF    (FSBCATNLM+FSBCATNIN),BEGIN      Inserts Blocked
         LA    R15,DIRNMR              |
         BAS   R14,CATERROR            |
         END   ,                       OF Inserts Blocked
         LCALL CATNAME                 SETUP NAME (NO DOTS & LEN)
         CLEAR CHKFLGS                 NEW SEARCH
         SET   CHKFMOD+CHKFINS    INDICATE INTENT TO MODIFY ENTRY LEN
         LCALL CATSRCH                 LOOK FOR ENTRY
         IF    ZERO,BEGIN              ENTRY FOUND
         LA    R15,DIRDUPER       ERROR - CAN'T INSERT DUPLICATE ACC
         BAS   R14,CATERROR
         END   ,                       OF ENTRY FOUND
         ACALL NTRYINS                 CALL INSERT
         IF    NZ,CATERROR
         TOCOM ,                       RETURN TO COMMON
         ACALL NTRYIAFT                CALL NEXT IN INSERT
         IF    NZ,CATERROR
         TOCOM SAVE=NO
         TITLE 'Catalog Driver Routines - Entry Delete'
*********************************************************************
* On entry: RQBLNAME contains the search key                        *
*             IF R0 = 0: Indicates an account search                *
*             IF R0 = 4: Indicates a file search                    *
* ON EXIT:                                                          *
*      IF CC = 0                                                    *
*        Delete done                                                *
*      IF CC ^ 0                                                    *
*        IF R15 =  4, Entry not found                               *
*        IF R15 = 12, Can't delete an account with files            *
*        IF R15 = 28, No more room in catalog                       *
*********************************************************************
CATDEL   CATENT ,
         IF    FSBCATNLM,BEGIN    CATALOGUE IN NoLengthModify MODE
         LA    R15,DIRNMR              |
         BAS   R14,CATERROR            |
         END   ,                  OF CATALOGUE IN NoLengthModify MODE
         LCALL CATNAME                 SETUP NAME (NO DOTS & LEN)
         CLEAR CHKFLGS                 NEW SEARCH
         SET   CHKFMOD+CHKFDEL    INDICATE INTENT TO MODIFY ENTRY LEN
         LCALL CATSRCH                 LOOK FOR ENTRY TO DELETE
         IF    ZERO,BEGIN              DELETE ENTRYS HERE
         ACALL NTRYDEL
         IF    NZ,CATERROR
         TOCOM SAVE=NO
         END   ,                       OF DELETE ENTRYS HERE
         BEGIN ,                       ENTRY NOT FOUND
         LA    R15,DIRNFER             |
         BAS   R14,CATERROR
         END   ,                       OF ENTRY NOT FOUND
         TITLE 'Tree List'
*********************************************************************
* On entry to CATLHERE:                                             *
*               The stack follows path to this entry                *
*               IX points to the current entry                      *
*               DSK points to the current buffer                    *
* On entry to CATLNEXT:                                             *
*               The stack follows path to the current entry         *
* For this routine:                                                 *
*               IX points to the entry                              *
*               NOD points to the node which the entry is in        *
*               DSK points to the buffer which the node is in       *
*               QR points to the current stack entry                *
*               CHKSEQA contains the buffer pointer                 *
* Subsequent calls must provide:                                    *
*               CHKSEQA with the current node's buffer pointer      *
*               The top of the search stack with the proper ptrs    *
* On return:                                                        *
*             IF CC = 0                                             *
*               R1/R0 contain the loc/len of the index portion of   *
*                 the next sequential entry.                        *
*               QR provides stack addressability                    *
*               DSK points to the current buffer                    *
*               RQFNNOD indicates if this is first time for this    *
*                 node in the tree traversal.                       *
*             IF CC ^ 0                                             *
*               There are no more entrys in this tree               *
*********************************************************************
         USING NODE,NOD
         USING NTRY,IX
         USING CHKDSTK,QR
CATLHERE DIRSAV RAR
         ST    DSK,CHKSEQA             SAVE BUFFER ADDR
         CLC   NTRYLEN,=&L.AL1(NIL)
         IF    EQ,CATLPOP              END OF LEAF NODE - POP
CATLTHIS LH    MIX,NTRYLEN
         TRESTKAD QR                   ADDR TO TOP OF STACK
         MVC   CHKSTBK,DSKBNUM         SAVE ON STACK - BLOCK #
         LR    PTR,NOD                 | NODE OFFSET
         SR    PTR,DSK                 | |
         STH   PTR,CHKSTNO             | |
         LR    PTR,IX                  | ENTRY OFFSET
         SR    PTR,NOD                 | |
         STH   PTR,CHKSTEO             | | (W/IN NODE)
         CLEAR RQFNNOD                 ASSUME NOT NEW
         IF    ^CHKSTFOLD,BEGIN        IS A NEW NODE
         SET   RQFNNOD                 |
         SET   CHKSTFOLD               | OLD NEXT TIME
         END   ,                       OF IS A NEW NODE
         DIREST RAR
         CLEAR R15                     SET CC
         BASR  RAR,RAR                 RET W/ IX/MIX = LOC/LEN OF NTRY
*
*  Get the next entry in tree using the tree stack
*
CATLNEXT DIRSAV RAR                    SAVE RET
         TRESTKAD QR                   ADDR TO TOP OF STACK
         L     DSK,CHKSEQA             ADDR TO BUFFER
         LH    NOD,CHKSTNO             ADDR TO NODE
         LA    NOD,DSKBLK(NOD)         |
         LH    IX,CHKSTEO              ADDR TO ENTRY
         LA    IX,NODE(IX)             |
         AH    IX,NTRYLEN              NEXT ENTRY ADDRESS (+LEN)
         LR    PTR,IX                  | OFFSET IN NODE
         SR    PTR,NOD                 | |
         STH   PTR,CHKSTEO             |
         IF    NODFLEAF,BEGIN          THIS IS A LEAF ENTRY
         CLC   NTRYLEN,=&L.AL1(NIL)
         IF    EQ,CATLPOP              NEXT ENTRY IS NIL
         B     CATLTHIS
         END   ,                       OF THIS IS A LEAF ENTRY
CATLPUSH LABEL ,
         CHKPUSH ADDRREG=QR,ERR=CATERROR        STACK INCREMENT
         MVC   CHKSTBK(PL),NTRYOFFB
         LA    IX,NODNTRYS-NODE        FIRST ENTRY OFFSET
         STH   IX,CHKSTEO              |
         DREAD CHKSTBK,PTR=SEQ,ERR=CATERROR
         TRESTKAD QR
         LH    NOD,CHKSTNO             NODE ADDRESSABILITY
         LA    NOD,DSKBLK(NOD)         |
         LH    IX,CHKSTEO              FIRST ENTRY OFFSET
         LA    IX,NODE(IX)             |
         IF    NODFLEAF,CATLTHIS       LIST THIS ONE
         B     CATLPUSH                CONTINUE PUSHING
CATLPOP  BEGIN ,                       DECREMENT STACK
         L     DSK,CHKSEQA             BUFFER ADDR
         LH    NOD,CHKSTNO             ADDR TO NODE
         LA    NOD,DSKBLK(NOD)         |
         DECR  PTR,CHKSTKP             DECREMENT STACK POINTER
         IF    (NODFTRT),BEGIN         @ TREE ROOT - EXIT
         DIREST RAR
         LA    R15,1                   INDICATE NO MORE ENTRYS
         LTR   R15,R15                 |
         BR    RAR
         END   ,                       OF @ TREE ROOT - EXIT
         TRESTKAD QR
         END   ,                       OF DECREMENT STACK
         DREAD CHKSTBK,PTR=SEQ,ERR=CATERROR
         TRESTKAD QR
         LH    NOD,CHKSTNO             ADDRESSABILITY TO NODE
         LA    NOD,DSKBLK(NOD)         |
         LH    IX,CHKSTEO              ADDRASSABILITY TO ENTRY
         LA    IX,NODE(IX)             |
         CLC   NTRYLEN,=&L.AL1(NIL)
         IF    EQ,CATLPOP
         B     CATLTHIS
         SPACE 2
         DROP  NOD                     NODE ADDR
         DROP  IX                      NTRY ADDR
         DROP  QR                      CHKDSTK ADDR
         SPACE 2
         LTORG ,
         TITLE 'Setup Name Fields'
* Cannot modify R0, R14, or R15 (MIX, CNT, or PTR)
CATNAME  LABEL ,
*               Name buffer
         MVC   CHKFNAME(2),RQBLNAME    Group - GG
         MVC   CHKFNAME+2(3),RQBLNAME+3         User - UUU
         MVC   CHKFNAME+CNTAMXSZ(CFSBNMSZ),RQBLNAME+CNTAMXSZ+2
         REGCH (IX,1),(DSK,2)
         LA    IX,CHKFNAME+CNTAMXSZ-1  START LOOKING HERE
         LA    DSK,CHKFNAME+L'CHKFNAME | LIMIT
         LOOP  BEGIN                   LOOK FOR BLANK
         INCR  IX
         CLI   @IX,C' '
         UNTIL (EQ,OR,(IX,GE,DSK)),END OF LOOK FOR BLANK
         LA    DSK,CHKFNAME            LENGTH OF NAME
         SR    IX,DSK                  |
         STC   IX,CHKFNMSZ             |
         BR    RAR
         TITLE 'Search Initialization'
*********************************************************************
* On entry: CHKFNAME contains the search key                        *
*             IF R0 = 0: Indicates an account search                *
*             IF R0 = 4: Indicates a file search                    *
*               CHKACCB/N and CHKACSP (traversal stack ptr) set up  *
* On Exit:      The FSB stack contains a trace of the path to the   *
*                 current location in the catalog                   *
*               The CC is set based on the value of R15             *
*                 IF R15 = 0: The entry was found                   *
*                   DSK points to the buffer of the current node    *
*                   NOD points to the entry                         *
*                 IF R15 > 0: The entry was not found               *
*                   DSK points to the buffer of the current node    *
*                   NOD points to the entry which is where the      *
*                       new entry would be.                         *
*                 IF R15 < 0: There are no entrys in this tree      *
*********************************************************************
CATSRCH  DIRSAV RAR
*               Set up FSB flags (Account/File)
         CLEAR CHKFACC+CHKFLEAF        Set Acc/File mode
         IF    (R0,EQ,ACCMODE),'SET CHKFACC '   |
         CLEAR CHKIVLV1                CLR 1ST LEVEL INTENT
*               FSB should already contain I/O block pointers
         IF    CHKFACC,BEGIN           SET UP FOR ACC SEARCH
         CLEAR CHKSTKP                 SEARCH_STACK POINTER
         MVC   CHKAPNT(1),=&L.AL1(NIL) SET POINTERS TO NIL
         MVC   CHKAPNT+1(L'CHKAPNT-1),CHKAPNT   |
         MVC   CHKCURB(PL),CHKROOTB    CUR ADDR(Blk & Offset)
         END   ELSE,BEGIN              SET UP FOR FILE SEARCH
         MVC   CHKSTKP,CHKACSP         STACK PTR := ACC PTR
         MVC   CHKSPNT(1),=&L.AL1(NIL) SET SEARCH PTRS TO NIL
         MVC   CHKSPNT+1(L'CHKSPNT-1),CHKSPNT
         IF    ('CLC CHKACCB(PL),=&L.AL1(NIL)',EQ),BEGIN
         ABORT  CATNILACC,CHKACCB
         END   ,
         DREAD CHKACCB,PTR=ACC,ERR=CATERROR     READ IN ACC BLOCK
         LH    NOD,CHKACCN             ADDR TO ACC ENTRY
         LA    NOD,DSKBLK(NOD)         |
         WITH (NTRY,NOD),'MVC CHKCURB(PL),NTGFLRB '     FILE TREE ROOT
         END   ,                       OF SET UP
*
         TITLE 'Catalog Search'
         CLC   CHKCURB(PL),=&L.AL1(NIL)         NIL TREE
         IF    EQ,BEGIN                |
         L     R15,=A(-1)              |
         B     CATSNONT                |
         END   ,                       OF NIL TREE
         DREAD CHKCURB,PTR=CUR,ERR=CATERROR     READ ROOT BLOCK
         LH    NOD,CHKCURN             GET ROOT OF TREE (CURRENT NODE)
         LA    NOD,DSKBLK(NOD)         |
         USING NODE,NOD           ADDRESSABILITY TO INTERNAL NODES
*
* SEARCH FOR AN ENTRY AND BALANCE ALONG THE WAY
*
TRAVERSE LABEL ,
         IF (CHKFMOD,AND,(NODFEMT+NODFFUL)),BEGIN
         ACALL NODBAL                  BALANCE
         IF    NZ,CATERROR
         END   ,
         IF    NODFLEAF,'SET CHKFLEAF '         INDICATE LEAF LEVEL
* CHOOSE PROPER BRANCH PATH
*   The comparison test relies on the length field being hex 'FFFF',
* the nil value.
         LA    NOD,NODNTRYS       ADDRESSABILITY TO INDIVIDUAL ENTRIES
         DROP  NOD                     NODE ADDR
         USING NTRY,NOD                |
         L     IX,=&L.AL1(NIL)    IX IS ADDRESS OF ENTRY 1 TO THE LEFT
CHOOSE   LABEL ,
         CLC   NTRYLEN,=&L.AL1(NIL)
         IF    EQ,IXFOUND         IF @ END OF LIST, THAT'S THE PTR
         IF    CHKFACC,BEGIN           GET ACCOUNT NAME
         CLC   CHKFNAME(CNTAMXSZ),NTGNAME
         END   ELSE,BEGIN              GET FILE NAME
         LC    QR,NTFLNMSZ             | | LENGTH
         DEX   QR,'CLC CHKFNAME+CNTAMXSZ(0),NTFLNAME '
         IF    EQ,BEGIN                TEST LENGTHS
         LC    QR,CHKFNMSZ             FULL NAME - ACC NAME LEN
         SH    QR,=Y(CNTAMXSZ)         |
         LC    MIX,NTFLNMSZ            FILE NAME LEN
         CR    QR,MIX                  COMPARE LENGTHS
         END   ,                       OF TEST LENGTHS
         END   ,                       OF GET FILE NAME
         IF    EQ,NTFOUND              ENTRY FOUND
         IF    LT,IXFOUND              INDEX FOUND
*        GET NEXT ENTRY IN NODE
         LR    IX,NOD                  ENTRY 1 TO THE LEFT
         LH    PTR,NTRYLEN             | LENGTH OF THIS ENTRY
         LA    NOD,NTRY(PTR)           | ADDRESS OF NEXT
         B     CHOOSE                  | CONTINUE LOOKING
IXFOUND  IF    CHKFLEAF,NTNOTFND
*
* Advance current node to offspring, updating search pointers
         WITH  (CHKDSTK,QR),BEGIN      ADD TO STACK
         CHKPUSH ADDRREG=QR,ERR=CATERROR
         MVC   CHKSTBK(PL),CHKCURB     | BLK AND NODE OFFSET
         LR    PTR,NOD                 | ENTRY OFFSET
         SR    PTR,DSK                 | |
         SH    PTR,CHKCURN             | |
         STH   PTR,CHKSTEO             | |
         END   ,                       OF ADD TO STACK
         MVC   CHKPARP,CHKCURP         PARENT ADDR
         MVC   CHKCURB(PL),NTRYOFFB
         CLC   CHKCURB(PL),=&L.AL1(NIL)         PROCESS NIL ENTRY
         IF    EQ,BEGIN                |
         ABORT  CATSRCH
         END   ,                       OF NIL ENTRY PROCESSING
         DROP  NOD                     NTRY ADDR
*
         DREAD CHKCURB,PTR=CUR,ERR=CATERROR
         LH    NOD,CHKCURN             OFFSET ADDRESS IN BLOCK
         LA    NOD,DSKBLK(NOD)         | ADDRESSABILITY (TO NODE)
         B     TRAVERSE
*
* Entry found
NTFOUND  CLEAR R15                     THIS ENTRY FOUND
         B     CATSRET                 |
NTNOTFND LA    R15,1                   THIS ENTRY NOT FOUND
CATSRET  LABEL ,
         WITH  (CHKDSTK,QR),BEGIN      ADD TO STACK
         CHKPUSH ADDRREG=QR,ERR=CATERROR
         MVC   CHKSTBK(PL),CHKCURB     | BLK AND NODE OFFSET
         LR    IX,NOD                  | ENTRY OFFSET
         SR    IX,DSK                  | |
         SH    IX,CHKCURN              | |
         STH   IX,CHKSTEO              | | (W/IN NODE)
         END   ,                       OF ADD TO STACK
CATSNONT MVC   CHKNTA,CHKCURA          ENTRY POINTERS
         MVC   CHKNTB(PL),CHKCURB      | (BLOCK)
         CLC   CHKNTB(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                ENTRY NOT NIL
         LR    IX,NOD                  | (OFFSET)
         SR    IX,DSK                  | |
         STH   IX,CHKNTN               | |
         END   ,                       OF ENTRY NOT NIL
         IF    CHKFACC,BEGIN           SAVE ACC NTRY PTRS
         IF    (R15,ZERO),BEGIN        ACC FOUND
         MVC   CHKACCP,CHKNTP          ACC PTRS := ENTRY PTRS
         MVC   CHKACSP,CHKSTKP         STACK POINTER
         END   ,                       OF ACC FOUND
         ELSE  BEGIN                   ACC NOT FOUND
         MVC   CHKACCA,=&L.AL1(NIL)
         MVC   CHKACCB(PL),=&L.AL1(NIL)
         MVC   CHKACSP,=&L.AL1(NIL)
         END   ,                       OF ACC NOT FOUND
         END   ,                       OF SAVE ACC NTRY PTRS
         DIREST RAR
         LTR   R15,R15                 SET CC
         BR    RAR                     RETURN
         SPACE 2
         TITLE 'Catalog Driver Routines - Error and Exit'
**
CATERROR IF    (R15,EQ,DIRNMR),BEGIN
         ACALL CATNMR
         IF    NZ,NILERR
         LA    R15,DIRNMR              NO MORE ROOM
         END   ,
         ELSEIF (R15,GT,DIRNMR),BEGIN  R14=PSW, R15=ERROR CODE
NILERR   LABEL ,
         ABORT  VCAT
         END   ,
         B     DIRCOM             RETURN TO VFIL's COMMON ROUTINES
DIRCOMSV ST    FBR,RQBFBR2        SAVE ENVIRONMENT (Thanks Greenpeace)
         ST    RAR,RQBRTN2
DIRCOM   DIREST FBR,RAR                RESTORE COMMON RTN REGS
         L     BR,RQBLBR2              |
         L     WAR,RQBLWAR             |
         LR    QR,R1                   MAKE QR POINT TO ENTRY
         LTR   R15,R15
         BR    RAR
         SPACE 4
CATCONT  LR    R1,QR                   RESTORE ENTRY PTR
         L     RAR,RQBRTN2             GET CONTINUE REGS BACK
         L     FBR,RQBFBR2             |
         REGCH (WAR,8),(CHKR,8)
         L     CHKR,FSBCHKA            RESTORE CHECKPOINT ADDR
         BR    RAR
         EJECT ,
*
*  CATALOG I/O ERROR ROUTINES
*
*        Because -- MIKEY SAID SO
CATRDERR ABORT  CATRDER,RQBLR1,RQBLR14,(RQBR)
*
CATWRERR LABEL
* -->D   QSNAP @R14,255                THE BLOCK IN ERROR
* -->D   QSNAP @R14+256,255            THE BLOCK IN ERROR
* -->D   QSNAP @R14+512,255            THE BLOCK IN ERROR
* -->D   QSNAP @R14+768,255            THE BLOCK IN ERROR
* -->D   QSNAP @R14+1024,255           THE BLOCK IN ERROR
* -->D   QSNAP @R14+1280,255           THE BLOCK IN ERROR
* -->D   QSNAP @R14+1536,255           THE BLOCK IN ERROR
* -->D   QSNAP @R14+1792,255           THE BLOCK IN ERROR
         ABORT CATWRER,RQBLR1,RQBLR14,(RQBR)
         LTORG ,
         TITLE 'Rename File'
*********************************************************************
* On entry: RQBLNAME contains the old search key                    *
*           RQBLRNAM contains the new search key                    *
*             IF R0 = 0: Indicates an account search                *
*             IF R0 = 4: Indicates a file search                    *
*                 Renaming accounts is not valid.  Neither is       *
*               renaming files across accounts.  Therefore          *
*               the first call to rename a file should be CATLOOK   *
*               for the account entry, and then call CATRENAM       *
*                 It is assumed that the case of renaming across    *
*               account boundaries has already been checked on      *
*               entry.                                              *
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*        Rename is done                                             *
*      IF CC ^ 0                                                    *
*        IF R15 =  4, Entry not found                               *
*        IF R15 =  8, Can't insert duplicate entry                  *
*        IF R15 = 24, Can't rename accounts                         *
*        IF R15 = 28, No more room in catalog                       *
*********************************************************************
CATRENAM CATENT ,
         BASE  FBR
         IF    (FSBCATNLM+FSBCATNIN),BEGIN      Inserts Blocked
         LA    R15,DIRNMR              |
         BAS   R14,CATERROR            |
         END   ,                       OF Inserts Blocked
         LCALL CATNAME                 SETUP NAME (NO DOTS & LEN)
*
         AIF   (&CHKOFF).RENCHK
         IF    (R0,NE,FILEMODE),BEGIN  Can't Rename Accounts
         LA    R15,DIRRENAC            |
         BAS   R14,CATERROR            |
         END   ,                       Of Can't Rename Acc
*
.RENCHK  ANOP  ,
         XC    RQBLNAME(L'RQBLNAME),RQBLRNAM    Exchange RQBL Names
         XC    RQBLRNAM(L'RQBLRNAM),RQBLNAME    |
         XC    RQBLNAME(L'RQBLNAME),RQBLRNAM    |
*
         XC    CHKFNMSZ(L'CHKFNAME+1),CHKFRNMS  Exchange Len & Name
         XC    CHKFRNMS(L'CHKFRNAM+1),CHKFNMSZ  |
         XC    CHKFNMSZ(L'CHKFNAME+1),CHKFRNMS  |
         LCALL CATNAME
         CLEAR CHKFLGS                 New Search
         LCALL CATSRCH                 Look for new entry
         IF    ZERO,BEGIN              New File Exists
         LA    R15,DIRDUPER            |
         BAS   R14,CATERROR            |
         END   ,                       Of New File Exists
         XC    CHKFNMSZ(L'CHKFNAME+1),CHKFRNMS  Exchange Len & Name
         XC    CHKFRNMS(L'CHKFRNAM+1),CHKFNMSZ  |
         XC    CHKFNMSZ(L'CHKFNAME+1),CHKFRNMS  |
         CLEAR CHKFLGS                 New search
         DREAD CHKACCB,PTR=ACC,ERR=CATERROR     Read ACC entry node
         SET   CHKFMOD+CHKFPER+CHKFDEL Show me the whole entry
         LA    R0,FILEMODE             R0 indicates File
         LCALL CATSRCH                 Look for old entry
         IF    NZ,BEGIN                Old entry not found
         LA    R15,DIRNFER             |
         BAS   R14,CATERROR            |
         END   ,                       Of Old entry not found
         ACALL NTRYLOOK                Get Entry copy
         IF    NZ,CATERROR             |
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         LA    CNT,CHKIRNT             ADDR OF RENAME BUFFER
         LR    PTR,MIX                 | (LEN)
         LR    MIX,IX                  ADDR OF OLD NTRY BUFFER
         LR    IX,PTR                  | (LEN)
         MVCL  CNT,MIX                 COPY ENTRY
         L     DSK,CHKNTA              ENTRY BUFFER ADDRESS
         LH    NOD,CHKNTN              ENTRY ADDRESS
         LA    NOD,DSKBLK(NOD)         |
*
         MVI   CHKI3TYP,CCHKREN        Indicate Rename
         MVC   CHKIERAB(PL),CHKACCB    ACCOUNT info
         MVC   CHKIERAS,CHKACSP        | Stack ptr
         MVC   CHKIERCB(PL),CHKCURB    CURRENT Node info
         MVC   CHKIERCT,CHKNTN         | Entry offset
         CLEAR CHKIERFL                Clear Rename Flags
         LH    PTR,CHKIERCN            Current node ADDR
         LA    PTR,DSKBLK(PTR)         |
         WITH  (NODE,PTR),BEGIN        |
         IF    NODFLEAF,BEGIN          It's a leaf delete
         SET   RENLEAF                 |
         IF    NODFTRT,BEGIN           Tree root
         IF    (NODNTNUM,EQ,1),'SET RENRTDL '   Will be root delete
         END   ,                       OF Tree root
         END   ,                       OF It's a leaf delete
         END   ,                       OF Current node ADDR
         MVC   CHKIEROS(L'CHKIERON+1),CHKFNMSZ  Old Name & size
         MVC   CHKIERNS(L'CHKIERNN+1),CHKFRNMS  New Name & size
         IWRITE ERR=CATERROR
*
         ACALL NTRYDEL                 DEL OLD NTRY (PTRS OK)
         IF    NZ,CATERROR
         MVC   CHKFNMSZ(L'CHKFNAME+1),CHKIERNS  New name & size
         MVC   CHKFRNMS(L'CHKFRNAM+1),CHKIEROS  Old name & size
         CLEAR CHKFLGS
         SET   CHKFMOD+CHKFINS
         LA    R0,FILEMODE             FIND LOC TO INS
         LCALL CATSRCH                 | (Entry isn't there)
         ACALL NTRYINS                 INSERT ENTRY
         IF    NZ,CATERROR
         REGCH (MIX,0),(IX,1)
         AGO   .NORENAC                DON'T RENAME ACCOUNTS
         LA    CNT,CHKIRNT             ADDR OF RENAME BUFFER
         IF    CHKFACC,BEGIN           ACCOUNT ENTRY
         WITH  (NTRY,CNT),BEGIN        ADDR TO SRC OF RENAME
         LA    NOD,NTGMXSP             LOC
         LA    QR,NTRY                 LEN = TOTAL-BEGIN_LEN
         SR    QR,NOD                  | -(BEGINNING_LEN)
         AR    QR,MIX                  | QR = TOTAL-BEGIN_LEN
         END   ,                       OF ADDR TO SRC OF REN
         WITH  (NTRY,IX),'LA MIX,NTGMXSP '      LOC - FROM NTGMXSP
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         LR    CNT,NOD                 SOURCE OF COPY
         LR    PTR,QR                  | LEN
         LR    IX,QR                   | DEST LEN (MIX = LOC)
         MVCL  MIX,CNT                 COPY RENAME BUFFER
         END   ELSE,BEGIN              FILE ENTRY
.NORENAC ANOP  ,
         WITH  (NTRY,IX),'LA QR,NTFLOC '        DEST OF FIXED RENAME
         LA    CNT,CHKIRNT             SOURCE OF FIXED RENAME
         WITH  (NTRY,CNT),BEGIN        | RENAME BUFFER
         MVC   @QR(NTFLNMSZ-NTFLOC),NTFLOC      COPY FIXED
         LH    MIX,NTRYLEN             OLD LENGTH
         LA    PTR,NTRY                START OF OLD ENTRY
         LA    NOD,NTFLNAME            SRC OF PERMITS
         LC    QR,NTFLNMSZ             |
         LA    CNT,@NOD(QR)            |
         END   ,                       OF ADDR TO SRC OF REN
*                                               PTR = TOTAL-NON_PERMIT
         SR    PTR,CNT                 | -(BEGINNING_LEN)
         AR    PTR,MIX                 | TOTAL-BEGIN_LEN
         WITH  (NTRY,IX),BEGIN         ADDR TO DEST OF PERMITS
         LC    QR,CHKFNMSZ             DEST OF PERMITS
         LA    MIX,NTFLNAME-CNTAMXSZ(QR)        | (QR = FULL NAME LEN)
         END   ,                       OF ADDR TO DEST OF REN
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         LR    IX,PTR                  COPY LENGTHS
         MVCL  MIX,CNT                 COPY RENAME BUFFER
         AGO   .NORENA2                DON'T RENAME ACCOUNTS
         END   ,                       OF FILE ENTRY
.NORENA2 ANOP  ,
*
         LA    IX,CHKINTRY             LOC OF NEW ENTRY
         LA    CNT,CHKIRNT             LEN OF NEW NTRY
         WITH (NTRY,CNT),'LH R0,NTRYLEN '
         LC    PTR,CHKFRNMS            | MINUS OLD NAME LEN
         SR    R0,PTR                  | |
         LC    PTR,CHKFNMSZ            | PLUS NEW NAME LEN
         AR    R0,PTR                  | |
         ACALL NTRYIAFT                INSERT
         IF    NZ,CATERROR
         CLEAR CHKIVLV3                3rd LEVEL INTENT DONE
         IWRITE ERR=CATERROR           |
         TOCOM SAVE=NO
         TITLE 'Sequential Access'
*********************************************************************
*   Sequentially list the whole CATALOG, account and file trees     *
* On entry: FSB buffers are set up                                  *
* ON RETURN TO CALLER:                                              *
*     IF CC = 0                                                     *
*       R1  = Location of entry                                     *
*       R0  = Len of entry                                          *
*       R14 = Type of entry                                         *
*         0 = Account entry                                         *
*         4 = File entry                                            *
*       RQFNNOD indicates whether or not this node is new (ie. the  *
*         first time encountered on the tree traversal)             *
*       CHKSEQA/B/N point to the buffer address, block num and node *
*         offset of the current entry                               *
*       CHKSEQEA/B/N point to the extended buffer address, block    *
*         num and node offset of the current entrys extended data   *
*         if such a field exists                                    *
*     IF CC ^ 0                                                     *
*       IF R15 =  8: No more entrys                                 *
*       IF R15 = 16: No entrys in account tree                      *
*********************************************************************
*NEST,1
CATSEQ   CATENT ,
         BASE  FBR
*               Name buffer
         CLEAR CHKFNAME                LIST ACCOUNTS
         CLEAR CHKFNMSZ                |
         CLEAR CHKFLGS                 NEW SEARCH
         LA    R0,ACCMODE              |
         LCALL CATSRCH                 |
         IF    NNEG,BEGIN              AN ACCOUNT ENTRY FOUND
         LR    IX,NOD                  ADDR TO ENTRY
         LH    NOD,CHKCURN             ADDR TO NODE
         AL    NOD,CHKCURA             |
         LCALL CATLHERE                START LISTING HERE
         WHILE ZERO,BEGIN              MORE ACCOUNT ENTRYS IN TREE
         WITH  (NTRY,NOD)              ENTRY ADDR
         WITH (CHKDSTK,QR),BEGIN       STACK ADDR
         MVC   CHKSEQB(PL),CHKSTBK     POINTERS - BLOCK/NODE
         ST    DSK,CHKSEQA             | BUFFER ADDR
         MVC   CHKACCB,CHKSTBK         NEW ACCOUNT (BLK)
         LH    PTR,CHKSTNO             | ENTRY OFFSET (IN BLK)
         AH    PTR,CHKSTEO             | |
         STH   PTR,CHKACCN             | |
         END   ,                       OF STACK ADDR
         MVC   CHKACSP,CHKSTKP         ACC STACK PTR
         ST    DSK,CHKACCA             |
*               Move whole account entry to buffer
         REGCH (IX,1),(PTR,15)
         LR    NOD,IX                  ADDR TO ENTRY
         ZOT   CHKINTRY,LA:CFSBMXNT    |
         LA    MIX,CHKINTRY            DESTINATION OF COPY OF NODE
         LR    CNT,NOD                 SOURCE OF COPY NODE
         LH    PTR,NTRYLEN             ENTRY LENGTH IN INDEX
         LR    IX,PTR                  LENGTHS TO COPY
         MVCL  MIX,CNT                 COPY
         CLC   NTRYDATB(PL),=&L.AL1(NIL)        EXTENDED DATA AREA
         IF    NE,BEGIN                |
         MVC   CHKSEQEB(PL),NTRYDATB   EXTENDED DATA PTRS
         DREAD CHKSEQEB,PTR=SEQE,ERR=CATERROR   |
         LA    NOD,CHKINTRY            ADDR TO CURRENT ENTRY
         LH    CNT,NTRYDATN            NTRYXTND ADDRESSABILITY
         LA    CNT,DSKBLK(CNT)         |
         WITH  (NTRYXTND,CNT),BEGIN
         LH    PTR,NTRYXLEN            DATA LEN OF EXTENDED DATA AREA
         LA    QR,CNTXFXLN             | FIXED LENGTH OVERHEAD
         SR    PTR,QR                  | |
         LA    CNT,NTRYXPER            SOURCE (ADDR OF CONT PERMITS)
         END   ,                       OF NTRYXTND ADDRESSABILITY
         LH    QR,NTRYLEN              DEST = END OF COPY (ORIG LEN)
         LA    MIX,NTRY(QR)            |
         ALR   QR,PTR                  NEW LEN (IN COPY)
         STH   QR,NTRYLEN              |
         LR    IX,PTR                  LENGTHS TO COPY
         MVCL  MIX,CNT                 COPY
         END   ,                       OF ENTRY HAS EXTENDED DATA AREA
         LA    R1,CHKINTRY             PTRS TO NTRY COPY
         LH    R0,NTRYLEN              | (R1/R0 = ENTRY LOC/LEN)
*
         LA    R14,ACCMODE
         CLEAR R15                     RETURN TO COMMON ROUTINES
         TOCOM ,                       | MORE ACCOUNTS TO COME
         CLEAR CHKFNAME                LIST THIS ACCOUNT'S FILES
         CLEAR CHKFNMSZ                |
         CLEAR CHKFLGS                 NEW SEARCH
         LA    R0,FILEMODE             |
         LCALL CATSRCH                 |
         IF    NNEG,BEGIN              A FILE ENTRY FOUND
         LR    IX,NOD                  ADDR TO ENTRY
         LH    NOD,CHKCURN             ADDR TO NODE
         AL    NOD,CHKCURA             |
         LCALL CATLHERE                START LISTING HERE
         WHILE ZERO,BEGIN              MORE FILE ENTRYS IN TREE
         WITH  (CHKDSTK,QR),BEGIN      STACK ADDR
         MVC   CHKSEQB(PL),CHKSTBK     POINTERS - BLOCK/NODE
         ST    DSK,CHKSEQA             | BUFFER
         END   ,                       OF STACK ADDR
         REGCH (IX,1),(PTR,15)
         LR    NOD,IX                  ADDR TO ENTRY
         ZOT   CHKINTRY,LA:CFSBMXNT    CLEAR ENTRY COPY SPACE
         LA    MIX,CHKINTRY            DESTINATION OF COPY OF NODE
         LR    CNT,NOD                 SOURCE OF COPY NODE
         LH    PTR,NTRYLEN             ENTRY LENGTH IN INDEX
         LR    IX,PTR                  LENGTHS TO COPY
         MVCL  MIX,CNT                 COPY
         CLC   NTRYDATB(PL),=&L.AL1(NIL)        EXTENDED DATA AREA
         IF    NE,BEGIN                |
         MVC   CHKSEQEB(PL),NTRYDATB   EXTENDED DATA PTRS
         DREAD CHKSEQEB,PTR=SEQE,ERR=CATERROR   |
         LA    NOD,CHKINTRY            ADDR TO CURRENT ENTRY
         LH    CNT,NTRYDATN            NTRYXTND ADDRESSABILITY
         LA    CNT,DSKBLK(CNT)         |
         WITH  (NTRYXTND,CNT),BEGIN
         LH    PTR,NTRYXLEN            DATA LEN OF EXTENDED DATA AREA
         LA    QR,CNTXFXLN             | FIXED LENGTH OVERHEAD
         SR    PTR,QR                  | |
         LA    CNT,NTRYXPER            SOURCE (ADDR OF CONT PERMITS)
         END   ,                       OF NTRYXTND ADDRESSABILITY
         LH    QR,NTRYLEN              DEST = END OF COPY (ORIG LEN)
         LA    MIX,NTRY(QR)            |
         ALR   QR,PTR                  NEW LEN (IN COPY)
         STH   QR,NTRYLEN              |
         LR    IX,PTR                  LENGTHS TO COPY
         MVCL  MIX,CNT                 COPY
         END   ,                       OF ENTRY HAS EXTENDED DATA AREA
         LA    R1,CHKINTRY             PTRS TO ENTRY COPY
         LH    R0,NTRYLEN              | (R1/R0 = ENTRY LOC/LEN)
*
         LA    R14,FILEMODE
         CLEAR R15                     RETURN TO COMMON ROUTINES
         TOCOM ,                       | MORE FILES TO COME
         LCALL CATLNEXT                GET NEXT FILE ENTRY
         END   ,                       OF MORE FILE ENTRYS IN TREE
         END   ,                       OF A FILE ENTRY FOUND
         SET   CHKFACC                 BACK TO ACCOUNT ENTRYS
         TRESTKAD QR                   READ IN ACCOUNT BLOCK
         WITH  (CHKDSTK,QR),BEGIN      STACK ADDR
         DREAD CHKSTBK,PTR=SEQ,ERR=CATERROR     READ ACC BLK
         END   ,                       OF STACK ADDR
         LCALL CATLNEXT                GET NEXT ACCOUNT ENTRY
         END   ,                       OF MORE ACCOUNT ENTRYS IN TREE
         LA    R15,CSEQEND
         END   ,                       OF AN ACCOUNT ENTRY FOUND
         ELSE  'LA R15,CSEQNONT '      NO ACCOUNT ENTRYS IN TREE
         TOCOM SAVE=NO
*NEST,2
         TITLE 'List Entrys'
*********************************************************************
*   Sequentially list a tree ACCOUNT/FILE                           *
* On entry: RQBLNAME contains the search key                        *
*             IF R0 = 0: Indicates an account search                *
*             IF R0 = 4: Indicates a file search                    *
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*       The RQB is formatted according to the RQFCLP flag           *
*       RAR contains the return address to obtain the next entry    *
*      IF CC ^ 0                                                    *
*       IF R15 =  8: No more entrys                                 *
*       IF R15 = 16: No entrys in this tree                         *
*********************************************************************
*NEST,1
DATEDSCT RECORD BEGIN                  DSECT date conversion work
         DC    C'??/??/??'             FMTDATE return area
         END   ,
         SPACE ,
         USING NODE,NOD
         USING NTRY,IX
CATLIS   CATENT ,
         BASE  FBR
         LCALL CATNAME                 SETUP NAME (NO DOTS & LEN)
         CLEAR CHKFLGS                 NEW SEARCH
         LCALL CATSRCH
         IF    NNEG,BEGIN              AN ENTRY FOUND
         LR    IX,NOD                  ADDR TO ENTRY
         LH    NOD,CHKCURN             ADDR TO NODE
         AL    NOD,CHKCURA             |
         LCALL CATLHERE                START LISTING HERE
         WHILE ZERO,BEGIN              MORE ENTRYS IN TREE
         ST    WR,RQBLSPTR             POINT TO TEMP WORK AREA
         L     WR,RQBLWR2              |
         VPUSH ,,L'DATEDSCT,PTR=SR     GET ROOM FOR DATE WORK AREA
         LR    QR,IX                   ADDR TO ENTRY
         WITH  (NTRY,QR),BEGIN         |
         IF    CHKFACC,BEGIN           ACCOUNT ENTRYS/NAMES
         CLEAR (RQBLMXSP,8)            CLEAR ANSWER AREA
         MVC   RQBLNAME(2),NTGNAME     gg
         MVI   RQBLNAME+2,C'.'         The ubiquitous dot
         MVC   RQBLNAME+3(3),NTGNAME+2 uuu
         MVC   RQBLMXSP+1(3),NTGMXSP   SPACE ALLOTMNT (3 BYTES TO 4)
         MVC   RQBLUSSP+1(3),NTGUSSP   SPACE USED (3 BYTES TO 4)
         END   ELSE,BEGIN              FILE ENTRYS/NAMES
         MVI   RQBLNAME,C' '           BLANK NAME BUFFER
         MVC   RQBLNAME+1(L'RQBLNAME-1),RQBLNAME
         MVC   RQBLNAME(4),=C'ORV.'    SHOW IT'S ORVYL FILE, NO JOKE!!
         MVI   RQBLNAME+6,C'.'         The ubiquitous dot
         MVC   RQBLNAME+4(2),CHKFNAME  gg
         MVC   RQBLNAME+7(3),CHKFNAME+2         uuu
         MVI   RQBLNAME+10,C'.'        DOT BETWEEN gg.uuu AND filename
         LC    CNT,NTFLNMSZ
         DEX   CNT,'MVC RQBLNAME+11(0),NTFLNAME '
         IF    RQFCLP,'MVC RQBLCRDT(12),NTFCRDT '       REST AS IS
         ELSE  BEGIN                   RETURN OTHER INFO IF NOT CLP
         BEGIN ,                       FORMAT CREATION DATE
         L4    R0,NTFCRDT              CREATION DATE
         CLEAR R1
         LR    R15,SR                  WORK AREA
         XCALL FMTDATE                 FORMAT IT
         MVC   RQBLCCRD(2),6(R1)       YEAR
         MVC   RQBLCCRD+2(2),0(R1)     MONTH
         MVC   RQBLCCRD+4(2),3(R1)     DAY
         END   ,                       OF FORMAT CREATION DATE
         BEGIN ,                       FORMAT LAST ACCESS DATE
         L4    R0,NTFLSDT              LAST ACCESS DATE
         CLEAR R1
         LR    R15,SR                  WORK AREA
         XCALL FMTDATE                 FORMAT IT
         MVC   RQBLCLSD(2),6(R1)       YEAR
         MVC   RQBLCLSD+2(2),0(R1)     MONTH
         MVC   RQBLCLSD+4(2),3(R1)     DAY
         END   ,                       OF FORMAT LAST ACCESS DATE
         END   ,                       OF RETURN OTHER INFO IF NOT CLP
         END   ,                       OF FILE ENTRYS/NAMES
         END   ,                       OF ADDR TO ENTRY
         CLEAR R15                     RETURN TO COMMON ROUTINES
         VPOP  ,,L'DATEDSCT            POINT TO VFIL/VCAT RQBL STACK
         ST    WR,RQBLWR2              |
         L     WR,RQBLSPTR             |
         TOCOM ,                       | MORE TO COME
         LCALL CATLNEXT                GET NEXT ENTRY
         END   ,                       OF MORE ENTRYS IN TREE
         LA    R15,CSEQEND
         END   ,                       OF AN ENTRY FOUND
         ELSE  'LA R15,CSEQNONT '      NO ENTRYS IN TREE
         TOCOM SAVE=NO
*NEST,2
         DROP  NOD                     NODE ADDR
         DROP  IX                      NTRY ADDR
         LTORG ,
         TITLE 'Entry Look'
*********************************************************************
* ON ENTRY: NOD and DSK contain the entry address and the block     *
*             address in memory of the entry to be examined         *
*           CHKNTB/N/AD, CHKCURB/N/AD, CHKPARB/N/AD, CHKLFTB/N,     *
*             CHKRHTB/N, all contain proper pointers to the current *
*             entry, the current node, its parent, and its left and *
*             right siblings respectively.                          *
* ON FINAL EXIT FROM NTRYLAFT:                                      *
*           Search pointers are still intact                        *
*********************************************************************
         USING NTRY,NOD
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REG ASSUMPTIONS
NTRYLOOK DIRENT FBR,RAR
         REGCH (PTR,15)                Efficiency for ZOT macro
         IF    CHKFMOD,BEGIN           INTENT TO CHANGE LEN
         IF    ('CLC CHKANCH,=&L.AL1(NIL)',EQ),BEGIN    NO ROOM
*                 If both chain anchors are nil, then no more room
*                 The look ahead for free space is done here so
*               that after the first return to the calling routine
*               there won't be a return of No_More_Room.
         LA    R15,DIRNMR              INDICATE - No_More_Room
         BAS   R14,NTIERROR            |
         END   ,                       OF NO ROOM
         END   ,                       OF INTENT TO CHANGE LEN
         ZOT   CHKINTRY,LA:CFSBMXNT    CLEAR COPY SPACE
         LA    MIX,CHKINTRY            DESTINATION OF COPY OF NODE
         LR    CNT,NOD                 SOURCE OF COPY NODE
         IF    CHKFPER,BEGIN           PERMITS REQUIRED TOO
         LH    PTR,NTRYLEN             ENTRY LENGTH IN INDEX
         LR    IX,PTR                  LENGTHS TO COPY
         MVCL  MIX,CNT                 COPY
         CLC   NTRYDATB(PL),=&L.AL1(NIL)        EXTENDED DATA AREA
         IF    NE,BEGIN                |
         MVC   CHKWRKB(PL),NTRYDATB    EXTENDED DATA PTRS
         DREAD CHKWRKB,PTR=WRK,ERR=NTLERROR     |
         LH    NOD,CHKNTN              ADDR TO CURRENT ENTRY
         AL    NOD,CHKNTA              |
         LH    CNT,NTRYDATN            NTRYXTND ADDRESSABILITY
         LA    CNT,DSKBLK(CNT)         |
         WITH  (NTRYXTND,CNT),BEGIN
         LH    PTR,NTRYXLEN       DATA LENGTH OF EXTENDED DATA AREA
         LA    QR,CNTXFXLN             | FIXED LENGTH OVERHEAD
         SR    PTR,QR                  | |
         LA    CNT,NTRYXPER       SOURCE (ADDRESS OF CONTINUED PERMITS)
         END   ,                       OF NTRYXTND ADDRESSABILITY
         LA    IX,CHKINTRY             ADDR TO COPY
         WITH  (NTRY,IX),BEGIN         |
         LH    QR,NTRYLEN         DEST = END OF COPY (ORIGINAL LEN)
         LA    MIX,NTRY(QR)            |
         ALR   QR,PTR                  NEW LEN (IN COPY)
         STH   QR,NTRYLEN              |
         END   ,                       OF ADDR TO COPY
         LR    IX,PTR                  LENGTHS TO COPY
         MVCL  MIX,CNT                 COPY
         END   ,                       OF ENTRY HAS EXTENDED DATA AREA
         LA    R1,CHKINTRY        PTRS TO ENTRY COPY (R1 = ENTRY ADDR)
         WITH  (NTRY,R1),'LH R0,NTRYLEN '       | (R0 = ENTRY SIZE)
         END   ,                       OF PERMITS REQUIRED TOO
         ELSE  BEGIN              ONLY FIXED PORTIONS (+ FILE NAME)
         IF    CHKFACC,'LA IX,L"NTRYGR '
         ELSE  BEGIN              FIXED SIZE OF FILE ENTRY (+ NAME)
         LC    IX,NTFLNMSZ             | NAME SIZE
         LA    IX,L'NTRYFL(,IX)        |
         END   ,                  OF FIXED SIZE OF FILE ENTRY (+ NAME)
         LR    PTR,IX                  LENGTHS TO COPY
         LR    QR,IX                   SAVE LENGTH
         MVCL  MIX,CNT                 COPY
         LA    R1,CHKINTRY        PTRS TO ENTRY COPY (R1 = ENTRY ADDR)
         LR    R0,QR                   | (R0 = ENTRY SIZE)
         END   ,                  OF ONLY FIXED PORTIONS (+ FILE NAME)
         DIREST FBR,RAR
         CLEAR R15                     ALL OK - SET CC
         BR    RAR
*********************************************************************
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*        R1  = Address of the requested entry                       *
*        R0  = Size of the entry                                    *
*        RAR = Address to return to after working w/ entry          *
*      IF CC ^ 0                                                    *
*        R14 conatains the PSW at error detection                   *
*        The 2nd low order byte of R15 indicates the module         *
*          in which the error occured.                              *
*        The low order byte of R15 contains the error code for      *
*          that module.                                             *
*        No subsequent return                                       *
* ON SUBSEQUENT RETURN FROM CALLER:                                 *
*      RAR = Return Address                                         *
*      IF R15 = 0                                                   *
*        The entry was not modified, no rewrite needed              *
*      IF R15 > 0                                                   *
*        The entry was modified but the size of the entry is the    *
*          same, so simply rewrite the block                        *
*      IF R15 < 0                                                   *
*        The entry was modified and the size was changed.           *
*        R0  = Size of new entry                                    *
* ON FINAL RETURN TO CALLER:                                        *
*      IF CC = 0                                                    *
*        Action complete                                            *
*********************************************************************
NTRYLAFT DIRENT FBR,RAR                2ND LIST ENTRY
         IF    (R15,ZERO),NTRYLOOX     NO CHANGES
         IF    (R15,POS),BEGIN         CHANGED, SAME SIZE - REWRITE
         IF    CHKFPER,BEGIN           PERMITS INCLUDED
         LH    R15,CHKNTN              OLD ENTRY ADDRESS
         AL    R15,CHKNTA              |
         WITH  (NTRY,R15),'LH R14,NTRYLEN '     OLD LEN (IN INDEX)
         LA    R1,CHKINTRY             R1 = NEW LOC
         WITH  (NTRY,R1),'LH R0,NTRYLEN '       NEW LEN (TOTAL)
         NTRYCHG DEST=CUR,ERR=NTLERROR ADJUST SPACE IN ENTRY
         END   ,                       OF PERMITS INCLUDED
         ELSE  BEGIN                   PERMITS NOT INCLUDED
         L     DSK,CHKNTA              BUFFER ADDRESS
         SET   DSKFMOD                 | MODIFIED - WRITE IT
         LH    CNT,CHKNTN              LOC OF OLD
         LA    CNT,DSKBLK(CNT)         |
         LA    MIX,CHKINTRY            LOC OF NEW
         IF    CHKFACC,'LA IX,L"NTRYGR '
         ELSE  'LA IX,L"NTRYFL '
         LR    PTR,IX                  LENGTHS TO COPY
         MVCL  CNT,MIX                 COPY
         END   ,                       OF PERMITS NOT INCLUDED
         END   ,                       OF CHANGED, SAME SIZE - REWRITE
         ELSE  BEGIN                   CHANGED, NEW SIZE - REWRITE
         IF    ^CHKFMOD,BEGIN          CAN'T CHANGE LEN W/OUT MODS BIT
         LA    R15,DIRMODLN            |
         BAS   R14,NTLERROR            |
         END   ,                  OF CAN'T CHANGE LEN W/OUT MODS BIT
         LA    IX,CHKINTRY             ADDR TO NEW ENTRY
         WITH  (NTRY,IX),BEGIN         |
         AIF   (&CHKOFF).NTLCHK
         IF    CHKFACC,BEGIN
         LH    PTR,FSBTAXLN            PTR = MAX PERMIT LEN
         LA    CNT,L'NTRYGR            | CNT = ACTUAL NON PERMIT LEN
         SR    PTR,CNT                 |
         END   ELSE,BEGIN
         LH    PTR,FSBTFXLN            PTR = MAX PERMIT LEN
         LA    CNT,L'NTRYFL+CNTFMXSZ
         SR    PTR,CNT                 |
         LC    CNT,NTFLNMSZ            CNT = ACTUAL NON PERMIT LEN
         LA    CNT,@CNT+L'NTRYFL       |
         END   ,
         LCR   QR,CNT                  QR = ACTUAL PERMIT LEN
         AR    QR,R0                   | (Total - Non_Permit)
         IF    ((QR,GT,PTR),OR,(R0,LT,CNT)),BEGIN       INV NTRY SIZE
         LA    R15,DIRNTSZ             ERROR - INVALID ENTRY SIZE
         BAS   R14,NTLERROR
         END   ,                       OF INVALID ENTRY SIZE
.NTLCHK  ANOP  ,
         STH   R0,NTRYLEN              UPDATE COPY'S SIZE FIELD
         END   ,                       OF WITH (NTRY,R1)
         LH    R15,CHKNTN              OLD ENTRY ADDRESS
         AL    R15,CHKNTA              |
         WITH  (NTRY,R15),'LH R14,NTRYLEN '     OLD ENTRY SIZE
         NTRYCHG DEST=CUR,ERR=NTLERROR ADJUST SPACE IN ENTRY
         END   ,                       OF CHANGED, NEW SIZE - REWRITE
*               Finish Checkpoint intentions and write
         IF    (CHKITYPE,NZ),BEGIN     MULTIPLE BLOCKS
         MVC   CHKINTCB(PL),CHKCURB    CURRENT NODE
         MVC   CHKINTCT,CHKNTN         | ENTRY OFFSET
         L     DSK,CHKCURA             PUT IN CLOCK TAG
         MVC   CHKINTCC,DSKTAG         |
         IWRITE ERR=NTLERROR
         IF    ('CLC CHKINTNB(PL),=&L.AL1(NIL)',NE),BEGIN
         DWRITE CHKINTNB,ERR=NTLERROR  WRITE NEW DATA BLOCK
         END   ,                       OF WRITE NEW DATA BLOCK
         END   ,                       OF MULTIPLE BLOCKS
         DWRITE CHKNTB,ERR=NTLERROR    WRITE ENTRY BLOCK
         IF    (CHKITYPE,NZ),BEGIN     MULTIPLE BLOCKS
         IF    (('CLC CHKINTOB(PL),=&L.AL1(NIL)',NE),AND,              *
               (CHKINTOB,NE,CHKINTNB)),BEGIN    WRITE OLD DATA BLK
         DWRITE CHKINTOB,ERR=NTLERROR  WRITE OLD DATA BLOCK
         END   ,                       OF WRITE OLD DATA BLOCK
         CLEAR CHKIVLV1                CLR 1ST LEVEL INTENTIONS; DONE
         IWRITE ERR=NTLERROR           WRITE INTENTIONS DONE
         END   ,                       OF MULTIPLE BLOCKS
NTRYLOOX CLEAR R15
NTLERROR DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         DROP  NOD                     NTRY ADDR
         TITLE 'Entry Insert'
*********************************************************************
* ON ENTRY: CHKCURA/B/N and CHKNTA/B/N contain pointers to entry    *
*             to insert before.                                     *
*           NOD and DSK point to the entry and it's buffer address  *
*             unless the entry is nil.                              *
*********************************************************************
NTRYINS  DIRENT FBR,RAR
***********************************
* Nil tree found                  *
***********************************
         CLC   CHKNTB(PL),=&L.AL1(NIL)
         IF    EQ,BEGIN                NIL TREE FOUND
         USING NODE,NOD
         SET   CHKFLEAF
* Format intentions (1st half, indicate root block later)
         MVI   CHKITYPE,CCHKRTIN       TRANS TYPE (Insert root)
         MVC   CHKIFLG,CHKFLG          FLAGS
         MVC   CHKICHAN,CHKCHAIN       OLD CHAIN PTRS
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         SET ALL ENTRYS TO NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
*
* Allocate a root for the account tree
         IF    CHKFACC,BEGIN
         GETNODE PTRS=CUR,TAG=NICC,ERR=NTIERROR
         LH    NOD,CHKCURN             ADDR TO TREE ROOT
         LA    NOD,DSKBLK(NOD)         |
         SET   NODFTRT+NODFLEAF        TREE ROOT & LEAF LEVEL
         MVC   CHKROOTB(PL),CHKCURB    SAVE THIS AS ROOT
         END   ,                       OF NIL ACCCOUNT TREE FOUND
* Allocate a root for the file tree
         ELSE  BEGIN
         DREAD CHKACCB,LOCK=YES,PTR=ACC,TAG=NIAC,ERR=NTIERROR
         SET   DSKFMOD                 BLOCK WILL BE MOD
         MVC   CHKINIAB(PL),CHKACCB    SET INTENT ACC RT PTRS
         GETNODE PTRS=CUR,TAG=NICC,ERR=NTIERROR
         LH    NOD,CHKCURN             ADDR TO ROOT
         LA    NOD,DSKBLK(NOD)         |
         SET   NODFTRT*NODFLEAF        TREE ROOT & LEAF LEVEL
         LH    IX,CHKACCN              ADDR TO ACCOUNT ENTRY
         AL    IX,CHKACCA              |
         WITH  (NTRY,IX),'MVC NTGFLRB(PL),CHKCURB '
         END   ,                       OF NIL FILE TREE FOUND
         ST    DSK,CHKNTA              ADDRESSABILITY TO FIRST ENTRY
         MVC   CHKNTB,CHKCURB          |
         LH    NOD,CHKCURN             |
         LA    NOD,DSKBLK(NOD)         |
         LA    NOD,NODNTRYS            |
         LR    QR,NOD                  | (OFFSET)
         SR    QR,DSK                  | |
         STH   QR,CHKNTN               | |
         END   ,                       OF NILL TREE (ACC/FILE) FOUND
         DROP  NOD                     NODE ADDR
***********************************
* End of Nil tree found           *
***********************************
         IF    ('CLC CHKANCH,=&L.AL1(NIL)',EQ),BEGIN    NO ROOM
*                 If both chain anchors are nil, then no more room
*                 The look ahead for free space is done here so
*               that after the first return to the calling routine
*               there won't be a return of No_More_Room.
         LA    R15,DIRNMR              INDICATE - No_More_Room
         BAS   R14,NTIERROR            |
         END   ,                       OF NO ROOM
         IF    CHKFACC,BEGIN           SET THIS AS CURRENT ACCOUNT
         MVC   CHKACCP,CHKNTP          |
         MVC   CHKACSP,CHKSTKP         |
         END   ,                       OF SET THIS AS CURRENT ACCOUNT
         ZOT   CHKINTRY,LA:CFSBMXNT    CLEAR COPY SPACE
         LA    R1,CHKINTRY             R1 = ADDR ON RET
         LA    R0,CFSBMXNT             | (R1 = LOC, R0 = LENGTH)
         DIREST FBR,RAR                |
         CLEAR R15                     | (ALL OK)
         BR    RAR                     |
*********************************************************************
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*        R1  = Address of the requested entry                       *
*        R0  = Size of entry space                                  *
*        RAR = Address to return to after working w/ entry          *
*      IF CC ^ 0                                                    *
*        R14 conatains the PSW at error detection                   *
*        The 2nd low order byte of R15 indicates the module         *
*          in which the error occured.                              *
*        The low order byte of R15 contains the error code for      *
*          that module.                                             *
*        No subsequent return                                       *
* ON SUBSEQUENT RETURN FROM CALLER:                                 *
*      RAR = Return Address                                         *
*      R1  = Address of new entry (no change)                       *
*      R0  = Size of new entry                                      *
* ON FINAL RETURN TO CALLER:                                        *
*      IF CC = 0                                                    *
*        Insert done                                                *
*      IF CC ^ 0                                                    *
*        R14 conatains the PSW at error detection                   *
*        The 2nd low order byte of R15 indicates the module         *
*          in which the error occured.                              *
*        The low order byte of R15 contains the error code for      *
*          that module.                                             *
*********************************************************************
NTRYIAFT DIRENT FBR,RAR
*               Limit Entry Size
         AIF   (&CHKOFF).NTICHK
         IF    CHKFACC,BEGIN
         LH    PTR,FSBTAXLN            PTR = MAX PERMIT LEN
         LA    CNT,L'NTRYGR            | CNT = NON PERMIT LEN
         SR    PTR,CNT                 |
         END   ELSE,BEGIN
         LH    PTR,FSBTFXLN            PTR = MAX PERMIT LEN
         LA    CNT,L'NTRYFL+CNTFMXSZ
         SR    PTR,CNT                 |
         LC    CNT,CHKFNMSZ            CNT = NON PERMIT LEN
         LA    CNT,@CNT+L'NTRYFL       |
         END   ,
         LCR   CNT,CNT                 CNT = ACTUAL PERMIT LEN
         AR    CNT,R0                  | (Total - Non_Permit)
         IF    ((CNT,GT,PTR),OR,(R0,NEG)),BEGIN INVALID ENTRY SIZE
         LA    R15,DIRNTSZ             ERROR - INVALID ENTRY SIZE
         BAS   R14,NTIERROR
         END   ,                       OF INVALID ENTRY SIZE
.NTICHK  ANOP  ,
*               Init first part of entry
         WITH  (NTRY,R1),BEGIN
         STH   R0,NTRYLEN              LEN OF COPY (NEW) NODE
         MVC   NTRYOFFB(PL),=&L.AL1(NIL)        NO OFFSPRING YET
         MVC   NTRYDATB(PL),=&L.AL1(NIL)        NO DATA BLOCK YET
         IF    CHKFACC,BEGIN           ACCOUNT MODE
         MVC   NTGNAME(CNTAMXSZ),CHKFNAME  '    PUT ACC NAME IN RECORD
         MVC   NTGFLRB(PL),=&L.AL1(NIL)         ROOT = NIL
         END   ELSE,BEGIN              FILE MODE
         LC    QR,CHKFNMSZ
         SH    QR,=Y(CNTAMXSZ)
         STC   QR,NTFLNMSZ             SAVE FILE NAME & SIZE
         DEX   QR,'MVC NTFLNAME(0),CHKFNAME+CNTAMXSZ '  |
         END   ,                       OF FILE ENTRY
         END   ,                       OF WITH (NTRY,R1)
*
         L     DSK,CHKNTA              ADDRESS OF CURRENT
         SET   DSKFMOD                 CURRENT BLOCK MODIFIED
*               Update entry count in node
         LH    NOD,CHKCURN             ADDRESS OF NODE
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NODE,NOD),'INCR QR,NODNTNUM '
         REGCH (IX,1)
*               Create space in node for entry
         LH    R15,CHKNTN         ADDRESS AT WHICH ENTRY IS TO START
         LA    R15,DSKBLK(R15)         |
         CLEAR R14                     OLD ENTRY LENGTH
         NTRYCHG DEST=CUR,ERR=NTIERROR MAKE ROOM (R1=NEW LOC, R0=LEN)
*               Finish Checkpoint intentions and write
         IF    (CHKITYPE,NZ),BEGIN     MULTIPLE BLOCKS
         MVC   CHKINICB(PL),CHKCURB    CURRENT NODE
         MVC   CHKINICT,CHKNTN         | ENTRY OFFSET
         L     DSK,CHKCURA             PUT IN CLOCK TAG
         MVC   CHKINICC,DSKTAG         |
         IF    (CHKITYPE,NE,CCHKRTIN),BEGIN     REGULAR INSERT
         MVI   CHKITYPE,CCHKNTIN
         END   ,                       OF REGULAR INSERT
         ELSEIF ^CHKFACC,BEGIN         FILE RT INS
         MVC   CHKINIAB(PL),CHKACCB    ACCOUNT ENTRY POINTERS
         END   ,                       OF FILE ROOT INSERT
         IWRITE ERR=NTIERROR
         CLC   CHKININB(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                WRITE NEW DATA BLOCK
         DWRITE CHKININB,ERR=NTIERROR
         END   ,                       OF WRITE NEW DATA BLOCK
         END   ,                       OF MULTIPLE BLOCKS
         DWRITE CHKNTB,ERR=NTIERROR    WRITE ENTRY BLOCK
         IF    (CHKITYPE,NZ),BEGIN     MULTIPLE BLOCKS
         CLC   CHKINIAB(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                WRITE ACC ENTRY BLOCK (FILES)
         DWRITE CHKINIAB,ERR=NTIERROR
         END   ,                       OF WRITE ACC ENTRY BLK (FILES)
         CLEAR CHKIVLV1                CLR 1ST LEVEL INTENTIONS; DONE
         IWRITE ERR=NTIERROR           WRITE INTENTIONS DONE
         END   ,                       OF MULTIPLE BLOCKS
         CLEAR R15
NTIERROR DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Entry Delete'
*********************************************************************
* ON ENTRY: CHKNTB/N/AD contain the block, offset, and buffer       *
*             address of the entry to be deleted                    *
*           CHKCURB/N/AD contain the block, offset, and buffer      *
*             address of the node that contains the entry to be     *
*             deleted                                               *
*           CHKPARB/N/AD contain the block, offset, and buffer      *
*             address of the parent of the node that will have      *
*             the entry deleted from it                             *
*           NOD points to the entry to be deleted                   *
*           DSK points to the buffer of the current entry to be     *
*             deleted                                               *
*           CHKLFTB/N and CHKRHTB/N contain block and offset and    *
*             offset pointers of the left and right siblings of the *
*             node to be deleted                                    *
* ON RETURN TO CALLER:                                              *
*      IF CC = 0                                                    *
*        Delete done                                                *
*      IF CC ^ 0                                                    *
*        R14 conatains the PSW at error detection                   *
*        The 2nd low order byte of R15 indicates the module         *
*          in which the error occured.                              *
*        The low order byte of R15 contains the error code for      *
*          that module.                                             *
*********************************************************************
NTRYDEL  DIRENT FBR,RAR
         IF    CHKFACC,BEGIN           DON'T DEL ACC LEAF W/ FILES
         WITH  (NTRY,NOD),'CLC NTGFLRB,=&L.AL1(NIL) '
         IF    NE,BEGIN                THIS ACC STILL HAS FILES
         LA    R15,DIRDELAC
         BAS   R14,NTDERROR
         END   ,                       OF THIS ACC STILL HAS FILES
         END   ,                       OF DON'T DEL ACC LEAF W/ FILS
         DLOKBUF CHKCURB,ERR=NTDERROR
*                 If an entry is being deleted which is not in a leaf
*               node, then the entry must be replaced by the leftmost
*               entry of the right subtree.
         IF    ^CHKFLEAF,BEGIN         NOT AT LEAF LEVEL
         MVI   CHKITYPE,CCHKNTDL       TRANS TYPE (Entry Delete)
         MVC   CHKIFLG,CHKFLG          FLAGS
         MVC   CHKICHAN,CHKCHAIN       OLD CHAIN POINTERS
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         SET INTENT TO NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
         LH    NOD,CHKNTN              ADDR TO THIS ENTRY
         AL    NOD,CHKNTA              |
         WITH  (NTRY,NOD),BEGIN        ADDR TO ENTRY
         AH    NOD,NTRYLEN        NEXT ENTRY HAS PTRS TO RIGHT SUBTREE
         MVC   CHKWRKB(PL),NTRYOFFB
         END   ,                       OF ADDR TO ENTRY
NTDPUSH  DREAD CHKWRKB,PTR=WRK,ERR=NTDERROR
         LH    NOD,CHKWRKN             ADDR TO NODE
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NODE,NOD),BEGIN        |
         IF    ^NODFLEAF,BEGIN         NOT AT LEAF YET
         LA    NOD,NODNTRYS            ADDR TO ENTRY
         WITH  (NTRY,NOD),BEGIN        |
         MVC   CHKWRKB(PL),NTRYOFFB
         B     NTDPUSH
         END   ,                       OF ADDR TO ENTRY
         END   ,                       OF NOT AT LEAF YET
*
         END   ,                       OF ADDR TO NODE
         MVC   CHKIND2B(PL),CHKWRKB
         DLOKBUF CHKWRKB,TAG=ND2C,ERR=NTDERROR
         LH    NOD,CHKWRKN             ADDR TO NODE
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NODE,NOD),BEGIN        |
         DECR  CNT,NODNTNUM            ONE LESS ENTRY IN THIS NODE
         LA    NOD,NODNTRYS            ADDR TO FIRST ENTRY
         END   ,                       OF ADDR TO NODE
         WITH  (NTRY,NOD),BEGIN        ADDR TO FIRST ENTRY
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         LH    PTR,NTRYLEN             ENTRY LENGTH
         LR    QR,PTR                  | SAVE LEN IN INDEX
         LA    CNT,NTRY                ENTRY ADDRESS
         END   ,                       OF ADDR TO FIRST ENTRY
         LA    MIX,CHKINTRY            DESTINATION ADDRESS
         LR    IX,PTR                  | LENGTH
         MVCL  MIX,CNT            MOVE AMOUNT IN INDEX TO COPY BUFFER
         LA    R1,CHKINTRY             NEW BUFFER (DUMMY)
         CLEAR R0                      | LEN
         LR    R15,NOD                 OLD ADDR
         LR    R14,QR                  | LEN (INDEX ONLY)
*        Delete old leaf entry (Index only)
         NTRYCHG DEST=WRK,DELXTND=NO,ERR=NTDERROR
         LH    NOD,CHKWRKN             ADDR TO NODE
         AL    NOD,CHKWRKA             |
         WITH  (NODE,NOD),BEGIN        |
         IF    NODFEMT,BEGIN           LEAF NODE IS EMPTY
         MVI   CHKI2TYP,CCHKDBAL       Bal leaf after delete
         MVC   CHKIDBAB(PL),CHKACCB    Acc ptr
         MVC   CHKI2FLG,CHKFLG
         MVI   CHKIDBNM,C' '           BLANK BUFFER
         MVC   CHKIDBNM+1(L'CHKIDBNM-1),CHKIDBNM
         LA    IX,NODNTRYS
         WITH (NTRY,IX),BEGIN          ADDR TO ENTRYS
         AH    IX,NTRYLEN              | 2nd entry
         IF    CHKFACC,BEGIN           ACCOUNT ENTRY
         MVC   CHKIDBNM(CNTAMXSZ),NTGNAME
         END   ELSE,BEGIN              FILE ENTRY
         MVC   CHKIDBNM(CNTAMXSZ),CHKFNAME      ACCOUNT NAME
         LC    QR,NTFLNMSZ
         LA    CNT,@QR+CNTAMXSZ
         STC   CNT,CHKIDBSZ
         DEX   QR,'MVC CHKIDBNM+CNTAMXSZ(0),NTFLNAME '
         END   ,                       OF FILE ENTRY
         END   ,                       OF ADDR TO ENTRYS
         END   ,                       OF LEAF NODE IS EMPTY
         END   ,                       OF ADDR TO NODE
         L     DSK,CHKNTA              OLD ENTRY ADDR TO BE DELETED
         LH    R15,CHKNTN              |
         LA    R15,DSKBLK(R15)         |
         WITH  (NTRY,R15),BEGIN        OLD ENTRY LEN
         LH    R14,NTRYLEN             |
         LA    QR,NTRYOFFB             OLD OFFSPRING PTR
         END   ,                       OF OLD ENTRY LEN
         LA    R1,CHKINTRY             NEW ENTRY ADDR
         WITH  (NTRY,R1),BEGIN         NEW ENTRY LEN (INDEX ONLY)
         LH    R0,NTRYLEN              |
         MVC   NTRYOFFB(PL),@QR        NEW_OFFSP_PTR := OLD_OFFSP_PTR
         END   ,                       OF NEW ENTRY LEN (INDEX ONLY)
*        Delete old entry & copy new entry (index part) from leaf
         NTRYCHG DEST=CUR,INSXTND=NO,ERR=NTDERROR
         END   ,                       OF NOT AT LEAF LEVEL
         ELSE  BEGIN                   DELETE OF LEAF ENTRY
         LH    PTR,CHKCURN             ADDR TO CURRENT NODE
         LA    PTR,DSKBLK(PTR)         |
         WITH  (NODE,PTR),BEGIN        ADDR TO NODE
         DECR  CNT,NODNTNUM            ONE LESS ENTRY
         IF    (^NODFACC,AND,(CNT,ZERO),AND,NODFTRT),BEGIN   ROOT DEL
         MVI   CHKITYPE,CCHKRTDL       INDICATE ROOT DELETE
         MVC   CHKIFLG,CHKFLG          FLAGS
         MVC   CHKICHAN,CHKCHAIN       OLD CHAIN POINTERS
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         SET INTENT TO NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
         MVC   CHKINDAB(PL),CHKACCB    ACC NODE ADDRESS
         END   ,                       OF ADDR TO NODE
         END   ,                       OF INDICATE ROOT DELETE
         LA    R1,CHKINTRY             NEW ENTRY ADDRESS (DUMMY)
         CLEAR R0                      | LEN
         LH    R15,CHKNTN              OLD ENTRY ADDRESS
         AL    R15,CHKNTA              |
         WITH  (NTRY,R15),'LH R14,NTRYLEN '
         NTRYCHG DEST=CUR,ERR=NTDERROR DELETE ENTRY
         END   ,                       OF DELETE OF LEAF ENTRY
*               Finish Checkpoint intentions and write
         IF    (CHKITYPE,NZ),BEGIN     MULTIPLE BLOCKS
*               If the transaction is a file root delete, then
*             first write the account entry with it's now nil
*             file tree pointer. Then write the entry's now empty
*             node, and finally the entry's modified data extent
*             if it exists.
*               If the transaction is a delete of a non-leaf
*             entry, then write the replacement entry's leaf
*             node, then the deleted entry's node, and finally
*             the deleted entry's modified data extent.  This
*             protects against a duplication of the replacement
*             entry (from the leaf).
*               The above procedures also insure that any entity
*             will not point to an already deleted item.
         MVC   CHKINDCB(PL),CHKCURB    CURRENT NODE
         MVC   CHKINDCT,CHKNTN         | ENTRY OFFSET
         L     DSK,CHKCURA             PUT IN CLOCK TAG
         MVC   CHKINDCC,DSKTAG         |
         IF    (CHKITYPE,NE,CCHKRTDL),BEGIN     REGULAR DELETE
         MVI   CHKITYPE,CCHKNTDL
         END   ELSE,BEGIN              FILE ROOT DEL
         LH    NOD,CHKCURN             |
         AL    NOD,CHKCURA             |
         WITH  (NODE,NOD),BEGIN        ADDR TO NODE
         RELNODE CHKCURN,NODLEN,CHKCURA,ERR=NTDERROR
         MVC   CHKINDCL,DSKBLINK       SAVE BLOCK LINK
         END   ,                       OF ADDR TO NODE
         DREAD CHKACCB,LOCK=YES,PTR=ACC,TAG=NDAC,ERR=NTDERROR
         SET   DSKFMOD
         LH    NOD,CHKACCN             ADDR TO ACC ENTRY
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NTRY,NOD),BEGIN        |
         MVC   NTGFLRB(PL),=&L.AL1(NIL)         NO MORE FILE TREE
         END   ,                       OF ADDR TO ACC ENTRY
         END   ,                       OF FILE ROOT DEL
         IWRITE ERR=NTDERROR
         CLC   CHKINDAB(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                WRITE ACCOUNT BLOCK
         DWRITE CHKINDAB,ERR=NTDERROR
         END   ,                       OF WRITE ACCOUNT BLOCK
         CLC   CHKIND2B(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                WRITE LEAF NTRY OF DELETE
         DWRITE CHKIND2B,ERR=NTDERROR
         END   ,                       OF WRITE LEAF NTRY
         END   ,                       OF MULTIPLE BLOCKS
         DWRITE CHKCURB,ERR=NTDERROR   WRITE ENTRY BLOCK
         IF    (CHKITYPE,NZ),BEGIN     MULTIPLE BLOCKS
         CLC   CHKINDOB(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                WRITE OLD DATA BLOCK
         DWRITE CHKINDOB,ERR=NTDERROR
         END   ,                       OF WRITE OLD DATA BLOCK
         CLEAR CHKIVLV1                CLR 1ST LEVEL INTENTIONS; DONE
         IWRITE ERR=NTDERROR           WRITE INTENTIONS DONE
         END   ,                       OF MULTIPLE BLOCKS
         IF    (CHKI2TYP,EQ,CCHKDBAL),BEGIN     FINISH 2ND LEVEL INTENT
         IF    CHKFACC,BEGIN           SET UP FOR ACC SEARCH
         MVI   CHKFNMSZ,CNTAMXSZ
         MVC   CHKFNAME(CNTAMXSZ),CHKIDBNM      ENTRY TO LOOK FOR
         LA    R0,ACCMODE              INDICATE ACC
         END   ELSE,BEGIN              SET UP FOR FILE SEARCH
         LC    QR,CHKIDBSZ             ENTRY TO LOOK FOR
         STC   QR,CHKFNMSZ             |
         MVC   CHKFNAME(L'CHKFNAME),CHKIDBNM    (ACC NAME INCLUDED TOO)
         DREAD CHKACCB,PTR=ACC,ERR=NTDERROR
         LA    R0,FILEMODE             INDICATE FILE
         END   ,                       OF SET UP FOR FILE SRCH
         SET   CHKFMOD                 YES, I WANT TO BALANCE
         LCALL CATSRCH                 | NO ERROR RETURNS
         CLEAR CHKIVLV2                CLR 2ND LEVEL INTENTIONS; DONE
         IWRITE ERR=NTDERROR           WRITE INTENTIONS DONE
         END   ,                       OF FINISH 2ND LEVEL INTENT
         CLEAR R15                     SET RETURN CODE - ALL OK
NTDERROR DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Change Entry Size'
*********************************************************************
* ON ENTRY:                                                         *
*           R1  = Location of buffer with entry in it. (NEW)        *
*           R0  = Length of entry in buffer (NEW)                   *
*               IF R0 = 0, it signifies an entry slot being deleted *
*               IF R0 < 0, don't change data extent ptrs of new     *
*                          entry                                    *
*           R15 = Address at which entry currently starts           *
*           R14 = Old entry length (index portion)                  *
*               IF R14 = 0, it signifies a new entry                *
*               IF R14 < 0, don't change data extent ptrs of old    *
*                           entry                                   *
*           CHK2WRA/B/N contain pointers to current node.           *
*           IF this is other that a simple change entry size (ie    *
*             insert root, insert entry, delete entry), then        *
*             CHKITYPE should have been initialized to indicate     *
*             this.                                                 *
* ON RETURN:                                                        *
*           IF CC = 0                                               *
*             Action complete: Intentions formatted if necessary    *
*               Space fields in node updated                        *
*               Rewrites must be done                               *
*           IF CC ^ 0                                               *
*             R14 conatains the PSW at error detection              *
*             The 2nd low order byte of R15 indicates the module    *
*               in which the error occured.                         *
*             The low order byte of R15 contains the error code for *
*               that module.                                        *
*********************************************************************
NTRYCHG  DIRENT FBR,RAR
         SET   CHKFDLXT*CHKFINXT       DEFAULT IS TO MOD XTND PTRS
         CLEAR CHKFXTAV                DEFAULT IS NO AVAIL EXTENDED
         IF    (R14,NEG),'CLEAR CHKFDLXT '      DON'T CHG XTND PTRS
         IF    (R0,NEG),'CLEAR CHKFINXT '       DON'T CHG XTND PTRS
         LPR   R0,R0
         LPR   R14,R14
         ST    R1,CHKBSAD              SAVE ENTRY COPY ADDRESS
         STH   R0,CHKBSLN              | (LEN)
         ST    R15,CHKBDAD             SAVE OLD ENTRY ADDR
         STH   R14,CHKBDLN             | (LEN)
*               Old data extension block
         DLOKBUF CHK2WRB,ERR=NTCERROR  LOCK CURRENT BUFFER
         REGCH (CNT,14),(PTR,15)
         IF    (CHKFDLXT,AND,(CHKBDLN,NZ)),BEGIN        OLD DATA ENTRY
         L     NOD,CHKBDAD             ADDR TO OLD ENT
         WITH  (NTRY,NOD),BEGIN        |
         CLC   NTRYDATB(PL),=&L.AL1(NIL)
         IF    NE,BEGIN                DATA BLOCK EXISTS
         IF    (CHKITYPE,ZERO),BEGIN   SET UP CHECKPOINT
         MVI   CHKITYPE,CCHKNTRY
         MVC   CHKIFLG,CHKFLG
         MVC   CHKICHAN,CHKCHAIN
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         SET INTENT TO NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
         END   ,                       OF SET UP CHECKPOINT
         SET   CHKFXTAV                INDICATE OLD EXTENDED BLK AVAIL
         MVC   CHKINTOB(PL),NTRYDATB   OLD DATA NODE
         MVC   CHKWRKB(PL),NTRYDATB    THIS ENTRY IS WORK ENTRY
         DREAD CHKWRKB,LOCK=YES,PTR=WRK,TAG=NTOC,ERR=NTCERROR
         SET   DSKFMOD                 THIS BLOCK WILL BE MOD
         LH    NOD,CHKWRKN             ADDR TO NTRYXTND
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NTRYXTND,NOD),BEGIN    |
         RELNODE CHKWRKN,NTRYXLEN,(DSK),ERR=NTCERROR
         MVC   CHKINTOL,DSKBLINK       SAVE BLOCK LINK
         MVC   CHKINTOF,DSKFL          | AND FLAGS
         END   ,                       OF ADDRESSABILITY TO NTRYXTND
         END   ,                       OF DATA BLOCK ALREADY EXISTS
         END   ,                       OF ADDR TO OLD ENTRY
         END   ,                       OF OLD DATA ENTRY
*               New data extension block
         IF    CHKFACC,'LH IX,FSBNAMXL '
         ELSE  'LH IX,FSBNFMXL '
         IF    (CHKFINXT,AND,(CHKBSLN,GT,IX)),BEGIN     EXT OVERFLOW
         IF    (CHKITYPE,ZERO),BEGIN   SET UP CHECKPOINT
         MVI   CHKITYPE,CCHKNTRY       TRANSACTION TYPE
         MVC   CHKIFLG,CHKFLG
         MVC   CHKICHAN,CHKCHAIN
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         SET INTENT TO NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
         END   ,                       OF SET UP CHECKPOINT
         IF    CHKFXTAV,'LH PTR,CHKINTOB '      INDICATE OLD AVAIL BLK
         ELSE  'LH PTR,=&L.AL1(NIL) '  | OR NOT AVAILABLE
         GETNODE PTRS=WRK,DATA=(PTR),LOCK=YES,TAG=NTNC,ERR=NTCERROR
         SET   DSKFMOD                 THIS BLOCK WILL BE MOD
         MVC   CHKINTNL,DSKBLINK       SAVE BLOCK LINK
         MVC   CHKINTNF,DSKFL          | AND FLAGS
         LA    NOD,CHKINTRY            COPY ADDRESS
         WITH (NTRY,NOD),'MVC NTRYDATB(PL),CHKWRKB ' DATA EXTENT ADDR
         MVC   CHKINTNB(PL),CHKWRKB    NEW DATA BLOCK IN INTENTIONS
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REG ASSUMPTIONS
         LA    NOD,DSKBLK(R1)          (R1 IS BLOCK OFFSET ON RETURN)
         WITH  (NTRYXTND,NOD),BEGIN    DESTINATION OF MOVE
         LA    MIX,NTRYXPER            |
         END   ,                       OF DESTINATION OF MOVE
         IF    CHKFACC,'LH PTR,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH PTR,FSBNFMXL '      |
         LA    CNT,CHKINTRY            SOURCE OF OVERFLOW COPY
         ALR   CNT,PTR                 |
         LH    IX,CHKBSLN              LENGTH OF COPY
         SR    IX,PTR                  |
         LR    PTR,IX                  | IX & PTR ARE THE LENGTHS
         MVCL  MIX,CNT                 COPY OVERFLOW
         END   ,                       OF EXTEND OVERFLOW
*        If no extend data and change-extended-ptrs-on-insert set
         ELSEIF (CHKFINXT,AND,(CHKBSLN,NZ)),BEGIN
         L     NOD,CHKBSAD             SET NO_DATA_EXTENT
         WITH  (NTRY,NOD),'MVC NTRYDATB(PL),=&L.AL1(NIL) '
         END   ,                       OF NO EXTEND OVERFLOW
*               Change entry size in index
         LH    CNT,CHKBDLN             OLD LENGTH
         LH    QR,CHKBSLN              NEW LENGTH (COPY)
         IF    CHKFACC,'LH IX,FSBNAMXL '
         ELSE  'LH IX,FSBNFMXL '
         CEIL  QR,IX                   LIMIT COPY TO MAX SIZE IN INDEX
         REGCH (CNT,14)                CHECK REG ASSUMPTIONS
         IF    ('SR QR,CNT',NZ),BEGIN  CHANGE ENTRY SIZE IN INDEX
         L     PTR,CHKBDAD             ADDRESS OF OLD ENTRY
         WITH  (NTRY,PTR),BEGIN        |
         LA    CNT,NTRY(CNT)           CNT = START OF OLD FOLLOW NTRYS
         WHILE ('CLC NTRYLEN,=&L.AL1(NIL)',NE),BEGIN    LOOK FOR END
         AH    PTR,NTRYLEN             NEXT ENTRY
         END   ,                       | OF LOOK FOR ENT
         LA    PTR,NTRY+CNODNLLN       PTR = END OF OLD FOLLOW ENTRYS
         END   ,                       OF ADDR TO ENTRYS
*               Collapse entries
         IF    (QR,NEG),BEGIN          COLLAPSE, NEW ENTRY SMALLER
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REG ASSUMPTIONS
         LR    MIX,CNT                 DESTINATION ADDRESS
         AR    MIX,QR                  | (QR IS NEG)
         LR    IX,PTR                  LENGTH
         SR    IX,CNT                  |
         LR    PTR,IX                  |
         MVCL  MIX,CNT                 COLLAPSE
         END   ,                       OF COLLAPSE, NEW ENTRY SMALLER
*               Expand entries
*                 CNT = START OF OLD FOLLOWING ENTRYS
*                 PTR = END OF OLD FOLLOWING ENTRYS (& IS DECR)
         ELSEIF (QR,POS),BEGIN         EXPAND, NEW ENTRY LARGER
         LR    MIX,QR                  MIX = TOT SIZ TO BE MADE AVAIL
         CEIL  QR,256                  QR = LENGTH TO MOVE EACH LOOP
NTRYEXP  LR    IX,PTR                  | REMAIN LENGTH (END - BEGIN)
         SR    IX,CNT                  | |
         IF (IX,LT,QR),'LR QR,IX'      | | DON'T MOVE MORE THAN THERE
         SR    PTR,QR                  PTR = SOURCE
         LR    IX,PTR                  IX = DESTINATION
         ALR   IX,MIX                  |
         DEX   QR,'MVC @IX(0),@PTR '   EXPAND
         INCR  QR
         IF    (PTR,GT,CNT),NTRYEXP    MORE TO MOVE
         LR    QR,MIX                  QR = NET LENGTH CHANGE
         END   ,                       OF EXPAND, NEW ENTRY LARGER
         END   ,                       OF CHANGE ENTRY SIZE IN INDEX
*               Copy main part of entry
         IF    (CHKBSLN,NZ),BEGIN      SOMETHING TO COPY
         L     NOD,CHKBDAD             ADDR TO ENTRY
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REG ASSUMPTIONS
         LR    MIX,NOD                 DESTINATION OF NEW ENTRY
         L     CNT,CHKBSAD             SOURCE (NEW ENTRY)
         LH    IX,CHKBSLN              LENGTH
         IF    CHKFACC,'LH PTR,FSBNAMXL '
         ELSE  'LH PTR,FSBNFMXL '
         CEIL  IX,PTR                  LIMIT TO MAX SIZE IN INDEX
         LR    DSK,IX                  | TEMP SAV OF INDEX SIZE
         LR    PTR,IX                  |
         MVCL  MIX,CNT                 COPY ENTRY
         WITH  (NTRY,NOD),'STH DSK,NTRYLEN '    Max size in index
         END   ,                       OF SOMETHING TO COPY
         L     DSK,CHK2WRA             INDICATE CURRENT BLOCK MODIFIED
         SET   DSKFMOD                 |
         LH    NOD,CHK2WRN             ADDRESSABILITY TO NODE
         LA    NOD,DSKBLK(NOD)         |
         USING NODE,NOD
         LH    IX,NODSPACE             NUMBER OF FREE BYTES
         SR    IX,QR                   | MINUS CHANGE IN ENTRY SIZE
         STH   IX,NODSPACE             | IX = Free space in node
         IF    CHKFACC,BEGIN           ACCOUNT NODE
         LH    MIX,FSBNAXSP            MIX = Max free space in node
         LH    CNT,FSBNANSP            CNT = Min free space in node
         END   ELSE,BEGIN              FILE NODE
         LH    MIX,FSBNFXSP            MIX = Max free space in node
         LH    CNT,FSBNFNSP            CNT = Min free space in node
         END   ,                       OF FILE NODE
         CLEAR NODFEMT+NODFFUL
         IF    (NODFTRT),BEGIN         TREE ROOT
         IF    (NODNTNUM,LT,1),'SET NODFEMT '
         IF    (IX,LT,CNT),'SET NODFFUL '
         END   ELSE,BEGIN              NOT TREE ROOT
         IF    (IX,GT,MIX),'SET NODFEMT '
         IF    (IX,LT,CNT),'SET NODFFUL '
         END   ,                       OF NOT TREE ROOT
         CLEAR R15                     SET CC - OK
NTCERROR DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         DROP  NOD
         LTORG ,
         TITLE 'Get Node'
*********************************************************************
* ON ENTRY: IF R14 = 0: It's an index node being allocated          *
*             Length for index node takes up whole block, which is  *
*             currently the same for account and file nodes.        *
*           IF R14 ^ 0: It's a data node being allocated.           *
*             IF R15 >= 0 it indicates that this data block is in   *
*               memory, and possibly has room for the allocate      *
*             Length for data node is the amount in CHKBSLN         *
*             (copy node length) minus the amount that can fit in   *
*             the index structure, plus space for extended data     *
*             node overhead.                                        *
*           CHKFACC indicates whether the request is for an account *
*             entry or a file entry                                 *
* ON EXIT:  IF CC = 0:                                              *
*             DSK = Buffer address of allocated node                *
*             R0  = Block number of allocated node                  *
*             R1  = Block offset of allocated node                  *
*             NOD = Addressability to allocated node                *
*             IF an index node:                                     *
*               NODLEN, NODNTNUM, NODSPACE, the NODFACC/NODFLEAF    *
*                 flags and the last_entry markers are initialized  *
*             IF a data node:                                       *
*               NTRYXLEN is initialized                             *
*           IF CC ^ 0                                               *
*             R14 conatains the PSW at error detection              *
*             The 2nd low order byte of R15 indicates the module    *
*               in which the error occured.                         *
*             The low order byte of R15 contains the error code for *
*               that module.                                        *
*********************************************************************
*********************************************************************
*   GETNODE assumes that an account node takes up a whole disk      *
* block, and so if a block isn't available, tough, it's an error    *
* on allocation.  Likewise, it assumes that a file node takes up a  *
* whole disk block, and so if a block isn't available, tough again. *
*********************************************************************
GETNODE  DIRENT FBR,RAR
         IF    (R14,NZ),BEGIN          GET A DATA NODE
         IF    (R15,NNEG),BEGIN        POSSIBLE BLOCK IN MEMORY
         IF    ^DSKFDLNK,EXIT          THIS BLOCK WAS EMPTIED
         DREAD (R15),ERR=GNERROR       CHECK OUT THE BLOCK IN MEM
         LH    IX,CHKBSLN              COMPUTE OVERFLOW AMOUNT
         IF    CHKFACC,'LH MIX,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH MIX,FSBNFMXL '      |
         SR    IX,MIX                  |
         LA    MIX,@IX+CNTXFXLN        | ADD SPACE FOR XTEND LEN
         DIRSAV MIX                    SAVE REQUESTED LEN
         ALLOC (DSK),(MIX),ERR=GNERROR TRY TO ALLOC XTND NODE
         DIREST MIX                    RESTORE REQUESTED LEN
         IF    (R15,ZERO),GNDNFORM     ROOM IN CURRENT BLOCK
         END   ,                       OF POSSIBLE BLOCK IN MEMORY
         CLC   CHKNXDB(BL),=&L.AL1(NIL)
         IF    NE,BEGIN                NEXT DATA BLOCK EXISTS
         DREAD CHKNXDB,ERR=GNERROR
         LH    IX,CHKBSLN              COMPUTE OVERFLOW AMOUNT
         IF    CHKFACC,'LH MIX,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH MIX,FSBNFMXL '      |
         SR    IX,MIX                  |
         LA    MIX,@IX+CNTXFXLN        | ADD SPACE FOR XTEND LEN
         DIRSAV MIX                    SAVE REQUESTED LEN
         ALLOC (DSK),(MIX),ERR=GNERROR TRY TO ALLOC XTND NODE
         DIREST MIX                    RESTORE REQUESTED LEN
         IF    (R15,ZERO),GNDNFORM     ROOM IN CURRENT BLOCK
         END   ,                       OF NEXT DATA BLOCK EXISTS
         GETBLOCK ERR=GNERROR          START A NEW BLOCK
         BEGIN ALLOCATE                FROM A NEW BLOCK
         SET   DSKFDATA                WILL BE USED AS A DATA BLOCK
         LH    IX,CHKBSLN              COMPUTE OVERFLOW AMOUNT
         IF    CHKFACC,'LH MIX,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH MIX,FSBNFMXL '      |
         SR    IX,MIX                  |
         LA    MIX,@IX+CNTXFXLN        | ADD SPACE FOR XTEND LEN
         DIRSAV MIX                    SAVE REQUESTED LEN
         ALLOC (DSK),(MIX),ERR=GNERROR ALLOCATE DATA SPACE
         DIREST MIX                    RESTORE REQUESTED LEN
         IF    (R15,NZ),BEGIN          TOO BIG FOR NEW BLOCK!!
         ABORT  CATGETN
         END   ,                       OF TOO BIG FOR NEW BLOCK!!
         END   ,                       OF ALLOCATE FROM A NEW BLOCK
GNDNFORM LABEL ,                       HANDLE BLOCK LINKS AND FLAGS
         IF    (DSKFDLNK),BEGIN        PART OF DATA-LINK
         IF    ((R14,LT,FSBTXXLN),AND,(DSKBLK,EQ,CHKNXDB)),BEGIN
         DIRSAV IX                     SAVE OFFSET IN BLK AND RETURN
         MVC   CHKNXDB,DSKBLINK        DELETE FROM NEXT_DATA CHAIN
         MVC   DSKBLINK,=&L.AL1(NIL)   |
         CLEAR DSKFDLNK                |
GNTST1   LABEL ,                       MUST BE EQUAL TO GNTST2
         AGO   .GTNLOST                Allow to be potentially lost
         IWRITE ERR=GNERROR            INDICATE FREED
.GTNLOST ANOP  ,
GNTST2   LABEL ,                       MUST BE EQUAL TO GNTST1
         DS    0S(GNTST1-GNTST2,GNTST2-GNTST1)  ERROR IF NE
         DWRITE DSKBLK,ERR=GNERROR     -->If chkpnt write, DSK chng
         DIREST IX                     RESTORE BLK OFFSET, RET CODE
         END   ,                       OF TAKE OUT OF DATA-LINK
         END   ,                       OF PART OF DATA LINK
         ELSE  BEGIN                   NOT PART OF DATA LINK
         IF    (R14,GE,FSBTXXLN),BEGIN ROOM FOR MORE
         MVC   DSKBLINK,CHKNXDB        PUT CUR BLK AS HEAD OF LINK
         MVC   CHKNXDB,DSKBNUM         |
         SET   DSKFDLNK                |
         END   ,                       OF ROOM FOR MORE
         END   ,                       OF NOT PART OF DATA LINK
         LA    NOD,DSKBLK(IX)          ADDRESS OF DATA RECORD
         WITH  (NTRYXTND,NOD),'STH MIX,NTRYXLEN '       LEN OF XTND
         END   ,                       OF GET A DATA NODE
         ELSE  BEGIN                   GET AN INDEX NODE
         GETBLOCK ERR=GNERROR          START A NEW BLOCK
         IF    CHKFACC,'LH R0,FSBNALEN '        LEN OF ACC NODE
         ELSE  'LH R0,FSBNFLEN '       | (FILE)
         ALLOC (DSK),(R0),ERR=GNERROR  NODE FOR ROOT
         LA    NOD,DSKBLK(R1)          ADDRESSABILITY TO NEW NODE
         WITH  (NODE,NOD),BEGIN        |
         STH   R0,NODLEN               SAVE SIZE
         LA    PTR,NODNTRYS            ADDRESSABILITY TO ENTRIES
         WITH  (NTRY,PTR),BEGIN        |
         MVC   NTRY(1),=&L.AL1(NIL)    NIL 1ST ENTRY
         MVC   NTRY+1(CNODNLLN-1),NTRY |
         END   ,                       OF ADDRESSABILITY TO ENTRIES
         IF    CHKFACC,BEGIN           INIT A NEW ACCOUNT NODE
         SET   NODFACC
         MVC   NODSPACE,FSBNASPA
         END   ,                       OF INIT A NEW ACCOUNT NODE
         ELSE  BEGIN                   INIT A NEW FILE NODE
         MVC   NODSPACE,FSBNFSPA
         END   ,                       OF INIT A NEW FILE NODE
         END   ,                       OF ADDRESSABILITY TO ENTRIES
         END   ,                       OF GET AN INDEX NODE
         LH    R0,DSKBNUM              BLOCK NUMBER
         CLEAR R15
GNERROR  DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Allocate a new block'
*********************************************************************
* ON ENTRY: Calling routine must have saved the old free block      *
*             pointer its own intentions block before calling this  *
*             routine                                               *
* ON EXIT:  IF CC = 0                                               *
*             R0  = Number of allocated block                       *
*             DSK = Buffer that contains block                      *
*           IF CC ^ 0                                               *
*             R14 conatains the PSW at error detection              *
*             The 2nd low order byte of R15 indicates the module    *
*               in which the error occured.                         *
*             The low order byte of R15 contains the error code for *
*               that module.                                        *
*********************************************************************
GETBLOCK DIRSAV RAR
         IF    ('CLC CHKFREB(BL),=&L.AL1(NIL)',EQ),BEGIN
         LA    R15,DIRNMR
         BAS   R14,GBERROR
         END   ,
         DREAD CHKFREB,ERR=GBERROR
*
         LH    R0,CHKFREB              INIT DISK BLOCK
         MVC   CHKFREB,DSKBLINK        | (POINTER TO NEXT BLOCK)
         DSKINIT (R0),(DSK)            |
*
         LH    R0,DSKBNUM              NEW BLOCK NUMBER
         DECR  QR,CHKFBNO              ONE LESS FREE BLOCK
         IF    (QR,LE,FSBLOGFR),BEGIN  LOGICALLY FULL
         SET   FSBCATNIN               NO MORE INSERTS
         IF    (QR,LE,FSBMNFRE),BEGIN  ROCK BOTTOM FULL
         SET   FSBCATNLM               NO MORE LenMod ACCESS
         END   ,                       OF ROCK BOTTOM FULL
         END   ,                       OF LOGICALLY FULL
         CLEAR R15                     SET RETURN CODE
GBERROR  DIREST RAR
         LTR   R15,R15
         BR    RAR
         TITLE 'Release Node'
*********************************************************************
* ON ENTRY: R1 Must contain the block buffer start address          *
*           R15 Must contain the address (relative to the           *
*                    start of the block) of the area to be linked   *
*           R0 Must contain size of area to be linked               *
*           CHKFACC indicates whether the request is for an account *
*             node or a file node                                   *
* ON EXIT:  DSK = Block buffer start address                        *
*           IF CC = 0                                               *
*             Specified node is released, and corresponding space   *
*               management chains are updated                       *
*           IF CC ^ 0                                               *
*             R14 contains the PSW at error detection               *
*             The 2nd low order byte of R15 indicates the module    *
*               in which the error occured.                         *
*             The low order byte of R15 contains the error code for *
*               that module.                                        *
*********************************************************************
RELNODE  DIRENT FBR,RAR
         DSKFREE ,
         IF    NZ,BEGIN                DSKFREE ERROR
         O     R15,=A(CDIRDFM)         OR IN DSKFREE MODULE NUMBER
         B     RNERROR
         END   ,                       OF DSKFREE ERROR
         IF    (R14,EQ,FSBDAVA),BEGIN  BLOCK IS EMPTY
         CLEAR DSKFDATA                |
*               Empty block not in a linked list
         IF    ^DSKFDLNK,BEGIN
         CLEAR DSKFINIT                FREE = SPACE MGMT NOT INIT
         MVC   DSKBLINK,CHKFREB   LINK BLOCK INTO FREE BLOCK CHAIN
         MVC   CHKFREB,DSKBNUM         |
         INCR  QR,CHKFBNO              | ONE MORE FREE BLOCK
         IF    (QR,GT,FSBMNFRE),BEGIN  ALLOW DELETE ACCESS
         CLEAR FSBCATNLM
         IF    (QR,GT,FSBLOGFR),BEGIN  ALLOW INSERT ACCESS TOO
         CLEAR FSBCATNIN
         END   ,                       OF ALLOW INSERT ACCESS
         END   ,                       OF ALLOW DELETE ACCESS
         END   ,                  OF EMPTY BLOCK NOT IN A LINKED LIST
*               First element of data linked list
         ELSEIF (DSKFDLNK,AND,(DSKBNUM,EQ,CHKNXDB)),BEGIN
         MVC   CHKNXDB,DSKBLINK        TAKEN OUT OF DATA LIST
         CLEAR DSKFDLNK*DSKFINIT       | FREE = SPACE MGMT NOT INIT
         MVC   DSKBLINK,CHKFREB   LINK BLOCK INTO FREE BLOCK CHAIN
         MVC   CHKFREB,DSKBNUM         |
         INCR  QR,CHKFBNO              | ONE MORE FREE BLOCK
         IF    (QR,GT,FSBMNFRE),BEGIN  ALLOW DELETE ACCESS
         CLEAR FSBCATNLM
         IF    (QR,GT,FSBLOGFR),BEGIN  ALLOW INSERT ACCESS TOO
         CLEAR FSBCATNIN
         END   ,                       OF ALLOW INSERT ACCESS
         END   ,                       OF ALLOW DELETE ACCESS
         END   ,                  OF FIRST ELEMENT OF DATA LINKED LIST
         END   ,                       OF BLOCK IS EMPTY
*               If block is not empty and not in linked list already,
*                 link into data block chain
         ELSEIF (DSKFDATA,AND,^DSKFDLNK,AND,(R14,GE,FSBTXXLN)),BEGIN
*          Currently, the only blocks that would have any space left
*        in them are extended data blocks.  Both account and file
*        index nodes take up a whole block.  But it doesn't hurt
*        to check that the block is for extended data anyway.
         MVC   DSKBLINK,CHKNXDB        LINK INTO DATA BLOCK CHAIN
         MVC   CHKNXDB,DSKBNUM         |
         SET   DSKFDLNK                NOW IT'S IN DATA LIST
         END   ,    OF BLOCK NOT EMPTY AND NOT IN LINKED LIST
         CLEAR R15
RNERROR  DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         LTORG ,
         TITLE 'Node Balance'
*********************************************************************
* ON ENTRY:                                                         *
*   NOD, DSK (registers), CHKCURA/B/N and CHKPARA/B/N point to      *
*    the node that caused call and its parent respectively          *
* DURING PROCEDURE:                                                 *
*   CHKNODN contains the number of nodes to work with               *
*   CHKSPAC contains the number of free bytes within those nodes    *
* ON EXIT:                                                          *
*   IF R15 = 0                                                      *
*     FSB pointers point to the parent of the original current      *
*       node as the point to continue searching                     *
*     DSK (register) points to the parent's (now current) buf addr  *
*     NOD (register) points to the parent (now current) node        *
*   IF R15 ^ 0                                                      *
*     R14 conatains the PSW at error detection                      *
*     The 2nd low order byte of R15 indicates the module            *
*       in which the error occured.                                 *
*     The low order byte of R15 contains the error code for         *
*       that module.                                                *
*     If the error is not catastrophic, (like no-more-room), then   *
*       the blocks in the buffer space should be invalidated to     *
*       indicate that they no longer contain the most recent and    *
*       correct copy of those blocks.  Then the routines may        *
*       continue to process other requests                          *
*********************************************************************
         USING NODE,NOD
NODBAL   DIRENT FBR,RAR                BALANCE 1 TO 3 NODES
         MVC   CHKICHAN,CHKCHAIN       OLD CHAIN POINTERS
         CLEAR CHKFLEAF+CHKFLFTU+CHKFRHTU
         CLEAR CHKFBAL+CHKF3BAL
         DLOKBUF CHKCURB,ERR=NBERROR   LOCK IN CURRENT BLOCK
         SET   DSKFMOD                 BLOCK WILL BE MOD
         MVC   CHKBALB(PL),CHKCURB     NODE THAT CAUSED BAL CALL
         LH    NOD,CHKCURN             ADDR TO CURRENT NODE
         LA    NOD,DSKBLK(NOD)         |
         LA    CNT,1                   ONE NODE TO BALANCE SO FAR
         STH   CNT,CHKNODN             |
         MVC   CHKSPAC,NODSPACE        SPACE COUNT IN FIRST NODE
         IF    ^NODFTRT,BEGIN          NOT AT TREE ROOT
         DLOKBUF CHKPARB,ERR=NBERROR
         SET   DSKFMOD                 BLOCK WILL BE MOD
         LH    NOD,CHKPARN             ADDR TO PAR NODE
         LA    NOD,DSKBLK(NOD)         |
         IF    (NODNTNUM,GE,2),'SET CHKF3BAL'   AT LEAST 3 OFFSPRING
         L     QR,=&L.AL1(NIL)         SET ENTRY TO LEFT = <NIL>
         LR    MIX,QR                  | 2 TO LEFT = <NIL> ALSO
         LA    IX,NODNTRYS
         WITH  (NTRY,IX),BEGIN         ADDR TO ENTRYS
NBCLOOK  CLC   NTRYOFFB(PL),CHKCURB
         IF    NE,BEGIN                NOT AT CUR YET
         LR    MIX,QR                  ADV 2ND PREV
         LR    QR,IX                   | AND PREV
         CLC   NTRYLEN,=&L.AL1(NIL)
         IF    EQ,BEGIN                CUR NOT FOUND IN PARENT
         ABORT  CATNOPAR               CUR NOT IN PAR ERROR
         END   ,                       OF CUR NOT FOUND IN PARENT
         AH    IX,NTRYLEN              | AND CURRENT
         B     NBCLOOK
         END   ,                       OF NOT AT CUR YET
         ST    QR,CHKBLPA              Left Parent Address
         CLC   NTRYLEN,=&L.AL1(NIL)
         IF    EQ,BEGIN                CUR IS LAST ENTRY
         IF    CHKF3BAL,BEGIN     AT LEAST 3 SIBLING NODES IN BALANCE
         MVC   CHKRHTP,CHKCURP         MAKE CURRENT RIGHT
         LR    IX,QR                   MAKE CUR 1 TO LEFT
         LR    QR,MIX                  MAKE LFT 2 TO LEFT
         MVC   CHKCURB(PL),NTRYOFFB
         ST    QR,CHKBLPA              Left Parent Address
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         DREAD CHKCURB,LOCK=YES,PTR=CUR,ERR=NBERROR
         SET   DSKFMOD                 BLOCK WILL BE MOD
         LH    NOD,CHKCURN             ADDR TO CUR NODE (NEW)
         LA    NOD,DSKBLK(NOD)         |
         SET   CHKFRHTU                INDICATE RIGHT IN BALANCE
         END   ,                  OF AT LEAST 3 SIBLING NODES IN BAL
         ELSE  BEGIN                   NOT AT LEAST 3 IN BAL
         MVC   CHKRHTB(PL),=&L.AL1(NIL)
         END   ,                       OF NOT AT LEAST 3 IN BAL
         END   ELSE,BEGIN              CUR ISN'T LAST ENTRY
         LR    PTR,IX                  ADDR TO NEXT ENTRY
         AH    PTR,NTRYLEN             |
         WITH (NTRY,PTR),'MVC CHKRHTB(PL),NTRYOFFB'
         ST    QR,CHKBLPA              Left Parent Address
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         DREAD CHKRHTB,LOCK=YES,PTR=RHT,ERR=NBERROR
         SET   DSKFMOD                 BLOCK WILL BE MOD
         LH    NOD,CHKRHTN             ADDR TO RIGHT NODE (NEW)
         LA    NOD,DSKBLK(NOD)         |
         SET   CHKFRHTU                INDICATE RIGHT IN BALANCE
         END   ,                       OF CUR ISN'T LAST ENTRY
         IF    CHKFRHTU,BEGIN          RIGHT IN BALANCE
         INCR  CNT,CHKNODN             ONE MORE NODE IN BALANCE
         LH    CNT,CHKSPAC             UPDATE SPACE FIELD FOR BALANCE
         AH    CNT,NODSPACE            |
         STH   CNT,CHKSPAC             |
         END   ,                       OF RIGHT IN BALANCE
         L     IX,CHKBLPA              LEFT PARENT NODE
         C     IX,=&L.AL1(NIL)
         IF    EQ,BEGIN                CUR IS FIRST ENTRY
         IF    CHKF3BAL,BEGIN          AT LEAST 3 NODES IN BALANCE
         MVC   CHKLFTP,CHKCURP         MAKE CUR LEFT
         MVC   CHKCURP,CHKRHTP         MAKE RIGHT CUR
         LH    NOD,CHKPARN             ADDR TO FIRST PAR ENTRY
         AL    NOD,CHKPARA             |
         LA    IX,NODNTRYS             |
         AH    IX,NTRYLEN              RIGHT WILL BE 3RD ENTRY
         AH    IX,NTRYLEN              |
         MVC   CHKRHTB(PL),NTRYOFFB
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         DREAD CHKRHTB,LOCK=YES,PTR=RHT,ERR=NBERROR
         SET   DSKFMOD                 BLOCK WILL BE MOD
         LH    NOD,CHKRHTN             ADDR TO RIGHT NODE (NEW)
         LA    NOD,DSKBLK(NOD)         |
         SET   CHKFLFTU                INDICATE LEFT IN BALANCE
         END   ELSE,BEGIN              NOT AT LEAST 3 NODES IN BALANCE
         MVC   CHKLFTB(PL),=&L.AL1(NIL)
         END   ,                  OF NOT AT LEAST 3 NODES IN BALANCE
         END   ELSE,BEGIN              CUR ISN'T FIRST ENTRY
         MVC   CHKLFTB(PL),NTRYOFFB
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         DREAD CHKLFTB,LOCK=YES,PTR=LFT,ERR=NBERROR
         SET   DSKFMOD                 BLOCK WILL BE MOD
         LH    NOD,CHKLFTN             ADDR TO LEFT NODE (NEW)
         LA    NOD,DSKBLK(NOD)         |
         SET   CHKFLFTU                INDICATE LEFT IN BALANCE
         END   ,                       OF CUR ISN'T FIRST ENTRY
         IF    CHKFLFTU,BEGIN          LEFT IN BALANCE
         INCR  CNT,CHKNODN             ONE MORE NODE IN BALANCE
         LH    CNT,CHKSPAC             UPDATE SPACE FIELD FOR BALANCE
         AH    CNT,NODSPACE            |
         STH   CNT,CHKSPAC             |
         END   ,                       OF LEFT IN BALANCE
         END   ,                       OF ADDR TO ENTRYS
         END   ,                       OF NOT AT TREE ROOT
         TITLE 'Node Balance - New nodes'
*********************************************************************
*   Space needed to avoid split                                     *
*   3 nodes: if central space needed is <= min space of entry       *
*       needed space: (5*max_entry)+(5*max_diff)-2                  *
*   3 nodes: if central space needed is > min space of entry        *
*       needed space: (6*max_entry)+(6*max_diff)-(2*min)-2          *
*   2 nodes: if central space needed is <= min space of entry       *
*       needed space: (3*max_entry)+(2*max_diff)-1                  *
*   2 nodes: if central space needed is > min space of entry        *
*       needed space: (3*max_entry)+(3*max_diff)-1                  *
*********************************************************************
         LH    NOD,CHKCURN             ADDR TO CURRENT
         AL    NOD,CHKCURA             |
         IF    CHKFACC,BEGIN           BALANCING ACCOUNT NODES
         LH    MIX,FSBNAMXL            | MAX LEN OF ACC ENTRY IN NODE
         LA    IX,L'NTRYGR             | MIN LEN OF ACC ENTRY IN NODE
         END   ,                       OF BALANCING ACCOUNT NODES
         ELSE  BEGIN                   BALANCING FILE NODES
         LH    MIX,FSBNFMXL            | MAX LEN OF FILE ENTRY IN NODE
         LA    IX,L'NTRYFL+1           | MIN LEN OF FILE ENTRY IN NODE
         END   ,                       OF BALANCING FILE NODES
         LH    CNT,CHKNODN             NUM OF NODES
         IF    (CNT,EQ,2),BEGIN        2 NODES IN BALANCE
         LR    PTR,MIX                 MAX DIFF
         SR    PTR,IX                  |
         MH    MIX,=Y(3)               NEEDED SPACE (3*max)
         MH    PTR,=Y(3)               | (3*max_diff)
         AR    MIX,PTR                 | (3*max)+(3*max_diff)
         DECR  MIX                     | (3*max)+(3*max_diff)-1
         END   ,                       OF 2 NODES IN BALANCE
         ELSEIF (CNT,EQ,3),BEGIN       3 NODES IN BALANCE
         AGO   .NBNOSP                 NO SPECIAL TESTS YET
         IF    CHKFACC,'LH PTR,FSBNANSP '       SPACE TO FREE
         ELSE  'LH PTR,FSBNFNSP '      | (min free space/node)
         SH    PTR,NODSPACE            |
         IF    (PTR,LE,IX),BEGIN       NEED <= MIN_ENTRY_SIZE SPACE
         LR    PTR,MIX                 MAX DIFF
         SR    PTR,IX                  |
         MH    MIX,=Y(6)               NEEDED SPACE (6*max)
         MH    PTR,=Y(6)               | (6*max_diff)
         AR    MIX,PTR                 | (6*max)+(6*max_diff)
         SH    MIX,=Y(2)               | (6*max)+(6*max_diff)-2
         END   ,                       OF NEED <= MIN_ENTRY_SIZE SPACE
         ELSE  BEGIN                   NEED > MIN_ENTRY_SIZE SPACE
.NBNOSP  ANOP
         LR    PTR,MIX                 MAX DIFF
         SR    PTR,IX                  |
         MH    MIX,=Y(6)               NEEDED SPACE (6*max)
         MH    PTR,=Y(6)               | (6*max_diff)
         MH    IX,=Y(2)                | (2*min)
         AR    MIX,PTR                 | (6*max)+(6*max_diff)
         SR    MIX,IX                  | (6*max)+(6*max_diff)-(2*min)
         SH    MIX,=Y(2)          | (6*max)+(6*max_diff)-(2*min)-2
         AGO   .NBNOSP2                NO SPECIAL TESTS YET
         END   ,                       OF NEED > MIN_ENTRY_SIZE SPACE
.NBNOSP2 ANOP
         END   ,                       OF 3 NODES IN BALANCE
         ELSEIF (CNT,EQ,1),BEGIN       1 NODE IN BALANCE
         IF    CHKFACC,'LH MIX,FSBNANSP '       MIN SPACE IN ONE NODE
         ELSE  'LH MIX,FSBNFNSP '      |
         END   ,                       OF 1 NODE IN BALANCE
         IF    (CHKSPAC,LT,MIX),BEGIN  BALANCE WITH NEW NODES
*
* Split Root Block
         IF    (NODFTRT*NODFFUL),BEGIN SPLIT ROOT BLOCK
         XTRC  RQBR,RQBR,CATBALRS
         INCR  CNT,CHKSTKP             UPDATE STACK PTR - SPLIT OFFSPR
         DDWRITE 1,CHKCURB,ERR=NBERROR Double-write root block
         MVC   CHKPARP,CHKCURP         CURRENT IS NOW PARENT
*               Make first allocated block left sibling
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         GETNODE PTRS=LFT,LOCK=YES,ERR=NBERROR
         SET   CHKFLFTU                INDICATE LEFT NODE IN BALANCE
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         GETNODE PTRS=CUR,LOCK=YES,ERR=NBERROR
         LH    NOD,CHKPARN             ADDR OF ROOT
         AL    NOD,CHKPARA             |
         BEGIN ,                       MOVE ALL BUT LAST TO LEFT
         LA    IX,NODNTRYS             ADDR TO ENTRYS OF ROOT NODE
         LR    MIX,IX                  | MIX = STRT OF ENTRYS
         WITH  (NTRY,IX),BEGIN         |
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         WHILE ('CLC NTRYLEN,=&L.AL1(NIL)',NE),BEGIN    LOOK FOR END
         LR    QR,IX                   QR POINTS TO PREV ENTRY
         AH    IX,NTRYLEN
         END   ,                       OF LOOK FOR END
         END   ,                       OF ADDR TO ENTRYS OF ROOT NODE
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REGS
         ST    MIX,CHKBSAD             SOURCE ADDR
         LR    IX,QR                   | LEN
         SR    IX,MIX                  | |
         STH   IX,CHKBSLN              | |
         LH    NOD,CHKLFTN             ADDR OF LEFT
         AL    NOD,CHKLFTA             |
         LA    CNT,NODNTRYS            DEST (LOC)
         ST    CNT,CHKBDAD             |
         NTRYMOV SRC=PAR,DEST=LFT      MOVE TO LEFT OFFSPRING NODE
         END   ,                       OF MOVE ALL BUT LAST TO LEFT
         BEGIN ,                       MOV 1ST PAR_PTR => LFT_END
         LH    NOD,CHKPARN             1ST PARENT (ROOT) ENTRY ADDR
         AL    NOD,CHKPARA             |
         LA    IX,NODNTRYS             |
         WITH  (NTRY,IX),'LA PTR,NTRYOFFB '
         LH    QR,CHKLFTN              END ENTRY IN LEFT
         AL    QR,CHKLFTA              |
         IF    CHKFACC,'LH CNT,FSBNASPA '
         ELSE  'LH CNT,FSBNFSPA '
         WITH  (NODE,QR),BEGIN         |
         SH    CNT,NODSPACE            |
         LA    QR,NODNTRYS(CNT)        |
         END   ,                       | OF WITH (NODE,QR)
         WITH (NTRY,QR),'MVC NTRYOFFB(PL),@PTR '        LFT_END:=PAR_PT
         WITH (NTRY,IX),'MVC NTRYOFFB(PL),CHKLFTB '     PAR_PTR := LFT
         END   ,                       OF MOV 1ST PAR_PTR => LFT_END
         BEGIN ,                       MOV PAR_END => CUR_END
         WITH (NTRY,IX),BEGIN          ADDR TO PAR ENTRYS
         AH    IX,NODNTRYS             2ND PAR ENTRY
         LA    PTR,NTRYOFFB            | OFFSPRING PTRS
         END   ,                       OF ADDR TO PAR ENTRYS
         LH    QR,CHKCURN              ADDR TO END ENTRY IN CUR NODE
         AL    QR,CHKCURA              |
         WITH (NODE,QR),'LA QR,NODNTRYS '
         WITH (NTRY,QR),'MVC NTRYOFFB(PL),@PTR '        CUR_END:=PAREND
         WITH (NTRY,IX),'MVC NTRYOFFB(PL),CHKCURB '     PAR_END := CUR
         END   ,                       OF MOV PAR_END => CUR_END
         BEGIN ,                       UPDATE PARENT NODE
         IF    NODFLEAF,'SET CHKFLEAF '
         CLEAR NODFFUL+NODFEMT+NODFLEAF
         END   ,                       OF UPDATE PARENT NODE
         BEGIN ,                       UPDATE LEFT NODE
         LH    NOD,CHKLFTN             |
         AL    NOD,CHKLFTA             |
         LH    CNT,NODSPACE            |
         IF    CHKFLEAF,'SET NODFLEAF '
         END   ,                       OF UPDATE LEFT NODE
         BEGIN ,                       UPDATE CURRENT NODE
         LH    NOD,CHKCURN             |
         AL    NOD,CHKCURA             |
         AH    CNT,NODSPACE            |
         IF    CHKFLEAF,'SET NODFLEAF '
         END   ,                       OF UPDATE CURRENT NODE
         STH   CNT,CHKSPAC             TOTAL AVAILABLE BALANCE SPACE
         MVC   CHKNODN,=Y(2)           BALANCE AMONG 2 NODES
         LCALL NBBAL
         MVI   CHKITYPE,CCHKRTSP       INDICATE - Root_Split
         MVC   CHKIFLG,CHKFLG          FLAGS
         MVC   CHKIRSPB(PL),CHKPARB    Parent of split, new root
         MVC   CHKIRSLB(PL),CHKLFTB    Left sibling
         MVC   CHKIRSCB(PL),CHKCURB    Current sibling
         LA    QR,3                    CATALOG BALANCE WRITE OF 3 BLKS
         A     QR,FSBCTBWR             |
         ST    QR,FSBCTBWR             |
         IWRITE ERR=NBERROR
         DWRITE CHKPARB,ERR=NBERROR
         DWRITE CHKLFTB,ERR=NBERROR
         DWRITE CHKCURB,ERR=NBERROR
         CLEAR CHKIVLV1
         IWRITE ERR=NBERROR
         B     NODBALX
         END   ,                       OF SPLIT ROOT BLOCK
         EJECT ,
*
* Balance inner nodes with a new node
*
         XTRC  RQBR,RQBR,CATBALSP
         BEGIN ,                  BALANCE INNER NODES W/ NEW NODES
         IF    (NOT,CHKFRHTU),BEGIN    RIGHT NOT IN BALANCE
         INCR  QR,CHKNODN              ONE MORE NODE FOR BALANCE
         MVC   CHKRHTB(PL),CHKCURB
         MVC   CHKRHTA,CHKCURA
         SET   CHKFRHTU
         END   ,                       OF RIGHT NOT IN BALANCE
         ELSEIF (NOT,CHKFLFTU),BEGIN   LEFT NOT IN BALANCE
         INCR  QR,CHKNODN              ONE MORE NODE FOR BALANCE
         MVC   CHKLFTB(PL),CHKCURB
         MVC   CHKLFTA,CHKCURA
         SET   CHKFLFTU
         END   ,                       OF RIGHT NOT IN BALANCE
*        Release left if it isn't node that caused balance call.
         ELSEIF ('CLC CHKLFTB(PL),CHKBALB',NE),BEGIN
         LH    QR,CHKSPAC              SUBTRACT LEFT SPACE COUNT
         LH    IX,CHKLFTN              | ADDRESSABILITY TO LEFT NODE
         AL    IX,CHKLFTA              | |
         WITH  (NODE,IX),'SH QR,NODSPACE '
         STH   QR,CHKSPAC              | NEW SPACE COUNT IN BAL NODES
         IF    (CHKLFTB,NE,CHKPARB),BEGIN
         IF    (CHKLFTB,NE,CHKCURB),BEGIN
         IF    (CHKLFTB,NE,CHKRHTB),BEGIN
         DRELBUF CHKLFTB,ERR=NBERROR   REL BLK BUFFER IF NOT SHARED
         END   ,
         END   ,
         END   ,
         MVC   CHKLFTP,CHKCURP
         END   ,
*        Release right if left is node that caused balance call.
         ELSE  BEGIN
         LH    QR,CHKSPAC              SUBTRACT LEFT SPACE COUNT
         LH    IX,CHKRHTN              | ADDRESSABILITY TO LEFT NODE
         AL    IX,CHKRHTA              | |
         WITH  (NODE,IX),'SH QR,NODSPACE '
         STH   QR,CHKSPAC              | NEW SPACE COUNT IN BAL NODES
         IF    (CHKRHTB,NE,CHKPARB),BEGIN
         IF    (CHKRHTB,NE,CHKCURB),BEGIN
         IF    (CHKRHTB,NE,CHKLFTB),BEGIN
         DRELBUF CHKRHTB,ERR=NBERROR   REL BLK BUFFER IF NOT SHARED
         END   ,
         END   ,
         END   ,
         MVC   CHKRHTP,CHKCURP
         END   ,
*
* Allocate a new node and balance
         INCR  QR,FSBCTBRD             CATALOG BALANCE READ
         GETNODE PTRS=CUR,LOCK=YES,ERR=NBERROR
         ACALL PARNTRY                 FIND PARENT ENTRYS
         BEGIN ,                       MOVE 1ST RIGHT ENTRY TO PARENT
         LH    NOD,CHKRHTN             ADDR TO RIGHT
         AL    NOD,CHKRHTA             |
         IF    NODFLEAF,'SET CHKFLEAF '
         LA    IX,NODNTRYS             ADDR TO 1ST RIGHT ENTRY
         WITH  (NTRY,IX),BEGIN         |
         LH    PTR,CHKCURN             ADDR TO NIL NTRY OF NEW
         AL    PTR,CHKCURA             |
         WITH (NODE,PTR),'LA PTR,NODNTRYS '     |
         WITH (NTRY,PTR),'LA PTR,NTRYOFFB '     | (NEW_NIL_PTR :=
         MVC   @PTR(PL),NTRYOFFB       |    1ST_RHT_PTR)
         MVC   NTRYOFFB(PL),CHKCURB    | 1ST RHT := NEW
         LH    CNT,CHKSPAC             ADD SPACE OF THIS NTRY
         AH    CNT,NTRYLEN             |
         STH   CNT,CHKSPAC             |
         ST    IX,CHKBSAD              SOURCE OF MOVE
         MVC   CHKBSLN,NTRYLEN         | (LEN)
         MVC   CHKBDAD,CHKBRPA         DEST OF MOVE
         NTRYMOV SRC=RHT,DEST=PAR
         END   ,                       OF ADDR TO 1ST RIGHT ENTRY
         END   ,                  OF MOVE 1ST RIGHT ENTRY TO PARENT
         LH    NOD,CHKCURN             ADDR TO NEW CUR NODE
         AL    NOD,CHKCURA             |
         IF    CHKFLEAF,'SET NODFLEAF '
         LH    QR,CHKSPAC              UPDATE SPACE AVAIL
         AH    QR,NODSPACE             |
         STH   QR,CHKSPAC              |
         LCALL NBBAL                   BALANCE WITH NEW NODE
*
* Write Blocks
         MVI   CHKITYPE,CCHKBINS       INDICATE NODE BALANCE W/ INSERT
         MVC   CHKIFLG,CHKFLG          COPY FLAGS
         MVC   CHKIBIPB(PL),CHKPARB    PARENT ADDRESS
         L     DSK,CHKPARA             | PUT IN CLOCK TAG
         MVC   CHKIBIPC,DSKTAG         |
         MVC   CHKIBILB(PL),CHKLFTB    LEFT NODE ADDRESS
         MVC   CHKIBICB(PL),CHKCURB    CURRENT NODE ADDRESS
         MVC   CHKIBIRB(PL),CHKRHTB    RIGHT NODE ADDRESS
         L     DSK,CHKRHTA             | PUT IN CLOCK TAG
         MVC   CHKIBIRC,DSKTAG         |
         LH    QR,CHKNODN              UPDATE BALANCE WRITE COUNTS
         INCR  QR                      | NUM OF SIBS + PAR
         A     QR,FSBCTBWR             |
         ST    QR,FSBCTBWR             |
         DDWRITE 1,CHKLFTB,ERR=NBERROR Double Write Left
         DDWRITE 2,CHKCURB,ERR=NBERROR Double Write Current
         DDWRITE 3,CHKRHTB,ERR=NBERROR Double Write Right
         IWRITE ERR=NBERROR
         DWRITE CHKPARB,ERR=NBERROR    WRITE PARENT BLOCK
         DWRITE CHKLFTB,ERR=NBERROR    WRITE LEFT BLOCK
         DWRITE CHKCURB,ERR=NBERROR    WRITE CURRENT BLOCK
         DWRITE CHKRHTB,ERR=NBERROR    WRITE RIGHT BLOCK
         CLEAR CHKIVLV1                CLR 1ST LEVEL INTENTIONS; DONE
         IWRITE ERR=NBERROR            | WRITE INTENTIONS DONE
         B     NODBALX
         END   ,                       OF BAL INNER NODES W/ NEW NODES
         END   ,                       OF BALANCE W/ NEW NODES
         TITLE 'Node Balance - Collapse'
*********************************************************************
*   Max space to still avoid collapse =                             *
*    # of nodes * max free space in node (FSBNAXSP,FSBNFXSP)        *
*********************************************************************
         LH    NOD,CHKCURN             ADDR TO CURRENT
         AL    NOD,CHKCURA             |
         IF    CHKFACC,BEGIN           BALANCING ACCOUNT NODES
         LH    IX,FSBNAXSP        | MAX FREE SPACE IN BAL ACC ENTRY
         END   ,                       OF BALANCING ACCOUNT NODES
         ELSE  BEGIN                   BALANCING FILE NODES
         LH    IX,FSBNFXSP        | MAX FREE SPACE IN BAL FILE ENTRY
         END   ,                       OF BALANCING FILE NODES
         LH    MIX,CHKNODN             NUM OF NODES
         REGCH (MIX,0),(IX,1)          CHECK REG PAIR
         MR    MIX,MIX            MAX FREE SPACE IN COMBINED NODES
         USING NTRY,IX
         IF    (CHKSPAC,GT,IX),BEGIN   BALANCE WITH COLLAPSE
         IF    NODFTRT,BEGIN           AN EMPTY ROOT
         IF    ^NODFACC,BEGIN          EMPTY FILE ROOT... ERROR HERE
         ABORT  CATBEFR                Balance_Empty_File_Root Error
         END   ,                  OF EMPTY FILE ROOT... ERROR HERE
         B     NODBALPX                RETURN W/ ADDR TO PAR ALREADY
         END   ,                       OF AN EMPTY ROOT
         LH    NOD,CHKPARN             ADDR TO PARENT
         AL    NOD,CHKPARA             |
* Root Collapse
         IF    (NODNTNUM,EQ,1),BEGIN   ROOT COLLAPSE (ONLY 2 SIBS)
         XTRC  RQBR,RQBR,CATBALRC
         IF    ^CHKFLFTU,BEGIN         INSURE A LEFT/CUR PAIR
         MVC   CHKLFTP,CHKCURP         LFT := CUR
         SET   CHKFLFTU                |
         MVC   CHKCURP,CHKRHTP         CUR := RHT
         MVC   CHKRHTB(PL),=&L.AL1(NIL)         RHT := NIL
         CLEAR CHKFRHTU                |
         END   ,                       OF INSURE A LEFT/CUR PAIR
         LA    IX,NODNTRYS             ADDR TO PAR ENTRY
         ST    IX,CHKBLPA              |
         MVC   CHKBLPL,NTRYLEN         |
         LH    NOD,CHKLFTN             ADDR TO LEFT END
         AL    NOD,CHKLFTA             |
         IF    CHKFACC,'LH CNT,FSBNASPA '       | MAX SPACE
         ELSE  'LH CNT,FSBNFSPA '      | |
         SH    CNT,NODSPACE            |
         LA    PTR,NODNTRYS            |
         ST    PTR,CHKBLAD             | LEFT ADDR
         STH   CNT,CHKBLLN             | (LEN)
         LA    PTR,NODNTRYS(CNT)       | LEFT_END
         WITH (NTRY,PTR),'LA PTR,NTRYOFFB '     | LEFT_END_OFFSPRING
         MVC   NTRYOFFB(PL),@PTR       PAR_PTR := LFT_END_PTR
         AH    IX,NTRYLEN              PAR_END IS NEXT
         LH    NOD,CHKCURN             ADDR TO CUR_END
         AL    NOD,CHKCURA             |
         IF    CHKFACC,'LH CNT,FSBNASPA '       | MAX SPACE
         ELSE  'LH CNT,FSBNFSPA '      | |
         SH    CNT,NODSPACE            |
         LA    PTR,NODNTRYS            | CUR NODE ENTRYS
         ST    PTR,CHKBCAD             | |
         STH   CNT,CHKBCLN             | LEN
         ALR   PTR,CNT                 CUR END
         WITH (NTRY,PTR),'LA PTR,NTRYOFFB '     |
         MVC   NTRYOFFB(PL),@PTR       PAR_END := CUR_END
*               Move entrys
         MVC   CHKBSAD,CHKBCAD         SOURCE
         MVC   CHKBSLN,CHKBCLN         | LEN
         ST    IX,CHKBDAD              DEST (After left par)
         NTRYMOV SRC=CUR,DEST=PAR      MOVE CUR => PAR
         MVC   CHKBSAD,CHKBLAD         SOURCE
         MVC   CHKBSLN,CHKBLLN         | LEN
         MVC   CHKBDAD,CHKBLPA         DEST (LFT_PAR_ADDR)
         NTRYMOV SRC=LFT,DEST=PAR      MOVE LFT => PAR
         LH    NOD,CHKLFTN             RELEASE LEFT NODE
         AL    NOD,CHKLFTA             |
         CLEAR CHKFLEAF                SET IF SIBLING = LEAF
         IF    NODFLEAF,'SET CHKFLEAF '         |
         RELNODE CHKLFTN,NODLEN,CHKLFTA,ERR=NBERROR
         LH    NOD,CHKCURN             RELEASE CURRENT NODE
         AL    NOD,CHKCURA             |
         RELNODE CHKCURN,NODLEN,CHKCURA,ERR=NBERROR
         LH    NOD,CHKPARN             SET PAR AS LEAF
         AL    NOD,CHKPARA             |
         IF    CHKFLEAF,'SET NODFLEAF '         |
         LH    IX,NODSPACE             | IX = Free space
         IF    CHKFACC,BEGIN           ACCOUNT NODE
         LH    MIX,FSBNAXSP            MIX = Max free space in node
         LH    CNT,FSBNANSP            CNT = Min free space in node
         END   ELSE,BEGIN              FILE NODE
         LH    MIX,FSBNFXSP            MIX = Max free space in node
         LH    CNT,FSBNFNSP            CNT = Min free space in node
         END   ,                       OF FILE NODE
         CLEAR NODFEMT+NODFFUL
         IF    (NODFTRT),BEGIN         TREE ROOT
         IF    (NODNTNUM,LT,1),'SET NODFEMT '
         IF    (IX,LT,CNT),'SET NODFFUL '
         END   ELSE,BEGIN              NOT TREE ROOT
         IF    (IX,GT,MIX),'SET NODFEMT '
         IF    (IX,LT,CNT),'SET NODFFUL '
         END   ,                       OF NOT TREE ROOT
         MVI   CHKITYPE,CCHKRTCL       INDICATE ROOT COLLAPSE
         MVC   CHKIFLG,CHKFLG          COPY FLAGS
         MVC   CHKIRCPB(PL),CHKPARB    PARENT ADDRESS
         MVC   CHKIRCLB(PL),CHKLFTB    LEFT NODE ADDRESS
         MVC   CHKIRCCB(PL),CHKCURB    CURRENT NODE ADDRESS
         LA    QR,3                    UPDATE BALANCE WRITE COUNTS
         A     QR,FSBCTBWR             |
         ST    QR,FSBCTBWR             |
*   Intentions not done here.  Worst case, if parent is written first,
* is 2 lost catalog blocks.
*        IWRITE ERR=NBERROR
         DWRITE CHKPARB,ERR=NBERROR
         DWRITE CHKLFTB,ERR=NBERROR    Potential lost block
         DWRITE CHKCURB,ERR=NBERROR    Potential lost block
         CLEAR CHKIVLV1
*        IWRITE ERR=NBERROR
         B     NODBALX
         END   ,                       OF ROOT COLLAPSE
         EJECT ,
*
* Collapse sibling nodes
         XTRC  RQBR,RQBR,CATBALCO
         ACALL PARNTRY                 ADDR TO PAR ENTRYS
         LH    NOD,CHKCURN             RPAR_PTR := CUR_END_PTR
         AL    NOD,CHKCURA             |
         IF    CHKFACC,'LH CNT,FSBNASPA '       |
         ELSE  'LH CNT,FSBNFSPA '      |
         SH    CNT,NODSPACE            |
         STH   CNT,CHKBCLN             | (LEN)
         LA    IX,NODNTRYS(CNT)        | CUR_END
         LA    PTR,NTRYOFFB            | CUR_END_OFFSPRING
         L     IX,CHKBRPA              |
         MVC   NTRYOFFB(PL),@PTR       | PAR_PTR := CUR_END_PT
*
         LH    NOD,CHKLFTN             LPAR_PTR := LFT_END_PTR
         AL    NOD,CHKLFTA             |
         IF    CHKFACC,'LH CNT,FSBNASPA '       |
         ELSE  'LH CNT,FSBNFSPA '      |
         SH    CNT,NODSPACE            |
         LA    IX,NODNTRYS(CNT)        | LEFT_END
         ST    IX,CHKBLAD              | LEFT ADDR
         LA    PTR,NTRYOFFB            | LEFT_END_OFFSPRING
         L     IX,CHKBLPA              |
         MVC   NTRYOFFB(PL),@PTR       | PAR_PTR := LFT_END_PT
*
         MVC   CHKBSAD,CHKBLPA         SOURCE
         MVC   CHKBSLN,CHKBLPL         | LEN
         IF    (NODSPACE,GE,CHKBLPL),BEGIN      PUT LEFT PAR IN LFT
         MVC   CHKBDAD,CHKBLAD         DEST
         NTRYMOV SRC=PAR,DEST=LFT      MOVE LFT_PAR TO LEFT
         LH    NOD,CHKLFTN             SPACE AVAIL IN LFT
         AL    NOD,CHKLFTA             |
         LH    CNT,NODSPACE            | CNT = SPACE AVAIL
         LH    NOD,CHKCURN             ADDR TO CUR ENTRYS
         AL    NOD,CHKCURA             |
         LA    IX,NODNTRYS             |
         LR    MIX,IX                  | START OF CUR ENTRYS
NBCLFUL  LH    QR,NTRYLEN              |
         C     QR,=&L.AL1(NIL)         |
         IF    (NE,AND,(CNT,GE,QR)),BEGIN       ROOM FOR ANOTHER
         SR    CNT,QR                  DECR FREE SPACE
         LA    IX,NTRY(QR)             NEXT ENTRY
         B     NBCLFUL                 Node_Bal_Col_Left_FULl
         END   ,                       OF ROOM FOR ANOTHER
         ST    MIX,CHKBCAD             ADDR OF CURRENT ENTRYS
         SR    IX,MIX                  | LEN
         STH   IX,CHKBCLN              | |
         IF    (CHKBCLN,NZ),BEGIN      MOVE CUR ENTRYS => LFT
         MVC   CHKBSAD,CHKBCAD         SOURCE
         MVC   CHKBSLN,CHKBCLN         | LEN
         L     CNT,CHKBDAD             DEST
         AH    CNT,CHKBLPL             | + LEFT PAR LEN
         ST    CNT,CHKBDAD             |
         NTRYMOV SRC=CUR,DEST=LFT      |
         END   ,                       OF MOV CUR NTRYS => LFT
         END   ,                       OF PUT LEFT PAR IN LFT
         ELSE  BEGIN                   PUT LEFT PAR IN CUR
         LH    NOD,CHKCURN             ADDR TO CUR
         AL    NOD,CHKCURA             |
         IF    (NODSPACE,LT,CHKBLPL),BEGIN      NO ROOM !!!
*                 With collapse, if one node is full (no room for left
*               parent) then the other nodes in balance should have
*               ample room.
         ABORT  CATCOLAP               COLLAPSE LOGICAL ERROR
         END   ,                       OF NO ROOM !!!
         LA    IX,NODNTRYS             DEST
         ST    IX,CHKBDAD              |
         NTRYMOV SRC=PAR,DEST=CUR      MOVE LFT_PAR => CUR
         END   ,                       OF PUT LEFT PAR IN CUR
         MVC   CHKBRPA,CHKBLPA         RHT = OLD LFT PAR PLACE
         SPACE 2
         LH    NOD,CHKCURN             ADDR TO CUR
         AL    NOD,CHKCURA             |
         IF    CHKFACC,'LH CNT,FSBNASPA '       CNT = SPACE USED
         ELSE  'LH CNT,FSBNFSPA '      |
         SH    CNT,NODSPACE            |
         IF    (CNT,POS),BEGIN         STILL SPACE TO MOVE OUT
         LA    IX,NODNTRYS             ADDR TO ENTRYS
         LH    QR,NTRYLEN              NEW PARENT LEN
         ST    IX,CHKBNPA              NEW PARENT ADDRESS
         STH   QR,CHKBNPL              | LEN
         SR    CNT,QR                  SUBTRACT NEW PARENT LEN
         LA    IX,NTRY(QR)             NEW CURRENT ADDR
         ST    IX,CHKBCAD              |
         STH   CNT,CHKBCLN             | LEN (TO MOVE RHT)
         LH    NOD,CHKRHTN             ADDR TO RIGHT
         AL    NOD,CHKRHTA             |
         LH    QR,CHKBRPL              QR = TOTAL TO MOVE RHT
         AR    QR,CNT                  |
         IF    (^CHKFRHTU,OR,(QR,GT,NODSPACE)),BEGIN    CAN'T COLLAPSE
*                 With collapse, if one node is full (no room for left
*               parent) then the other nodes in balance should have
*               ample room.
         ABORT  CATCOLAP               COLLAPSE LOGICAL ERROR
         END   ,                       OF CAN'T COLLAPSE
         LA    IX,NODNTRYS             START OF RIGHT ENTRYS
         ST    IX,CHKBRAD              |
*               Move entrys
         MVC   CHKBSAD,CHKBRPA         SOURCE LOC
         MVC   CHKBSLN,CHKBRPL         | LEN
         MVC   CHKBDAD,CHKBRAD         DEST LOC
         NTRYMOV SRC=PAR,DEST=RHT      MOVE Rht_Par => Rht
         IF    (CHKBCLN,NZ),BEGIN      MOVE Cur_Entrys => Rht
         MVC   CHKBSAD,CHKBCAD         SOURCE LOC
         MVC   CHKBSLN,CHKBCLN         | LEN (SAME DEST)
         NTRYMOV SRC=CUR,DEST=RHT      MOVE Cur_Entrys => Rht
         END   ,                       OF MOVE Cur_Entrys => Rht
         MVC   CHKBSAD,CHKBNPA         SOURCE LOC (New_Par)
         MVC   CHKBSLN,CHKBNPL         | LEN
         MVC   CHKBDAD,CHKBRPA         DEST LOC (Right_Par)
         NTRYMOV SRC=CUR,DEST=PAR      MOVE New_Par => Par
         END   ,                       OF STILL SPACE TO MOVE OUT
*               Change offspring pointers of entrys to be moved
         LH    NOD,CHKLFTN             Lft_End := Rht_Par_Off
         AL    NOD,CHKLFTA             |
         IF    CHKFACC,'LH CNT,FSBNASPA '       |
         ELSE  'LH CNT,FSBNFSPA '      |
         SH    CNT,NODSPACE            |
         LA    IX,NODNTRYS(CNT)        | Left_End
         LA    PTR,NTRYOFFB            | Left_End_Offsp
         L     IX,CHKBRPA              |
         MVC   @PTR(PL),NTRYOFFB       | Lft_End := Rht_Par
         MVC   NTRYOFFB(PL),CHKLFTB    Par := Lft
         LH    NOD,CHKCURN             RELEASE CUR
         AL    NOD,CHKCURA             |
         RELNODE CHKCURN,NODLEN,CHKCURA,ERR=NBERROR
         MVI   CHKITYPE,CCHKBDEL       INDICATE BAL W/ DEL
         MVC   CHKIFLG,CHKFLG          COPY FLAGS
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         MAKE INTENT NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
         MVC   CHKIBDOB(PL),CHKCURB    OLD NODE ADDRESS
         L     DSK,CHKCURA             | PUT IN CLOCK TAG
         MVC   CHKIBDOC,DSKTAG         |
         MVC   CHKCURP,CHKRHTP         RIGHT BECOMES CURRENT
         CLEAR CHKFRHTU                RHT NO LONGER IN BAL
         DECR  CNT,CHKNODN             ONE LESS NODE IN BAL
         MVC   CHKIBDPB(PL),CHKPARB    PARENT ADDRESS
         L     DSK,CHKPARA             | PUT IN CLOCK TAG
         MVC   CHKIBDPC,DSKTAG         |
         MVC   CHKIBDLB(PL),CHKLFTB    LEFT NODE ADDRESS
         MVC   CHKIBDCB(PL),CHKCURB    CURRENT NODE ADDRESS
*
         LH    NOD,CHKLFTN             TOTAL SPACE IN 2 NODES
         AL    NOD,CHKLFTA             |
         LH    CNT,NODSPACE            |
         LH    NOD,CHKCURN             |
         AL    NOD,CHKCURA             |
         AH    CNT,NODSPACE            |
         STH   CNT,CHKSPAC             |
         LCALL NBBAL
         DDWRITE 1,CHKLFTB,ERR=NBERROR
         DDWRITE 2,CHKCURB,ERR=NBERROR
         LA    QR,2                    UPDATE BALANCE WRITE COUNTS
         AH    QR,CHKNODN              | NUM OF SIBS + deleted + PAR
         A     QR,FSBCTBWR             |
         ST    QR,FSBCTBWR             |
         IWRITE ERR=NBERROR
         DWRITE CHKPARB,ERR=NBERROR
         DWRITE CHKLFTB,ERR=NBERROR
         DWRITE CHKCURB,ERR=NBERROR
         DWRITE CHKIBDOB,ERR=NBERROR   OLD CUR THAT WAS DELETED
         CLEAR CHKIVLV1
         IWRITE ERR=NBERROR
         B     NODBALX
         END   ,                       OF BALANCE WITH COLLAPSE
         DROP  IX
         TITLE 'Node Balance - Using present nodes'
         XTRC  RQBR,RQBR,CATBAL
         LCALL NBBAL                   BALANCE AMONG PRESENT NODES
*               Format Checkpoint Block
         MVI   CHKITYPE,CCHKNBAL       INDICATE NODE BAL
         MVC   CHKIFLG,CHKFLG          COPY FLAGS
         MVC   CHKIV1LN(1),=&L.AL1(NIL)         MAKE INTENT NIL
         MVC   CHKIV1LN+1(L'CHKIV1LN-1),CHKIV1LN
         MVC   CHKINBPB(PL),CHKPARB    PARENT ADDRESS
         L     DSK,CHKPARA             | PUT IN CLOCK TAG
         MVC   CHKINBPC,DSKTAG         |
         MVC   CHKINBLB(PL),CHKLFTB    LEFT NODE ADDRESS
         MVC   CHKINBCB(PL),CHKCURB    CURRENT NODE ADDRESS
         MVC   CHKINBRB(PL),CHKRHTB    RIGHT NODE ADDRESS
*               Double write blocks (Left, Current, and Right)
         IF    CHKFLFTU,BEGIN          LEFT IN BALANCE
         DDWRITE 1,CHKLFTB,ERR=NBERROR
         END   ,                       OF LEFT IN BALANCE
         DDWRITE 2,CHKCURB,ERR=NBERROR
         IF    CHKFRHTU,BEGIN          RIGHT IN BALANCE
         DDWRITE 3,CHKRHTB,ERR=NBERROR
         END   ,                       OF RIGHT IN BALANCE
         LH    QR,CHKNODN              UPDATE BALANCE WRITE COUNTS
         INCR  QR                      | NUM OF SIBS + PAR
         A     QR,FSBCTBWR             |
         ST    QR,FSBCTBWR             |
         IWRITE ERR=NBERROR
         DWRITE CHKPARB,ERR=NBERROR    WRITE PARENT BLOCK
         IF    CHKFLFTU,BEGIN          LEFT IN BALANCE
         DWRITE CHKLFTB,ERR=NBERROR
         END   ,                       OF LEFT IN BALANCE
         DWRITE CHKCURB,ERR=NBERROR    WRITE CUR BLOCK
         IF    CHKFRHTU,BEGIN          RIGHT IN BALANCE
         DWRITE CHKRHTB,ERR=NBERROR
         END   ,                       OF RIGHT IN BALANCE
         CLEAR CHKIVLV1                CLR 1ST LEVEL INTENTIONS; DONE
         IWRITE ERR=NBERROR            | WRITE INTENTIONS DONE
         B     NODBALX
         TITLE 'Node Balance - Exit'
*
* RETURN W/ ADDRESSABILITY TO PARENT
NODBALX  MVC   CHKCURP,CHKPARP         MAKE PARENT CURRENT
         DECR  PTR,CHKSTKP             POP TO PARENT'S LEVEL
NODBALPX MVC   CHKPARB(PL),=&L.AL1(NIL)         |
         MVC   CHKLFTB(PL),=&L.AL1(NIL)         LEFT SIBLING POINTER
         MVC   CHKRHTB(PL),=&L.AL1(NIL)         RIGHT SIBLING POINTER
         DREAD CHKCURB,ERR=NBERROR     CUR = LEAST RECENTLY ACCESSED
         LH    NOD,CHKCURN             ADDR TO CUR (OLD PAR)
         LA    NOD,DSKBLK(NOD)         |
         CLEAR CHKFLEAF
         CLEAR R15
NBERROR  DIREST FBR,RAR
         LTR   R15,R15                 SET CC
         BR    RAR
         DROP  NOD
         LTORG ,
         TITLE 'Inner Balance'
*********************************************************************
* NBBAL - Balance among given nodes                                 *
* ON ENTRY: CHKNODN indicates how many nodes are in the balance     *
*           CHKSPAC indicates how much space is in these nodes      *
*           CHKFLFTU and CHKFRHTU flags indicate if the             *
*             respective left and right nodes are in the balance    *
*           The left, current, right, and parent pointers are       *
*             assumed to be initialized and the nodes in memory     *
*           This routine should be called only if there is enough   *
*             room to avoid a collapse or split                     *
* ON EXIT:  The balance is complete among the given nodes.          *
*********************************************************************
*NEST,1
         USING NODE,NOD
         USING NTRY,IX
NBBAL    DIRENT FBR,RAR
NBREBAL  CLEAR CHKFBAL                 INIT FLAG FOR NO 2ND PASS
         ACALL PARNTRY                 FIND PARENT ENTRY
         REGCH (MIX,0),(IX,1)          CHECK REG ASSUMPTIONS
*        (Total - possible_increase_from_parent)/#_nodes = IDEAL AVG
*        Poss_incr_from_parent = par_lengths - (min_len * #_dividing _
*      parents)
         LH    CNT,CHKNODN             NUM DIVIDING ENTRYS
         LR    MIX,CNT                 | #NODES -1
         DECR  MIX                     | |
         IF    CHKFACC,BEGIN           | MIN ENTRY LEN (ACC)
         LA    IX,L'NTRYGR             | |
         END   ELSE,BEGIN              | MIN ENTRY LEN (FILE)
         LA    IX,L'NTRYFL+1           | |
         END   ,                       | OF MIN ENTRY LEN (FILE)
         MR    MIX,MIX                 | (#NODES-1)*MIN_NTRY
         SH    IX,CHKBLPL              IX = POSSIBLE PAR EXCESS (NEG)
         SH    IX,CHKBRPL              | |
         AH    IX,CHKSPAC         TOTAL_SPACE - POSSIBLE_PAR_EXCESS
         CLEAR MIX                     |
         DR    MIX,CNT                 |
         IF    (MIX,NZ),'INCR IX '
         IF    CHKFACC,'LH MIX,FSBNANSP '       MIN VALUE OF SPACE/NODE
         ELSE  'LH MIX,FSBNFNSP '      |
         FLOOR IX,MIX                  |
         STH   IX,CHKSPAC              AVERAGE SPACE/NODE
         LH    NOD,CHKCURN             ADDR TO CURRENT
         AL    NOD,CHKCURA             |
         LH    CNT,NODSPACE            AMOUNT AVAIL IN CURRENT
         STH   CNT,CHKBCLN             |
         TITLE 'Inner Balance - Left => Cur'
         IF    CHKFLFTU,BEGIN          LEFT IS IN BALANCE
         LH    NOD,CHKLFTN             ADDRESS OF LEFT NODE
         AL    NOD,CHKLFTA             |
         LH    CNT,NODSPACE            SPACE IN LEFT
         IF    (CNT,LT,CHKSPAC),BEGIN  PROBABLY FREE LEFT
         IF    CHKFACC,BEGIN           MAX USEABLE SPACE/NODE (ACC)
         LH    CNT,FSBNASPA            |
         LR    PTR,CNT                 |
         SH    PTR,FSBNANSP            | PTR = MAX USEABLE SPACE
         END   ELSE,BEGIN              MAX USEABLE SPACE/NODE (FILE)
         LH    CNT,FSBNFSPA            |
         LR    PTR,CNT                 |
         SH    PTR,FSBNFNSP            | PTR = MAX USEABLE SPACE
         END   ,                  OF MAX USEABLE SPACE/NODE (FILE)
         SH    CNT,CHKSPAC             CNT = IDEAL USEABLE SPACE
         LA    IX,NODNTRYS        ADDR TO LEFT NTRYS (IX = NEW_PAR_PTR)
NBLIDEAL LH    QR,NTRYLEN              SEARCH FOR IDEAL LEN OF ENTRYS
         IF    (QR,LE,PTR),BEGIN       SPACE AVAIL W/IN MAX
         SR    PTR,QR                  DECR MAX USEABLE SPACE
         SR    CNT,QR                  DECR IDEAL USEABLE SPACE
         LA    IX,NTRY(QR)             NEXT ENTRY
         IF    (CNT,POS),NBLIDEAL      MORE ROOM IN IDEAL BALANCE
         END   ,                       OF SPACE AVAIL W/IN MAX
         BEGIN ,                       LEN TO MOVE OUT OF LEFT
         LR    PTR,IX                  |
         LA    CNT,NODNTRYS            |
         SR    PTR,CNT                 | PTR = CUR-START = LEN_SO_FAR
         IF    CHKFACC,'LH CNT,FSBNASPA '       MAX SPACE
         ELSE  'LH CNT,FSBNFSPA '      |
         SH    CNT,NODSPACE            | CNT = TOTAL USED SPACE
         SR    CNT,PTR                 | CNT = LEN TO MOVE OUT
         END   ,                       OF LEN TO MOVE OUT OF LEFT
         IF    (CNT,POS),BEGIN         THERE IS SOMETHING TO MOVE OUT
         LH    PTR,CHKCURN             ADDR TO CUR
         AL    PTR,CHKCURA             |
         WITH  (NODE,PTR),'LH PTR,NODSPACE '    FREE SPACE
         SH    PTR,CHKBLPL             | MINUS PAR TO BE MOVED IN
         IF    NPOS,BEGIN              NOT EVEN ROOM FOR PARENT
         SET   CHKFBAL                 REBALANCE PASS NEEDED
         B     NBBRHT                  DO BALANCE W/ RIGHT NODE
         END   ,                       OF NOT EVEN ROOM FOR PARENT
NBLSHORT LR    MIX,CNT            LEN_TO_MOVE - NEW_PAR_LEN = LFT_LEN
         LH    QR,NTRYLEN              | NEW_PAR_LEN
         SR    MIX,QR                  | MIX = LEFT_LEN
         IF    (MIX,GT,PTR),BEGIN      CAME UP SHORT IN MOVE
         SET   CHKFBAL                 INDICATE REBALANCE PASS NEEDED
         SR    CNT,QR                  DECR LEN_TO_MOVE (INCL NEW_PAR)
         LA    IX,NTRY(QR)             | NEXT ENTRY
         B     NBLSHORT                SEE IF STILL SHORT??
         END   ,                       OF CAME UP SHORT IN MOVE
         IF    (CNT,POS),BEGIN         STILL SOMETHING TO MOVE OUT
*               Change offspring pointers of entrys to be moved
         ST    IX,CHKBNPA              New_Parent_Addr
         STH   QR,CHKBNPL              New_Parent_Len
         LA    IX,NTRY(QR)             NEXT ENTRY = Left_Addr
         ST    IX,CHKBLAD              |
         STH   MIX,CHKBLLN             Left_Len
         LH    NOD,CHKCURN             Current_Addr
         AL    NOD,CHKCURA             |
         ST    NOD,CHKBCAD             |
         CLEAR CHKBCLN                 | Cur_Len
         L     IX,CHKBLPA              Par_Ptr := Old_End_Ptr
         LA    PTR,NTRYOFFB            | |
         L     IX,CHKBLAD              | Addr to end <NIL> entry
         AH    IX,CHKBLLN              | |
         MVC   @PTR(PL),NTRYOFFB       |
         LA    PTR,NTRYOFFB            Old_End_Ptr := New_Par_Ptr
         L     IX,CHKBNPA              | New_Par_Ptr
         MVC   @PTR(PL),NTRYOFFB       |
         MVC   NTRYOFFB(PL),CHKLFTB    New_Par_Ptr := Ptr_to_left
*               Move entrys
         MVC   CHKBSAD,CHKBLPA         SOURCE LOC
         MVC   CHKBSLN,CHKBLPL         | LEN
         LH    NOD,CHKCURN             DEST LOC
         AL    NOD,CHKCURA             |
         LA    IX,NODNTRYS             |
         ST    IX,CHKBDAD              |
         NTRYMOV SRC=PAR,DEST=CUR      MOVE Lft_Par ==> Cur
         IF    (CHKBLLN,NZ),BEGIN      MOVE Lft_Entrys ==> Cur
         MVC   CHKBSAD,CHKBLAD         SOURCE LOC
         MVC   CHKBSLN,CHKBLLN         | LEN (SAME DEST)
         NTRYMOV SRC=LFT,DEST=CUR      MOVE Lft_Entrys ==> Cur
         END   ,                       OF MOVE Lft_Entrys ==> Cur
         MVC   CHKBSAD,CHKBNPA         SOURCE LOC (New_Par)
         MVC   CHKBSLN,CHKBNPL         | LEN
         MVC   CHKBDAD,CHKBLPA         DEST LOC (Left_Par)
         NTRYMOV SRC=LFT,DEST=PAR      MOVE New_Par ==> Par
         END   ,                       OF STILL SOMETHING TO MOVE OUT
         END   ,                  OF THERE IS SOMETHING TO MOVE OUT
         END   ,                       OF PROBABLY NEED TO FREE
         TITLE 'Inner Balance - Cur => Left'
*               CNT = Space in left
         ELSEIF (CNT,GT,CHKSPAC),BEGIN PROBABLY FILL LEFT
         LR    PTR,CNT                 MAX AVAIL SPACE
         IF    CHKFACC,'SH PTR,FSBNANSP '       | (ACC)
         ELSE  'SH PTR,FSBNFNSP '      | (FILE)
         SH    CNT,CHKSPAC             CNT = IDEAL USEABLE SPACE
         LH    QR,CHKBLPL              LEFT PARENT ENTRY LENGTH
         IF    (PTR,GE,QR),BEGIN       ROOM FOR AT LEAST THE PARENT
         SR    PTR,QR                  DECR MAX USEABLE SPACE
         SR    CNT,QR                  DECR IDEAL USEABLE SPACE
         LH    NOD,CHKCURN             ADDR TO CURRENT NODE
         AL    NOD,CHKCURA             |
         LA    IX,NODNTRYS             ADDR TO CUR ENTRYS
         IF    (CNT,POS),BEGIN         NEED MORE THAN JUST PARENT
         LR    MIX,IX                  THIS FIXES BUG (M. DURKET)
NBLCIDEA CLC   NTRYLEN,=&L.AL1(NIL)    TEST FOR END OF NODE
         IF    NE,BEGIN                NOT @ END OF NODE
         LR    MIX,IX             NEW PARENT ADDRESS (IF @ END OF NODE)
         LH    QR,NTRYLEN              SEARCH FOR IDEAL LEN OF ENTRYS
         IF    (QR,LE,PTR),BEGIN       SPACE AVAIL W/IN MAX
         SR    PTR,QR                  DECR MAX AVAIL SPACE
         SR    CNT,QR                  DECR IDEAL FREE SPACE
         LA    IX,NTRY(QR)             NEXT ENTRY
         IF    (CNT,POS),NBLCIDEA      MORE ROOM IN IDEAL BALANCE
         END   ,                       OF SPACE AVAIL W/IN MAX
         END   ,                       OF NOT @ END OF NODE
         ELSE  BEGIN              @ END OF NODE - INDICATE REBAL PASS
         SET CHKFBAL
         LR    IX,MIX                  NEW PARENT ADDRESS
         END   ,                       OF @ END OF NODE
         ST    IX,CHKBNPA              NEW PAR ADDR
         MVC   CHKBNPL,NTRYLEN         | (LEN)
         LR    PTR,IX                  LEN TO MOVE TO LEFT
         LA    CNT,NODNTRYS            |
         SR    PTR,CNT                 | PTR = CUR-START = LEN_SO_FAR
         ST    CNT,CHKBCAD             | CURRENT ENTRY ADDR
         STH   PTR,CHKBCLN             | | LEN
         END   ,                  OF ROOM FOR MORE THAN JUST PARENT
         ELSE  BEGIN                   JUST PARENT GETS MOVED
         CLEAR CHKBCAD                 NOTHING TO MOVE FROM CURRENT
         CLEAR CHKBCLN                 | ZERO LEN
         LA    IX,NODNTRYS             NEW PARENT ADDR (1ST ENTRY)
         ST    IX,CHKBNPA              |
         MVC   CHKBNPL,NTRYLEN         | (LEN)
         CLC   NTRYLEN,=&L.AL1(NIL)    COMPARE FOR NIL 1ST ENTRY
         IF    EQ,BEGIN                |
         SET   CHKFBAL
         B     NBCTLX                  Node_Balance_Cur_To_Left_eXit
         END   ,                       OF COMPARE FOR NIL 1ST ENTRY
         END   ,                       OF JUST PARENT GETS MOVED
         BEGIN ,                       COMPUTE LEFT ADDR
         LH    NOD,CHKLFTN             ADDR TO LEFT NODE
         AL    NOD,CHKLFTA             |
         IF    CHKFACC,'LH IX,FSBNASPA '        USED SPACE (ACC TOTAL)
         ELSE  'LH IX,FSBNFSPA '       | (FILE TOTAL)
         SH    IX,NODSPACE             | TOTAL - FREE = USED
         LA    IX,NODNTRYS(IX)         LEFT ADDR (DEST)
         ST    IX,CHKBLAD              |
         END   ,                       OF COMPUTE LEFT ADDR
*               Change offspring pointers of entrys to be moved
         L     IX,CHKBLPA              Par_Ptr := Old_End_Ptr
         LA    PTR,NTRYOFFB            | |
         L     IX,CHKBLAD              | Addr to end <NIL> entry
         MVC   @PTR(PL),NTRYOFFB       |
         LA    PTR,NTRYOFFB            Old_End_Ptr := New_Par_Ptr
         L     IX,CHKBNPA              | New_Par_Ptr
         MVC   @PTR(PL),NTRYOFFB       |
         MVC   NTRYOFFB(PL),CHKLFTB    New_Par_Ptr := Ptr_to_left
*               Move entrys
         MVC   CHKBSAD,CHKBLPA         SOURCE LOC
         MVC   CHKBSLN,CHKBLPL         | LEN
         MVC   CHKBDAD,CHKBLAD         DEST LOC
         NTRYMOV SRC=PAR,DEST=LFT      MOVE Lft_Par ==> Lft
         IF    (CHKBCLN,NZ),BEGIN      MOVE Cur_Entrys ==> Lft
         MVC   CHKBSAD,CHKBCAD         SOURCE LOC
         MVC   CHKBSLN,CHKBCLN         | LEN
         L     IX,CHKBLAD              NEW DEST (Incr by Left_Par_Len)
         AH    IX,CHKBLPL              |
         ST    IX,CHKBDAD              |
         NTRYMOV SRC=CUR,DEST=LFT
         END   ,                       OF MOVE Cur_Entrys ==> Lft
         LH    NOD,CHKCURN             ADDR TO CUR
         AL    NOD,CHKCURA             |
         LA    IX,NODNTRYS             ADDR TO 1ST (NEW PAR)
         ST    IX,CHKBSAD              | (SOURCE)
         MVC   CHKBSLN,CHKBNPL         | LEN
         MVC   CHKBDAD,CHKBLPA         DEST LOC (Left_Par)
         NTRYMOV SRC=CUR,DEST=PAR      MOVE New_Par ==> Par
         END   ,                       OF ROOM FOR AT LEAST THE PARENT
NBCTLX   END   ,                       OF PROBABLY NEED TO FILL
         END   ,                       OF LEFT IN BALANCE
         TITLE 'Inner Balance - Right => Cur'
NBBRHT   IF    CHKFRHTU,BEGIN          RIGHT IN BALANCE
         IF    CHKFLFTU,BEGIN     LEFT IN BAL, NEED TO UPDATE RHT_PAR
         L     IX,CHKBLPA              ADDR TO LFT_PAR ENTRY
         AH    IX,NTRYLEN              RHT_PAR
         ST    IX,CHKBRPA              |
         MVC   CHKBRPL,NTRYLEN         |
         END   ,                  OF LFT IN BAL, NEED TO UPDATE RHT_PAR
         LH    NOD,CHKRHTN             ADDRESS OF RIGHT NODE
         AL    NOD,CHKRHTA             |
         LH    CNT,NODSPACE            SPACE IN RIGHT
         IF    (CNT,LT,CHKSPAC),BEGIN  PROBABLY FREE RIGHT
         LR    PTR,CNT                 CNT (NEG) = IDEAL TO MOVE OUT
         SH    CNT,CHKSPAC             |
         IF    CHKFACC,BEGIN           MUST MOVE OUT (ACC)
         AH    CNT,=Y(L'NTRYGR-1)      CNT (NEG) = MIN MOVE OUT(MIN-1)
         SH    PTR,FSBNANSP            | PTR (NEG) = MIN SPACE REQ
         END   ,                       OF MUST MOVE OUT (ACC)
         ELSE  BEGIN                   MUST MOVE OUT (FILE)
         AH    CNT,=Y(L'NTRYFL)        CNT (NEG) = MIN MOVE OUT(MIN-1)
         SH    PTR,FSBNFNSP            | PTR (NEG) = MIN SPACE REQ
         END   ,                       OF MUST MOVE OUT (FILE)
         IF    (PTR,LT,CNT),'LR CNT,PTR '       CNT (NEG) = MIN MOVE
         LH    PTR,CHKCURN             ADDR TO CUR NODE
         AL    PTR,CHKCURA             |
         WITH  (NODE,PTR),'LH PTR,NODSPACE '    PTR = SPACE IN CUR
         IF    (PTR,LT,CHKBRPL),BEGIN  NO ROOM FOR EVEN PARENT
         SET   CHKFBAL                 INDICATE REBALANCE PASS
         END   ELSE,BEGIN              ROOM FOR AT LEAST PARENT
         SH    PTR,CHKBRPL             SUBTRACT PARENT LENGTH
         LA    IX,NODNTRYS             ADDR TO RIGHT ENTRYS
         LH    QR,NTRYLEN              1st ENTRY LEN
         AR    CNT,QR                  |
NBRIDEAL IF    (CNT,NEG),BEGIN         MORE TO MOVE OUT OF RIGHT
         IF    (PTR,LT,QR),BEGIN  NO ROOM FOR ANOTHER ENTRY IN CUR
         SET   CHKFBAL                 INDICATE REBALANCE PASS
         END   ELSE,BEGIN              ROOM FOR ANOTHER ENTRY IN CUR
         SR    PTR,QR                  SUBTRACT THIS LEN
         LA    IX,NTRY(QR)             NEXT ENTRY
         LH    QR,NTRYLEN              | (LEN)
         IF    (QR,NPOS),'SET CHKFBAL; B NBBRCPOK '
         AR    CNT,QR
         B     NBRIDEAL
         END   ,                  OF ROOM FOR ANOTHER ENTRY IN CUR
         END   ,                       OF MORE TO MOVE OUT OF RIGHT
NBBRCPOK ST    IX,CHKBNPA              New_Parent_Addr
         MVC   CHKBNPL,NTRYLEN         | Len
         LA    MIX,NODNTRYS            Right_Entrys_Addr
         ST    MIX,CHKBRAD             |
         SR    IX,MIX                  | Len
         STH   IX,CHKBRLN              | |
         LH    NOD,CHKCURN             Cur_Entrys_Addr
         AL    NOD,CHKCURA             |
         IF CHKFACC,'LH CNT,FSBNASPA ' Total node space
         ELSE  'LH CNT,FSBNFSPA '      |
         SH    CNT,NODSPACE            | Addr to end of entrys
         LA    IX,NODNTRYS(CNT)        | |
         ST    IX,CHKBCAD              |
         L     PTR,CHKBRPA             Par_Ptr := Old_End_Ptr
         WITH (NTRY,PTR),'LA PTR,NTRYOFFB '     |
         MVC   @PTR(PL),NTRYOFFB       |
         LA    PTR,NTRYOFFB            Old_End_Ptr := New_Par_Ptr
         L     IX,CHKBNPA              |
         MVC   @PTR(PL),NTRYOFFB       |
         MVC   NTRYOFFB(PL),CHKCURB    New_Par_Ptr := Ptr_to_Cur
*               Move entrys
         MVC   CHKBSAD,CHKBRPA         MOVE PAR TO CUR - SOURCE LOC
         MVC   CHKBSLN,CHKBRPL         | LEN
         MVC   CHKBDAD,CHKBCAD         DEST LOC (END OF CUR)
         NTRYMOV SRC=PAR,DEST=CUR
         IF    (CHKBRLN,NZ),BEGIN      MOVE RIGHT BODY TO CUR
         MVC   CHKBSAD,CHKBRAD         SOURCE LOC
         MVC   CHKBSLN,CHKBRLN         | LEN
         L     IX,CHKBDAD              NEW DEST (END OF CUR)
         AH    IX,CHKBRPL              |
         ST    IX,CHKBDAD              |
         ST    IX,CHKBCAD              |
         NTRYMOV SRC=RHT,DEST=CUR      |
         END   ,                       OF MOVE RIGHT BODY TO CUR
         MVC   CHKBSAD,CHKBRAD         MOVE NEW PAR TO PAR - SHIFTED
         MVC   CHKBSLN,CHKBNPL         | LEN
         MVC   CHKBDAD,CHKBRPA         DEST LOC
         NTRYMOV SRC=RHT,DEST=PAR      |
         END   ,                       OF ROOM FOR AT LEAST PARENT
         END   ,                       OF PROBABLY NEED TO FREE
         TITLE 'Inner Balance - Cur => Right'
         ELSEIF (CNT,GT,CHKSPAC),BEGIN PROBABLY NEED TO FILL
         LR    PTR,CNT                 MAX SPACE TO FILL
         IF    CHKFACC,'SH PTR,FSBNANSP '       | (ACC)
         ELSE  'SH PTR,FSBNFNSP '      | (FILE)
         SH    CNT,CHKSPAC             CNT = IDEAL SPACE TO FILL
         LH    QR,CHKBRPL              RIGHT PARENT ENTRY LENGTH
         IF    (PTR,GE,QR),BEGIN       ROOM FOR AT LEAST THE PARENT
         SR    PTR,QR                  DECR MAX SPACE TO FILL
         SR    CNT,QR                  DECR IDEAL SPACE TO FILL
         LH    NOD,CHKCURN             ADDR TO CURRENT NODE
         AL    NOD,CHKCURA             |
         LA    IX,NODNTRYS             ADDR TO CUR ENTRYS (IX)
         IF    (CNT,POS),BEGIN         NEED MORE THAN JUST PARENT
         IF    CHKFACC,'LH DSK,FSBNASPA '       MAX SPAC IN NODE (ACC)
         ELSE  'LH DSK,FSBNFSPA '      | (FILE)
         SH    DSK,NODSPACE       TOTAL USED = MAX FREE - CUR FREE
         IF    (DSK,NPOS),BEGIN        NOTHING TO MOVE OUT
         SET   CHKFBAL                 INDICATE REBALANCE
         END   ,                       OF NOTHING TO MOVE OUT
         ELSE  BEGIN                   SOMETHING TO MOVE OUT OF CUR
         LA    IX,NODNTRYS             ADDR TO CUR ENTRYS
         L     MIX,=&L.AL1(NIL)   SET 2 PREV TO NIL (MIX = 2 PREV NTRY)
         LR    NOD,MIX            SET PREV TO NIL (NOD = PREV ENTRY)
NBRCUMAX IF    (DSK,GT,PTR),BEGIN      NOT YET UNDER MAX
         CLC   NTRYLEN,=&L.AL1(NIL)    NOT @ END
         IF    NE,BEGIN                |
         LH    QR,NTRYLEN              LEN OF THIS ENTRY
         SR    DSK,QR                  DECR REMAINING LENGTH IN CUR
         LR    MIX,NOD                 ADV PREVIOUS PTRS
         LR    NOD,IX                  |
         LA    IX,NTRY(QR)             NEXT ENTRY
         B     NBRCUMAX                TRY TO GET UNDER MAX
         END   ,                       OF NOT @ END
         ELSE  BEGIN                   @ END BEFORE UNDER MAX
         LR    IX,NOD                  NEW PARENT IS PREV ENTRY
         ST    IX,CHKBNPA              |
         MVC   CHKBNPL,NTRYLEN         | (LEN)
         CLEAR CHKBCLN                 NOTHING TO MOVE FROM CUR TO RHT
         END   ,                       OF @ END BEFORE UNDER MAX
         END   ,                       OF NOT YET UNDER MAX
         ELSE  BEGIN                   LOOK FOR IDEAL LEN
NBRCIDEA IF    (DSK,GT,CNT),BEGIN      STILL OVER IDEAL
         CLC   NTRYLEN,=&L.AL1(NIL)    NOT @ END
         IF    NE,BEGIN                |
         LH    QR,NTRYLEN              LEN OF THIS ENTRY
         SR    DSK,QR                  DECR REMAINING LENGTH IN CUR
         LR    MIX,NOD                 ADV PREVIOUS PTRS
         LR    NOD,IX                  |
         LA    IX,NTRY(QR)             NEXT ENTRY
         B     NBRCIDEA                TRY TO GET TO IDEAL LEN
         END   ,                       OF NOT @ END
         END   ,                       OF STILL OVER IDEAL
         C     MIX,=&L.AL1(NIL)        2ND PREV ENTRY DOESN'T EXIST!
         IF    EQ,BEGIN                |
         SET   CHKFBAL                 RAN OUT OF ENTRYS, REBALANCE
         END   ,                  OF 2ND PREV ENTRY DOESN'T EXIST!
         ELSE  BEGIN                   2ND PREV DOES EXIST
         LR    IX,NOD                  CUR := PREV
         LR    NOD,MIX                 NEW_PAR := 2ND PREV
         AH    DSK,NTRYLEN             ADD THIS ENTRYS LEN TO MOVE OUT
         END   ,                       OF 2ND PREV DOES EXIST
         ST    IX,CHKBCAD         ADDR OF ENTRYS TO MOVE OUT OF CUR
         STH   DSK,CHKBCLN             | LEN
         ST    NOD,CHKBNPA             ADDR OF NEW PAR
         WITH (NTRY,NOD),'MVC CHKBNPL,NTRYLEN ' | (LEN)
         END   ,                       OF LOOK FOR IDEAL LEN
         END   ,                       OF SOMETHING TO MOVE OUT OF CUR
         BEGIN ,                       COMPUTE RIGHT ADDR
         LH    NOD,CHKRHTN             ADDR TO RIGHT NODE
         AL    NOD,CHKRHTA             |
         LA    IX,NODNTRYS             RIGHT ADDR (DEST)
         ST    IX,CHKBRAD              |
         END   ,                       OF COMPUTE RIGHT ADDR
*               Change offspring pointers of entrys to be moved
         L     IX,CHKBRPA              Par_Ptr := Old_End_Ptr
         LA    PTR,NTRYOFFB            | |
         L     IX,CHKBCAD              | Addr to end <NIL> entry
         AH    IX,CHKBCLN              |
         MVC   @PTR(PL),NTRYOFFB       |
         LA    PTR,NTRYOFFB            Old_End_Ptr := New_Par_Ptr
         L     IX,CHKBNPA              | New_Par_Ptr
         MVC   @PTR(PL),NTRYOFFB       |
         MVC   NTRYOFFB(PL),CHKCURB    New_Par_Ptr := Ptr_to_right
*               Move entrys
         MVC   CHKBSAD,CHKBRPA         SOURCE LOC
         MVC   CHKBSLN,CHKBRPL         | LEN
         MVC   CHKBDAD,CHKBRAD         DEST LOC
         NTRYMOV SRC=PAR,DEST=RHT      MOVE Rht_Par ==> Rht
         IF    (CHKBCLN,NZ),BEGIN      MOVE Cur_Entrys ==> Rht
         MVC   CHKBSAD,CHKBCAD         SOURCE LOC
         MVC   CHKBSLN,CHKBCLN         | LEN (SAME DEST)
         NTRYMOV SRC=CUR,DEST=RHT      MOVE Cur_Entrys ==> Rht
         END   ,                       OF MOVE Rht_Entrys ==> Cur
         MVC   CHKBSAD,CHKBNPA         SOURCE LOC (New_Par)
         MVC   CHKBSLN,CHKBNPL         | LEN
         MVC   CHKBDAD,CHKBRPA         DEST LOC (Right_Par)
         NTRYMOV SRC=CUR,DEST=PAR      MOVE New_Par ==> Par
         END   ,                       OF ROOM FOR AT LEAST THE PARENT
         END   ,                       OF SOMETHING TO MOVE OUT OF CUR
         END   ,                       OF PROBABLY NEED TO FILL
         END   ,                       OF RIGHT IN BALANCE
         TITLE 'Inner Balance - Rebalance test and Balance flags'
         LH    NOD,CHKPARN             SET PAR BALANCE FLAGS
         AL    NOD,CHKPARA             |
         LH    IX,NODSPACE             | IX = Free space
         IF    CHKFACC,BEGIN           ACCOUNT NODE
         LH    MIX,FSBNAXSP            MIX = Max free space in node
         LH    CNT,FSBNANSP            CNT = Min free space in node
         END   ELSE,BEGIN              FILE NODE
         LH    MIX,FSBNFXSP            MIX = Max free space in node
         LH    CNT,FSBNFNSP            CNT = Min free space in node
         END   ,                       OF FILE NODE
         CLEAR NODFEMT+NODFFUL
         IF    (NODFTRT),BEGIN         TREE ROOT
         IF    (NODNTNUM,LT,1),'SET NODFEMT '
         IF    (IX,LT,CNT),'SET NODFFUL '
         END   ELSE,BEGIN              NOT TREE ROOT
         IF    (IX,GT,MIX),'SET NODFEMT '
         IF    (IX,LT,CNT),'SET NODFFUL '
         END   ,                       OF NOT TREE ROOT
         LH    NOD,CHKCURN             CLEAR CUR BAL FLAGS
         AL    NOD,CHKCURA             |
         LH    CNT,NODSPACE            | TOTAL SPACE AVAILABLE
         CLEAR NODFFUL+NODFEMT         |
         IF    CHKFRHTU,BEGIN          RHT IN BALANCE
         LH    NOD,CHKRHTN             CLEAR RHT BAL FLAGS
         AL    NOD,CHKRHTA             |
         AH    CNT,NODSPACE            | TOTAL SPACE AVAILABLE
         CLEAR NODFFUL+NODFEMT         |
         END   ,                       OF RHT IN BALANCE
         IF    CHKFLFTU,BEGIN          LFT IN BALANCE
         LH    NOD,CHKLFTN             CLEAR LFT BAL FLAGS
         AL    NOD,CHKLFTA             |
         AH    CNT,NODSPACE            | TOTAL SPACE AVAILABLE
         CLEAR NODFFUL+NODFEMT         |
         END   ,                       OF LFT IN BALANCE
         STH   CNT,CHKSPAC             TOTAL SPACE AVAILABLE
         IF    CHKFBAL,BEGIN           REBALANCE PASS IF NECESSARY
         B     NBREBAL                 |
         END   ,                       OF REBALANCE PASS IF NECESSARY
         CLEAR R15                     ALL OK - NODES BALANCED
NBBALX   DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
         DROP  IX
         DROP  NOD
*NEST,2
         TITLE 'Find Dividing Parent'
*********************************************************************
* ON ENTRY: CHKFLFTU and CHKFRHTU flags indicate if the             *
*             respective left and right nodes are in the balance    *
*           The left, current, right, and parent pointers are       *
*             assumed to be initialized and the nodes in memory     *
* ON EXIT:  CHKBLPA/LPL and CHKBRPA/RPL are initialized             *
*********************************************************************
         USING NODE,NOD
PARNTRY  DIRENT FBR
         IF    CHKFLFTU,BEGIN          LEFT NODE IS IN BALANCE
         LA    IX,CHKLFTB              ADDR TO LEFT NODE
         END   ,                       OF LEFT NODE IS IN BALANCE
         ELSE  BEGIN                   CUR NODE IS LEFT-MOST
         LA    IX,CHKCURB              ADDR TO CUR NODE
         END   ,                       OF CUR NODE IS LEFT-MOST
         LH    NOD,CHKPARN             ADDR TO PARENT
         AL    NOD,CHKPARA             |
         LA    NOD,NODNTRYS            ADDR TO INDIVIDUAL ENTRIES
         WITH  (NTRY,NOD),BEGIN        |
         LOOP  BEGIN                   LOOK FOR OFFSPRING
         IF    ('CLC NTRYOFFB(PL),@IX',EQ),EXIT FOUND OFFSPR
         IF    ('CLC NTRYLEN,=&L.AL1(NIL)',EQ),BEGIN    NOT FOUND
         ABORT  CAT1PNF                1st parent not found
         END   ,                       OF NOT FOUND
         AH    NOD,NTRYLEN             NEXT ENTRY
         UNTIL FALSE,END               OF LOOK FOR OFFSPRING
         IF    CHKFLFTU,BEGIN          SPLITS LEFT/CUR NODES
         ST    NOD,CHKBLPA             PARENT ENTRY ADDRESS
         MVC   CHKBLPL,NTRYLEN         LEN OF PARENT ENTRY
         AH    NOD,NTRYLEN             NEXT ENTRY IS RIGHT PAR
         END   ,                       OF SPLITS LEFT/CUR NODES
         ELSE  'CLEAR CHKBLPL '        ZERO LEN IF NOT IN BAL
         IF    CHKFRHTU,BEGIN          SPLITS CUR/RHT NODES
         IF    ('CLC NTRYOFFB(PL),=&L.AL1(NIL)',EQ),BEGIN
         ABORT  CAT2PNF                2nd parent not found
         END   ,
         ST    NOD,CHKBRPA             PARENT ENTRY ADDR
         MVC   CHKBRPL,NTRYLEN         | (LEN)
         END   ,                       OF SPLITS CUR/RHT NODES
         ELSE  'CLEAR CHKBRPL '        ZERO LEN IF NOT IN BAL
         END   ,                       OF ADDR TO INDIVIDUAL ENTRIES
PARNTRYX DIREST FBR
         BR    RAR
         DROP  NOD
         TITLE 'Move Entrys'
*********************************************************************
* ON ENTRY:                                                         *
*           R1  = source node address in mem                        *
*           R15 = destination node address in mem                   *
*           CHKBSAD = Source location of move                       *
*           CHKBSLN = Source length of move                         *
*               IF CHKBSLN < 0, don't delete source in node         *
*           CHKBDAD = Destination location of move                  *
* ON RETURN:                                                        *
*           IF CC = 0                                               *
*             Action complete:                                      *
*               Space fields of nodes have been updated             *
*               Number of entry counts also updated                 *
*           IF CC ^ 0                                               *
*             R14 conatains the PSW at error detection              *
*             The 2nd low order byte of R15 indicates the module    *
*               in which the error occured.                         *
*             The low order byte of R15 contains the error code for *
*               that module.                                        *
*********************************************************************
NTRYMOV  DIRENT FBR
         REGCH (IX,1),(PTR,15)         DON'T DAMAGE THESE ADDR REGS
         IF    (CHKBSLN,NZ),BEGIN      SOMETHING TO MOVE
         BEGIN ,                       COUNT NUM OF ENTRYS IN SOURCE
         CLEAR CNT                     INIT ENTRY COUNT
         L     QR,CHKBSAD              SOURCE ADDRESS
         WITH  (NTRY,QR),BEGIN         ADDR TO ENTRYS OF SOURCE
         LH    MIX,CHKBSLN             SOURCE LENGTH
         LPR   MIX,MIX                 | ABS VAL
NTMSCNT  IF    (MIX,GE,NTRYLEN),BEGIN  AT LEAST 1 MORE ENTRY
         SH    MIX,NTRYLEN             DECR LENGTH
         INCR  CNT                     INCR NUM OF ENTRYS
         AH    QR,NTRYLEN              ADDR TO NEXT ENTRY
         CLC   NTRYLEN,=&L.AL1(NIL)    REPEAT IF NOT @ END
         IF    NE,NTMSCNT              |
         END   ,                       OF AT LEAST 1 MORE ENTRY
         STH   CNT,CHKBSN              SAVE NUM OF ENTRYS IN SOURCE
         END   ,                       OF ADDR TO ENTRYS OF SOURCE
         END   ,                  OF COUNT NUM OF ENTRYS IN SOURCE
         LH    QR,CHKBSLN              SOURCE ENTRYS LENGTH
         IF    (QR,NNEG),BEGIN         DELETE SOURCE
         SET   CHKFDSRC
         WITH  (NODE,R1)          ONLY UPDATE COUNTS IF DELETE SOURCE
         LH    MIX,NODSPACE            UPDATE SOURCE LEN
         AH    MIX,CHKBSLN             |
         STH   MIX,NODSPACE            |
         LH    MIX,NODNTNUM            UPDATE NUM OF ENTRYS IN SOURCE
         SH    MIX,CHKBSN              |
         STH   MIX,NODNTNUM            |
         END   ,                       OF DELETE SOURCE
         ELSE  'CLEAR CHKFDSRC '       OR DON'T UPDATE SOURCE
         WITH  (NODE,R15),BEGIN        ADDR TO DEST NODE
         LH    MIX,NODSPACE            UPDATE DEST LEN
         SH    MIX,CHKBSLN             |
         STH   MIX,NODSPACE            |
         LH    MIX,NODNTNUM            UPDATE NUM OF ENTRYS IN DEST
         AH    MIX,CHKBSN              |
         STH   MIX,NODNTNUM            |
         END   ,                       OF ADDR TO DEST NODE
         L     MIX,CHKBSAD             SOURCE ADDR
         LH    IX,CHKBSLN              | (LEN)
         LPR   IX,IX                   | ABS VALUE
         L     PTR,CHKBDAD             DEST ADDR
*               Change entry size in index
         LR    QR,IX                   SOURCE LENGTH - DEST LEN
         WITH  (NTRY,PTR),BEGIN        DEST ADDRESS
         LA    CNT,NTRY           CNT = START OF OLD FOLLOWING ENTRYS
NTMDEND  LH    IX,NTRYLEN         FIND END OF BLOCK FOLLOWING CUR ENTRY
         C     IX,=&L.AL1(NIL)         | END OF ENTRIES MARKER
         IF    NE,BEGIN                | NOT AT END OF ENTRIES
         LA    PTR,NTRY(IX)            NEXT ENTRY
         B     NTMDEND
         END   ,                       | OF NOT AT END OF ENTRIES
         LA    PTR,NTRY+CNODNLLN  PTR = END OF OLD FOLLOWING ENTRYS
         END   ,                       OF ADDR TO ENTRYS
*               Add entrys
*               CNT = START OF OLD FOLLOWING ENTRYS
*               PTR = END OF OLD FOLLOWING ENTRYS (& IS DECR)
         LR    MIX,QR             MIX = TOTAL SIZE TO BE MADE AVAIL
         CEIL  QR,256                  QR = LENGTH TO MOVE EACH LOOP
NTMEXP   LR    IX,PTR             | REMAINING LENGTH (END - BEGINNING)
         SR    IX,CNT                  | |
         IF (IX,LT,QR),'LR QR,IX' | | DON'T MOVE MORE THAN WHAT'S THERE
         SR    PTR,QR                  PTR = SOURCE
         LR    IX,PTR                  IX = DESTINATION
         ALR   IX,MIX                  |
         DEX   QR,'MVC @IX(0),@PTR '   EXPAND
         INCR  QR
         IF    (PTR,GT,CNT),NTMEXP     MORE TO MOVE
         LR    QR,MIX                  QR = NET LENGTH CHANGE
*               Do move
         IF    (CHKBSLN,NZ),BEGIN      SOMETHING TO COPY
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REG ASSUMPTIONS
         L     MIX,CHKBDAD             DESTINATION (LOC)
         L     CNT,CHKBSAD             SOURCE
         LH    PTR,CHKBSLN             | (LENGTH)
         LR    IX,PTR                  |
         MVCL  MIX,CNT                 COPY ENTRY
         END   ,                       OF SOMETHING TO COPY
         IF    (CHKFDSRC,AND,(CHKBSLN,NZ)),BEGIN        DELETE SOURCE
         L     PTR,CHKBSAD             ADDR TO ENTRYS FOLLOWING SOURCE
         AH    PTR,CHKBSLN             |
         WITH  (NTRY,PTR),BEGIN        |
         LA    CNT,NTRY           CNT = STRT OF FOLLOWING SOURCE ENTRYS
NTMSEND  LH    IX,NTRYLEN         FIND END OF BLOCK FOLLOWING CUR ENTRY
         C     IX,=&L.AL1(NIL)         | END OF ENTRIES MARKER
         IF    NE,BEGIN                | NOT AT END OF ENTRIES
         LA    PTR,NTRY(IX)            NEXT ENTRY
         B     NTMSEND
         END   ,                       | OF NOT AT END OF ENTRIES
         LA    PTR,NTRY+CNODNLLN  PTR = END OF OLD FOLLOWING ENTRYS
         END   ,                  OF ADDR TO ENTRYS FOLLOWING SOURCE
*               Delete source entrys
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REG ASSUMPTIONS
         SR    PTR,CNT            LENGTH (CNT = SOURCE OF THIS MOVE)
         LR    IX,PTR                  |
         L     MIX,CHKBSAD             DEST ADDR OF THIS MOVE
         MVCL  MIX,CNT                 DELETE SOURCE ENTRYS
         END   ,                       OF DELETE SOURCE
         END   ,                       OF SOMETHING TO MOVE
         CLEAR R15                     SET CC - OK
NTMOVERR DIREST FBR
         LTR   R15,R15
         BR    RAR
         LTORG ,
         USING LAST,LAS
         USING CURRENT,CUR
         USING NEWCHAIN,NEW
         TITLE 'DskInit'
*********************************************************************
* ON ENTRY:                                                         *
*        DSK = BLOCK BUFFER START ADDRESS                           *
*        R0  = BLOCK NUMBER                                         *
* ON RETURN:                                                        *
*        DSK = BLOCK BUFFER START ADDRESS                           *
*        BLOCK IS INITIALIZED                                       *
*********************************************************************
         BUGNTRY DSKINIT
DSKINIT  DIRENT FBR
* CLEAR HEADER AREA
         ZOT   DSKHEAD,LA:CDSKHSIZ-(DSKHEAD-DSKSTART)
         STH   R0,DSKBNUM              SAVE BLOCK NUMBER
         L     NEW,=A(CDSKNIL)         END OF LIST POINTER
         STH   NEW,DSKFBAC        THIS ALWAYS NIL, NO PREVIOUS ELEM.
         STH   NEW,DSKFFWD             NO ELEMENTS IN LIST YET
         STH   NEW,DSKBLINK            NO BLOCK LINK ON INIT
* INITIALIZE REMAINDER OF BLOCK WITH A LINK
         LA    NEW,CDSKHSIZ            NEW BLOCK IS ONE TO BE LINKED
         LH    R0,FSBDAVA              SIZE OF SPACE REMAINING
*                                 SIZE OF BLOCK IS IN R0
*
* INSERT INTO FIRST FIT LIST
*
         LA    CUR,DSKHEAD-DSKBLK      POINT TO HEADER
INITLINK LR    LAS,CUR                 ADVANCE POINTER BY ONE LINK
         LH    CUR,LASFFWD(DSK)        UPDATE POINTER TO CURRENT LINK
         IF    ((NEW,GE,CUR),AND,(CUR,NE,CDSKNIL)),INITLINK
*        INSERT IF BEFORE CURRENT ADDRESS OR IF AT END OF LIST
         STH   CUR,NEWFFWD(DSK)        NEW NOW POINTS AHEAD TO CUR
         IF    (CUR,NE,CDSKNIL),BEGIN  IF NOT END OF LIST
         STH   NEW,CURFBAC(DSK)        CUR POINTS BACK TO NEW
         END   ,
         STH   NEW,LASFFWD(DSK)   LAST NOW POINTS AHEAD TO NEW BLOCK
         STH   LAS,NEWFBAC(DSK)        NEW POINTS BACK TO LAS
         STH   R0,NEWSIZ(DSK)          STORE SIZE OF BLOCK IN BLOCK
         LR    CUR,NEW                 NOW IT'S INSERTED AND CUR BLOCK
         AH    R0,DSKFRE               TOTAL UP AMOUNT OF FREE MEMORY
         STH   R0,DSKFRE               STORE THIS IN BLOCK
         CLEAR R15                     ALL OK, SET RETURN CODE
         SET   DSKFINIT+DSKFMOD
         DIREST FBR
         LTR   R15,R15                 SET CC
         BR    RAR
* PAGE
         TITLE 'DskGet'
*********************************************************************
* ON ENTRY:                                                         *
*        R1 = BLOCK BUFFER START ADDRESS                            *
*        R0 = SIZE OF REQUEST FOR CORE                              *
*          IF R0 > 0 : USE BEST FIT ALGORITHM                       *
*          IF R0 < 0 : USE FIRST FIT ALGORITHM                      *
*   DSKGET must be passed an initialized block.                     *
* ON RETURN:                                                        *
*        DSK = BLOCK BUFFER START ADDRESS                           *
*        CC = 0:                                                    *
*          R1  = STARTING ADDRESS OF ALLOCATE                       *
*          R0  = LENGTH OF ALLOCATE                                 *
*          R14 = AMOUNT OF AVAILABLE SPACE LEFT                     *
*        CC ^ 0:                                                    *
*          R14 = PSW @ ERROR DETECTION                              *
*          IF R15 = 4 THEN NO SPACE AVAILABLE                       *
*          IF R15 = 8 THEN BLOCK NOT INITIALIZED                    *
*********************************************************************
         SPACE ,
DSKGET   DIRENT FBR
         LR    DSK,R1                  GET CONTROL BLOCK ADDRESS
         IF    (NOT,DSKFINIT),BEGIN    IF BLOCK NOT INITIALIZED
         LA    R15,CDSKINER            INDICATE INITIALIZATION ERROR
         BAS   R14,DGERROR
         END   ,
         IF    (R0,ZERO),BEGIN         NO ACTION IF ZERO LENGTH
         CLEAR R15,R1
         B     DSKGETX                 EXIT ROUTINE
         END   ,
         IF    (R0,POS),BEGIN          BEST FIT REQUESTED
         A     R0,=A(CDSKLLIM-1)       ROUND LEN UP TO NEXT 8 BYES
         N     R0,=A(-CDSKLLIM)        |
         IF    (R0,GT,DSKFRE),BEGIN
         LA    R15,CDSKSERR            NO SPACE AVAILABLE
         B     DSKGETX                 |
         END   ,                       OF NO SPACE AVAILABLE
         CLEAR SIZ                     START OFF WITH CLOSEST = 0
         LA    CUR,DSKHEAD-DSKBLK      START OF LIST
BSTLOOK  LR    LAS,CUR                 ADVANCE POINTER
         LH    CUR,LASFFWD(DSK)        |
         IF    (CUR,NE,CDSKNIL),BEGIN  NOT END YET; LOOK FOR BEST
         LH    NEW,CURSIZ(DSK)         SIZE OF THIS BLOCK
         IF    (NEW,GE,R0),BEGIN       IT'S BIG ENOUGH
         IF    ((NEW,LE,SIZ),OR,(SIZ,LT,R0)),BEGIN      BEST SO FAR
*    Since all searches are done by address (lowest address first),
* this test will choose as the best fit block, (from a group of
* blocks of the same size) the one with the highest address.  By
* consistantly allocating from the top of the pool (first and best
* fit), one obtains a less fragmented pool.
         LR    R1,CUR                  R1 = LOC; SIZ = LENGTH
         LR    SIZ,NEW                 |
         END   ,                       BEST SO FAR
         END   ,                       BEING BIG ENOUGH
         B     BSTLOOK                 KEEP LOOKING
         END   ,                  END OF LIST; CHECK IF BEST FOUND
         IF    (SIZ,GE,R0),BEGIN       YES, SPACE WAS FOUND
         LR    CUR,R1                  CUR = LOC; SIZ = LEN
         END   ELSE,BEGIN              NO, SPACE WASN'T FOUND
         LA    R15,CDSKSERR            NO SPACE AVAILABLE
         B     DSKGETX                 |
         END   ,
         END   ELSE,BEGIN              FIRST FIT REQUESTED
         LCR   R0,R0                   COMPLEMENT LENGTH
         A     R0,=A(CDSKLLIM-1)       ROUND LEN UP TO NEXT 8 BYTES
         N     R0,=A(-CDSKLLIM)        |
         IF    (R0,GT,DSKFRE),BEGIN
         LA    R15,CDSKSERR            NO SPACE AVAILABLE
         B     DSKGETX                 |
         END   ,                       OF NO SPACE AVAILABLE
         LA    CUR,DSKHEAD-DSKBLK      LIST HEAD POINTER
FIRLOOK  LR    LAS,CUR                 INCREMENT, POINTER STYLE
         LH    CUR,LASFFWD(DSK)        |
         IF    (CUR,EQ,CDSKNIL),BEGIN
         LA    R15,CDSKSERR            NO SPACE AVAILABLE
         B     DSKGETX
         END   ,
         LH    SIZ,CURSIZ(DSK)         GET SIZE(CURRENT)
         IF    (SIZ,LT,R0),FIRLOOK     IF BLOCK SMALL, LOOK AHEAD
         END   ,                       BLK FOUND; CUR=LOC, SIZ=LEN
         IF    (SIZ,NE,R0),BEGIN       NOT ALL SPACE TAKEN
         SR    SIZ,R0                  SPACE LEFT OVER
         STH   SIZ,CURSIZ(DSK)         | SAVE IT
         LR    R1,CUR                  ADDRESS OF ALLOC
         AR    R1,SIZ                  | R1=ALLOC LOC, R0=ALLOC LEN
         END   ELSE,BEGIN              ALL SPACE TAKEN
* DELETE FIRST-FIT LINK NOW
         LH    LAS,CURFBAC(DSK)   GET PREV ELEMENT IN FIRST-FIT LIST
         LH    NEW,CURFFWD(DSK)        LAST NOW POINTS TO NEXT
         STH   NEW,LASFFWD(DSK)        |
         IF    (NEW,NE,CDSKNIL),BEGIN  IF NOT LAST ELEMENT
         STH   LAS,NEWFBAC(DSK)        NEXT NOW POINTS TO PREV
         END   ,
         END   ,                       FIRST-FIT LINK IS NOW REMOVED
         LH    SIZ,DSKFRE         GET AMOUNT OF FREE MEM REMAINING
         SR    SIZ,R0             SUBTRACT CURRENT ALLOCATED AMOUNT
         STH   SIZ,DSKFRE              STORE ADJUSTED VALUE
         LR    R4,R2                   SAVE DSK REGISTER
         LA    R2,@R1(DSK)             ADDRESSABILITY TO THIS BLOCK
         ZOT   (R2),(R0),REG1=R14,REG2=R2       CLEAR ALLOC
         LR    R2,R4                   RESTORE DSK REGISTER
         SET DSKFMOD
         CLEAR R15                     ALL OK, SET RETURN CODE
DSKGETX  LABEL ,
         LH    R14,DSKFRE              SPACE REMAINING
DGERROR  DIREST FBR
         LTR   R15,R15                 SET CC
         BR    RAR
* PAGE
         TITLE 'DskFree'
*********************************************************************
* ON ENTRY: R1 MUST CONTAIN THE BLOCK BUFFER START ADDRESS          *
*           R15 MUST CONTAIN THE ADDRESS (RELATIVE TO THE           *
*                    START OF THE BLOCK) OF THE AREA TO BE LINKED   *
*           R0 MUST CONTAIN SIZE OF AREA TO BE LINKED               *
* ON EXIT:                                                          *
*          DSK = BLOCK BUFFER START ADDRESS                         *
*          CC = 0                                                   *
*            R1 POINTS TO LINKED BLOCK (RELATIVE TO START OF BLOCK) *
*            R14 CONTAINS FREE SPACE NOW ON BLOCK                   *
*          CC ^ 0                                                   *
*            R14 = PSW @ ERROR DETECTION                            *
*            IF R15 = 4,  LENGTH ERROR                              *
*            IF R15 = 8,  ADDRESS ERROR                             *
*            IF R15 = 12, OVERLAP ERROR                             *
*********************************************************************
         SPACE
DSKFREE  DIRENT FBR
         LR    DSK,R1                  GET CONTROL BLOCK ADDRESS
         A     R0,=A(CDSKLLIM-1)       ROUND UP SIZE TO 8 BYTES
         N     R0,=A(-CDSKLLIM)        |
         LH    R1,FSBDAVA              FREE SPACE ON A BLOCK
         IF    ((R0,NPOS),OR,(R0,GT,R1)),'BAS R14,DSKLNER '
         LR    NEW,R15                 CHECK FOR CDSKLLIM BOUNDARY
         N     NEW,=A(-CDSKLLIM)       |
         IF    ((NEW,NE,R15),OR,(NEW,NPOS)),'BAS R14,DSKADER '
         LR    R1,R0                   CHECK FOR BLOCK OVERFLOW
         AR    R1,NEW                  |
         LH    R15,FSBDSZ              HIGHEST AVAILABLE OFFSET
         SH    R15,=Y(8)               |
         IF    (R1,GT,R15),'BAS R14,DSKLNER '
*                                 SIZE OF BLOCK IS IN R0
*
* INSERT INTO FIRST FIT LIST
*
         LA    CUR,DSKHEAD-DSKBLK      POINT TO HEADER
LINKMEM  LR    LAS,CUR                 ADVANCE POINTER BY ONE LINK
         LH    CUR,LASFFWD(DSK)        UPDATE POINTER TO CURRENT LINK
         IF    ((NEW,GE,CUR),AND,(CUR,NE,CDSKNIL)),LINKMEM
*   If the block being freed starts before the previous free block
* ends, or ends after the next free block starts, then it is an
* error.
         LR    R1,LAS
         AH    R1,LASSIZ(DSK)
         IF    (NEW,LT,R1),'BAS R14,DSKOVER '   BLK STARTS BEFORE PREV
         IF    (CUR,NE,CDSKNIL),BEGIN  IF NOT END OF LIST
         LR    R1,NEW
         AR    R1,R0
         IF    (R1,GT,CUR),'BAS R14,DSKOVER '   BLK ENDS AFTER NEXT
         END   ,                       OF NOT AT END OF LIST
*        INSERT IF BEFORE CURRENT ADDRESS OR IF AT END OF LIST
         STH   CUR,NEWFFWD(DSK)        NEW NOW POINTS AHEAD TO CUR
         IF    (CUR,NE,CDSKNIL),BEGIN  IF NOT END OF LIST
         STH   NEW,CURFBAC(DSK)        CUR POINTS BACK TO NEW
         END   ,
         STH   NEW,LASFFWD(DSK)   LAST NOW POINTS AHEAD TO NEW BLOCK
         STH   LAS,NEWFBAC(DSK)        NEW POINTS BACK TO LAS
         STH   R0,NEWSIZ(DSK)          STORE SIZE OF BLOCK IN BLOCK
         LR    CUR,NEW                 NOW IT'S INSERTED AND CUR BLOCK
*
* TEST TO COLLAPSE LOW END
*
         LR    NEW,LAS                 ADDRESS OF LAST BLOCK
         AH    NEW,LASSIZ(DSK)         ADD SIZE OF BLOCK
         IF    (NEW,EQ,CUR),BEGIN      IF BLOCKS ADJACENT COLLAPSE
         LH    NEW,CURFFWD(DSK)        LAST POINTS TO NEXT
         STH   NEW,LASFFWD(DSK)        |
         IF    (NEW,NE,CDSKNIL),BEGIN  IF NOT AT END OF LIST
         STH   LAS,NEWFBAC(DSK)   NEXT BLOCK POINTS BACK PAST MERGE
         END   ,
         LH    SIZ,LASSIZ(DSK)         SIZE OF LAST
         AH    SIZ,CURSIZ(DSK)    ADD SIZE OF CURRENT TO GET TOTAL
         STH   SIZ,LASSIZ(DSK)         STORE SIZE IN BLOCK
         LR    CUR,LAS            AFTER COLLPSE CURRENT IS OLD LAST
         END   ,
*
* TEST TO COLLAPSE HIGH END
*
         LR    SIZ,CUR                 GET ADDRESS OF CURRENT
         AH    SIZ,CURSIZ(DSK)    ADD SIZE OF CURRENT (ADDR OF ADJ)
         LH    NEW,CURFFWD(DSK)        LOAD POINTER TO NEXT
         IF    (NEW,EQ,SIZ),BEGIN      IF ADJACENT COLLAPSE
         LH    NEW,NEWFFWD(DSK)        CUR BLOCK POINTS PAST NEXT
         STH   NEW,CURFFWD(DSK)        |
         IF    (NEW,NE,CDSKNIL),BEGIN  IF NOT AT END OF LIST
         STH   CUR,NEWFBAC(DSK)   NEXT BLOCK POINTS BACK PAST MERGE
         END   ,
         LR    NEW,SIZ                 NEW IS AGAIN NEXT (FROM ABOVE)
         LH    SIZ,CURSIZ(DSK)         GET SIZE OF CUR
         AH    SIZ,NEWSIZ(DSK)         ADD SIZE OF NEXT
         STH   SIZ,CURSIZ(DSK)         SAVE SIZE OF BLOCK IN BLOCK
         END   ,
         AH    R0,DSKFRE               TOTAL UP AMOUNT OF FREE MEMORY
         STH   R0,DSKFRE               STORE THIS IN BLOCK
         LR    R1,CUR                  R1 POINTS TO LINKED BLOCK
         SET DSKFMOD
         CLEAR R15                     ALL OK, SET RETURN CODE
DSKFREX  LABEL ,
         LH    R14,DSKFRE              FREE SPACE AVAILABLE
DFERROR  DIREST FBR
         LTR   R15,R15                 SET CC
         BR    RAR
         SPACE 2
DSKLNER  LABEL ,
         LA    R15,CDSKLNER            INDICATE LENGTH ERROR
         B     DFERROR                 EXIT
DSKADER  LABEL ,
         LA    R15,CDSKADER            INDICATE ADDRESS ERROR
         B     DFERROR                 EXIT
DSKOVER  LABEL ,
         LA    R15,CDSKOVER            INDICATE OVERLAP ERROR
         B     DFERROR                 EXIT
         SPACE 2
         DROP  LAS                     LAST ADDR
         DROP  CUR                     CURRENT ADDR
         DROP  NEW                     NEWCHAIN ADDR
         TITLE ' '
         LTORG ,
         TITLE 'No More Room Recovery'
*********************************************************************
*   For recovery, the buffers must be nullified, and if a rename    *
* insert was in progress then the old entry must be reinserted.     *
*   If a Rename reinsert was being done, then KAPUT!                *
*********************************************************************
CATNMR   DIRENT FBR,RAR
         IF    (CHKI3TYP,EQ,CCHKREN),'ABORT  CATRENNR'
         IF    (CHKITYPE,NZ),BEGIN     BACK OUT OF FIRST LEVEL
         MVC   CHKCHAIN,CHKICHAN
         CLEAR CHKIVLV1
         END   ,                       OF BACK OUT OF FIRST LEVEL
         LCALL NILBUF                  RESET BUFFER CONTENTS
         IF    (CHKFBNO,LE,FSBLOGFR),BEGIN      UNDER LOGICAL LIMIT
         SET   FSBCATNIN               NO INSERTS
         IF    (CHKFBNO,LE,FSBMNFRE),BEGIN      UNDER MINIMUM
         SET   FSBCATNLM               NoLengthModify MODE
*
         ST    WR,RQBLSPTR             SAVE WORK REG
         L     WR,RQBLWR2              | AND GET OLD WR
*
&MSG1    SETC  ' ORVYL File System Updates Frozen!!'
VWTOMSG1 RECORD BEGIN                  VWTO MESSAGE LENGTH
FSNAME1  DS    CL8                     File System name
MSG1     DS    C'&MSG1'
MSGTOT1  EQU   FSNAME1,*-FSNAME1,C'R'
         END   ,
         VPUSH ,,L'VWTOMSG1,PTR=R1
         WITH  (VWTOMSG1,R1),BEGIN     MESSAGE AREA ADDR
         MVC   FSNAME1,FSBNAME         | FILE SYS NAME
         MVC   MSG1,=C'&MSG1'          | MESSAGE
         LA    R0,L'MSGTOT1            | LEN
         LCR   R0,R0                   | Negative = No Erase
         END   ,                       OF MESSAGE AREA ADDR
         XTRC  R0,R1,VWTO
* -->    VCALL VWTO                    (R1,R0)=(LOC,LEN)
         VPOP  ,,L'VWTOMSG1
*
         ST    WR,RQBLWR2              SAVE WORK AREA PTR
         L     WR,RQBLSPTR             | GET MY POINTER BACK
         END   ,                       OF UNDER MINIMUM
         ELSE  'CLEAR FSBCATNLM'       CLEAR NoLenMod
         END   ,                       OF UNDER LOGICAL LIMIT
         ELSE  'CLEAR FSBCATNLM*FSBCATNIN'
         CLEAR R15
         DIREST FBR,RAR
         LTR   R15,R15
         BR    RAR
CATNMRER ABORT  CATNMR                 No More Room Error
         TITLE 'Checkpoint Recovery'
*********************************************************************
*   Note:  Of the 4 minimum rotating buffers used in VCAT, one is   *
* locked in core for a checkpoint copy during 1st level intentions. *
* This allows lower level routines to work with a checkpoint copy   *
* and yet not permanently alter block counts, chain pointers etc.   *
* Currently the only 1st level recovery routine to call NODBAL      *
* is the Root Split recovery operation and it uses only 3           *
* buffers (1 for root, and 2 offspring).                            *
*   If other 1st level checkpoint routines change, this must be     *
* taken into account, or else there is the possibility of a ABORT   *
* CATIOS, when the buffer management routines run out of I/O space. *
*********************************************************************
CATREC   CATENT ,
         BASE  FBR
*               Look for a free buffer to copy checkpoint to
         LA    R2,CFSBPL               INDEX INCREMENT
         L     R3,FSBBLKTOP            UPPER LIMIT
         LA    R4,FSBBLK1              STARTING ADDR
CHKAVCOR CLI   @R4+CFSBPL-1,X'00'      AVAILABLE?
         IF    EQUAL,BEGIN             | YES
         L     DSK,@R4+CFSBBL          BUFFER ADDRESS
         OC    @R4+CFSBBL(4),=A(VIOLOCK)        LOCK IT
         CLEAR (@R4,CFSBBL)            BLOCK 0 = CHKPNT
         B     CHKCORFN                FOUND SLOT
         END   ,                       OF AVAILABLE
         BXLE  R4,R2,CHKAVCOR          CONTINUE LOOKING
         ABORT  CHKNOCOR               NO CORE
CHKCORFN ST    DSK,CHKCHKA             CHKPNT COPY (ADDR)
         LH    R15,FSBDSZ              | LEN
         LR    R1,R15                  | |
         LR    R0,DSK                  LOC (DEST)
         LR    R14,CHKR                | (SOURCE)
         MVCL  R0,R14                  COPY CHECKPOINT
*
         LC    R15,CHKITYPE
         IF    (R15,GT,CCHKNTDL),BEGIN NOT IMPLEMENTED
         ABORT  CHK1NIMP
         END   ,                       OF NOT IMPLEMENTED
         CLEAR CHKSTKP                 SEARCH_STACK POINTER
         MVC   CHKAPNT(1),=&L.AL1(NIL) SET POINTERS TO NIL
         MVC   CHKAPNT+1(L'CHKAPNT-1),CHKAPNT   |
         B     TABLE1(R15)
TABLE1   B     LEVEL2                  NO 1ST LEVEL INTENTIONS
         B     CHKRTIN
         B     CHKRTDL
         B     CHKRTSP
         B     CHKRTCL
         B     CHKNBAL
         B     CHKBINS
         B     CHKBDEL
         B     CHKNTRY
         B     CHKNTIN
         B     CHKNTDL
*********************************************************************
*   For the 1st level recovery, it is important that Checkpoint     *
* fields other than the block chain fields aren't changed.  The     *
* INSXTND and DELXTND parameters on the NTRYCHG calls are important *
* because they keep the wrong Checkpoint fields from being modified *
*********************************************************************
         TITLE 'Checkpoint Recovery - Root Insert'
CHKRTIN  LABEL ,                       Root Insert Recovery
         IF    CHKIFLG.CHKFACC,BEGIN   ACCOUNT ROOT INSERT
         ABORT  CHKRTIN                CURRENTLY ONLY FOR FILES
         END   ELSE,BEGIN              FILE ROOT INSERT
*               Deal with new extended entry
         IF ('CLC CHKININB(PL),=&L.AL1(NIL)',NE),BEGIN  NEW EXISTS
         DREAD CHKININB,ERR=CHKRECER   LOOK AT NEX EXTENDED ENTRY
         IF    ('CLC CHKININC,DSKTAG',EQ),BEGIN NEW ^ WRITTEN
         IF    ^DSKFINIT,BEGIN         INITIALIZE SPACE MGMT PTRS
         DSKINIT CHKININB,(DSK)        |
         SET   DSKFDATA                | WILL BE USED FOR EXTND DATA
         END   ,                       OF INITIALIZE SPACE MGMT PTRS
         LA    NOD,CHKINTRY            ADDR TO ENTRY COPY
         WITH  (NTRY,NOD),BEGIN        |
         MVC   CHKBSLN,NTRYLEN         ENTRY LENGTH
         END   ,                       OF ADDR TO ENTRY COPY
         GETNODE PTRS=2WR,DATA=CHKININB,ERR=CHKRECER
         SET   DSKFMOD                 WILL MODIFY THIS BLOCK
         LA    NOD,CHKINTRY            ADDR TO ENTRY COPY
         WITH  (NTRY,NOD),BEGIN        |
         IF    ('CLC NTRYDATB(PL),CHK2WRB',NE),BEGIN
         ABORT  CHKNTXT                EXTENDED PTRS DON'T MATCH
         END   ,
         END   ,                       OF ADDR TO ENTRY COPY
         LA    NOD,DSKBLK(R1)          (R1 IS BLOCK OFFSET ON RET)
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REGS
         WITH  (NTRYXTND,NOD),'LA MIX,NTRYXPER '        DEST OF MOV
         IF    CHKFACC,'LH PTR,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH PTR,FSBNFMXL '      |
         LA    CNT,CHKINTRY            START OF EXTENDED
         ALR   CNT,PTR                 |
         LH    IX,CHKBSLN              LENGTH OF COPY
         SR    IX,PTR                  |
         LR    PTR,IX                  |
         MVCL  MIX,CNT                 COPY EXTENDED
         MVC   DSKBLINK,CHKININL       SET DISK LINK
         MVC   DSKFL,CHKININF          | AND FLAGS
         DWRITE CHKININB,ERR=CHKRECER  WRITE NEW BLOCK
         END   ,                       OF NEW ^ WRITTEN
         END   ,                       OF NEW EXISTS
*               Deal with entry block
         MVC   CHKCURB(PL),CHKINICB    LOOK AT ENTRY BLOCK
         DREAD CHKCURB,PTR=CUR,ERR=CHKRECER
         IF    ('CLC CHKINICC,DSKTAG',EQ),BEGIN CH INDEX PART
         DSKINIT CHKCURB,CHKCURA       INITIALIZE DISK BLOCK
         ALLOC (DSK),LH:FSBNFLEN,ERR=CHKRECER   NODE FOR ROOT
         LA    NOD,DSKBLK(R1)          ADDRESSABILITY TO NEW NODE
         WITH  (NODE,NOD),BEGIN        |
         SET   NODFTRT*NODFLEAF        ROOT OF TREE AND LEAF
         INCR  QR,NODNTNUM             SET ENTRY COUNT
         STH   R0,NODLEN               SAVE SIZE
         LA    PTR,NODNTRYS            ADDRESSABILITY TO ENTRIES
         WITH  (NTRY,PTR),BEGIN        |
         MVC   NTRY(1),=&L.AL1(NIL)    NIL 1ST ENTRY
         MVC   NTRY+1(CNODNLLN-1),NTRY |
         END   ,                       OF ADDRESSABILITY TO ENTRIES
         MVC   NODSPACE,FSBNFSPA
         LA    R15,NODNTRYS            R15/R14 = OLD ENTRY LOC/LEN
         CLEAR R14                     |
         END   ,                       OF ADDRESSABILITY TO NEW NODE
         LA    R1,CHKINTRY             R1/R0 = NEW ENTRY LOC/LEN
         WITH  (NTRY,R1),'LH R0,NTRYLEN '
         CEIL  R0,FSBNFMXL             INDEX MAX
*                 By making the copy length at most the max length
*               allowed in an index node, the NTRYCHG routine won't
*               reallocate a new extended data block, which has
*               already been written.  This and the index pointer
*               parms on the NTRYCHG call are important for pointer
*               integrity.
         NTRYCHG DEST=CUR,DELXTND=NO,INSXTND=NO,ERR=CHKRECER
         DWRITE CHKCURB,ERR=CHKRECER   WRITE MODIFIED
         END   ,                       OF CHANGE INDEX PART
*               Deal with account entry
         DREAD CHKINIAB,ERR=CHKRECER   READ ACCOUNT ENTRY
         IF    ('CLC CHKINIAC,DSKTAG',EQ),BEGIN ACC ^ WRITTEN
         SET   DSKFMOD                 WILL MODIFY BLOCK
         LH    NOD,CHKINIAN            ADDR TO ACCOUNT ENTRY
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NTRY,NOD),'MVC NTGFLRB(PL),CHKINICB '   FILE RT PTR
         DWRITE CHKINIAB,ERR=CHKRECER
         END   ,                       OF ACC ^ WRITTEN
         END   ,                       OF FILE ROOT INSERT
         B     CHKCLR1                 Clear 1st level of CHECKPOINT
         TITLE 'Checkpoint Recovery - Root Delete'
CHKRTDL  LABEL ,                       Root Delete Recovery
         IF    CHKIFLG.CHKFACC,BEGIN   ACCOUNT ROOT DELETE
         ABORT  CHKRTDL                CURRENTLY ONLY DONE FOR FILE
         END   ELSE,BEGIN              FILE ROOT DELETE
*               If Account entry not written, set file root to nil
         DREAD CHKINDAB,ERR=CHKRECER   LOOK AT ACCOUNT BLOCK
         IF    ('CLC CHKINDAC,DSKTAG',EQ),BEGIN ACC ^ WRITTEN
         LH    NOD,CHKINDAN            MAKE ACC FILE TREE NIL
         LA    NOD,DSKBLK(NOD)         |
         WITH (NTRY,NOD),'MVC NTGFLRB(PL),=&L.AL1(NIL) '
         DWRITE CHKINDAB,ERR=CHKRECER  |
         END   ,                       OF ACC ^ WRITTEN
*               If current not written, release node
         DREAD CHKINDCB,ERR=CHKRECER   LOOK AT CURRENT NODE
         IF    ('CLC CHKINDCC,DSKTAG',EQ),BEGIN CUR ^ WRITTEN
         LH    NOD,CHKINDCN            ADDR TO CUR
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NODE,NOD),BEGIN        |
         RELNODE CHKINDCN,NODLEN,(DSK),ERR=CHKRECER
         END   ,                       OF ADDR TO CUR
         MVC   DSKBLINK,CHKINDCL       LINK TO OLD FREE BLOCK
         DWRITE CHKINDCB,ERR=CHKRECER
         END   ,                       OF CUR ^ WRITTEN
*               If extended exists and not written, release it
         IF ('CLC CHKINDOB(PL),=&L.AL1(NIL)',NE),BEGIN  EXT EXISTS
         DREAD CHKINDOB,ERR=CHKRECER   LOOK AT EXTENDED DATA
         IF    ('CLC CHKINDOC,DSKTAG',EQ),BEGIN EXT ^ WRITTEN
         MVC   CHKCHAIN,CHKICHAN       OLD CHAIN POINTERS
         LH    NOD,CHKINDON            ADDR TO EXTENDED DATA
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NTRYXTND,NOD),BEGIN    |
         RELNODE CHKINDON,NTRYXLEN,(DSK),ERR=CHKRECER
         END   ,                       OF ADDR TO EXTENDED DATA
         MVC   DSKBLINK,CHKINDOL       LINK TO CORRECT BLOCK
         MVC   DSKFL,CHKINDOF          | AND FLAGS
         DWRITE CHKINDOB,ERR=CHKRECER
         END   ,                       OF EXT ^ WRITTEN
         END   ,                       OF OLD EXTENDED EXISTS
         END   ,                       OF FILE ROOT DELETE
         B     CHKCLR1                 Clear 1st level of Checkpoint
         TITLE 'Checkpoint Recovery - Root Split'
CHKRTSP  LABEL ,                       Root Split Recovery
         DREAD CHKIRSCB,LOCK=YES,ERR=CHKRECER   CURRENT = FREE AGAIN
         CLEAR DSKFINIT                | FREE = SPACE MGMT NOT INIT
         MVC   DSKBLINK,CHKFREB        |
         MVC   CHKFREB,CHKIRSCB        |
         DREAD CHKIRSLB,LOCK=YES,ERR=CHKRECER   LEFT = FREE AGAIN
         CLEAR DSKFINIT                | FREE = SPACE MGMT NOT INIT
         MVC   DSKBLINK,CHKFREB        |
         MVC   CHKFREB,CHKIRSLB        |
*                 Since the checkpoint block being worked with is
*               only a temporary copy, and the real space management
*               pointers will be copied back from the permanent copy
*               the block counts don't need to be updated.
*                 Start over with transaction.
         MVC   CHKCURB(PL),CHKIRSPB    READ DOUBLE WRITE 1 AS CUR
         DDREAD 1,CHKCURB,ERR=CHKRECER |
         ST    DSK,CHKCURA             |
         ACALL NODBAL                  LET BALANCE DO CLEAN UP
         IF    NZ,'ACALL CHKRECER '
         B     CHKCLR1                 Clear 1st level of Checkpoint
         TITLE 'Checkpoint Recovery - Root Collapse'
CHKRTCL  ABORT  CHKRTCL                Root Collapse Recovery
*               Not checkpointed now
         TITLE 'Checkpoint Recovery - Balance, No Insert/Delete'
CHKNBAL  LABEL ,                       Balance (no Ins/Del) Recovery
         MVC   CHKPARB(PL),CHKINBPB    LOOK AT PARENT ENTRY
         DREAD CHKPARB,PTR=PAR,ERR=CHKRECER
         IF    ('CLC CHKINBPC,DSKTAG',NE),BEGIN PAR WRITTEN
         IF    CHKFLFTU,BEGIN          READ AND WRITE LEFT
         DDREAD 1,CHKINBLB,ERR=CHKRECER         |
         DWRITE CHKINBLB,ERR=CHKRECER  |
         END   ,                       |
         DDREAD 2,CHKINBCB,ERR=CHKRECER         READ AND WRITE CURRENT
         DWRITE CHKINBCB,ERR=CHKRECER  |
         IF    CHKFRHTU,BEGIN          READ AND WRITE RIGHT
         DDREAD 3,CHKINBRB,ERR=CHKRECER         |
         DWRITE CHKINBRB,ERR=CHKRECER  |
         END   ,                       |
         END   ,                       OF PARENT WRITTEN
*               If Parent not written let next transaction do balance
         B     CHKCLR1                 Clear 1st level of CHECKPOINT
         TITLE 'Checkpoint Recovery - Balance with Insert'
CHKBINS  LABEL ,                       Balance with Insert recovery
         MVC   CHKPARB(PL),CHKIBIPB    LOOK AT PARENT ENTRY
         DREAD CHKPARB,PTR=PAR,ERR=CHKRECER
         IF    ('CLC CHKIBIPC,DSKTAG',NE),BEGIN PAR WRITTEN
         DDREAD 1,CHKIBILB,ERR=CHKRECER READ AND WRITE LEFT BLOCK
         DWRITE CHKIBILB,ERR=CHKRECER  |
         DDREAD 2,CHKIBICB,ERR=CHKRECER READ AND WRITE CURRENT BLOCK
         DWRITE CHKIBICB,ERR=CHKRECER  |
         DDREAD 3,CHKIBIRB,ERR=CHKRECER READ AND WRITE RIGHT BLOCK
         DWRITE CHKIBIRB,ERR=CHKRECER  |
         END   ELSE,BEGIN              PARENT NOT WRITTEN
*               If parent not written, then neither is the new
*             Current block, so only the Checkpoint free list pointer
*             needs to be changed back before it is left to the next
*             transaction to do a balance with insert.
         L     PTR,CHKCHKA             PUT CURRENT BACK ON FREE LIST
         WITH  (CHKPNT,PTR),BEGIN      |
         MVC   CHKCHAIN,CHKICHAN       | OLD BLOCK PTRS & COUNTERS
         END   ,                       OF PUT CUR BACK ON FREE LIST
         END   ,                       OF PARENT NOT WRITTEN
         B     CHKCLR1                 Clear 1st level of CHECKPOINT
         TITLE 'Checkpoint Recovery - Balance with Delete'
CHKBDEL  LABEL ,                       Balance with Delete Recovery
         MVC   CHKPARB(PL),CHKIBDPB    LOOK AT PARENT ENTRY
         DREAD CHKPARB,PTR=PAR,ERR=CHKRECER
         IF    ('CLC CHKIBDPC,DSKTAG',NE),BEGIN PAR WRITTEN
         DDREAD 1,CHKIBDLB,ERR=CHKRECER         READ AND WRITE LEFT
         DWRITE CHKIBDLB,ERR=CHKRECER  |
         DDREAD 2,CHKIBDCB,ERR=CHKRECER         READ AND WRITE CURRENT
         DWRITE CHKIBDCB,ERR=CHKRECER  |
*               If parent has been written, then the Checkpoint
*             free list pointer has been updated, and only the
*             block needs to be updated.
         DREAD CHKIBDOB,ERR=CHKRECER   PUT OLD BLOCK ON FREE CHAIN
         CLEAR DSKFINIT                | FREE = SPACE MGMT NOT INIT
         MVC   DSKBLINK,CHKIFREB       |
         DWRITE CHKIBDOB,ERR=CHKRECER  |
         END   ELSE,BEGIN              PARENT NOT WRITTEN
*               If parent hasn't been written, then the Checkpoint
*             pointer needs to be restored to its old value and
*             then let the next transaction do the balance.
         L     PTR,CHKCHKA             WOULD_BE_DEL OFF FREE CHAIN
         WITH  (CHKPNT,PTR),BEGIN      |
         MVC   CHKCHAIN,CHKICHAN       | OLD BLOCK PTRS AND COUNTERS
         END   ,                       OF WOULD_BE_DEL OFF FREE CHAIN
         END   ,                       OF PARENT NOT WRITTEN
         B     CHKCLR1                 Clear 1st level CHECKPOINT
         TITLE 'Checkpoint Recovery - Modify Entry'
CHKNTRY  LABEL ,                       Modify Entry Recovery
*                 Deal with old extended entry
*               Old extended must be deleted before new is allocated
*               because the new extended might use all or part of
*               old extended's space
         IF ('CLC CHKINTOB(PL),=&L.AL1(NIL)',NE),BEGIN  OLD EXISTS
         DREAD CHKINTOB,ERR=CHKRECER   LOOK AT OLD
         IF    ('CLC CHKINTOC,DSKTAG',EQ),BEGIN OLD ^ WRITTEN
         LH    NOD,CHKINTON            ADDR TO OLD EXTENDED
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NTRYXTND,NOD),BEGIN    |
         RELNODE CHKINTON,NTRYXLEN,(DSK),ERR=CHKRECER
         END   ,                       OF ADDR TO OLD EXTENDED
         MVC   DSKBLINK,CHKINTOL       PROPER BLOCK LINK
         MVC   DSKFL,CHKINTOF          | AND FLAGS
         IF    (CHKINTOB,NE,CHKINTNB),BEGIN     OLD <> NEW
         DWRITE CHKINTOB,ERR=CHKRECER  WRITE OLD EXTENDED
         END   ,                       OF OLD <> NEW
         END   ,                       OF OLD NOT WRITTEN
         END   ,                       OF OLD EXISTS
*               Deal with new extended entry
         IF ('CLC CHKINTNB(PL),=&L.AL1(NIL)',NE),BEGIN  NEW EXISTS
         DREAD CHKINTNB,ERR=CHKRECER   LOOK AT NEX EXTENDED ENTRY
         IF    ('CLC CHKINTNC,DSKTAG',EQ),BEGIN NEW ^ WRITTEN
         IF    ^DSKFINIT,BEGIN         INITIALIZE SPACE MGMT PTRS
         DSKINIT CHKINTNB,(DSK)        |
         SET   DSKFDATA                | WILL BE USED FOR EXTND DATA
         END   ,                       OF INITIALIZE SPACE MGMT PTRS
         LA    NOD,CHKINTRY            ADDR TO ENTRY COPY
         WITH  (NTRY,NOD),BEGIN        |
         MVC   CHKBSLN,NTRYLEN         ENTRY LENGTH
         END   ,                       OF ADDR TO ENTRY COPY
         GETNODE PTRS=2WR,DATA=CHKINTNB,ERR=CHKRECER
         SET   DSKFMOD                 WILL MODIFY THIS BLOCK
         LA    NOD,CHKINTRY            ADDR TO ENTRY COPY
         WITH  (NTRY,NOD),BEGIN        |
         IF    ('CLC NTRYDATB(PL),CHK2WRB',NE),BEGIN
         ABORT  CHKNTXT                EXTENDED PTRS DON'T MATCH
         END   ,
         END   ,                       OF ADDR TO ENTRY COPY
         LA    NOD,DSKBLK(R1)          (R1 IS BLOCK OFFSET ON RET)
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REGS
         WITH  (NTRYXTND,NOD),'LA MIX,NTRYXPER '        DEST OF MOV
         IF    CHKFACC,'LH PTR,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH PTR,FSBNFMXL '      |
         LA    CNT,CHKINTRY            START OF EXTENDED
         ALR   CNT,PTR                 |
         LH    IX,CHKBSLN              LENGTH OF COPY
         SR    IX,PTR                  |
         LR    PTR,IX                  |
         MVCL  MIX,CNT                 COPY EXTENDED
         MVC   DSKBLINK,CHKINTNL       SET DISK LINK
         MVC   DSKFL,CHKINTNF          | AND FLAGS
         DWRITE CHKINTNB,ERR=CHKRECER  WRITE NEW BLOCK
         END   ,                       OF NEW ^ WRITTEN
         END   ,                       OF NEW EXISTS
*               Deal with entry block
         MVC   CHKCURB(PL),CHKINTCB    LOOK AT ENTRY BLOCK
         DREAD CHKCURB,PTR=CUR,ERR=CHKRECER
         IF    ('CLC CHKINTCC,DSKTAG',EQ),BEGIN CH INDEX PART
         LH    R15,CHKINTCT            R15/R14 = OLD ENTRY LOC/LEN
         LA    R15,DSKBLK(R15)         |
         WITH  (NTRY,R15),'LH R14,NTRYLEN '
         LA    R1,CHKINTRY             R1/R0 = NEW ENTRY LOC/LEN
         WITH  (NTRY,R1),'LH R0,NTRYLEN '
         IF    CHKFACC,'LH QR,FSBNAMXL '        INDEX MAX
         ELSE  'LH QR,FSBNFMXL '       |
         CEIL  R0,QR                   |
*                 By making the copy length at most the max length
*               allowed in an index node, the NTRYCHG routine won't
*               reallocate a new extended data block, which has
*               already been written.  This and the index pointer
*               parms on the NTRYCHG call are important for pointer
*               integrity.
         NTRYCHG DEST=CUR,DELXTND=NO,INSXTND=NO,ERR=CHKRECER
         DWRITE CHKCURB,ERR=CHKRECER   WRITE MODIFIED
         END   ,                       OF CHANGE INDEX PART
         B     CHKCLR1                 Clear 1st level CHECKPOINT
         TITLE 'Checkpoint Recovery - Insert Entry'
CHKNTIN  LABEL ,                       Entry Insert Recovery
*               Deal with new extended entry
         IF ('CLC CHKININB(PL),=&L.AL1(NIL)',NE),BEGIN  NEW EXISTS
         DREAD CHKININB,ERR=CHKRECER   LOOK AT NEX EXTENDED ENTRY
         IF    ('CLC CHKININC,DSKTAG',EQ),BEGIN NEW ^ WRITTEN
         IF    ^DSKFINIT,BEGIN         INITIALIZE SPACE MGMT PTRS
         DSKINIT CHKININB,(DSK)        |
         SET   DSKFDATA                | WILL BE USED FOR EXTND DATA
         END   ,                       OF INITIALIZE SPACE MGMT PTRS
         LA    NOD,CHKINTRY            ADDR TO ENTRY COPY
         WITH  (NTRY,NOD),BEGIN        |
         MVC   CHKBSLN,NTRYLEN         ENTRY LENGTH
         END   ,                       OF ADDR TO ENTRY COPY
         GETNODE PTRS=2WR,DATA=CHKININB,ERR=CHKRECER
         SET   DSKFMOD                 WILL MODIFY THIS BLOCK
         LA    NOD,CHKINTRY            ADDR TO ENTRY COPY
         WITH  (NTRY,NOD),BEGIN        |
         IF    ('CLC NTRYDATB(PL),CHK2WRB',NE),BEGIN
         ABORT  CHKNTXT                EXTENDED PTRS DON'T MATCH
         END   ,
         END   ,                       OF ADDR TO ENTRY COPY
         LA    NOD,DSKBLK(R1)          (R1 IS BLOCK OFFSET ON RET)
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15) CHECK REGS
         WITH  (NTRYXTND,NOD),'LA MIX,NTRYXPER '        DEST OF MOV
         IF    CHKFACC,'LH PTR,FSBNAMXL '       MAX IN INDEX
         ELSE  'LH PTR,FSBNFMXL '      |
         LA    CNT,CHKINTRY            START OF EXTENDED
         ALR   CNT,PTR                 |
         LH    IX,CHKBSLN              LENGTH OF COPY
         SR    IX,PTR                  |
         LR    PTR,IX                  |
         MVCL  MIX,CNT                 COPY EXTENDED
         MVC   DSKBLINK,CHKININL       SET DISK LINK
         MVC   DSKFL,CHKININF          | AND FLAGS
         DWRITE CHKININB,ERR=CHKRECER  WRITE NEW BLOCK
         END   ,                       OF NEW ^ WRITTEN
         END   ,                       OF NEW EXISTS
*               Deal with entry block
         MVC   CHKCURB(PL),CHKINICB    LOOK AT ENTRY BLOCK
         DREAD CHKCURB,PTR=CUR,ERR=CHKRECER
         IF    ('CLC CHKINICC,DSKTAG',EQ),BEGIN CH INDEX PART
         LH    R15,CHKINTCN            NODE ADDRESS
         LA    R15,DSKBLK(R15)         |
         WITH (NODE,R15),'INCR QR,NODNTNUM '    ONE MORE NTRY
         LH    R15,CHKINTCT            R15/R14 = OLD ENTRY LOC/LEN
         LA    R15,DSKBLK(R15)         |
         CLEAR R14                     |
         LA    R1,CHKINTRY             R1/R0 = NEW ENTRY LOC/LEN
         WITH  (NTRY,R1),'LH R0,NTRYLEN '
         IF    CHKFACC,'LH QR,FSBNAMXL '        INDEX MAX
         ELSE  'LH QR,FSBNFMXL '       |
         CEIL  R0,QR                   |
*                 By making the copy length at most the max length
*               allowed in an index node, the NTRYCHG routine won't
*               reallocate a new extended data block, which has
*               already been written.  This and the index pointer
*               parms on the NTRYCHG call are important for pointer
*               integrity.
         NTRYCHG DEST=CUR,DELXTND=NO,INSXTND=NO,ERR=CHKRECER
         DWRITE CHKCURB,ERR=CHKRECER   WRITE MODIFIED
         END   ,                       OF CHANGE INDEX PART
         B     CHKCLR1                 Clear 1st level of CHECKPOINT
         TITLE 'Checkpoint Recovery - Delete Entry'
CHKNTDL  LABEL ,
*               Deal with leaf and current node in non leaf delete
         IF ('CLC CHKIND2B(PL),=&L.AL1(NIL)',NE),BEGIN  ^ LEAF DEL
         MVC   CHKCURB(PL),CHKIND2B    USE CUR PTRS SLOT
         DREAD CHKIND2B,PTR=CUR,ERR=CHKRECER    LOOK AT LEAF BLOCK
         IF    ('CLC CHKIND2C,DSKTAG',EQ),BEGIN LEAF ^WRITTEN
         LH    NOD,CHKIND2N            ADDR TO 1ST ENTRY IN NODE
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NODE,NOD),BEGIN        NODE ADDR
         DECR  QR,NODNTNUM             ONE LESS ENTRY
         LA    NOD,NODNTRYS            LEAF INDEX (IN CHKPNT)
         END   ,                       OF NODE ADDR
         LA    R1,CHKINTRY             NEW BUFFER (DUMMY)
         CLEAR R0                      | LEN
         LR    R15,NOD                 OLD BUFFER ADDR
         WITH  (NTRY,R15),'LH R14,NTRYLEN '     | INDEX LEN
         NTRYCHG DEST=CUR,DELXTND=NO,INSXTND=NO,ERR=CHKRECER
         DWRITE CHKIND2B,ERR=CHKRECER  DEL ENTRY
         END   ,                       OF LEAF ^ WRITTEN
         MVC   CHKCURB(PL),CHKINDCB    LOOK AT CURRENT BLOCK
         DREAD CHKCURB,PTR=CUR,ERR=CHKRECER
         IF    ('CLC CHKINDCC,DSKTAG',EQ),BEGIN CUR ^ WRITTEN
         LH    R15,CHKINDCT            ADDR TO OLD ENTRY
         LA    R15,DSKBLK(R15)         |
         WITH  (NTRY,R15),'LH R14,NTRYLEN '     | INDEX LEN
         LA    R1,CHKINTRY             ADDR TO NEW ENTRY (FROM LEAF)
         WITH  (NTRY,R1),'LH R0,NTRYLEN '       | INDEX LEN
         NTRYCHG DEST=CUR,DELXTND=NO,INSXTND=NO,ERR=CHKRECER
         DWRITE CHKINDCB,ERR=CHKRECER  COP LEAF NTRY
         END   ,                       OF CUR ^ WRITTEN
         END   ,                       OF ^ LEAF DELETE
*               Deal with current node in leaf delete
         ELSE  BEGIN                   LEAF DELETE
         MVC   CHKCURB(PL),CHKINDCB    LOOK AT ENTRY BLOCK
         DREAD CHKCURB,PTR=CUR,ERR=CHKRECER
         IF    ('CLC CHKINDCC,DSKTAG',EQ),BEGIN CH INDEX PART
         LH    R15,CHKINDCN            NODE ADDR
         LA    R15,DSKBLK(R15)         |
         WITH (NODE,R15),'DECR QR,NODNTNUM '    ONE LESS ENTRY
         LH    R15,CHKINDCT            R15/R14 = OLD ENTRY LOC/LEN
         LA    R15,DSKBLK(R15)         |
         WITH  (NTRY,R15),'LH R14,NTRYLEN '
         LA    R1,CHKINTRY             R1/R0 = NEW ENTRY LOC/LEN
         CLEAR R0                      | ZERO LEN = DELETE
*                 The index pointer parms on the NTRYCHG call are
*               required because they keep the NTRYCHG routine from
*               changing extended data ptrs when the extended data
*               has already been written.
         NTRYCHG DEST=CUR,DELXTND=NO,INSXTND=NO,ERR=CHKRECER
         DWRITE CHKINDCB,ERR=CHKRECER  WRITE MODIFIED
         END   ,                       OF CHANGE INDEX PART
         END   ,                       OF LEAF DELETE
*               Deal with extended data entry
         IF ('CLC CHKINDOB(PL),=&L.AL1(NIL)',NE),BEGIN  OLD EXISTS
         DREAD CHKINDOB,ERR=CHKRECER   LOOK AT OLD EXTENDED
         IF    ('CLC CHKINDOC,DSKTAG',EQ),BEGIN OLD ^ WRITTEN
         LH    NOD,CHKINDON            ADDR TO OLD EXTENDED
         LA    NOD,DSKBLK(NOD)         |
         WITH  (NTRYXTND,NOD),BEGIN    |
         RELNODE CHKINDON,NTRYXLEN,(DSK),ERR=CHKRECER
         END   ,                       OF ADDR TO OLD EXTENDED
         MVC   DSKBLINK,CHKINDOL       PROPER BLOCK LINK
         MVC   DSKFL,CHKINDOF          | AND FLAGS
         DWRITE CHKINDOB,ERR=CHKRECER  WRITE OLD EXTENDED
         END   ,                       OF OLD ^ WRITTEN
         END   ,                       OF OLD EXISTS
         B     CHKCLR1                 Clear 1st level of CHECKPOINT
         TITLE 'Checkpoint Recovery - Finish 1st level'
CHKCLR1  LABEL ,
         L     R14,CHKCHKA             COPY ORIGINAL CHECKPOINT
         LH    R15,FSBDSZ              | BLOCK SIZE
         LR    R0,CHKR                 DEST ADDR
         LR    R1,R15                  | LEN
         MVCL  R0,R14                  |
         CLEAR CHKIVLV1                CLEAR THIS LEVEL
         IWRITE ERR=CHKRECER           |
         TITLE 'Checkpoint Recovery - 2nd Level'
LEVEL2   DRELBUF LA:0,ERR=CHKRECER     RELEASE CHECKPOINT COPY BUF
         LC    R15,CHKI2TYP
         IF    (R15,GT,CCHKDBAL),BEGIN NOT IMPLEMENTED
         ABORT  CHK2NIMP
         END   ,                       OF NOT IMPLEMENTED
         B     TABLE2(R15)
TABLE2   B     LEVEL3                  NO 2ND LEVEL INTENTIONS
         B     CHKDBAL
         TITLE 'Checkpoint Recovery - Required balance on delete'
CHKDBAL  LABEL ,                       Balance on delete Recovery
         IF    CHKFACC,BEGIN           SET UP FOR ACC SEARCH
         MVI   CHKFNMSZ,CNTAMXSZ       ENTRY TO LOOK FOR
         MVC   CHKFNAME(CNTAMXSZ),CHKIDBNM      |
         LA    R0,ACCMODE              |
         END   ELSE,BEGIN              SET UP FOR FILE SEARCH
         MVC   CHKFNMSZ,CHKIDBSZ       NTRY TO LOOK FOR (LEN)
         MVC   CHKFNAME(L'CHKFNAME),CHKIDBNM    |
         MVC   CHKACCB(PL),CHKIDBAB    ACCOUNT BLOCK
         MVC   CHKACSP,CHKIDBAS        | ACC STACK PTR
         LA    R0,FILEMODE             |
         END   ,                       OF SET UP FOR FILE SEARCH
         SET   CHKFMOD                 YES, I WANT TO BALANCE
         ACALL CATSRCH                 |
         B     CHKCLR2                 Clear 2nd level on CHECKPOINT
         TITLE 'Checkpoint Recovery - Finish 2nd Level'
CHKCLR2  CLEAR CHKIVLV2                CLEAR 2ND LEVEL INTENTIONS
         IWRITE ERR=CHKRECER           |
         B     LEVEL3
         TITLE 'Checkpoint Recovery - 3rd Level'
LEVEL3   LC    R15,CHKI3TYP
         IF    (R15,GT,CCHKREN),BEGIN  NOT IMPLEMENTED
         ABORT  CHK3NIMP
         END   ,                       OF NOT IMPLEMENTED
         B     TABLE3(R15)
TABLE3   B     LEVELN                  NO 3RD LEVEL INTENTIONS
         B     CHKREN
         TITLE 'Checkpoint Recovery - Rename Entry'
CHKREN   LABEL ,                       Rename Entry Recovery
         MVC   CHKACCB(PL),CHKIERAB    ACCOUNT BLOCK
         MVC   CHKACSP,CHKIERAS        | ACC STACK PTR
         IF    CHKFDEL,BEGIN           STILL IN DELETE STAGE
*          In delete stage, the old name is in the CHKIERON slot
*        and the new name is in the CHKIERNN slot.
         MVC   CHKFNMSZ,CHKIEROS       NTRY TO LOOK FOR (LEN)
         MVC   CHKFNAME(L'CHKFNAME),CHKIERON    |
         LA    R0,FILEMODE             |
         CLEAR CHKFLGS                 NEW SEARCH
         SET   CHKFMOD+CHKFDEL         DEL THIS ONE IF THERE
         ACALL CATSRCH                 |
         IF    ZERO,BEGIN              DEL LEAVES HERE
         ACALL NTRYDEL
         IF    NZ,CATERROR
         END   ,                       OF DEL LEAVES HERE
         XC    CHKFNMSZ(L'CHKFNAME+1),CHKFRNMS  Exchange Len & Name
         XC    CHKFRNMS(L'CHKFRNAM+1),CHKFNMSZ  |
         XC    CHKFNMSZ(L'CHKFNAME+1),CHKFRNMS  |
         END   ,                       OF STILL IN DEL STAGE
         CLEAR CHKFLGS
         SET   CHKFMOD+CHKFINS
         LA    R0,FILEMODE             FIND LOC TO INS
         LCALL CATSRCH                 |
         IF    NZ,BEGIN                NOT ALREADY INSERTED
         ACALL NTRYINS                 INSERT ENTRY
         IF    NZ,CATERROR
         REGCH (MIX,0),(IX,1)
         AGO   .NOCRNAC                DON'T RENAME ACCOUNTS
         LA    CNT,CHKIRNT             ADDR OF RENAME BUFFER
         IF    CHKFACC,BEGIN           ACCOUNT ENTRY
         WITH  (NTRY,CNT),BEGIN        ADDR TO SRC OF RENAME
         LA    NOD,NTGMXSP             LOC
         LA    QR,NTRY                 LEN = TOTAL-BEGIN_LEN
         SR    QR,NOD                  | -(BEGINNING_LEN)
         AR    QR,MIX                  | QR = TOTAL-BEGIN_LEN
         END   ,                       OF ADDR TO SRC OF REN
         WITH  (NTRY,IX),'LA MIX,NTGMXSP '      LOC - FROM NTGMXSP
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         LR    CNT,NOD                 SOURCE OF COPY
         LR    PTR,QR                  | LEN
         LR    IX,QR                   | DEST LEN (MIX = LOC)
         MVCL  MIX,CNT                 COPY RENAME BUFFER
         END   ELSE,BEGIN              FILE ENTRY
.NOCRNAC ANOP  ,
         WITH  (NTRY,IX),'LA QR,NTFLOC '        DEST OF FIXED RENAME
         LA    CNT,CHKIRNT             SOURCE OF FIXED RENAME
         WITH  (NTRY,CNT),BEGIN        | RENAME BUFFER
         MVC   @QR(NTFLNMSZ-NTFLOC),NTFLOC      COPY FIXED
         LH    MIX,NTRYLEN             OLD LENGTH
         LA    PTR,NTRY                START OF OLD ENTRY
         LA    NOD,NTFLNAME            SRC OF PERMITS
         LC    QR,NTFLNMSZ             |
         LA    CNT,@NOD(QR)            |
         END   ,                       OF ADDR TO SRC OF REN
*                                               PTR = TOTAL-NON_PERMIT
         SR    PTR,CNT                 | -(BEGINNING_LEN)
         AR    PTR,MIX                 | TOTAL-BEGIN_LEN
         WITH  (NTRY,IX),BEGIN         ADDR TO DEST OF PERMITS
         LC    QR,CHKFNMSZ             DEST OF PERMITS
         LA    MIX,NTFLNAME-CNTAMXSZ(QR)        | (QR = FULL NAME LEN)
         END   ,                       OF ADDR TO DEST OF REN
         REGCH (MIX,0),(IX,1),(CNT,14),(PTR,15)
         LR    IX,PTR                  COPY LENGTHS
         MVCL  MIX,CNT                 COPY RENAME BUFFER
         AGO   .NOCRNA2                DON'T RENAME ACCOUNTS
         END   ,                       OF FILE ENTRY
.NOCRNA2 ANOP  ,
*
         LA    IX,CHKINTRY             LOC OF NEW ENTRY
         LA    CNT,CHKIRNT             LEN OF NEW NTRY
         WITH (NTRY,CNT),'LH R0,NTRYLEN '
         LC    PTR,CHKFRNMS            | MINUS OLD NAME LEN
         SR    R0,PTR                  | |
         LC    PTR,CHKFNMSZ            | PLUS NEW NAME LEN
         AR    R0,PTR                  | |
         ACALL NTRYIAFT                INSERT
         IF    NZ,CATERROR
         END   ,                       OF NOT ALREADY INSERTED
         CLEAR CHKIVLV3                3rd LEVEL INTENT DONE
         IWRITE ERR=CATERROR           |
LEVELN   LABEL ,                       DONE
*
         CLEAR R15                     SET CC
         TOCOM SAVE=NO                 AND RETURN
CHKRECER ABORT  CHKRECER
         EJECT ,
         XTRCDATA ,
         END   .
