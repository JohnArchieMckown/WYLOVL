PATH     TITLE 'Orvyl SCOM Path Manager'
         COPY  HEADER
PATH     MODULE TRCNUM=14
         TITLE 'Global Control Blocks'
         COPY  PZERO
         USING (PZERO,R0)
         EJECT ,
         COPY  MAT
         EJECT ,
         COPY  ASB
         EJECT ,
         COPY  DISPPARM
         EJECT ,
         COPY  LOCKPARM
         EJECT ,
         COPY  IOSPARM
         EJECT ,
         COPY  SIGPARM
         EJECT ,
         COPY  TIMEPARM
         EJECT ,
         COPY  VMPARM
         EJECT
         COPY  ACCTPARM
         EJECT ,
         COPY  PAGEPARM
         EJECT ,
         COPY  XITPARM
         EJECT ,
         COPY  UPTHPARM
         EJECT ,
         COPY  SCOMPARM
         EJECT
         COPY  PINFO
SCOMPLEN EQU   L'#SCSR+10*8            Room for 10 Segments
         TITLE 'Local Macros'
         MACRO
&L       FIX   &LOC,&LEN
&L       PSET  @PAGE
         PMOV  @PAGLOC,&LOC,OP=LA
         PMOV  @PAGLEN,&LEN,OP=LA
         VCALL PAGFIX
         MEND
         SPACE 2
         MACRO
&L       UNFIX &LOC,&LEN
&L       PSET  @PAGE
         PMOV  @PAGLOC,&LOC,OP=LA
         PMOV  @PAGLEN,&LEN,OP=LA
         VCALL PAGUFIX
         MEND
         SPACE 2
         MACRO
&L       ADDSG &LOC,&LEN,&PARM
&L       PSET  @ADDSEG,CLEAR=NO
         PMOV  @ADDSLOC,&LOC,OP=LA
         PMOV  @ADDSLEN,&LEN,OP=LA
         PMOV  @ADDSPA,&PARM,OP=LA
         ACALL ADDSEG
         MEND  ,
         SPACE 2
         MACRO
&L       VALBUF &LOC,&LEN,&TYPE
&L       PSET  @VALBUF
         PMOV  @VALBLOC,&LOC,OP=L
         PMOV  @VALBLEN,&LEN,OP=LH
         PMOV  @VALBKEY,UPRKEY,OP=IC
         AIF   ('&TYPE' NE 'W').NOWRT
         SET   @VALBWRT
.NOWRT   ANOP
         ACALL VALBUF
         MEND
         TITLE 'Local Control Blocks'
*****************************************************************
*                                                               *
*    UPCB  --  User Path Control block.  This contains all the  *
*              info about a user path.                          *
*                                                               *
*****************************************************************
         SPACE 2
UPCB     RECORD BEGIN
         DC    C'UPCB'       Control block ID
*
* Path I/O information
*
UPATHID  DS    A             Device ID of the path
UPIOCB   DS    A             Addr of an I/O control block for notify
UPIOPA   DS    A             I/O parameter area
*
* Path status
*
UPPFLG   FLAG  ,             Path status flags (same as PATHFL)
         FLAG  CLOSED          The path closed
         FLAG  FULLQE          His full queue emptied
         FLAG  NEWINFO         New information pending
         FLAG  DISCPOST        Discretionary post
         FLAG  OPENED          The partner opened his end
*
* Work task info
*
UPWFLG   FLAG  ,             Wakeup flags
         FLAG  IOCOMP          The notify request has completed
         FLAG  DOHALT          A halt request has been issued
         FLAG  TIMEUP          The timer expired
         FLAG  TIMEST          Timer needs to be started
         FLAG  TIMERUN         A timer is running
         FLAG  CLOSING         The path will be closing up
         FLAG  OPENING         The path is opening up
UPECB    DS    D             Control Block for waiting
UPNIOPA  DS    A             Address of the notify parm area
*
* Other static info
*
UPATSK   DS    A             Task ID of the Attaching Task
UPIOXID  DS    A             Exit ID for I/O complete
UPNXID   DS    A             Exit ID for the Notify I/O
UPATXID  DS    A             Exit ID for attention
UPTOXID  DS    A             Exit ID for timeout
UPMAXBUF DS    A             Size of maximum buffer
UPNME    DS    CL8           Name for this side of the path
UPNYOU   DS    CL8           Name for that side of the path
UPNPASS  DS    CL4           Password for the path
*
* Current Request info
*
UPCRID   DS    A             Current request ID
UPCR01   DS    A             Request register 1
UPCR14   DS    A             Request register 14
UPCR15   DS    A             Request register 15
UPCTYPE  FLAG  ,             Flags for work task(same as @M1PTYPE)
         FLAG  (IDLE,00,EQ)     No I/O active on work task
         FLAG  (UPTATCH,04,EQ)  Attach
         FLAG  (UPTREAD,08,EQ)  Read
         FLAG  (UPTWRIT,12,EQ)  Write
         FLAG  (UPTHALT,16,EQ)  Halt
         FLAG  (UPTDTCH,20,EQ)  Detach
UPRFLGS  FLAG  ,             Other flags
         FLAG  UPMWAIT          Wait mode I/O request
         FLAG  UPMTRUNC         Truncate mode
*
UPRKEY   DS    X             Requestor's PSW key
UPBUFLOC DS    A             Location of the requestor's buffer
UPBUFLEN DS    A             Length of the requestor's buffer
*
UPRR01   DS    A             Return register 1
UPRR14   DS    A             Return register 14
UPRR15   DS    A             Return register 15
*
UPTOVAL  DS    D             Timeout value (TOD)
UPTOID   DS    A             Timer ID
*
* Unread data pointers
*
UPRLOC   DS    A             Location of the buffer
UPRLEN   DS    A             Length of the data in the buffer
UPROFF   DS    A             Current offset into the buffer
         END   ,
         EJECT ,
*
* General parm area for passing the UPCB address
*
         SPACE ,
@UPCBP   RECORD BEGIN
@UPCB    DS    A             UPCB addr
@UPCF    FLAG  ,
         FLAG  @UPCFM31      User in 31 bit mode
         END   ,
         SPACE 2
*
* Parm area for Validating addresses
*
         SPACE ,
@VALBUF  RECORD BEGIN
@VALBLOC DS    A             Location of the buffer
@VALBLEN DS    H             Length of the buffer
@VALBKEY DS    X             Key under which to check buffers
@VALBFL  FLAG  ,
         FLAG  @VALBWRT      Need write access to the buffer
         END   ,
         SPACE 2
*
* Parm area for passing the PINFO address
*
         SPACE ,
@PINFO   RECORD BEGIN
@PINFOP  DS    A             PINFO addr
         END   ,
         TITLE 'Main Entry'
*****************************************************************
*                                                               *
*   M1PATH --  This routine is the main entry point for mode 1  *
*              path requests.  Different routines are called,   *
*              depending on the type of the request.            *
*                                                               *
*   Input  --  @M1PATH                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
M1PATH   PROC  @M1PATH,SCOPE=GLOBAL
*
* Get the UPCB.  If this is an attach, we get a new one.
*
         IF    @M1PATCH,BEGIN
         ACALL NEWUPCB                 Get a new one
         LR    RX,RVR                  Get the control block
         ST    RX,@M1PDVID             Save the device ID
         END   ELSE,'L RX,@M1PDVID'    Otherwise he tells us
         IF    (@RX,NE,'UPCB'),'ABORT BADUPCB'
         WITH  (UPCB,RX)
*
* Fill in the UPCB with all the info passed.
*
         MVC   UPCRID,@M1PRQID         Request ID
         MVC   UPCR01,@M1PR01
         MVC   UPCR14,@M1PR14
         MVC   UPCR15,@M1PR15
         MVC   UPRKEY,@M1PPKEY
         CLEAR UPRFLGS                 Clear request flags
         IF    @M1PWAIT,'SET UPMWAIT'  Mode Wait
         ELSE  'CLEAR UPMWAIT'
*
* Figure out what needs to be done
*
         PSET  @UPCBP                  Common parm area
         IF    @M1PM31,'SET @UPCFM31'
         ST    RX,@UPCB                control block address
         LC    RS,@M1PTYPE             Get the request type
         IF    ((RS,Z),OR,(RS,GE,TTLEN)),'ABORT BADM1PTYPE'
         ACALL PTTAB(RS)
*
* The return from these is our return, so we are done
*
         PEND  ,                       Return to the caller
*
PTTAB    DC    A(0)                    Invalid
         DC    A(ATTACH)               Attach
         DC    A(READ)                 Read
         DC    A(WRITE)                Write
         DC    A(HALT)                 Halt
         DC    A(0)                    Invalid
         DC    A(DETACH)               Detach
TTLEN    EQU   *-PTTAB                 length of the table
         EJECT ,
*****************************************************************
*                                                               *
*   ATTACH --  This handles the attach request.  It opens this  *
*              side of the path.                                *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  RVR contains panic code or zero.                 *
*                                                               *
*****************************************************************
         SPACE 2
ATTACH   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         MVC   UPRR01,=X'80000000'     Default is no return
         MVC   UPRR14,=X'80000000'     Default is no return
         MVC   UPRR15,=X'80000000'     Default is no return
*
* Validate the parms.  First the path names.
*
         IF    ^@UPCFM31,BEGIN
         MVI   UPCR01,0                Only 24 bit addresses allowed
         END   ,
         L     RA,UPCR01               Get the buffer location
         VALBUF (RA),LA:20             Make sure we can read it
         IF    (RVR,NZ),ATTSPEC        Nope...spec 'im
         MVC   UPNME(20),@RA           Move the info in
         CLC   UPNME,=8X'FF'           Is he trying to be Anybody?
         IF    EQ,ATTSPEC              If so, we won't let him.
         IF    (UPNME,EQ,UPNYOU),ATTSPEC  No talking to yourself
*
* Validate the timeout and buffer length
*
         LH    RB,UPCR15               Get the timeout value
         IF    ((RB,NEG),OR,(RB,GT,6000)),ATTSPEC
         CLEAR RA
         M     RA,=FE6'1'              Convert to uS
         SLDL  RA,12                   Convert to TOD format
         STM   RA,RB,UPTOVAL           Save the timeout value
*
         LH    RA,UPCR15+2             Get the buffer length
         IF    ((RA,NP),OR,(RA,GT,8192)),ATTSPEC
         ST    RA,UPMAXBUF             Maximum buffer size
*
* Ready to do the path stuff.  Start by allocating a device.
*
         LA    RS,#IOUSCOM             SCOM device
         SYSCTL RS,TYPE=ALLOC          Do the device allocation
         ST    RS,UPATHID              Save it as the path ID
*
* Now we start up the task which will handle asynchronous events for
* this path.
*
         IF    UPMWAIT,BEGIN
         SET   UPTATCH                 Tell the task what to do
         SET   TIMEST                  Start a timer if needed
         END   ,
         PSET  @TCREATE
         MVC   @TCRPSW(4),=X'070C0000'
         MVC   @TCRPSW+4(4),=A(X'80000000'+PATHTASK)
         MVC   @TCRPRIO,=A(10)         Higher priority
         ST    RX,@TCRPARM             Parm is the UPCB
         SET   @TCRFSTK                It will need a stack
         VCALL TCREATE                 Create the task
*
* If this was a mode wait request, the response will be from the
* other task.  If not, we will just respond that the path is not
* yet open, and post the I/O complete.
*
         IF    ^UPMWAIT,BEGIN          Not mode wait
         MVC   UPRR15,=A(16)           Signal path not open yet
         PSET  @UPCBP                  Common control block
         ST    RX,@UPCB                Tell it which one
         ACALL IODONE                  And post the I/O complete
         END   ,
         EJECT ,
*
* We are done for now.  Setup the return code and return.
*
         CLEAR RVR                     Good return
         B     ATTDONE                 The attach is done
*
* If there was some problem, we have to free the UPCB that was
* created before we were entered.
*
ATTSPEC  PSET  @UPCBP
         ST    RX,@UPCB                Save the location
         ACALL DELUPCB                 Free it up
         LA    RVR,6                   Specification error
*
* All done, return to the caller
*
ATTDONE  PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*     READ --  This routine handles the read I/O requests?      *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
READ     PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         MVC   UPRR01,=X'80000000'     Default is no return
         MVC   UPRR14,=X'80000000'     Default is no return
         MVC   UPRR15,=X'80000000'     Default is no return
*
* Validate the parms.
*
         LT    RA,UPCR01               Get the location
         IF    NEG,BEGIN
         LCR   RA,RA                   Get the positive value
         SET   UPMTRUNC                Mode truncate
         END   ,
         IF    ^@UPCFM31,BEGIN
         N     RA,=X'00FFFFFF'         Only 24 bit addresses
         END   ,
         ST    RA,UPBUFLOC             Save the location
         LH    RB,UPCR15+2             Get the length of his buffer
         IF    ((RB,NP),OR,(RB,GT,8192)),READSPEC
         ST    RB,UPBUFLEN             Save the length of the buffer
         VALBUF (RA),(RB),W            Make sure we can write it
         IF    (RVR,NZ),READDONE       Can't... signal the exception
*
* Validate the timeout.
*
         LH    RB,UPCR15               Get the timeout value
         IF    ((RB,NEG),OR,(RB,GT,6000)),READSPEC
         CLEAR RA
         M     RA,=FE6'1'              Convert to uS
         SLDL  RA,12                   Convert to TOD format
         STM   RA,RB,UPTOVAL           Save the timeout value
*
* If there is no data left over from a previous read, we check to
* see if there is any fresh data.
*
         IF    (UPRLOC,Z),BEGIN        No leftovers.
*
* Mode wait I/O's are handled from the other task unless there are
* leftovers.
*
         IF    UPMWAIT,BEGIN           He will wait for it
         SET   UPTREAD                 Tell the task what to do
         SET   TIMEST                  And start the timer if needed
         SIGNL UPECB                   Then wake it up
         CLEAR RVR                     Good return from the SVC
         B     READDONE                And we're done here
         END   ,
*
* If there is no data on the path, see why not and return.
*
         IF    ^OPENED,BEGIN           Path not open yet
         MVC   UPRR15,=A(16)           Set return code
         B     READPOST                Post the I/O complete
         END   ,
         IF    ^NEWINFO,BEGIN          No fresh data
         IF    CLOSED,'MVC UPRR15,=A(-4)'        Path is closed
         ELSE  'MVC UPRR15,=A(4)'                Just no data
         B     READPOST                Post the I/O complete
         END   ,
*
* There is data on the path to be received.  We receive it.
*
         PSET  @UPCBP                  Common parm area
         ST    RX,@UPCB                control block address
         ACALL DOREAD                  Read a message from the path
         IF    (UPRLOC,Z),BEGIN        No buffer returned.
         IF    CLOSED,'MVC UPRR15,=A(-4)'        Path is closed
         ELSE  'MVC UPRR15,=A(4)'                Just no data
         B     READPOST                Post the I/O complete
         END   ,
         END   ,
*
* We now have a buffer pointed to by UPRLOC, UPRLEN.  It could be
* that we had it left over or that we just got it. We move what we
* can into the user's area.
*
         PSET  @UPCBP                  Common parm area
         ST    RX,@UPCB                control block address
         ACALL DOMOVE                  Move a message to the user
*
* All done here
*
         CLEAR UPRR15
READPOST PSET  @UPCBP                  Common control block
         ST    RX,@UPCB                Tell it which one
         ACALL IODONE                  Post it complete
         CLEAR RVR                     Good return for the SVC
         B     READDONE                All done
*
READSPEC LA    RVR,6
READDONE PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*   DOREAD --  This routine reads a transaction from the path   *
*              into a buffer and puts the address and length of *
*              the buffer in the UPCB.                          *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DOREAD   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
*
* Make sure there is not a buffer there already
*
         IF    (UPRLOC,NZ),'ABORT GOTRBUF'
*
* Get a new buffer
*
         VMGET L:UPMAXBUF,LOC=LOCSYS   Get a buffer big enough
         IF    (RVR,Z),'ABORT NOMEM'
         ST    RVR,UPRLOC              Save the location
*
* Setup for the I/O
*
         CLEAR NEWINFO                 Pre-clear the flag
         L     RY,UPIOPA               Get the parm area
         WITH  (#SCSR,RY)              Address it
         CLEAR #SCSR
         WITH  (#SCOMCMD,RY),'MVC #SCCMD,=A(#SCCRECV)'
         FIX   L:UPRLOC,L:UPMAXBUF     Fix the receive buffer
         ADDSG L:UPRLOC,L:UPMAXBUF,#SCSR Add it to the list
*
* Get an IOS ID
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait
         VCALL IOSIDGET                Go get us an ID
         LR    RK,RVR                  Copy the ID
         FIX   #SCSR,SCOMPLEN          Fix the parm area
*
* Send the parm area out on the path
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,UPATHID        Path ID
         ST    RK,@IOSID               I/O ID
         PMOV  @IOSCP,LA:#SCSR         Parm area address
         SET   @IOSFSYNC               Syncronous
         VCALL IOSDOIO                 Do the I/O
         LR    RB,RVR                  Copy the ending status
*
* Free up the stuff we got
*
         UNFIX #SCSR,SCOMPLEN          Unfix the parm area
         UNFIX L:UPRLOC,L:UPMAXBUF     And the buffer
         PSET  @IOSIDFRE
         ST    RK,@IOSFID
         VCALL IOSIDFRE                Free the IOS ID
*
* Check the ending status
*
         IF    (RB,EQ,#SCESOK),BEGIN   Normal response
         L     RB,#SCSRRLN             Get the returned length
         IF    (RB,Z),BEGIN            No buffer returned
         VMFREE L:UPMAXBUF,A=L:UPRLOC,LOC=LOCSYS
         CLEAR UPRLOC                  Clear the buffer location
         END   ,
         ELSE  'SET NEWINFO'           Assume there is more data
         ST    RB,UPRLEN               Save the length in the UPCB
         CLEAR UPROFF                  Offset is the first byte
         EXIT  DOREAD                  Return to the caller
         END   ,
*
*
         IF    (RB,EQ,#SCESNP),BEGIN   No partner
         VMFREE L:UPMAXBUF,A=L:UPRLOC,LOC=LOCSYS Free the buffer
         CLEAR UPRLOC                  Clear the buffer location
         END   ELSE,BEGIN              Some other bad return
         ABORT PATHREAD                Arrrghhhh.....
         END   ,
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   DOMOVE --  This routine moves data from a previously read   *
*              transaction into the user's buffer area.  The    *
*              pointer to the current data is updated.  If mode *
*              truncate was specified, the rest of the data is  *
*              freed at the end of the request.                 *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DOMOVE   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
*
* Make sure there is not a buffer there already
*
         IF    (UPRLOC,Z),'ABORT NORBUF'         No data available
*
* Move the data into the user area
*
         L     RA,UPBUFLOC             Get the user buffer area
         L     RB,UPBUFLEN             Amount he will accept
         L     RJ,UPRLOC               Address of the data
         L     RS,UPROFF               Current offset into the buffer
         AR    RJ,RS                   Plus the ofset into it
         L     RK,UPRLEN               Get the length of the data
         SR    RK,RS                   Less the amount we've moved
         CEIL  RB,RK                   No more than we've got
         CEIL  RK,RB                   And no more than we want
*
* We know how much we're going to move. Tell the caller.
*
         ST    RK,UPRR01               Amount of data moved in
         AR    RS,RK                   Get the new offset
         ST    RS,UPROFF               Save that
         S     RS,UPRLEN               Get - amount left to move
         LCR   RS,RS
         ST    RS,UPRR14               Save the amount not moved.
*
* Do the actual move.
*
         MVCL  RA,RJ                   Move the data
*
* If we are in truncate mode, or if there is no data left, we free
* the buffer.
*
         IF    (UPMTRUNC,OR,(UPROFF,GE,UPRLEN)),BEGIN
         VMFREE L:UPMAXBUF,A=L:UPRLOC,LOC=LOCSYS
         CLEAR UPRLOC
         CLEAR UPROFF
         CLEAR UPRLEN                  Clear the buffer info
         END   ,
         PEND  ,
         EJECT ,
         LTORG ,
         EJECT ,
*****************************************************************
*                                                               *
*    WRITE --  This routine handles the write I/O requests.     *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
WRITE    PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         MVC   UPRR01,=X'80000000'     Default is no return
         MVC   UPRR14,=X'80000000'     Default is no return
         MVC   UPRR15,=X'80000000'     Default is no return
*
* Validate the parms.
*
         IF    ^@UPCFM31,BEGIN
         MVI   UPCR01,0                Enforce 24 bit mode
         END   ,
         L     RA,UPCR01               Get the location
         ST    RA,UPBUFLOC             Save the location
         LH    RB,UPCR15+2             Get the length of his buffer
         IF    ((RB,NP),OR,(RB,GT,8192)),WRITSPEC
         ST    RB,UPBUFLEN             Save the length of the buffer
         VALBUF (RA),(RB)              Make sure we can read it
         IF    (RVR,NZ),WRITDONE       Can't... signal the exception
*
* Validate the timeout.
*
         LH    RB,UPCR15               Get the timeout value
         IF    ((RB,NEG),OR,(RB,GT,6000)),WRITSPEC
         CLEAR RA
         M     RA,=FE6'1'              Convert to uS
         SLDL  RA,12                   Convert to TOD format
         STM   RA,RB,UPTOVAL           Save the timeout value
*
* See if the path is open.  If not, and we're mode wait, we wait
* for it.
*
         IF    ^OPENED,BEGIN           Path not open yet
         IF    ^UPMWAIT,BEGIN
         MVC   UPRR15,=A(16)           Set return code
         B     WRITPOST                Post the I/O complete
         END   ,
*
         SET   OPENING                 Path opening
         SET   UPTWRIT                 Tell the task what to do
         SET   TIMEST                  Have it start the timer
         SIGNL UPECB                   Wake it up
         CLEAR RVR                     Good return from the SVC
         B     WRITDONE                All done here
         END   ,
*
* Try to write the data out to the path.
*
         PSET  @UPCBP
         ST    RX,@UPCB                Pass the UPCB pointer
         ACALL DOWRITE                 Do the write
*
* See how it went
*
         IF    (RVR,Z),BEGIN           The write went ok
         CLEAR UPRR15                  Good return code
         B     WRITPOST                I/O complete
         END   ,
*
         IF    (RVR,NEG),BEGIN         Path closed
         MVC   UPRR15,=A(-4)           Signal return code
         B     WRITPOST                I/O complete
         END   ,
*
* It must have been a full queue.
*
         IF    UPMWAIT,BEGIN           He will wait for it
         SET   UPTWRIT                 Tell the task what to do
         SET   TIMEST                  Star the timer if needed
         SIGNL UPECB                   Wake up the synch task
         CLEAR RVR                     Good return from the SVC
         B     WRITDONE                And we're done here
         END   ,
         MVC   UPRR15,=A(8)            Otherwise we just tell him
*
* All done here
*
WRITPOST PSET  @UPCBP                  Common control block
         ST    RX,@UPCB                Tell it which one
         ACALL IODONE                  Post it complete
         CLEAR RVR                     Good return for the SVC
         B     WRITDONE                All done
*
WRITSPEC LA    RVR,6
WRITDONE PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  DOWRITE --  This routine writes a transaction to the path    *
*              from the user's area.  It return an indication   *
*              of success or failure.                           *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  RVR=0: OK; RVR < 0: Closed; RVR > 0: Fullqueue   *
*                                                               *
*****************************************************************
         SPACE 2
DOWRITE  PROC  @UPCBP,SCOPE=LOCAL      Dudley
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
*
* Setup for the I/O
*
         CLEAR FULLQE                  Pre-clear the flag
         L     RY,UPIOPA               Get the parm area
         WITH  (#SCSR,RY)              Address it
         CLEAR #SCSR
         WITH  (#SCOMCMD,RY),'MVC #SCCMD,=A(#SCCSEND)'
         FIX   L:UPBUFLOC,L:UPBUFLEN   Fix the user's area
         ADDSG L:UPBUFLOC,L:UPBUFLEN,#SCSR Add it to the list
*
* Get an IOS ID
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait
         VCALL IOSIDGET                Go get us an ID
         LR    RK,RVR                  Copy the ID
         FIX   #SCSR,SCOMPLEN          Fix the parm area
*
* Send the parm area out on the path
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,UPATHID        Path ID
         ST    RK,@IOSID               I/O ID
         PMOV  @IOSCP,LA:#SCSR         Parm area address
         SET   @IOSFSYNC               Syncronous
         VCALL IOSDOIO                 Do the I/O
         LR    RB,RVR                  Copy the ending status
*
* Free up the stuff we got
*
         UNFIX #SCSR,SCOMPLEN          Unfix the parm area
         UNFIX L:UPBUFLOC,L:UPBUFLEN   And the buffer
         PSET  @IOSIDFRE
         ST    RK,@IOSFID
         VCALL IOSIDFRE                Free the IOS ID
*
* Check the ending status
*
         IF    (RB,EQ,#SCESOK),BEGIN   Normal response
         CLEAR RVR                     Good return code
         EXIT  DOWRITE                 Return to the caller
         END   ,
*
         IF    (RB,EQ,#SCESNP),BEGIN   No partner
         L     RVR,=A(-4)              Path closed
         EXIT  DOWRITE
         END   ,
*
         IF    (RB,EQ,#SCESFQ),BEGIN   Buffer too big
         LA    RVR,4                   Full queue code
         EXIT  DOWRITE
         END   ,
*
         IF    (RB,EQ,#SCESBOM),BEGIN  Buffer too big
         LA    RVR,4                   Full queue code
         CLEAR UPMWAIT                 Don't hold your breath
         EXIT  DOWRITE
         END   ,
*
         ABORT PATHREAD                Any other...
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*     HALT --  This routine handles the Halt  I/O requests.     *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
HALT     PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         IF    ^IDLE,BEGIN             Don't bother if task idle
         SET   DOHALT                  Turn on the flag
         SIGNL UPECB                   Wake it up
         END   ,
         CLEAR RVR                     Good return
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*   DETACH --  This routine handles the Detach I/O request.     *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DETACH   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         SET   CLOSING                 Prevent anymore notifies
*
* Setup for the I/O
*
         L     RY,UPIOPA               Get the parm area
         WITH  (#SCCLOSE,RY)           Address it
         CLEAR #SCCLOSE
         WITH  (#SCOMCMD,RY),'MVC #SCCMD,=A(#SCCCLOS)'
*
* Get an IOS ID
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait
         VCALL IOSIDGET                Go get us an ID
         LR    RK,RVR                  Copy the ID
         FIX   #SCCLOSE,L'#SCCLOSE     Fix the parm area
*
* Send the parm area out on the path
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,UPATHID        Path ID
         ST    RK,@IOSID               I/O ID
         PMOV  @IOSCP,LA:#SCCLOSE      Parm area address
         SET   @IOSFSYNC               Syncronous
         VCALL IOSDOIO                 Do the I/O
*
* Free up the stuff we got
*
         UNFIX #SCCLOSE,L'#SCCLOSE     Unfix the parm area
         PSET  @IOSIDFRE
         ST    RK,@IOSFID
         VCALL IOSIDFRE                Free the IOS ID
*
* Make the processing task clean up
*
         VCALL ASLOCK                  Lock up the address space
         SET   UPTDTCH                 Set the detach request code
         SIGNL UPECB                   Wake up the task
         VCALL ASULOCK                 Free the lock
         CLEAR RVR                     Good return code
         PEND  ,                       Return to the caller
         EJECT
         LTORG
         EJECT ,
*****************************************************************
*                                                               *
* PATHTASK --  This routine handles the asynchronous nature of  *
*              path I/O.  It waits for things to happen and     *
*              takes action on what needs to be done.           *
*                                                               *
*   Input  --  @TENTRY                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PATHTASK PROC  @TENTRY,SCOPE=LOCAL
         L     RX,@TEPARM              The parm is our UPCB address
         WITH  (UPCB,RX)
*
* First set up the exit for our notify completion
*
         PSET  @EXRADD
         MVC   @EXRPSW(4),=X'070C0000'
         MVC   @EXRPSW+4(4),=A(X'80000000'+PTIOCX)
         ST    RX,@EXRPARM             The UPCB is the parm
         WITH  (XITMSKD,@EXRTYPE),BEGIN
         SET   XITMIOCN+XITMIOCA       I/O complete is all
         END   ,
         SET   @EXRAFS
         VCALL EXRADD                  Go do the actual adding
*
* Then do the exit for the timer.
*
         PSET  @EXRADD
         MVC   @EXRPSW(4),=X'070C0000'
         MVC   @EXRPSW+4(4),=A(X'80000000'+PTTIMEX)
         ST    RX,@EXRPARM             The UPCB is the parm
         WITH  (XITMSKD,@EXRTYPE),BEGIN
         SET   XITMRTC                 Real time timer
         END   ,
         SET   @EXRAFS
         VCALL EXRADD                  Go do the actual adding
         EJECT
*
* Enable the exits
*
         PSET  @XITMSK
         WITH  (XITMSKD,@XITMSK),BEGIN
         SET   XITMRTC                 Real time clocks
         SET   XITMIOCN+XITMIOCA       I/O completion
         END   ,
         VCALL XITMASK                 Set the mask
*
* Open up the path.  First get an IOS ID.
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait
         VCALL IOSIDGET                Go get us an ID
         LR    RK,RVR                  Copy the ID
*
* Setup the I/O parameter area.
*
         L     RY,UPIOPA               Get our I/O parm area
         WITH  (#SCOPEN,RY),BEGIN
         CLEAR #SCOPEN
         WITH  (#SCOMCMD,RY),'MVC #SCCMD,=A(#SCCOPEN)'
         MVC   #SCOME,UPNME            Move in our name
         MVC   #SCOYOU,UPNYOU          Move in partner's name
         MVC   #SCOPASS,UPNPASS        And the password
         MVC   #SCOBUFL,UPMAXBUF       Max buffer size
         ACALL DOPINFO                 Create PINFO area
         LR    RB,RVR                  PINFO area address
         LRA   RS,@RB                   to Real
         ST    RS,#SCOINFO              to parameter list
         FIX   #SCOPEN,L'#SCOPEN       Fix the memory in core
         FIX   @RB,L'PINFO+4
*
* Go ahead and do the I/O
*
         PSET  @IOSDOIO                Setup for the Call
         MVC   @IOSPID,PZCURPID
         PMOV  @IOSCP,LA:#SCOPEN       Channel program
         PMOV  @IOSCHID,UPATHID        Device ID of the path
         ST    RK,@IOSID               IOS ID
         SET   @IOSFSYNC               Synchronous I/O
         VCALL IOSDOIO                 Do the OPEN
         IF    (RVR,NZ),'ABORT BADOPEN'
*
* Free up the stuff we got
*
         UNFIX #SCOPEN,L'#SCOPEN       Unfix the parm area
         UNFIX @RB,L'PINFO+4
         PSET  @PINFO
         ST    RB,@PINFOP
         ACALL RELPINFO                Release the Pinfo area
         PSET  @IOSIDFRE
         ST    RK,@IOSFID
         VCALL IOSIDFRE                Free the IOS ID
         END   ,
*
* If a timer needs to be started, we do that too.
*
         IF    TIMEST,BEGIN
         CLEAR TIMEST                  Clear the flag
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL DOTIME                  And start the timer
         END   ,
*
* Start the notify up.
*
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL DONOTE                  Go and do it
         EJECT ,
*
* This is the main loop of the Path processing task.  It waits for
* event to occur, then handles the event.
*
         SPACE 2
MLOOP    LABEL ,
*
* Wait for something to happen
*
         AWAIT UPECB,LEN=LONG          Might be a long time
         CLEAR UPECB                   Clear it out
*
* We are awake now, let's find out what happened.
*
IOACT    IF    ^IDLE,BEGIN             Some I/O is active
*
* If a halt request was received we terminate the I/O right now.
*
         IF    DOHALT,BEGIN
         CLEAR DOHALT                  Clear the flag
         CLEAR UPRR15
         CLEAR UPRR01
         CLEAR UPRR14                  All registers cleared.
         B     ACTIOPST                Post it complete
         END   ,
*
* If a timer needs to be started, we do that too.
*
         IF    TIMEST,BEGIN
         CLEAR TIMEST                  Clear the flag
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL DOTIME                  And start the timer
         END   ,
         EJECT
*
*  Attach
*
         IF    UPTATCH,BEGIN           An attach is in progress
         IF    TIMEUP,BEGIN            No time left
         CLEAR TIMEUP
         MVC   UPRR15,=A(16)           Not yet opened return code
         B     ACTIOPST                Post the user
         END   ,
         IF    OPENED,BEGIN            The path is opened...
         CLEAR UPRR15                  Good return code
         B     ACTIOPST                Post it complete
         END   ,
         EXIT  IOACT                   Otherwise, keep waiting
         END   ,
         EJECT ,
*
*  Read
*
         IF    UPTREAD,BEGIN           A read is in progress
         IF    TIMEUP,BEGIN            The read timed out
         CLEAR TIMEUP
         IF    OPENED,'MVC UPRR15,=A(4)'  No buffer received code
         ELSE  'MVC UPRR15,=A(16)'        Path not open yet
         B     ACTIOPST                Post it complete
         END   ,
*
* See if the path is all tapped out.
*
         IF    ^NEWINFO,BEGIN
         IF    CLOSED,BEGIN
         MVC   UPRR15,=A(-4)           Path is closed
         B     ACTIOPST                Post the I/O complete
         END   ,
         EXIT  IOACT                   Otherwise, nothing to do.
         END   ,
*
* There is data on the path to be received.  We receive it.
*
         PSET  @UPCBP                  Common parm area
         ST    RX,@UPCB                control block address
         ACALL DOREAD                  Read a message from the path
         IF    (UPRLOC,Z),BEGIN        No buffer returned.
         IF    CLOSED,BEGIN
         MVC   UPRR15,=A(-4)           Path is closed
         B     ACTIOPST                Post the I/O complete
         END   ,
         EXIT  IOACT                   Have to wait a little longer
         END
         PSET  @UPCBP                  Common parm area
         ST    RX,@UPCB                control block address
         ACALL DOMOVE                  Move a message to the user
*
         CLEAR UPRR15                  Good return code
         B     ACTIOPST                All done, post it complete
         END   ,
         EJECT ,
*
*  Write
*
         IF    UPTWRIT,BEGIN           An Write is in progress
         IF    TIMEUP,BEGIN            The write timed out
         CLEAR TIMEUP
         IF    OPENED,'MVC UPRR15,=A(8)' Full queue not relieved
         ELSE  'MVC UPRR15,=A(16)'       Path not yet open
         B     ACTIOPST                Post it complete
         END   ,
         IF    CLOSED,BEGIN
         MVC   UPRR15,=A(-4)           Path is closed
         B     ACTIOPST                Post the I/O complete
         END   ,
*
         IF    (FULLQE,OR,(OPENED,AND,OPENING)),BEGIN
         CLEAR OPENING
         PSET  @UPCBP                  Common parm area
         ST    RX,@UPCB                control block address
         ACALL DOWRITE                 Write the message to the path
*
         IF    (RVR,POS),EXIT,IOACT    Got another full queue
         IF    (RVR,Z),BEGIN           It all went ok
         CLEAR UPRR15                  Good return code
         B     ACTIOPST                Complete
         END   ,
         IF    (RVR,NEG),BEGIN         Path closed
         MVC   UPRR15,=A(-4)           Code
         B     ACTIOPST                Mark it complete
         END   ,
         END   ,
         END   ,
         EXIT  IOACT                   Any others do nothing
ACTIOPST LABEL ,                       Post an active I/O complete
         PSET  @UPCBP
         ST    RX,@UPCB
         SET   IDLE                    We are Idle now
         IF    TIMERUN,BEGIN           If a timer is running...
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL CANTIME                 Cancel it.
         END   ,
         PSET  @UPCBP                  Common control block
         ST    RX,@UPCB                Tell it which one
         ACALL IODONE                  Post the I/O complete
         END   ,
*
* We have handled the processing for any I/Os that we had to do.
* If we were awakened because our notify completed, we have to
* restart it, unless the path is closed, in which case we're done.
*
         IF    IOCOMP,BEGIN
         CLEAR IOCOMP
         IF    CLOSING,'SET CLOSED'
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL DONOTE                  Start up the notify again
         END   ,
*
         IF    (UPTDTCH,AND,CLOSED),BEGIN
         CLEAR UPRR15                  Good return
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL IODONE                  Detach I/O complete
         PSET  @UPCBP
         ST    RX,@UPCB
         ACALL DELUPCB                 Free the UPCB
         VCALL TEXIT                   Then make the task go away
         END   ,
         B     MLOOP                   Continue
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*   DONOTE --  This routine issues the notify I/O requests.     *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DONOTE   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
*
* We have to lock to do this so that we make sure no notifies are sent
* after the path is closed.
*
         VCALL ASLOCK                  Lock up the address space
         IF    CLOSED,BEGIN            If it's closing, dont send
         VCALL ASULOCK                 Free the lock
         EXIT  DONOTE
         END   ,
*
* Setup for the I/O
*
         L     RY,UPNIOPA              Get the parm area
         WITH  (#SCNOTE,RY)            Address it
         CLEAR #SCNOTE
         WITH  (#SCOMCMD,RY),'MVC #SCCMD,=A(#SCCNOTE)'
         FIX   #SCNOTE,L'#SCNOTE       Fix the parm area
         L     RK,UPIOCB               Get an IOS ID
*
* Send the parm area out on the path
*
         PSET  @IOSDOIO
         MVC   @IOSPID,PZCURPID
         MVC   @IOSCHID,UPATHID        Path ID
         ST    RK,@IOSID               I/O ID
         PMOV  @IOSCP,LA:#SCNOTE       Parm area address
         MVC   @IOSXID,UPNXID          Notify exit ID
         VCALL IOSDOIO                 Do the I/O
*
* Free up the stuff we got
*
         UNFIX #SCNOTE,L'#SCNOTE       Unfix the parm area
         VCALL ASULOCK                 Free the lock
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  NEWUPCB --  This routine allocates a new UPCB some of the    *
*              subdidiary control blocks and fills in some of   *
*              the data areas.                                  *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  RVR contains the UPCB address.                   *
*                                                               *
*****************************************************************
         SPACE 2
NEWUPCB  PROC  SCOPE=LOCAL
*
* Allocate the UPCB itself
*
         VMGET L'UPCB,LOC=LOCSYS       Get the memory
         IF    (RVR,Z),'ABORT NOMEM'   No memory here
         LR    RX,RVR                  Copy the address
         WITH  (UPCB,RX)
*
* Initialize some of it
*
         CLEAR UPCB                    Zero it out
         MVC   UPCB(4),=C'UPCB'        Move in the ID
         MVC   UPATSK,PZCURTSK         Task ID of the attacher
*
* Allocate some other control blocks
*
         VMGET SCOMPLEN,LOC=LOCSYS,ONEPAGE=YES  Get the IO parm area
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR
         CLEAR (@RA,SCOMPLEN)          Clear it all out
         ST    RA,UPIOPA               Save the address
*
         VMGET L'#SCNOTE,LOC=LOCSYS    Get an I/O parm for notify
         IF    (RVR,Z),'ABORT NOMEM'
         LR    RA,RVR
         CLEAR (@RA,L'#SCNOTE)         Clear it all out
         ST    RA,UPNIOPA              Save the address
*
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,UPIOXID             Save the I/O XIT ID
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,UPNXID              Save the Notify XIT ID
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,UPATXID             And the Attention XIT ID
         PSET  @XITNEW
         VCALL XITNEW
         ST    RVR,UPTOXID             And the Timer XIT ID
*
* Get an IOS ID
*
         PSET  @IOSIDGET
         SET   @IOSFWAIT               We can wait
         VCALL IOSIDGET                Go get us an ID
         ST    RVR,UPIOCB              Save it for notifies
         LA    RVR,UPCB                Return the UPCB pointer
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  DELUPCB --  This routine frees a UPCB and any subsidiary     *
*              control blocks associated with it.               *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DELUPCB  PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         MVC   UPCB(4),=C'upcb'        Mark it as deleted
*
* Delete the associated control blocks
*
         PSET  @IOSIDFRE
         PMOV  @IOSFID,UPIOCB
         VCALL IOSIDFRE                Free the IOS ID
*
         VMFREE SCOMPLEN,A=UPIOPA,LOC=LOCSYS     Free the IO parm
         IF    (RVR,NZ),'ABORT DELIOPA'
         VMFREE L'#SCNOTE,A=UPNIOPA,LOC=LOCSYS   Free the IO parm
         IF    (RVR,NZ),'ABORT DELNIOPA'
*
         PSET  @XITDEL
         MVC   @XITDID,UPIOXID         I/O Complete XIT Id
         VCALL XITDEL
         PSET  @XITDEL
         MVC   @XITDID,UPNXID          Notify Complete XIT Id
         VCALL XITDEL
         PSET  @XITDEL
         MVC   @XITDID,UPATXID         Attention XIT Id
         VCALL XITDEL
         PSET  @XITDEL
         MVC   @XITDID,UPTOXID         Timer XIT Id
         VCALL XITDEL
*
* Free the UPCB itself
*
         CLEAR UPCB                    Blitz it
         VMFREE L'UPCB,A=LA:UPCB,LOC=LOCSYS      Free the memory
         IF    (RVR,NZ),'ABORT FREEUPCB'         Something went wrong
         PEND  ,                       Return to the caller
         EJECT ,
*****************************************************************
*                                                               *
*  DOPINFO --  This routine creates a PINFO area                *
*                                                               *
*   Input  --  none                                             *
*                                                               *
*  Output  --  Pointer to PINFO area                            *
*                                                               *
*****************************************************************
         SPACE 2
DOPINFO  PROC  ,SCOPE=LOCAL
         VMGET L'PINFO+4,LOC=LOCSYS
         IF    ('LTR RB,RVR',Z),'ABORT NOPINMEM'   No memory here
*
*  Set area length
*
         LA    RS,L'PINFO
         ST    RS,@RB                  First word is area length
*
* Fill in PINFO fields
*
         LA    RA,@RB+4                PINFO area
         WITH  (PINFO,RA)
         CLEAR PINFO                   Zero it out
         MVC   PINFO(4),=CL4'PINF'     Eye catcher id
*
*  Set ORVYL system name
*
         USING PZERO,R0
         L     RS,PZMATP               MAT POINTER
         DROP  R0
         WITH  (MAT,RS)
         MVC   PINFOSYS,MATSNAME
         DROP  RS
*
*  Get logged on account and privileges
*
         PSET  @ACAINFO
         USING PZERO,R0
         MVC   @ACAASB,PZCURASB        CURRENT ASB
         DROP  R0
         VCALL ACAINFO                 GET INFO
         MVC   PINFOACC,=CL8' '
         MVC   PINFOACC(2),@ACAUID+3   GROUP
         MVI   PINFOACC+2,C'.'
         MVC   PINFOACC+3(3),@ACAUID   USER
         MVC   PINFOIFL,MILPRIV        SET PRIVS
*
*  Milten line
*
         MVC   PINFOLNO,=H'-1'
         LR    RVR,RB                  Area pointer
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  RELPINFO --  This routine deletes a PINFO area               *
*                                                               *
*   Input  --  Pointer to PINFO area                            *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
RELPINFO PROC  @PINFO,SCOPE=LOCAL
         L     RB,@PINFOP
         LA    RS,@RB+4
         WITH  (PINFO,RS)
         CLEAR PINFO
         VMFREE L'PINFO+4,A=(RB),LOC=LOCSYS
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   IODONE --  Signal the I/O requestor that the I/O is         *
*              complete.  It uses information from the UPCB.    *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
IODONE   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
*
* Schedule the I/O complete exit
*
         PSET  @XITDO
         MVC   @XITRQID,UPIOXID        Move in the request ID
         MVC   @XITTSK,UPATSK          Task ID
         MVI   @XITTYPE,XITTIOCN       I/O complete
         WITH  (@M1PIOCP,@XITPARM)     Map the parm area
         MVC   @M1PICRQ,UPCRID         Current request ID
         MVC   @M1PIR01,UPRR01         Register 1
         MVC   @M1PIR14,UPRR14         Register 14
         MVC   @M1PIR15,UPRR15         Register 15
         VCALL XITDO                   Schedule the exit
         IF    (RVR,NZ),'ABORT BADIOCPX'  Can't schedule the exit
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   DOTIME --  This routine sets a real time timer.             *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
DOTIME   PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
         IF    (UPTOVAL,Z),EXIT        Don't wait for no time
*
* Start the time
*
         PSET  @RTSET
         MVC   @RTSCLK,UPTOVAL         Move in the time
         SET   @RTSFINT                And it is an interval
         MVC   @RTSXIT,UPTOXID         Move in the request ID
         VCALL RTSET                   Schedule the exit
         IF    (RVR,Z),'ABORT SETRT'   Bad timer ID returned
         ST    RVR,UPTOID              Save the ID
         SET   TIMERUN                 Indicate that a timer is running
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  CANTIME --  Cancel an outstanding timer.                     *
*                                                               *
*   Input  --  @UPCBP                                           *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
CANTIME  PROC  @UPCBP,SCOPE=LOCAL
         L     RX,@UPCB                Get the UPCB address
         WITH  (UPCB,RX)
*
* Schedule the I/O complete exit
*
         PSET  @RTCNCK
         MVC   @RTCID,UPTOID           Move in the timer ID
         VCALL RTCAN                   Schedule the exit
*         IF    (RVR,NZ),'ABORT RTCAN'  Bad cancel request
         CLEAR TIMERUN
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   PTIOCX --  This is the I/O complete exit.  It just moves    *
*              new flags to the UPCB.                           *
*                                                               *
*   Input  --  @XITDATA                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PTIOCX   PROC  @XITDATA,SCOPE=LOCAL
*
* Get the UPCB address and the new flags
*
         L     RS,@XITDSA              Get the Exit Status Area loc
         WITH  (XITSAREA,RS),BEGIN
         WITH  (@IOTERM,XITSXPRM)
         L     RX,XITSRPRM             Get the UPCB address
         L     RA,@IOTEND              Get the ending status
         XTRC  RA,RA,PATHPOST
         END   ,
         WITH  (UPCB,RX)
*
* Update the UPCB flags
*
         EX    RA,'OI UPPFLG,0'        or the new ones in
*
* If there is no I/O active in the task, we have to signal the
* main task that something happened.
*
         IF    IDLE,BEGIN              No synchronous I/O out
         PSET  @XITDO
         MVC   @XITRQID,UPATXID        Move in the attn ID
         MVC   @XITTSK,UPATSK          Main task ID
         MVI   @XITTYPE,XITTATTN       Set it as an attention exit
         WITH  (@M1PATP,@XITPARM)
         MVC   @M1PATRQ,UPCRID         Move in the request ID
         VCALL XITDO                   Schedule the exit
         END   ,
*
* We also have to wake up the processing task
*
         SET   IOCOMP                  Tell it why its waking up
         SIGNL UPECB                   Go to it
         VCALL EXRDONE                 Then return from the exit
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  PTTIMEX --  This is the timer complete exit. It just wakes   *
*              up the processing task.                          *
*                                                               *
*   Input  --  @XITDATA                                         *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
PTTIMEX  PROC  @XITDATA,SCOPE=LOCAL
*
* Get the UPCB address and the new flags
*
         L     RS,@XITDSA              Get the Exit Status Area loc
         WITH  (XITSAREA,RS),'L RX,XITSRPRM'  Get the UPCB address
         WITH  (UPCB,RX)
*
* We now have to wake up the processing task
*
         SET   TIMEUP                  Tell it why
         CLEAR TIMERUN                 Timer not running now
         SIGNL UPECB                   Go to it
         VCALL EXRDONE                 Then return from the exit
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*   ADDSEG --  This routine adds information about an area of   *
*              virtual memory to the list in a path send/recv   *
*              request parameter area.  It updates the count    *
*              and length values in the parm area.              *
*                                                               *
*   Input  --  @ADDSEG                                          *
*                                                               *
*  Output  --  none                                             *
*                                                               *
*****************************************************************
         SPACE 2
@ADDSEG  RECORD BEGIN
@ADDSPA  DS    A             Address of the parameter area
@ADDSLOC DS    A             Location of the data to add
@ADDSLEN DS    H             Length of the data to add
         END   ,
         SPACE 2
ADDSEG   PROC  @ADDSEG,SCOPE=LOCAL
         L     RX,@ADDSPA    Get the parameter area
         WITH  (#SCSR,RX)
*
* Get our starting point for this data
*
         L     RJ,#SCSRCT              Get current count
         SLL   RJ,3                    Size of each segment
         LA    RJ,#SCSRSEG(RJ)         Location of new segment ptrs
         L     RA,@ADDSLOC             Starting location
         LH    RB,@ADDSLEN             And total length
*
* Loop through the data area, adding a segment to the parm area for
* each page or fraction thereof.
*
         WHILE (RB,NZ),BEGIN           Through the info
*
* Fill in the location for the current part of the data area
*
         LRA   RS,@RA                  Real address of current bit
         IF    NZ,'ABORT BADFIX'       What?
         ST    RS,@RJ                  Save the real address
*
* Figure out how long to the next page boundary
*
         LR    RS,RA                   Copy the current address
         AH    RS,=Y(4096)             Get to the next page
         N     RS,=X'7FFFF000'         Address of the next page
         SR    RS,RA                   Length to the page boundary
         CEIL  RS,RB                   Max is the buffer length
         ST    RS,@RJ+4                Save the segment length
*
* Adjust the pointers for the next pass through
*
         AR    RA,RS                   Get to the next segment
         SR    RB,RS                   Length is less this segment
         LA    RJ,@RJ+8                Location for next entry
         END   ,
*
* Update the count of segments
*
         LA    RS,#SCSRSEG             Starting location
         SR    RJ,RS                   Length in bytes
         SRL   RJ,3                    Length in entries
         ST    RJ,#SCSRCT              Save the count
*
* Update the overall length
*
         L     RS,#SCSRLEN             Get the previous length
         AH    RS,@ADDSLEN             Add what we just put in
         ST    RS,#SCSRLEN             Update the length
         PEND  ,
         EJECT ,
*****************************************************************
*                                                               *
*  VALBUF  --  Validate a buffer location.                      *
*                                                               *
*   Input  --  @VALBUF                                          *
*                                                               *
*  Output  --  RVR: 0=OK; 4=Protection; 5=Addressing            *
*                                                               *
*****************************************************************
         SPACE 2
VALBUF   PROC  @VALBUF,SCOPE=LOCAL
         L     RJ,@VALBLOC             Get the buffer location
         LH    RK,@VALBLEN             And it's length
         LC    RB,@VALBKEY             Get the key of the issuer
*
* Check out the buffer
*
         PSET  @PAGE
         MVC   @PAGLOC,@VALBLOC        Location of the buffer
         LH    RS,@VALBLEN             Get the length
         ST    RS,@PAGLEN              Tell him about it
         MVC   @PAGKEY,@VALBKEY        Inform him of the key too
         VCALL PAGTPROT                Test the protection
         IF    (RVR,Z),EXIT            All is well
         IF    (RVR,EQ,3),BEGIN        Addressing exception
         LA    RVR,5
         EXIT  VALBUF
         END   ,
         IF    (RVR,EQ,2),BEGIN        No access
         LA    RVR,4
         EXIT  VALBUF
         END   ,
         IF    @VALBWRT,'LA RVR,4'     Only read, he wants write
         ELSE  'CLEAR RVR'             He just wants to look
         PEND  ,
         EJECT ,
         XTRCDATA ,                    Generate the trace info
         END   .
